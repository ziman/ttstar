-- vim: ft=ttstar

### Desugared ###

  let
    postulate Nat : Type
    postulate Z : Nat
    postulate S : (n :R: Nat) -> Nat
    postulate Bool : Type
    postulate True : Bool
    postulate False : Bool
    postulate NList : Type
    postulate Nil : NList
    postulate Cons : (x :R: Nat) -> (xs :R: NList) -> NList
    someList : NList = Cons 9 (Cons 5 (Cons 1 (Cons 3 (Cons 1 (Cons 5 (Cons 2 Nil))))))
    Rel2 : (a : Type) -> Type = (\a : Type. (x : a) -> (y : a) -> Type)
    postulate Acc : (a : Type) -> (lt : Rel2 a) -> (x : a) -> Type
    postulate MkAcc : (a : Type) -> (lt : Rel2 a) -> (x : a) -> (acc : (y : a) -> (pf : lt y x) -> Acc a lt y) -> Acc a lt x
    postulate LE : (_x0 : Nat) -> (_x1 : Nat) -> Type
    postulate LEZ : (n : Nat) -> LE Z n
    postulate LES : (m : Nat) -> (n : Nat) -> (_x2 : LE m n) -> LE (S m) (S n)
    LT : (x : Nat) -> (y : Nat) -> Type = (\x : Nat. (\y : Nat. LE (S x) y))
    leRefl : (x : Nat) -> LE x x 
      [leRefl] Z = LEZ Z
      x : Nat
        [leRefl] (S x) = LES x x (leRefl x)
    leTrans : (x : Nat) -> (y : Nat) -> (z : Nat) -> (_x3 : LE x y) -> (_x4 : LE y z) -> LE x z 
      y : Nat z : Nat pf : LE y z
        [leTrans] Z y z ({LEZ} [y]) pf = LEZ z
      x : Nat y : Nat z : Nat xLEy : LE x y yLEz : LE y z
        [leTrans] (S x) (S y) (S z) ({LES} [x] [y] xLEy) ({LES} [y] [z] yLEz) = LES x z (leTrans x y z xLEy yLEz)
    leS : (x : Nat) -> (y : Nat) -> (_x5 : LE x y) -> LE x (S y) 
      y : Nat
        [leS] Z y ({LEZ} [y]) = LEZ (S y)
      x : Nat y : Nat xLEy : LE x y
        [leS] (S x) (S y) ({LES} [x] [y] xLEy) = LES x (S y) (leS x y xLEy)
    lemmaLTZ : (a : Type) -> (n : Nat) -> (_x6 : LT n Z) -> a 
    wfLT : (x : Nat) -> Acc Nat LT x = (\x : Nat. 
      let f : (x : Nat) -> (y : Nat) -> (_x7 : LT y x) -> Acc Nat LT y 
        y : Nat pf : LT y Z
          [f] Z y pf = lemmaLTZ (Acc Nat LT y) y pf
        x : Nat y : Nat yLEx : LE y x
          [f] (S x) y ({LES} [y] [x] yLEx) = MkAcc Nat LT y (\z : Nat. (\zLTy : LT z y. f x z (leTrans (S z) y x zLTy yLEx)))
      in MkAcc Nat LT x (f x))
    length : (_x8 : NList) -> Nat 
      [length] Nil = Z
      x : Nat xs : NList
        [length] (Cons x xs) = S (length xs)
    Shorter : (xs : NList) -> (ys : NList) -> Type = (\xs : NList. (\ys : NList. LT (length xs) (length ys)))
    wfShorter : (xs : NList) -> Acc NList Shorter xs = (\xs : NList. 
      let f : (xs : NList) -> (ys : NList) -> (_x9 : Shorter ys xs) -> Acc NList Shorter ys 
        ys : NList pf : Shorter ys Nil
          [f] Nil ys pf = lemmaLTZ (Acc NList Shorter ys) (length ys) pf
        x : Nat xs : NList ys : NList yLEx : LE (length ys) (length xs)
          [f] (Cons x xs) ys ({LES} [length ys] [length xs] yLEx) = MkAcc NList Shorter ys (\zs : NList. (\zLTy : LT (length zs) (length ys). f xs zs (leTrans (S (length zs)) (length ys) (length xs) zLTy yLEx)))
      in MkAcc NList Shorter xs (f xs))
    leq : (_x10 : Nat) -> (_x11 : Nat) -> Bool 
      y : Nat
        [leq] Z y = True
      x : Nat
        [leq] (S x) Z = False
      x : Nat y : Nat
        [leq] (S x) (S y) = leq x y
    not : (_x12 : Bool) -> Bool 
      [not] True = False
      [not] False = True
    qel : (y : Nat) -> (x : Nat) -> Bool = (\y : Nat. (\x : Nat. leq x y))
    gt : (x : Nat) -> (y : Nat) -> Bool = (\x : Nat. (\y : Nat. not (leq y x)))
    condCons : (_x13 : Bool) -> (_x14 : Nat) -> (_x15 : NList) -> NList 
      [condCons] True = Cons
      [condCons] False = (\x : Nat. (\xs : NList. xs))
    filter : (_x16 : (_x17 : Nat) -> Bool) -> (_x18 : NList) -> NList 
      p : (_x19 : Nat) -> Bool
        [filter] p Nil = Nil
      p : (_x20 : Nat) -> Bool x : Nat xs : NList
        [filter] p (Cons x xs) = condCons (p x) x (filter p xs)
    append : (_x21 : NList) -> (_x22 : NList) -> NList 
      ys : NList
        [append] Nil ys = ys
      x : Nat xs : NList ys : NList
        [append] (Cons x xs) ys = Cons x (append xs ys)
    postulate Id : (a : Type) -> (_x23 : a) -> (_x24 : a) -> Type
    postulate Refl : (a : Type) -> (x : a) -> Id a x x
    postulate Split : (_x25 : NList) -> Type
    postulate SNil : Split Nil
    postulate SOne : (x : Nat) -> Split (Cons x Nil)
    postulate SMore : (x : Nat) -> (xs : NList) -> (y : Nat) -> (ys : NList) -> Split (append (Cons x xs) (Cons y ys))
    pushL : (x : Nat) -> (xs : NList) -> (_x26 : Split xs) -> Split (Cons x xs) 
      x : Nat
        [pushL] x [Nil] SNil = SOne x
      x : Nat y : Nat
        [pushL] x [Cons y Nil] (SOne y) = SMore x Nil y Nil
      x : Nat y : Nat ys : NList z : Nat zs : NList
        [pushL] x [append (Cons y ys) (Cons z zs)] (SMore y ys z zs) = SMore x (Cons y ys) z zs
    split : (xs : NList) -> Split xs 
      [split] Nil = SNil
      x : Nat
        [split] (Cons x Nil) = SOne x
      x : Nat y : Nat xs : NList
        [split] (Cons x (Cons y xs)) = 
          let step : (counter : Nat) -> (x : Nat) -> (y : Nat) -> (xs : NList) -> Split (Cons x (Cons y xs)) 
            x : Nat y : Nat xs : NList
              [step] Z x y xs = SMore x Nil y xs
            x : Nat y : Nat xs : NList
              [step] (S Z) x y xs = SMore x Nil y xs
            c : Nat x : Nat y : Nat
              [step] (S (S c)) x y Nil = SMore x Nil y Nil
            c : Nat x : Nat y : Nat z : Nat xs : NList
              [step] (S (S c)) x y (Cons z xs) = pushL x (Cons y (Cons z xs)) (step c y z xs)
          in step (S (length xs)) x y xs
    merge : (_x27 : NList) -> (_x28 : NList) -> NList 
      ys : NList
        [merge] Nil ys = ys
      xs : NList
        [merge] xs Nil = xs
      x : Nat xs : NList y : Nat ys : NList
        [merge] (Cons x xs) (Cons y ys) = 
          let f : (_x29 : Bool) -> NList 
            [f] True = Cons x (merge xs (Cons y ys))
            [f] False = Cons y (merge (Cons x xs) ys)
          in f (leq x y)
    shorterL : (xs : NList) -> (y : Nat) -> (ys : NList) -> Shorter xs (append xs (Cons y ys)) 
      y : Nat ys : NList
        [shorterL] Nil y ys = LES Z (length ys) (LEZ (length ys))
      x : Nat xs : NList y : Nat ys : NList
        [shorterL] (Cons x xs) y ys = LES (S (length xs)) (length (append xs (Cons y ys))) (shorterL xs y ys)
    shorterR : (x : Nat) -> (xs : NList) -> (ys : NList) -> Shorter ys (Cons x (append xs ys)) 
      x : Nat ys : NList
        [shorterR] x Nil ys = LES (length ys) (length ys) (leRefl (length ys))
      x : Nat z : Nat xs : NList ys : NList
        [shorterR] x (Cons z xs) ys = leS (S (length ys)) (length (Cons z (append xs ys))) (shorterR z xs ys)
    msort' : (xs : NList) -> (acc : Acc NList Shorter xs) -> NList = (\xs : NList. (\acc : Acc NList Shorter xs. 
      let fx : (xs : NList) -> (acc : Acc NList Shorter xs) -> (_x0 : Split xs) -> NList 
        acc : Acc NList Shorter Nil
          [fx] [Nil] acc SNil = Nil
        x : Nat acc : Acc NList Shorter (Cons x Nil)
          [fx] [Cons x Nil] acc (SOne x) = Cons x Nil
        y : Nat ys : NList z : Nat zs : NList acc : (qs : NList) -> (_x1 : Shorter qs (append (Cons y ys) (Cons z zs))) -> Acc NList Shorter qs
          [fx] [append (Cons y ys) (Cons z zs)] ({MkAcc} [NList] [Shorter] [append (Cons y ys) (Cons z zs)] acc) (SMore y ys z zs) = merge (msort' (Cons y ys) (acc (Cons y ys) (shorterL (Cons y ys) z zs))) (msort' (Cons z zs) (acc (Cons z zs) (shorterR y ys (Cons z zs))))
      in fx xs acc (split xs)))
    msort : (xs : NList) -> NList = (\xs : NList. msort' xs (wfShorter xs))
    main : NList = msort someList
  in main

### Evarified ###

  let
    postulate Nat :1: Type
    postulate Z :2: Nat
    postulate S :3: (n :R: Nat) -> Nat
    postulate Bool :4: Type
    postulate True :5: Bool
    postulate False :6: Bool
    postulate NList :7: Type
    postulate Nil :8: NList
    postulate Cons :9: (x :R: Nat) -> (xs :R: NList) -> NList
    someList :10: NList = Cons -12- 9 -11- (Cons -23- 5 -22- (Cons -30- 1 -29- (Cons -33- 3 -32- (Cons -38- 1 -37- (Cons -41- 5 -40- (Cons -48- 2 -47- Nil))))))
    Rel2 :51: (a :52: Type) -> Type = (\a :53: Type. (x :54: a) -> (y :55: a) -> Type)
    postulate Acc :56: (a :57: Type) -> (lt :58: Rel2 -59- a) -> (x :60: a) -> Type
    postulate MkAcc :61: (a :62: Type) -> (lt :63: Rel2 -64- a) -> (x :65: a) -> (acc :66: (y :67: a) -> (pf :68: lt -70- y -69- x) -> Acc -73- a -72- lt -71- y) -> Acc -76- a -75- lt -74- x
    postulate LE :77: (_x0 :78: Nat) -> (_x1 :79: Nat) -> Type
    postulate LEZ :80: (n :81: Nat) -> LE -83- Z -82- n
    postulate LES :84: (m :85: Nat) -> (n :86: Nat) -> (_x2 :87: LE -89- m -88- n) -> LE -91- (S -92- m) -90- (S -93- n)
    LT :94: (x :95: Nat) -> (y :96: Nat) -> Type = (\x :97: Nat. (\y :98: Nat. LE -100- (S -101- x) -99- y))
    leRefl :102: (x :103: Nat) -> LE -105- x -104- x 
      [leRefl] -106- Z = LEZ -107- Z
      x :108: Nat
        [leRefl] -109- (S -110- x) = LES -113- x -112- x -111- (leRefl -114- x)
    leTrans :115: (x :116: Nat) -> (y :117: Nat) -> (z :118: Nat) -> (_x3 :119: LE -121- x -120- y) -> (_x4 :122: LE -124- y -123- z) -> LE -126- x -125- z 
      y :127: Nat z :128: Nat pf :129: LE -131- y -130- z
        [leTrans] -136- Z -135- y -134- z -133- ({LEZ} -137- [y]) -132- pf = LEZ -138- z
      x :139: Nat y :140: Nat z :141: Nat xLEy :142: LE -144- x -143- y yLEz :145: LE -147- y -146- z
        [leTrans] -152- (S -153- x) -151- (S -154- y) -150- (S -155- z) -149- ({LES} -158- [x] -157- [y] -156- xLEy) -148- ({LES} -161- [y] -160- [z] -159- yLEz) = LES -164- x -163- z -162- (leTrans -169- x -168- y -167- z -166- xLEy -165- yLEz)
    leS :170: (x :171: Nat) -> (y :172: Nat) -> (_x5 :173: LE -175- x -174- y) -> LE -177- x -176- (S -178- y) 
      y :179: Nat
        [leS] -182- Z -181- y -180- ({LEZ} -183- [y]) = LEZ -184- (S -185- y)
      x :186: Nat y :187: Nat xLEy :188: LE -190- x -189- y
        [leS] -193- (S -194- x) -192- (S -195- y) -191- ({LES} -198- [x] -197- [y] -196- xLEy) = LES -201- x -200- (S -202- y) -199- (leS -205- x -204- y -203- xLEy)
    lemmaLTZ :206: (a :207: Type) -> (n :208: Nat) -> (_x6 :209: LT -211- n -210- Z) -> a 
    wfLT :212: (x :213: Nat) -> Acc -216- Nat -215- LT -214- x = (\x :217: Nat. 
      let f :218: (x :219: Nat) -> (y :220: Nat) -> (_x7 :221: LT -223- y -222- x) -> Acc -226- Nat -225- LT -224- y 
        y :227: Nat pf :228: LT -230- y -229- Z
          [f] -233- Z -232- y -231- pf = lemmaLTZ -236- (Acc -239- Nat -238- LT -237- y) -235- y -234- pf
        x :240: Nat y :241: Nat yLEx :242: LE -244- y -243- x
          [f] -247- (S -248- x) -246- y -245- ({LES} -251- [y] -250- [x] -249- yLEx) = MkAcc -255- Nat -254- LT -253- y -252- (\z :256: Nat. (\zLTy :257: LT -259- z -258- y. f -262- x -261- z -260- (leTrans -267- (S -268- z) -266- y -265- x -264- zLTy -263- yLEx)))
      in MkAcc -272- Nat -271- LT -270- x -269- (f -273- x))
    length :274: (_x8 :275: NList) -> Nat 
      [length] -276- Nil = Z
      x :277: Nat xs :278: NList
        [length] -279- (Cons -281- x -280- xs) = S -282- (length -283- xs)
    Shorter :284: (xs :285: NList) -> (ys :286: NList) -> Type = (\xs :287: NList. (\ys :288: NList. LT -290- (length -291- xs) -289- (length -292- ys)))
    wfShorter :293: (xs :294: NList) -> Acc -297- NList -296- Shorter -295- xs = (\xs :298: NList. 
      let f :299: (xs :300: NList) -> (ys :301: NList) -> (_x9 :302: Shorter -304- ys -303- xs) -> Acc -307- NList -306- Shorter -305- ys 
        ys :308: NList pf :309: Shorter -311- ys -310- Nil
          [f] -314- Nil -313- ys -312- pf = lemmaLTZ -317- (Acc -320- NList -319- Shorter -318- ys) -316- (length -321- ys) -315- pf
        x :322: Nat xs :323: NList ys :324: NList yLEx :325: LE -327- (length -328- ys) -326- (length -329- xs)
          [f] -332- (Cons -334- x -333- xs) -331- ys -330- ({LES} -337- [length -338- ys] -336- [length -339- xs] -335- yLEx) = MkAcc -343- NList -342- Shorter -341- ys -340- (\zs :344: NList. (\zLTy :345: LT -347- (length -348- zs) -346- (length -349- ys). f -352- xs -351- zs -350- (leTrans -357- (S -358- (length -359- zs)) -356- (length -360- ys) -355- (length -361- xs) -354- zLTy -353- yLEx)))
      in MkAcc -365- NList -364- Shorter -363- xs -362- (f -366- xs))
    leq :367: (_x10 :368: Nat) -> (_x11 :369: Nat) -> Bool 
      y :370: Nat
        [leq] -372- Z -371- y = True
      x :373: Nat
        [leq] -375- (S -376- x) -374- Z = False
      x :377: Nat y :378: Nat
        [leq] -380- (S -381- x) -379- (S -382- y) = leq -384- x -383- y
    not :385: (_x12 :386: Bool) -> Bool 
      [not] -387- True = False
      [not] -388- False = True
    qel :389: (y :390: Nat) -> (x :391: Nat) -> Bool = (\y :392: Nat. (\x :393: Nat. leq -395- x -394- y))
    gt :396: (x :397: Nat) -> (y :398: Nat) -> Bool = (\x :399: Nat. (\y :400: Nat. not -401- (leq -403- y -402- x)))
    condCons :404: (_x13 :405: Bool) -> (_x14 :406: Nat) -> (_x15 :407: NList) -> NList 
      [condCons] -408- True = Cons
      [condCons] -409- False = (\x :410: Nat. (\xs :411: NList. xs))
    filter :412: (_x16 :413: (_x17 :414: Nat) -> Bool) -> (_x18 :415: NList) -> NList 
      p :416: (_x19 :417: Nat) -> Bool
        [filter] -419- p -418- Nil = Nil
      p :420: (_x20 :421: Nat) -> Bool x :422: Nat xs :423: NList
        [filter] -425- p -424- (Cons -427- x -426- xs) = condCons -430- (p -431- x) -429- x -428- (filter -433- p -432- xs)
    append :434: (_x21 :435: NList) -> (_x22 :436: NList) -> NList 
      ys :437: NList
        [append] -439- Nil -438- ys = ys
      x :440: Nat xs :441: NList ys :442: NList
        [append] -444- (Cons -446- x -445- xs) -443- ys = Cons -448- x -447- (append -450- xs -449- ys)
    postulate Id :451: (a :452: Type) -> (_x23 :453: a) -> (_x24 :454: a) -> Type
    postulate Refl :455: (a :456: Type) -> (x :457: a) -> Id -460- a -459- x -458- x
    postulate Split :461: (_x25 :462: NList) -> Type
    postulate SNil :463: Split -464- Nil
    postulate SOne :465: (x :466: Nat) -> Split -467- (Cons -469- x -468- Nil)
    postulate SMore :470: (x :471: Nat) -> (xs :472: NList) -> (y :473: Nat) -> (ys :474: NList) -> Split -475- (append -477- (Cons -479- x -478- xs) -476- (Cons -481- y -480- ys))
    pushL :482: (x :483: Nat) -> (xs :484: NList) -> (_x26 :485: Split -486- xs) -> Split -487- (Cons -489- x -488- xs) 
      x :490: Nat
        [pushL] -493- x -492- [Nil] -491- SNil = SOne -494- x
      x :495: Nat y :496: Nat
        [pushL] -499- x -498- [Cons -501- y -500- Nil] -497- (SOne -502- y) = SMore -506- x -505- Nil -504- y -503- Nil
      x :507: Nat y :508: Nat ys :509: NList z :510: Nat zs :511: NList
        [pushL] -514- x -513- [append -516- (Cons -518- y -517- ys) -515- (Cons -520- z -519- zs)] -512- (SMore -524- y -523- ys -522- z -521- zs) = SMore -528- x -527- (Cons -530- y -529- ys) -526- z -525- zs
    split :531: (xs :532: NList) -> Split -533- xs 
      [split] -534- Nil = SNil
      x :535: Nat
        [split] -536- (Cons -538- x -537- Nil) = SOne -539- x
      x :540: Nat y :541: Nat xs :542: NList
        [split] -543- (Cons -545- x -544- (Cons -547- y -546- xs)) = 
          let step :548: (counter :549: Nat) -> (x :550: Nat) -> (y :551: Nat) -> (xs :552: NList) -> Split -553- (Cons -555- x -554- (Cons -557- y -556- xs)) 
            x :558: Nat y :559: Nat xs :560: NList
              [step] -564- Z -563- x -562- y -561- xs = SMore -568- x -567- Nil -566- y -565- xs
            x :569: Nat y :570: Nat xs :571: NList
              [step] -575- (S -576- Z) -574- x -573- y -572- xs = SMore -580- x -579- Nil -578- y -577- xs
            c :581: Nat x :582: Nat y :583: Nat
              [step] -587- (S -588- (S -589- c)) -586- x -585- y -584- Nil = SMore -593- x -592- Nil -591- y -590- Nil
            c :594: Nat x :595: Nat y :596: Nat z :597: Nat xs :598: NList
              [step] -602- (S -603- (S -604- c)) -601- x -600- y -599- (Cons -606- z -605- xs) = pushL -609- x -608- (Cons -611- y -610- (Cons -613- z -612- xs)) -607- (step -617- c -616- y -615- z -614- xs)
          in step -621- (S -622- (length -623- xs)) -620- x -619- y -618- xs
    merge :624: (_x27 :625: NList) -> (_x28 :626: NList) -> NList 
      ys :627: NList
        [merge] -629- Nil -628- ys = ys
      xs :630: NList
        [merge] -632- xs -631- Nil = xs
      x :633: Nat xs :634: NList y :635: Nat ys :636: NList
        [merge] -638- (Cons -640- x -639- xs) -637- (Cons -642- y -641- ys) = 
          let f :643: (_x29 :644: Bool) -> NList 
            [f] -645- True = Cons -647- x -646- (merge -649- xs -648- (Cons -651- y -650- ys))
            [f] -652- False = Cons -654- y -653- (merge -656- (Cons -658- x -657- xs) -655- ys)
          in f -659- (leq -661- x -660- y)
    shorterL :662: (xs :663: NList) -> (y :664: Nat) -> (ys :665: NList) -> Shorter -667- xs -666- (append -669- xs -668- (Cons -671- y -670- ys)) 
      y :672: Nat ys :673: NList
        [shorterL] -676- Nil -675- y -674- ys = LES -679- Z -678- (length -680- ys) -677- (LEZ -681- (length -682- ys))
      x :683: Nat xs :684: NList y :685: Nat ys :686: NList
        [shorterL] -689- (Cons -691- x -690- xs) -688- y -687- ys = LES -694- (S -695- (length -696- xs)) -693- (length -697- (append -699- xs -698- (Cons -701- y -700- ys))) -692- (shorterL -704- xs -703- y -702- ys)
    shorterR :705: (x :706: Nat) -> (xs :707: NList) -> (ys :708: NList) -> Shorter -710- ys -709- (Cons -712- x -711- (append -714- xs -713- ys)) 
      x :715: Nat ys :716: NList
        [shorterR] -719- x -718- Nil -717- ys = LES -722- (length -723- ys) -721- (length -724- ys) -720- (leRefl -725- (length -726- ys))
      x :727: Nat z :728: Nat xs :729: NList ys :730: NList
        [shorterR] -733- x -732- (Cons -735- z -734- xs) -731- ys = leS -738- (S -739- (length -740- ys)) -737- (length -741- (Cons -743- z -742- (append -745- xs -744- ys))) -736- (shorterR -748- z -747- xs -746- ys)
    msort' :749: (xs :750: NList) -> (acc :751: Acc -754- NList -753- Shorter -752- xs) -> NList = (\xs :755: NList. (\acc :756: Acc -759- NList -758- Shorter -757- xs. 
      let fx :760: (xs :761: NList) -> (acc :762: Acc -765- NList -764- Shorter -763- xs) -> (_x0 :766: Split -767- xs) -> NList 
        acc :768: Acc -771- NList -770- Shorter -769- Nil
          [fx] -774- [Nil] -773- acc -772- SNil = Nil
        x :775: Nat acc :776: Acc -779- NList -778- Shorter -777- (Cons -781- x -780- Nil)
          [fx] -784- [Cons -786- x -785- Nil] -783- acc -782- (SOne -787- x) = Cons -789- x -788- Nil
        y :790: Nat ys :791: NList z :792: Nat zs :793: NList acc :794: (qs :795: NList) -> (_x1 :796: Shorter -798- qs -797- (append -800- (Cons -802- y -801- ys) -799- (Cons -804- z -803- zs))) -> Acc -807- NList -806- Shorter -805- qs
          [fx] -810- [append -812- (Cons -814- y -813- ys) -811- (Cons -816- z -815- zs)] -809- ({MkAcc} -820- [NList] -819- [Shorter] -818- [append -822- (Cons -824- y -823- ys) -821- (Cons -826- z -825- zs)] -817- acc) -808- (SMore -830- y -829- ys -828- z -827- zs) = merge -832- (msort' -834- (Cons -836- y -835- ys) -833- (acc -838- (Cons -840- y -839- ys) -837- (shorterL -843- (Cons -845- y -844- ys) -842- z -841- zs))) -831- (msort' -847- (Cons -849- z -848- zs) -846- (acc -851- (Cons -853- z -852- zs) -850- (shorterR -856- y -855- ys -854- (Cons -858- z -857- zs))))
      in fx -861- xs -860- acc -859- (split -862- xs)))
    msort :863: (xs :864: NList) -> NList = (\xs :865: NList. msort' -867- xs -866- (wfShorter -868- xs))
    main :869: NList = msort -870- someList
  in main

### Constraints ###

[] -> [2,3,5,6,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,274,275,276,278,279,280,281,282,283,367,368,369,371,372,374,375,376,377,378,379,380,381,382,383,384,447,448,463,465,466,468,469,470,471,472,473,474,480,481,482,483,485,488,489,490,491,493,494,495,496,497,499,500,501,502,503,504,505,506,507,508,509,510,511,512,514,519,520,521,522,523,524,525,526,527,528,529,530,531,532,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,749,750,755,760,766,772,775,780,781,782,785,786,787,788,789,790,791,792,793,803,804,808,815,816,825,826,827,828,829,830,831,832,834,835,836,847,848,849,859,862,863,864,865,867,870,R]
[54] -> [285]
[54,58,66,207,751] -> [285]
[54,63,66,751] -> [285]
[54,63,751] -> [285]
[55] -> [286]
[55,58,66,207,751] -> [286]
[55,63,66,751] -> [286]
[55,63,751] -> [286]
[57,66,207,751] -> [7,320]
[58,66,78,207,751] -> [97,100,101]
[58,66,79,207,751] -> [98,99]
[58,66,95,207,751] -> [97,287,290,291]
[58,66,96,207,751] -> [98,288,289,292]
[58,66,97,207,751] -> [95]
[58,66,98,207,751] -> [96]
[58,66,99,207,751] -> [79]
[58,66,100,207,751] -> [78]
[58,66,207,285,751] -> [54,287]
[58,66,207,286,751] -> [55,288]
[58,66,207,287,751] -> [285]
[58,66,207,288,751] -> [286]
[58,66,207,289,751] -> [96]
[58,66,207,290,751] -> [95]
[58,66,207,751] -> [77,94,284,319]
[60,66,207,751] -> [308,318]
[62,66,751] -> [7,343]
[62,751] -> [7,365]
[62,809] -> [820]
[63,66,78,751] -> [97,100,101]
[63,66,79,751] -> [98,99]
[63,66,95,751] -> [97,287,290,291]
[63,66,96,751] -> [98,288,289,292]
[63,66,97,751] -> [95]
[63,66,98,751] -> [96]
[63,66,99,751] -> [79]
[63,66,100,751] -> [78]
[63,66,285,751] -> [54,287]
[63,66,286,751] -> [55,288]
[63,66,287,751] -> [285]
[63,66,288,751] -> [286]
[63,66,289,751] -> [96]
[63,66,290,751] -> [95]
[63,66,751] -> [77,94,284,342]
[63,78,751] -> [97,100,101]
[63,79,751] -> [98,99]
[63,95,751] -> [97,287,290,291]
[63,96,751] -> [98,288,289,292]
[63,97,751] -> [95]
[63,98,751] -> [96]
[63,99,751] -> [79]
[63,100,751] -> [78]
[63,285,751] -> [54,287]
[63,286,751] -> [55,288]
[63,287,751] -> [285]
[63,288,751] -> [286]
[63,289,751] -> [96]
[63,290,751] -> [95]
[63,751] -> [77,94,284,364]
[63,809] -> [819]
[65,66,751] -> [324,341]
[65,751] -> [298,363]
[65,809] -> [818]
[66,67,751] -> [301,344]
[66,68,751] -> [302,345]
[66,71,751] -> [305]
[66,72,751] -> [306]
[66,73,751] -> [307]
[66,74,751] -> [305]
[66,75,751] -> [306]
[66,76,751] -> [307]
[66,81,133,302,751] -> [137]
[66,81,302,751] -> [128,138]
[66,82,302,751] -> [120,125]
[66,83,302,751] -> [121,126]
[66,85,148,302,751] -> [161]
[66,85,149,302,751] -> [158]
[66,85,302,751] -> [139,164]
[66,85,330,751] -> [337]
[66,86,148,302,751] -> [160]
[66,86,149,302,751] -> [157]
[66,86,302,751] -> [141,163]
[66,86,330,751] -> [336]
[66,87,88,302,751] -> [125]
[66,87,89,302,751] -> [126]
[66,87,119,120,302,751] -> [143]
[66,87,119,121,302,751] -> [144]
[66,87,119,143,302,751] -> [120]
[66,87,119,144,302,751] -> [121]
[66,87,119,302,751] -> [142,166]
[66,87,122,123,302,751] -> [146]
[66,87,122,124,302,751] -> [147]
[66,87,122,146,302,751] -> [123]
[66,87,122,147,302,751] -> [124]
[66,87,122,302,751] -> [145,165]
[66,87,125,302,751] -> [88]
[66,87,126,302,751] -> [89]
[66,87,148,302,751] -> [159]
[66,87,149,302,751] -> [156]
[66,87,165,302,751] -> [122]
[66,87,166,302,751] -> [119]
[66,87,302,751] -> [139,140,141,162,167,168,169]
[66,87,330,751] -> [335]
[66,88,302,751] -> [143,146]
[66,88,751] -> [326]
[66,89,302,751] -> [144,147]
[66,89,751] -> [327]
[66,90,302,751] -> [120,123,125]
[66,90,751] -> [99]
[66,91,302,751] -> [121,124,126]
[66,91,751] -> [100]
[66,92,751] -> [101]
[66,99,119,302,751] -> [120]
[66,99,209,751] -> [99]
[66,99,302,751] -> [125]
[66,99,751] -> [90,99]
[66,100,119,302,751] -> [121]
[66,100,209,751] -> [100]
[66,100,302,751] -> [126]
[66,100,751] -> [91,100]
[66,101,119,302,751] -> [358]
[66,101,209,751] -> [101]
[66,101,302,751] -> [358]
[66,101,751] -> [92,101]
[66,116,302,751] -> [344,357,358,359]
[66,117,302,751] -> [324,356,360]
[66,118,302,751] -> [323,355,361]
[66,119,120,302,751] -> [99]
[66,119,121,302,751] -> [100]
[66,119,302,348,751] -> [359]
[66,119,302,349,751] -> [360]
[66,119,302,358,751] -> [101]
[66,119,302,359,751] -> [348]
[66,119,302,360,751] -> [349]
[66,119,302,751] -> [133,149,345,354]
[66,120,302,751] -> [82,90]
[66,121,302,751] -> [83,91]
[66,122,123,302,751] -> [326]
[66,122,124,302,751] -> [327]
[66,122,302,326,751] -> [123]
[66,122,302,327,751] -> [124]
[66,122,302,328,751] -> [360]
[66,122,302,329,751] -> [361]
[66,122,302,360,751] -> [328]
[66,122,302,361,751] -> [329]
[66,122,302,751] -> [132,148,325,353]
[66,123,302,751] -> [90,130]
[66,124,302,751] -> [91,131]
[66,125,302,751] -> [82,90,99]
[66,126,302,751] -> [83,91,100]
[66,129,302,751] -> [132]
[66,130,302,751] -> [123]
[66,131,302,751] -> [124]
[66,132,302,751] -> [122]
[66,133,137,302,751] -> [81]
[66,133,302,751] -> [119]
[66,137,302,751] -> [127,133]
[66,138,302,751] -> [81]
[66,142,302,751] -> [156]
[66,143,302,751] -> [88]
[66,144,302,751] -> [89]
[66,145,302,751] -> [159]
[66,146,302,751] -> [88]
[66,147,302,751] -> [89]
[66,148,159,302,751] -> [87]
[66,148,160,302,751] -> [86]
[66,148,161,302,751] -> [85]
[66,148,302,751] -> [122]
[66,149,156,302,751] -> [87]
[66,149,157,302,751] -> [86]
[66,149,158,302,751] -> [85]
[66,149,302,751] -> [119]
[66,156,302,751] -> [149]
[66,157,302,751] -> [140,149]
[66,158,302,751] -> [139,149]
[66,159,302,751] -> [148]
[66,160,302,751] -> [141,148]
[66,161,302,751] -> [140,148]
[66,162,302,751] -> [87]
[66,163,302,751] -> [86]
[66,164,302,751] -> [85]
[66,207,318,751] -> [60]
[66,207,319,751] -> [58]
[66,207,320,751] -> [57]
[66,207,751] -> [56,317]
[66,208,751] -> [308,316,321]
[66,209,291,751] -> [321]
[66,209,321,751] -> [291]
[66,209,751] -> [309,315]
[66,287,751] -> [287]
[66,288,751] -> [288]
[66,291,302,751] -> [359]
[66,291,751] -> [291,338,348]
[66,292,302,751] -> [361]
[66,292,751] -> [292,349]
[66,300,751] -> [298,366]
[66,301,751] -> [67,313,331,344,351]
[66,302,353,751] -> [122]
[66,302,354,751] -> [119]
[66,302,355,751] -> [118]
[66,302,356,751] -> [117]
[66,302,357,751] -> [116]
[66,302,358,751] -> [101]
[66,302,359,751] -> [291]
[66,302,361,751] -> [292]
[66,302,751] -> [68,80,84,92,93,115,116,117,118,134,135,136,150,151,152,153,154,155,312,330,350]
[66,305,751] -> [71,74,318]
[66,306,751] -> [72,75,319]
[66,307,751] -> [73,76,320]
[66,308,751] -> [313]
[66,309,751] -> [312]
[66,312,751] -> [302]
[66,313,751] -> [301]
[66,315,751] -> [209]
[66,316,751] -> [208]
[66,317,751] -> [207]
[66,318,751] -> [305]
[66,319,751] -> [306]
[66,320,751] -> [307]
[66,324,751] -> [331]
[66,325,751] -> [335]
[66,326,751] -> [88]
[66,327,751] -> [89]
[66,328,751] -> [338]
[66,329,751] -> [339]
[66,330,335,751] -> [87]
[66,330,336,751] -> [86]
[66,330,337,751] -> [85]
[66,330,751] -> [302]
[66,331,751] -> [301]
[66,335,751] -> [330]
[66,336,751] -> [323,330,339]
[66,337,751] -> [324,330,338]
[66,338,751] -> [291,328]
[66,339,751] -> [329]
[66,340,751] -> [66]
[66,341,751] -> [65]
[66,342,751] -> [63]
[66,343,751] -> [62]
[66,344,751] -> [67]
[66,345,751] -> [68]
[66,348,751] -> [291]
[66,349,751] -> [292]
[66,350,751] -> [302]
[66,351,751] -> [301]
[66,366,751] -> [300]
[66,751] -> [93,206,299,300,314,323,332,333,334,339,340,352,362]
[66,809] -> [817]
[67] -> [795]
[68] -> [796]
[71] -> [805]
[72] -> [806]
[73] -> [807]
[74] -> [763]
[74,751] -> [295]
[75] -> [764]
[75,751] -> [296]
[76] -> [765]
[76,751] -> [297]
[78,819] -> [97,100,101]
[79,819] -> [98,99]
[81,87,751,796] -> [107,673,681,682]
[81,180,751,796] -> [183]
[81,751,796] -> [179,184]
[82,87,751,796] -> [88,104]
[82,751,796] -> [174,176]
[83,87,751,796] -> [89,105]
[83,751,796] -> [175,177]
[85,87,751,796] -> [108,113]
[85,191,751,796] -> [198]
[85,751,796] -> [186,201,679,684,694,695,696,716,722]
[86,87,751,796] -> [108,112]
[86,191,751,796] -> [197]
[86,435,751,796] -> [684,699]
[86,436,751,796] -> [685,686,698,700,701]
[86,698,751,796] -> [436]
[86,699,751,796] -> [435]
[86,751,796] -> [187,200,434,435,436,437,438,439,440,441,442,443,444,445,446,449,450,673,678,680,693,697,716,721]
[87,88,751,796] -> [82,99,104,176]
[87,89,751,796] -> [83,100,105,177]
[87,90,751,796] -> [104]
[87,91,751,796] -> [105]
[87,99,751,796] -> [88]
[87,100,751,796] -> [89]
[87,101,751,796] -> [695]
[87,103,751,796] -> [716,725,726]
[87,104,751,796] -> [82,88,90]
[87,105,751,796] -> [83,89,91]
[87,107,751,796] -> [81]
[87,111,751,796] -> [87]
[87,112,751,796] -> [86]
[87,113,751,796] -> [85]
[87,173,174,751,796] -> [189]
[87,173,175,751,796] -> [190]
[87,173,189,751,796] -> [174]
[87,173,190,751,796] -> [175]
[87,173,751,796] -> [188,203]
[87,176,751,796] -> [88]
[87,177,751,796] -> [89]
[87,191,751,796] -> [196]
[87,203,751,796] -> [173]
[87,291,751,796] -> [696]
[87,292,751,796] -> [697]
[87,664,751,796] -> [685,703]
[87,665,751,796] -> [686,702]
[87,668,751,796] -> [698]
[87,669,751,796] -> [699]
[87,670,751,796] -> [700]
[87,671,751,796] -> [701]
[87,680,751,796] -> [682]
[87,681,751,796] -> [81]
[87,682,751,796] -> [680]
[87,695,751,796] -> [101]
[87,696,751,796] -> [291]
[87,697,751,796] -> [292]
[87,698,751,796] -> [668]
[87,699,751,796] -> [669]
[87,700,751,796] -> [670]
[87,701,751,796] -> [671]
[87,702,751,796] -> [665]
[87,703,751,796] -> [664]
[87,725,751,796] -> [103]
[87,751,796] -> [80,102,103,106,108,109,110,111,114,186,187,199,204,205,677,684,692,704,720,726]
[88,751,796] -> [189]
[89,751,796] -> [190]
[90,751,796] -> [99,174,176]
[91,751,796] -> [100,175,177]
[92,751,796] -> [101]
[95,819] -> [97,287,290,291]
[96,819] -> [98,288,289,292]
[97,819] -> [95]
[98,819] -> [96]
[99] -> [99]
[99,173,751,796] -> [174]
[99,751] -> [99]
[99,751,796] -> [90,99,176]
[99,762] -> [99]
[99,819] -> [79]
[100] -> [100]
[100,173,751,796] -> [175]
[100,751] -> [100]
[100,751,796] -> [91,100,177]
[100,762] -> [100]
[100,819] -> [78]
[101] -> [101]
[101,751] -> [101]
[101,751,796] -> [92,101]
[101,762] -> [101]
[173,174,751,796] -> [99]
[173,175,751,796] -> [100]
[173,706,751,796] -> [748]
[173,748,751,796] -> [706]
[173,751,796] -> [180,191,713,714,736,746,747]
[174,751,796] -> [82,90]
[175,751,796] -> [83,91]
[176,751,796] -> [82,90,99]
[177,751,796] -> [83,91,100]
[180,183,751,796] -> [81]
[180,751,796] -> [173]
[183,751,796] -> [179,180]
[184,751,796] -> [81]
[188,751,796] -> [196]
[189,751,796] -> [88]
[190,751,796] -> [89]
[191,196,751,796] -> [87]
[191,197,751,796] -> [86]
[191,198,751,796] -> [85]
[191,751,796] -> [173]
[196,751,796] -> [191]
[197,751,796] -> [187,191]
[198,751,796] -> [186,191]
[199,751,796] -> [87]
[200,751,796] -> [86]
[201,751,796] -> [85]
[285] -> [54]
[285,819] -> [287]
[286] -> [55]
[286,819] -> [288]
[287] -> [287]
[287,751] -> [287]
[287,762] -> [287]
[287,819] -> [285]
[288] -> [288]
[288,751] -> [288]
[288,762] -> [288]
[288,819] -> [286]
[289,819] -> [96]
[290,819] -> [95]
[291] -> [291]
[291,751] -> [291]
[291,762] -> [291]
[292] -> [292]
[292,751] -> [292]
[292,762] -> [292]
[294,751] -> [298,868]
[295,751] -> [74,752]
[296,751] -> [75,753]
[297,751] -> [76,754]
[298,751] -> [294]
[362,751] -> [66]
[363,751] -> [65]
[364,751] -> [63]
[365,751] -> [62]
[435,513] -> [516,517,518]
[435,810] -> [812,813,814]
[435,818] -> [822,823,824]
[436,513] -> [515]
[436,810] -> [811]
[436,818] -> [821]
[449] -> [449]
[449,751,796] -> [449,698,713]
[450] -> [450]
[450,751,796] -> [450,699,714]
[464] -> [486,533,767]
[467] -> [486,487,533,767]
[475] -> [486,487,553,767]
[484] -> [492,498,513,608]
[486] -> [464,467,475,553]
[487] -> [467,475,553]
[492] -> [484]
[498] -> [484]
[513] -> [434,435,436,437,438,439,440,441,442,443,444,445,446,449,450,484]
[513,515] -> [436]
[513,516] -> [435]
[533] -> [464,467,553,767]
[553] -> [475,486,487,533]
[608] -> [484]
[663,751,796] -> [843,844,845]
[664,751,796] -> [675,688,842]
[665,751,796] -> [674,687,841]
[670,751,796] -> [700]
[671,751,796] -> [701]
[672,751,796] -> [675]
[673,751,796] -> [674]
[674,751,796] -> [665]
[675,751,796] -> [664]
[677,751,796] -> [87]
[678,751,796] -> [86]
[679,751,796] -> [85]
[685,751,796] -> [688]
[686,751,796] -> [687]
[687,751,796] -> [665]
[688,751,796] -> [664]
[692,751,796] -> [87]
[693,751,796] -> [86]
[694,751,796] -> [85]
[698,751,796] -> [449]
[699,751,796] -> [450]
[700,751,796] -> [670]
[701,751,796] -> [671]
[706,751,796] -> [719,733,856]
[707,751,796] -> [855]
[708,751,796] -> [854,857,858]
[713,751,796] -> [449]
[714,751,796] -> [450]
[715,751,796] -> [719]
[719,751,796] -> [706]
[720,751,796] -> [87]
[721,751,796] -> [86]
[722,751,796] -> [85]
[727,751,796] -> [733]
[733,751,796] -> [706]
[736,751,796] -> [173]
[751] -> [61,293,756,794,833,839,840,846,852,853,866]
[751,752] -> [295,805]
[751,753] -> [296,806]
[751,754] -> [297,807]
[751,795] -> [838,839,840,851,852,853]
[751,796] -> [80,84,92,93,101,170,171,172,178,181,182,185,192,193,194,195,202,291,434,435,436,437,438,439,440,441,442,443,444,445,446,449,450,662,663,670,671,676,680,689,690,691,695,696,697,705,707,708,717,718,723,724,728,729,730,731,732,734,735,737,738,739,740,741,742,743,744,745,837,850,857,858]
[751,796,841] -> [665]
[751,796,842] -> [664]
[751,796,843] -> [663]
[751,796,854] -> [708]
[751,796,855] -> [707]
[751,796,856] -> [706]
[751,805] -> [752]
[751,806] -> [753]
[751,807] -> [754]
[751,837] -> [796]
[751,838] -> [795]
[751,850] -> [796]
[751,851] -> [795]
[751,868] -> [294]
[752] -> [757]
[753] -> [758]
[754] -> [759]
[756] -> [751]
[757] -> [752]
[757,762] -> [763]
[758] -> [753]
[758,762] -> [764]
[759] -> [754]
[759,762] -> [765]
[761] -> [774,784,810,861]
[762] -> [756,773,783,809,860]
[762,763] -> [757]
[762,764] -> [758]
[762,765] -> [759]
[763] -> [74,769,777]
[764] -> [75,770,778]
[765] -> [76,771,779]
[767] -> [464,467,475,533]
[768] -> [773]
[769] -> [763]
[770] -> [764]
[771] -> [765]
[773] -> [762]
[774] -> [761]
[776] -> [783]
[777] -> [763]
[778] -> [764]
[779] -> [765]
[783] -> [762]
[784] -> [761]
[794] -> [817]
[795] -> [67]
[796] -> [68]
[805] -> [71]
[806] -> [72]
[807] -> [73]
[809] -> [762]
[809,817] -> [66]
[809,818] -> [65]
[809,819] -> [63]
[809,820] -> [62]
[810] -> [434,435,436,437,438,439,440,441,442,443,444,445,446,449,450,761]
[810,811] -> [436]
[810,812] -> [435]
[817] -> [809]
[818] -> [434,435,436,437,438,439,440,441,442,443,444,445,446,449,450,809]
[818,821] -> [436]
[818,822] -> [435]
[819] -> [77,94,284,809]
[820] -> [7,809]
[833] -> [751]
[846] -> [751]
[860] -> [762]
[861] -> [761]
[866] -> [751]
[R] -> [869]

### Solution ###

[2,3,5,6,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,274,275,276,278,279,280,281,282,283,367,368,369,371,372,374,375,376,377,378,379,380,381,382,383,384,447,448,463,465,466,468,469,470,471,472,473,474,480,481,482,483,485,488,489,490,491,493,494,495,496,497,499,500,501,502,503,504,505,506,507,508,509,510,511,512,514,519,520,521,522,523,524,525,526,527,528,529,530,531,532,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,749,750,755,760,766,772,775,780,781,782,785,786,787,788,789,790,791,792,793,803,804,808,815,816,825,826,827,828,829,830,831,832,834,835,836,847,848,849,859,862,863,864,865,867,869,870,R]

### Annotated ###

  let
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Bool :E: Type
    postulate True :R: Bool
    postulate False :R: Bool
    postulate NList :E: Type
    postulate Nil :R: NList
    postulate Cons :R: (x :R: Nat) -> (xs :R: NList) -> NList
    someList :R: NList = Cons -R- 9 -R- (Cons -R- 5 -R- (Cons -R- 1 -R- (Cons -R- 3 -R- (Cons -R- 1 -R- (Cons -R- 5 -R- (Cons -R- 2 -R- Nil))))))
    Rel2 :E: (a :E: Type) -> Type = (\a :E: Type. (x :E: a) -> (y :E: a) -> Type)
    postulate Acc :E: (a :E: Type) -> (lt :E: Rel2 -E- a) -> (x :E: a) -> Type
    postulate MkAcc :E: (a :E: Type) -> (lt :E: Rel2 -E- a) -> (x :E: a) -> (acc :E: (y :E: a) -> (pf :E: lt -E- y -E- x) -> Acc -E- a -E- lt -E- y) -> Acc -E- a -E- lt -E- x
    postulate LE :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Type
    postulate LEZ :E: (n :E: Nat) -> LE -E- Z -E- n
    postulate LES :E: (m :E: Nat) -> (n :E: Nat) -> (_x2 :E: LE -E- m -E- n) -> LE -E- (S -E- m) -E- (S -E- n)
    LT :E: (x :E: Nat) -> (y :E: Nat) -> Type = (\x :E: Nat. (\y :E: Nat. LE -E- (S -E- x) -E- y))
    leRefl :E: (x :E: Nat) -> LE -E- x -E- x 
      [leRefl] -E- Z = LEZ -E- Z
      x :E: Nat
        [leRefl] -E- (S -E- x) = LES -E- x -E- x -E- (leRefl -E- x)
    leTrans :E: (x :E: Nat) -> (y :E: Nat) -> (z :E: Nat) -> (_x3 :E: LE -E- x -E- y) -> (_x4 :E: LE -E- y -E- z) -> LE -E- x -E- z 
      y :E: Nat z :E: Nat pf :E: LE -E- y -E- z
        [leTrans] -E- Z -E- y -E- z -E- ({LEZ} -E- [y]) -E- pf = LEZ -E- z
      x :E: Nat y :E: Nat z :E: Nat xLEy :E: LE -E- x -E- y yLEz :E: LE -E- y -E- z
        [leTrans] -E- (S -E- x) -E- (S -E- y) -E- (S -E- z) -E- ({LES} -E- [x] -E- [y] -E- xLEy) -E- ({LES} -E- [y] -E- [z] -E- yLEz) = LES -E- x -E- z -E- (leTrans -E- x -E- y -E- z -E- xLEy -E- yLEz)
    leS :E: (x :E: Nat) -> (y :E: Nat) -> (_x5 :E: LE -E- x -E- y) -> LE -E- x -E- (S -E- y) 
      y :E: Nat
        [leS] -E- Z -E- y -E- ({LEZ} -E- [y]) = LEZ -E- (S -E- y)
      x :E: Nat y :E: Nat xLEy :E: LE -E- x -E- y
        [leS] -E- (S -E- x) -E- (S -E- y) -E- ({LES} -E- [x] -E- [y] -E- xLEy) = LES -E- x -E- (S -E- y) -E- (leS -E- x -E- y -E- xLEy)
    lemmaLTZ :E: (a :E: Type) -> (n :E: Nat) -> (_x6 :E: LT -E- n -E- Z) -> a 
    wfLT :E: (x :E: Nat) -> Acc -E- Nat -E- LT -E- x = (\x :E: Nat. 
      let f :E: (x :E: Nat) -> (y :E: Nat) -> (_x7 :E: LT -E- y -E- x) -> Acc -E- Nat -E- LT -E- y 
        y :E: Nat pf :E: LT -E- y -E- Z
          [f] -E- Z -E- y -E- pf = lemmaLTZ -E- (Acc -E- Nat -E- LT -E- y) -E- y -E- pf
        x :E: Nat y :E: Nat yLEx :E: LE -E- y -E- x
          [f] -E- (S -E- x) -E- y -E- ({LES} -E- [y] -E- [x] -E- yLEx) = MkAcc -E- Nat -E- LT -E- y -E- (\z :E: Nat. (\zLTy :E: LT -E- z -E- y. f -E- x -E- z -E- (leTrans -E- (S -E- z) -E- y -E- x -E- zLTy -E- yLEx)))
      in MkAcc -E- Nat -E- LT -E- x -E- (f -E- x))
    length :R: (_x8 :R: NList) -> Nat 
      [length] -R- Nil = Z
      x :E: Nat xs :R: NList
        [length] -R- (Cons -R- x -R- xs) = S -R- (length -R- xs)
    Shorter :E: (xs :E: NList) -> (ys :E: NList) -> Type = (\xs :E: NList. (\ys :E: NList. LT -E- (length -E- xs) -E- (length -E- ys)))
    wfShorter :E: (xs :E: NList) -> Acc -E- NList -E- Shorter -E- xs = (\xs :E: NList. 
      let f :E: (xs :E: NList) -> (ys :E: NList) -> (_x9 :E: Shorter -E- ys -E- xs) -> Acc -E- NList -E- Shorter -E- ys 
        ys :E: NList pf :E: Shorter -E- ys -E- Nil
          [f] -E- Nil -E- ys -E- pf = lemmaLTZ -E- (Acc -E- NList -E- Shorter -E- ys) -E- (length -E- ys) -E- pf
        x :E: Nat xs :E: NList ys :E: NList yLEx :E: LE -E- (length -E- ys) -E- (length -E- xs)
          [f] -E- (Cons -E- x -E- xs) -E- ys -E- ({LES} -E- [length -E- ys] -E- [length -E- xs] -E- yLEx) = MkAcc -E- NList -E- Shorter -E- ys -E- (\zs :E: NList. (\zLTy :E: LT -E- (length -E- zs) -E- (length -E- ys). f -E- xs -E- zs -E- (leTrans -E- (S -E- (length -E- zs)) -E- (length -E- ys) -E- (length -E- xs) -E- zLTy -E- yLEx)))
      in MkAcc -E- NList -E- Shorter -E- xs -E- (f -E- xs))
    leq :R: (_x10 :R: Nat) -> (_x11 :R: Nat) -> Bool 
      y :E: Nat
        [leq] -R- Z -R- y = True
      x :E: Nat
        [leq] -R- (S -R- x) -R- Z = False
      x :R: Nat y :R: Nat
        [leq] -R- (S -R- x) -R- (S -R- y) = leq -R- x -R- y
    not :E: (_x12 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    qel :E: (y :E: Nat) -> (x :E: Nat) -> Bool = (\y :E: Nat. (\x :E: Nat. leq -E- x -E- y))
    gt :E: (x :E: Nat) -> (y :E: Nat) -> Bool = (\x :E: Nat. (\y :E: Nat. not -E- (leq -E- y -E- x)))
    condCons :E: (_x13 :E: Bool) -> (_x14 :E: Nat) -> (_x15 :E: NList) -> NList 
      [condCons] -E- True = Cons
      [condCons] -E- False = (\x :E: Nat. (\xs :E: NList. xs))
    filter :E: (_x16 :E: (_x17 :E: Nat) -> Bool) -> (_x18 :E: NList) -> NList 
      p :E: (_x19 :E: Nat) -> Bool
        [filter] -E- p -E- Nil = Nil
      p :E: (_x20 :E: Nat) -> Bool x :E: Nat xs :E: NList
        [filter] -E- p -E- (Cons -E- x -E- xs) = condCons -E- (p -E- x) -E- x -E- (filter -E- p -E- xs)
    append :E: (_x21 :E: NList) -> (_x22 :E: NList) -> NList 
      ys :E: NList
        [append] -E- Nil -E- ys = ys
      x :E: Nat xs :E: NList ys :E: NList
        [append] -E- (Cons -E- x -E- xs) -E- ys = Cons -R- x -R- (append -E- xs -E- ys)
    postulate Id :E: (a :E: Type) -> (_x23 :E: a) -> (_x24 :E: a) -> Type
    postulate Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    postulate Split :E: (_x25 :E: NList) -> Type
    postulate SNil :R: Split -E- Nil
    postulate SOne :R: (x :R: Nat) -> Split -E- (Cons -R- x -R- Nil)
    postulate SMore :R: (x :R: Nat) -> (xs :R: NList) -> (y :R: Nat) -> (ys :R: NList) -> Split -E- (append -E- (Cons -E- x -E- xs) -E- (Cons -R- y -R- ys))
    pushL :R: (x :R: Nat) -> (xs :E: NList) -> (_x26 :R: Split -E- xs) -> Split -E- (Cons -R- x -R- xs) 
      x :R: Nat
        [pushL] -R- x -E- [Nil] -R- SNil = SOne -R- x
      x :R: Nat y :R: Nat
        [pushL] -R- x -E- [Cons -R- y -R- Nil] -R- (SOne -R- y) = SMore -R- x -R- Nil -R- y -R- Nil
      x :R: Nat y :R: Nat ys :R: NList z :R: Nat zs :R: NList
        [pushL] -R- x -E- [append -E- (Cons -E- y -E- ys) -E- (Cons -R- z -R- zs)] -R- (SMore -R- y -R- ys -R- z -R- zs) = SMore -R- x -R- (Cons -R- y -R- ys) -R- z -R- zs
    split :R: (xs :R: NList) -> Split -E- xs 
      [split] -R- Nil = SNil
      x :R: Nat
        [split] -R- (Cons -R- x -R- Nil) = SOne -R- x
      x :R: Nat y :R: Nat xs :R: NList
        [split] -R- (Cons -R- x -R- (Cons -R- y -R- xs)) = 
          let step :R: (counter :R: Nat) -> (x :R: Nat) -> (y :R: Nat) -> (xs :R: NList) -> Split -E- (Cons -R- x -R- (Cons -R- y -R- xs)) 
            x :R: Nat y :R: Nat xs :R: NList
              [step] -R- Z -R- x -R- y -R- xs = SMore -R- x -R- Nil -R- y -R- xs
            x :R: Nat y :R: Nat xs :R: NList
              [step] -R- (S -R- Z) -R- x -R- y -R- xs = SMore -R- x -R- Nil -R- y -R- xs
            c :E: Nat x :R: Nat y :R: Nat
              [step] -R- (S -R- (S -R- c)) -R- x -R- y -R- Nil = SMore -R- x -R- Nil -R- y -R- Nil
            c :R: Nat x :R: Nat y :R: Nat z :R: Nat xs :R: NList
              [step] -R- (S -R- (S -R- c)) -R- x -R- y -R- (Cons -R- z -R- xs) = pushL -R- x -E- (Cons -R- y -R- (Cons -R- z -R- xs)) -R- (step -R- c -R- y -R- z -R- xs)
          in step -R- (S -R- (length -R- xs)) -R- x -R- y -R- xs
    merge :R: (_x27 :R: NList) -> (_x28 :R: NList) -> NList 
      ys :R: NList
        [merge] -R- Nil -R- ys = ys
      xs :R: NList
        [merge] -R- xs -R- Nil = xs
      x :R: Nat xs :R: NList y :R: Nat ys :R: NList
        [merge] -R- (Cons -R- x -R- xs) -R- (Cons -R- y -R- ys) = 
          let f :R: (_x29 :R: Bool) -> NList 
            [f] -R- True = Cons -R- x -R- (merge -R- xs -R- (Cons -R- y -R- ys))
            [f] -R- False = Cons -R- y -R- (merge -R- (Cons -R- x -R- xs) -R- ys)
          in f -R- (leq -R- x -R- y)
    shorterL :E: (xs :E: NList) -> (y :E: Nat) -> (ys :E: NList) -> Shorter -E- xs -E- (append -E- xs -E- (Cons -E- y -E- ys)) 
      y :E: Nat ys :E: NList
        [shorterL] -E- Nil -E- y -E- ys = LES -E- Z -E- (length -E- ys) -E- (LEZ -E- (length -E- ys))
      x :E: Nat xs :E: NList y :E: Nat ys :E: NList
        [shorterL] -E- (Cons -E- x -E- xs) -E- y -E- ys = LES -E- (S -E- (length -E- xs)) -E- (length -E- (append -E- xs -E- (Cons -E- y -E- ys))) -E- (shorterL -E- xs -E- y -E- ys)
    shorterR :E: (x :E: Nat) -> (xs :E: NList) -> (ys :E: NList) -> Shorter -E- ys -E- (Cons -E- x -E- (append -E- xs -E- ys)) 
      x :E: Nat ys :E: NList
        [shorterR] -E- x -E- Nil -E- ys = LES -E- (length -E- ys) -E- (length -E- ys) -E- (leRefl -E- (length -E- ys))
      x :E: Nat z :E: Nat xs :E: NList ys :E: NList
        [shorterR] -E- x -E- (Cons -E- z -E- xs) -E- ys = leS -E- (S -E- (length -E- ys)) -E- (length -E- (Cons -E- z -E- (append -E- xs -E- ys))) -E- (shorterR -E- z -E- xs -E- ys)
    msort' :R: (xs :R: NList) -> (acc :E: Acc -E- NList -E- Shorter -E- xs) -> NList = (\xs :R: NList. (\acc :E: Acc -E- NList -E- Shorter -E- xs. 
      let fx :R: (xs :E: NList) -> (acc :E: Acc -E- NList -E- Shorter -E- xs) -> (_x0 :R: Split -E- xs) -> NList 
        acc :E: Acc -E- NList -E- Shorter -E- Nil
          [fx] -E- [Nil] -E- acc -R- SNil = Nil
        x :R: Nat acc :E: Acc -E- NList -E- Shorter -E- (Cons -R- x -R- Nil)
          [fx] -E- [Cons -R- x -R- Nil] -E- acc -R- (SOne -R- x) = Cons -R- x -R- Nil
        y :R: Nat ys :R: NList z :R: Nat zs :R: NList acc :E: (qs :E: NList) -> (_x1 :E: Shorter -E- qs -E- (append -E- (Cons -E- y -E- ys) -E- (Cons -R- z -R- zs))) -> Acc -E- NList -E- Shorter -E- qs
          [fx] -E- [append -E- (Cons -E- y -E- ys) -E- (Cons -R- z -R- zs)] -E- ({MkAcc} -E- [NList] -E- [Shorter] -E- [append -E- (Cons -E- y -E- ys) -E- (Cons -R- z -R- zs)] -E- acc) -R- (SMore -R- y -R- ys -R- z -R- zs) = merge -R- (msort' -R- (Cons -R- y -R- ys) -E- (acc -E- (Cons -E- y -E- ys) -E- (shorterL -E- (Cons -E- y -E- ys) -E- z -E- zs))) -R- (msort' -R- (Cons -R- z -R- zs) -E- (acc -E- (Cons -E- z -E- zs) -E- (shorterR -E- y -E- ys -E- (Cons -E- z -E- zs))))
      in fx -E- xs -E- acc -R- (split -R- xs)))
    msort :R: (xs :R: NList) -> NList = (\xs :R: NList. msort' -R- xs -E- (wfShorter -E- xs))
    main :R: NList = msort -R- someList
  in main

### Specialised ###

  let
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Bool :E: Type
    postulate True :R: Bool
    postulate False :R: Bool
    postulate NList :E: Type
    postulate Nil :R: NList
    postulate Cons :R: (x :R: Nat) -> (xs :R: NList) -> NList
    someList :R: NList = Cons -R- 9 -R- (Cons -R- 5 -R- (Cons -R- 1 -R- (Cons -R- 3 -R- (Cons -R- 1 -R- (Cons -R- 5 -R- (Cons -R- 2 -R- Nil))))))
    Rel2 :E: (a :E: Type) -> Type = (\a :E: Type. (x :E: a) -> (y :E: a) -> Type)
    postulate Acc :E: (a :E: Type) -> (lt :E: Rel2 -E- a) -> (x :E: a) -> Type
    postulate MkAcc :E: (a :E: Type) -> (lt :E: Rel2 -E- a) -> (x :E: a) -> (acc :E: (y :E: a) -> (pf :E: lt -E- y -E- x) -> Acc -E- a -E- lt -E- y) -> Acc -E- a -E- lt -E- x
    postulate LE :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Type
    postulate LEZ :E: (n :E: Nat) -> LE -E- Z -E- n
    postulate LES :E: (m :E: Nat) -> (n :E: Nat) -> (_x2 :E: LE -E- m -E- n) -> LE -E- (S -E- m) -E- (S -E- n)
    LT :E: (x :E: Nat) -> (y :E: Nat) -> Type = (\x :E: Nat. (\y :E: Nat. LE -E- (S -E- x) -E- y))
    leRefl :E: (x :E: Nat) -> LE -E- x -E- x 
      [leRefl] -E- Z = LEZ -E- Z
      x :E: Nat
        [leRefl] -E- (S -E- x) = LES -E- x -E- x -E- (leRefl -E- x)
    leTrans :E: (x :E: Nat) -> (y :E: Nat) -> (z :E: Nat) -> (_x3 :E: LE -E- x -E- y) -> (_x4 :E: LE -E- y -E- z) -> LE -E- x -E- z 
      y :E: Nat z :E: Nat pf :E: LE -E- y -E- z
        [leTrans] -E- Z -E- y -E- z -E- ({LEZ} -E- [y]) -E- pf = LEZ -E- z
      x :E: Nat y :E: Nat z :E: Nat xLEy :E: LE -E- x -E- y yLEz :E: LE -E- y -E- z
        [leTrans] -E- (S -E- x) -E- (S -E- y) -E- (S -E- z) -E- ({LES} -E- [x] -E- [y] -E- xLEy) -E- ({LES} -E- [y] -E- [z] -E- yLEz) = LES -E- x -E- z -E- (leTrans -E- x -E- y -E- z -E- xLEy -E- yLEz)
    leS :E: (x :E: Nat) -> (y :E: Nat) -> (_x5 :E: LE -E- x -E- y) -> LE -E- x -E- (S -E- y) 
      y :E: Nat
        [leS] -E- Z -E- y -E- ({LEZ} -E- [y]) = LEZ -E- (S -E- y)
      x :E: Nat y :E: Nat xLEy :E: LE -E- x -E- y
        [leS] -E- (S -E- x) -E- (S -E- y) -E- ({LES} -E- [x] -E- [y] -E- xLEy) = LES -E- x -E- (S -E- y) -E- (leS -E- x -E- y -E- xLEy)
    lemmaLTZ :E: (a :E: Type) -> (n :E: Nat) -> (_x6 :E: LT -E- n -E- Z) -> a 
    wfLT :E: (x :E: Nat) -> Acc -E- Nat -E- LT -E- x = (\x :E: Nat. 
      let f :E: (x :E: Nat) -> (y :E: Nat) -> (_x7 :E: LT -E- y -E- x) -> Acc -E- Nat -E- LT -E- y 
        y :E: Nat pf :E: LT -E- y -E- Z
          [f] -E- Z -E- y -E- pf = lemmaLTZ -E- (Acc -E- Nat -E- LT -E- y) -E- y -E- pf
        x :E: Nat y :E: Nat yLEx :E: LE -E- y -E- x
          [f] -E- (S -E- x) -E- y -E- ({LES} -E- [y] -E- [x] -E- yLEx) = MkAcc -E- Nat -E- LT -E- y -E- (\z :E: Nat. (\zLTy :E: LT -E- z -E- y. f -E- x -E- z -E- (leTrans -E- (S -E- z) -E- y -E- x -E- zLTy -E- yLEx)))
      in MkAcc -E- Nat -E- LT -E- x -E- (f -E- x))
    length :R: (_x8 :R: NList) -> Nat 
      [length] -R- Nil = Z
      x :E: Nat xs :R: NList
        [length] -R- (Cons -R- x -R- xs) = S -R- (length -R- xs)
    Shorter :E: (xs :E: NList) -> (ys :E: NList) -> Type = (\xs :E: NList. (\ys :E: NList. LT -E- (length -E- xs) -E- (length -E- ys)))
    wfShorter :E: (xs :E: NList) -> Acc -E- NList -E- Shorter -E- xs = (\xs :E: NList. 
      let f :E: (xs :E: NList) -> (ys :E: NList) -> (_x9 :E: Shorter -E- ys -E- xs) -> Acc -E- NList -E- Shorter -E- ys 
        ys :E: NList pf :E: Shorter -E- ys -E- Nil
          [f] -E- Nil -E- ys -E- pf = lemmaLTZ -E- (Acc -E- NList -E- Shorter -E- ys) -E- (length -E- ys) -E- pf
        x :E: Nat xs :E: NList ys :E: NList yLEx :E: LE -E- (length -E- ys) -E- (length -E- xs)
          [f] -E- (Cons -E- x -E- xs) -E- ys -E- ({LES} -E- [length -E- ys] -E- [length -E- xs] -E- yLEx) = MkAcc -E- NList -E- Shorter -E- ys -E- (\zs :E: NList. (\zLTy :E: LT -E- (length -E- zs) -E- (length -E- ys). f -E- xs -E- zs -E- (leTrans -E- (S -E- (length -E- zs)) -E- (length -E- ys) -E- (length -E- xs) -E- zLTy -E- yLEx)))
      in MkAcc -E- NList -E- Shorter -E- xs -E- (f -E- xs))
    leq :R: (_x10 :R: Nat) -> (_x11 :R: Nat) -> Bool 
      y :E: Nat
        [leq] -R- Z -R- y = True
      x :E: Nat
        [leq] -R- (S -R- x) -R- Z = False
      x :R: Nat y :R: Nat
        [leq] -R- (S -R- x) -R- (S -R- y) = leq -R- x -R- y
    not :E: (_x12 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    qel :E: (y :E: Nat) -> (x :E: Nat) -> Bool = (\y :E: Nat. (\x :E: Nat. leq -E- x -E- y))
    gt :E: (x :E: Nat) -> (y :E: Nat) -> Bool = (\x :E: Nat. (\y :E: Nat. not -E- (leq -E- y -E- x)))
    condCons :E: (_x13 :E: Bool) -> (_x14 :E: Nat) -> (_x15 :E: NList) -> NList 
      [condCons] -E- True = Cons
      [condCons] -E- False = (\x :E: Nat. (\xs :E: NList. xs))
    filter :E: (_x16 :E: (_x17 :E: Nat) -> Bool) -> (_x18 :E: NList) -> NList 
      p :E: (_x19 :E: Nat) -> Bool
        [filter] -E- p -E- Nil = Nil
      p :E: (_x20 :E: Nat) -> Bool x :E: Nat xs :E: NList
        [filter] -E- p -E- (Cons -E- x -E- xs) = condCons -E- (p -E- x) -E- x -E- (filter -E- p -E- xs)
    append :E: (_x21 :E: NList) -> (_x22 :E: NList) -> NList 
      ys :E: NList
        [append] -E- Nil -E- ys = ys
      x :E: Nat xs :E: NList ys :E: NList
        [append] -E- (Cons -E- x -E- xs) -E- ys = Cons -R- x -R- (append -E- xs -E- ys)
    postulate Id :E: (a :E: Type) -> (_x23 :E: a) -> (_x24 :E: a) -> Type
    postulate Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    postulate Split :E: (_x25 :E: NList) -> Type
    postulate SNil :R: Split -E- Nil
    postulate SOne :R: (x :R: Nat) -> Split -E- (Cons -R- x -R- Nil)
    postulate SMore :R: (x :R: Nat) -> (xs :R: NList) -> (y :R: Nat) -> (ys :R: NList) -> Split -E- (append -E- (Cons -E- x -E- xs) -E- (Cons -R- y -R- ys))
    pushL :R: (x :R: Nat) -> (xs :E: NList) -> (_x26 :R: Split -E- xs) -> Split -E- (Cons -R- x -R- xs) 
      x :R: Nat
        [pushL] -R- x -E- [Nil] -R- SNil = SOne -R- x
      x :R: Nat y :R: Nat
        [pushL] -R- x -E- [Cons -R- y -R- Nil] -R- (SOne -R- y) = SMore -R- x -R- Nil -R- y -R- Nil
      x :R: Nat y :R: Nat ys :R: NList z :R: Nat zs :R: NList
        [pushL] -R- x -E- [append -E- (Cons -E- y -E- ys) -E- (Cons -R- z -R- zs)] -R- (SMore -R- y -R- ys -R- z -R- zs) = SMore -R- x -R- (Cons -R- y -R- ys) -R- z -R- zs
    split :R: (xs :R: NList) -> Split -E- xs 
      [split] -R- Nil = SNil
      x :R: Nat
        [split] -R- (Cons -R- x -R- Nil) = SOne -R- x
      x :R: Nat y :R: Nat xs :R: NList
        [split] -R- (Cons -R- x -R- (Cons -R- y -R- xs)) = 
          let step :R: (counter :R: Nat) -> (x :R: Nat) -> (y :R: Nat) -> (xs :R: NList) -> Split -E- (Cons -R- x -R- (Cons -R- y -R- xs)) 
            x :R: Nat y :R: Nat xs :R: NList
              [step] -R- Z -R- x -R- y -R- xs = SMore -R- x -R- Nil -R- y -R- xs
            x :R: Nat y :R: Nat xs :R: NList
              [step] -R- (S -R- Z) -R- x -R- y -R- xs = SMore -R- x -R- Nil -R- y -R- xs
            c :E: Nat x :R: Nat y :R: Nat
              [step] -R- (S -R- (S -R- c)) -R- x -R- y -R- Nil = SMore -R- x -R- Nil -R- y -R- Nil
            c :R: Nat x :R: Nat y :R: Nat z :R: Nat xs :R: NList
              [step] -R- (S -R- (S -R- c)) -R- x -R- y -R- (Cons -R- z -R- xs) = pushL -R- x -E- (Cons -R- y -R- (Cons -R- z -R- xs)) -R- (step -R- c -R- y -R- z -R- xs)
          in step -R- (S -R- (length -R- xs)) -R- x -R- y -R- xs
    merge :R: (_x27 :R: NList) -> (_x28 :R: NList) -> NList 
      ys :R: NList
        [merge] -R- Nil -R- ys = ys
      xs :R: NList
        [merge] -R- xs -R- Nil = xs
      x :R: Nat xs :R: NList y :R: Nat ys :R: NList
        [merge] -R- (Cons -R- x -R- xs) -R- (Cons -R- y -R- ys) = 
          let f :R: (_x29 :R: Bool) -> NList 
            [f] -R- True = Cons -R- x -R- (merge -R- xs -R- (Cons -R- y -R- ys))
            [f] -R- False = Cons -R- y -R- (merge -R- (Cons -R- x -R- xs) -R- ys)
          in f -R- (leq -R- x -R- y)
    shorterL :E: (xs :E: NList) -> (y :E: Nat) -> (ys :E: NList) -> Shorter -E- xs -E- (append -E- xs -E- (Cons -E- y -E- ys)) 
      y :E: Nat ys :E: NList
        [shorterL] -E- Nil -E- y -E- ys = LES -E- Z -E- (length -E- ys) -E- (LEZ -E- (length -E- ys))
      x :E: Nat xs :E: NList y :E: Nat ys :E: NList
        [shorterL] -E- (Cons -E- x -E- xs) -E- y -E- ys = LES -E- (S -E- (length -E- xs)) -E- (length -E- (append -E- xs -E- (Cons -E- y -E- ys))) -E- (shorterL -E- xs -E- y -E- ys)
    shorterR :E: (x :E: Nat) -> (xs :E: NList) -> (ys :E: NList) -> Shorter -E- ys -E- (Cons -E- x -E- (append -E- xs -E- ys)) 
      x :E: Nat ys :E: NList
        [shorterR] -E- x -E- Nil -E- ys = LES -E- (length -E- ys) -E- (length -E- ys) -E- (leRefl -E- (length -E- ys))
      x :E: Nat z :E: Nat xs :E: NList ys :E: NList
        [shorterR] -E- x -E- (Cons -E- z -E- xs) -E- ys = leS -E- (S -E- (length -E- ys)) -E- (length -E- (Cons -E- z -E- (append -E- xs -E- ys))) -E- (shorterR -E- z -E- xs -E- ys)
    msort' :R: (xs :R: NList) -> (acc :E: Acc -E- NList -E- Shorter -E- xs) -> NList = (\xs :R: NList. (\acc :E: Acc -E- NList -E- Shorter -E- xs. 
      let fx :R: (xs :E: NList) -> (acc :E: Acc -E- NList -E- Shorter -E- xs) -> (_x0 :R: Split -E- xs) -> NList 
        acc :E: Acc -E- NList -E- Shorter -E- Nil
          [fx] -E- [Nil] -E- acc -R- SNil = Nil
        x :R: Nat acc :E: Acc -E- NList -E- Shorter -E- (Cons -R- x -R- Nil)
          [fx] -E- [Cons -R- x -R- Nil] -E- acc -R- (SOne -R- x) = Cons -R- x -R- Nil
        y :R: Nat ys :R: NList z :R: Nat zs :R: NList acc :E: (qs :E: NList) -> (_x1 :E: Shorter -E- qs -E- (append -E- (Cons -E- y -E- ys) -E- (Cons -R- z -R- zs))) -> Acc -E- NList -E- Shorter -E- qs
          [fx] -E- [append -E- (Cons -E- y -E- ys) -E- (Cons -R- z -R- zs)] -E- ({MkAcc} -E- [NList] -E- [Shorter] -E- [append -E- (Cons -E- y -E- ys) -E- (Cons -R- z -R- zs)] -E- acc) -R- (SMore -R- y -R- ys -R- z -R- zs) = merge -R- (msort' -R- (Cons -R- y -R- ys) -E- (acc -E- (Cons -E- y -E- ys) -E- (shorterL -E- (Cons -E- y -E- ys) -E- z -E- zs))) -R- (msort' -R- (Cons -R- z -R- zs) -E- (acc -E- (Cons -E- z -E- zs) -E- (shorterR -E- y -E- ys -E- (Cons -E- z -E- zs))))
      in fx -E- xs -E- acc -R- (split -R- xs)))
    msort :R: (xs :R: NList) -> NList = (\xs :R: NList. msort' -R- xs -E- (wfShorter -E- xs))
    main :R: NList = msort -R- someList
  in main

### Final annotation ###

  let
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Bool :E: Type
    postulate True :R: Bool
    postulate False :R: Bool
    postulate NList :E: Type
    postulate Nil :R: NList
    postulate Cons :R: (x :R: Nat) -> (xs :R: NList) -> NList
    someList :R: NList = Cons -R- 9 -R- (Cons -R- 5 -R- (Cons -R- 1 -R- (Cons -R- 3 -R- (Cons -R- 1 -R- (Cons -R- 5 -R- (Cons -R- 2 -R- Nil))))))
    Rel2 :E: (a :E: Type) -> Type = (\a :E: Type. (x :E: a) -> (y :E: a) -> Type)
    postulate Acc :E: (a :E: Type) -> (lt :E: Rel2 -E- a) -> (x :E: a) -> Type
    postulate MkAcc :E: (a :E: Type) -> (lt :E: Rel2 -E- a) -> (x :E: a) -> (acc :E: (y :E: a) -> (pf :E: lt -E- y -E- x) -> Acc -E- a -E- lt -E- y) -> Acc -E- a -E- lt -E- x
    postulate LE :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Type
    postulate LEZ :E: (n :E: Nat) -> LE -E- Z -E- n
    postulate LES :E: (m :E: Nat) -> (n :E: Nat) -> (_x2 :E: LE -E- m -E- n) -> LE -E- (S -E- m) -E- (S -E- n)
    LT :E: (x :E: Nat) -> (y :E: Nat) -> Type = (\x :E: Nat. (\y :E: Nat. LE -E- (S -E- x) -E- y))
    leRefl :E: (x :E: Nat) -> LE -E- x -E- x 
      [leRefl] -E- Z = LEZ -E- Z
      x :E: Nat
        [leRefl] -E- (S -E- x) = LES -E- x -E- x -E- (leRefl -E- x)
    leTrans :E: (x :E: Nat) -> (y :E: Nat) -> (z :E: Nat) -> (_x3 :E: LE -E- x -E- y) -> (_x4 :E: LE -E- y -E- z) -> LE -E- x -E- z 
      y :E: Nat z :E: Nat pf :E: LE -E- y -E- z
        [leTrans] -E- Z -E- y -E- z -E- ({LEZ} -E- [y]) -E- pf = LEZ -E- z
      x :E: Nat y :E: Nat z :E: Nat xLEy :E: LE -E- x -E- y yLEz :E: LE -E- y -E- z
        [leTrans] -E- (S -E- x) -E- (S -E- y) -E- (S -E- z) -E- ({LES} -E- [x] -E- [y] -E- xLEy) -E- ({LES} -E- [y] -E- [z] -E- yLEz) = LES -E- x -E- z -E- (leTrans -E- x -E- y -E- z -E- xLEy -E- yLEz)
    leS :E: (x :E: Nat) -> (y :E: Nat) -> (_x5 :E: LE -E- x -E- y) -> LE -E- x -E- (S -E- y) 
      y :E: Nat
        [leS] -E- Z -E- y -E- ({LEZ} -E- [y]) = LEZ -E- (S -E- y)
      x :E: Nat y :E: Nat xLEy :E: LE -E- x -E- y
        [leS] -E- (S -E- x) -E- (S -E- y) -E- ({LES} -E- [x] -E- [y] -E- xLEy) = LES -E- x -E- (S -E- y) -E- (leS -E- x -E- y -E- xLEy)
    lemmaLTZ :E: (a :E: Type) -> (n :E: Nat) -> (_x6 :E: LT -E- n -E- Z) -> a 
    wfLT :E: (x :E: Nat) -> Acc -E- Nat -E- LT -E- x = (\x :E: Nat. 
      let f :E: (x :E: Nat) -> (y :E: Nat) -> (_x7 :E: LT -E- y -E- x) -> Acc -E- Nat -E- LT -E- y 
        y :E: Nat pf :E: LT -E- y -E- Z
          [f] -E- Z -E- y -E- pf = lemmaLTZ -E- (Acc -E- Nat -E- LT -E- y) -E- y -E- pf
        x :E: Nat y :E: Nat yLEx :E: LE -E- y -E- x
          [f] -E- (S -E- x) -E- y -E- ({LES} -E- [y] -E- [x] -E- yLEx) = MkAcc -E- Nat -E- LT -E- y -E- (\z :E: Nat. (\zLTy :E: LT -E- z -E- y. f -E- x -E- z -E- (leTrans -E- (S -E- z) -E- y -E- x -E- zLTy -E- yLEx)))
      in MkAcc -E- Nat -E- LT -E- x -E- (f -E- x))
    length :R: (_x8 :R: NList) -> Nat 
      [length] -R- Nil = Z
      x :E: Nat xs :R: NList
        [length] -R- (Cons -R- x -R- xs) = S -R- (length -R- xs)
    Shorter :E: (xs :E: NList) -> (ys :E: NList) -> Type = (\xs :E: NList. (\ys :E: NList. LT -E- (length -E- xs) -E- (length -E- ys)))
    wfShorter :E: (xs :E: NList) -> Acc -E- NList -E- Shorter -E- xs = (\xs :E: NList. 
      let f :E: (xs :E: NList) -> (ys :E: NList) -> (_x9 :E: Shorter -E- ys -E- xs) -> Acc -E- NList -E- Shorter -E- ys 
        ys :E: NList pf :E: Shorter -E- ys -E- Nil
          [f] -E- Nil -E- ys -E- pf = lemmaLTZ -E- (Acc -E- NList -E- Shorter -E- ys) -E- (length -E- ys) -E- pf
        x :E: Nat xs :E: NList ys :E: NList yLEx :E: LE -E- (length -E- ys) -E- (length -E- xs)
          [f] -E- (Cons -E- x -E- xs) -E- ys -E- ({LES} -E- [length -E- ys] -E- [length -E- xs] -E- yLEx) = MkAcc -E- NList -E- Shorter -E- ys -E- (\zs :E: NList. (\zLTy :E: LT -E- (length -E- zs) -E- (length -E- ys). f -E- xs -E- zs -E- (leTrans -E- (S -E- (length -E- zs)) -E- (length -E- ys) -E- (length -E- xs) -E- zLTy -E- yLEx)))
      in MkAcc -E- NList -E- Shorter -E- xs -E- (f -E- xs))
    leq :R: (_x10 :R: Nat) -> (_x11 :R: Nat) -> Bool 
      y :E: Nat
        [leq] -R- Z -R- y = True
      x :E: Nat
        [leq] -R- (S -R- x) -R- Z = False
      x :R: Nat y :R: Nat
        [leq] -R- (S -R- x) -R- (S -R- y) = leq -R- x -R- y
    not :E: (_x12 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    qel :E: (y :E: Nat) -> (x :E: Nat) -> Bool = (\y :E: Nat. (\x :E: Nat. leq -E- x -E- y))
    gt :E: (x :E: Nat) -> (y :E: Nat) -> Bool = (\x :E: Nat. (\y :E: Nat. not -E- (leq -E- y -E- x)))
    condCons :E: (_x13 :E: Bool) -> (_x14 :E: Nat) -> (_x15 :E: NList) -> NList 
      [condCons] -E- True = Cons
      [condCons] -E- False = (\x :E: Nat. (\xs :E: NList. xs))
    filter :E: (_x16 :E: (_x17 :E: Nat) -> Bool) -> (_x18 :E: NList) -> NList 
      p :E: (_x19 :E: Nat) -> Bool
        [filter] -E- p -E- Nil = Nil
      p :E: (_x20 :E: Nat) -> Bool x :E: Nat xs :E: NList
        [filter] -E- p -E- (Cons -E- x -E- xs) = condCons -E- (p -E- x) -E- x -E- (filter -E- p -E- xs)
    append :E: (_x21 :E: NList) -> (_x22 :E: NList) -> NList 
      ys :E: NList
        [append] -E- Nil -E- ys = ys
      x :E: Nat xs :E: NList ys :E: NList
        [append] -E- (Cons -E- x -E- xs) -E- ys = Cons -R- x -R- (append -E- xs -E- ys)
    postulate Id :E: (a :E: Type) -> (_x23 :E: a) -> (_x24 :E: a) -> Type
    postulate Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    postulate Split :E: (_x25 :E: NList) -> Type
    postulate SNil :R: Split -E- Nil
    postulate SOne :R: (x :R: Nat) -> Split -E- (Cons -R- x -R- Nil)
    postulate SMore :R: (x :R: Nat) -> (xs :R: NList) -> (y :R: Nat) -> (ys :R: NList) -> Split -E- (append -E- (Cons -E- x -E- xs) -E- (Cons -R- y -R- ys))
    pushL :R: (x :R: Nat) -> (xs :E: NList) -> (_x26 :R: Split -E- xs) -> Split -E- (Cons -R- x -R- xs) 
      x :R: Nat
        [pushL] -R- x -E- [Nil] -R- SNil = SOne -R- x
      x :R: Nat y :R: Nat
        [pushL] -R- x -E- [Cons -R- y -R- Nil] -R- (SOne -R- y) = SMore -R- x -R- Nil -R- y -R- Nil
      x :R: Nat y :R: Nat ys :R: NList z :R: Nat zs :R: NList
        [pushL] -R- x -E- [append -E- (Cons -E- y -E- ys) -E- (Cons -R- z -R- zs)] -R- (SMore -R- y -R- ys -R- z -R- zs) = SMore -R- x -R- (Cons -R- y -R- ys) -R- z -R- zs
    split :R: (xs :R: NList) -> Split -E- xs 
      [split] -R- Nil = SNil
      x :R: Nat
        [split] -R- (Cons -R- x -R- Nil) = SOne -R- x
      x :R: Nat y :R: Nat xs :R: NList
        [split] -R- (Cons -R- x -R- (Cons -R- y -R- xs)) = 
          let step :R: (counter :R: Nat) -> (x :R: Nat) -> (y :R: Nat) -> (xs :R: NList) -> Split -E- (Cons -R- x -R- (Cons -R- y -R- xs)) 
            x :R: Nat y :R: Nat xs :R: NList
              [step] -R- Z -R- x -R- y -R- xs = SMore -R- x -R- Nil -R- y -R- xs
            x :R: Nat y :R: Nat xs :R: NList
              [step] -R- (S -R- Z) -R- x -R- y -R- xs = SMore -R- x -R- Nil -R- y -R- xs
            c :E: Nat x :R: Nat y :R: Nat
              [step] -R- (S -R- (S -R- c)) -R- x -R- y -R- Nil = SMore -R- x -R- Nil -R- y -R- Nil
            c :R: Nat x :R: Nat y :R: Nat z :R: Nat xs :R: NList
              [step] -R- (S -R- (S -R- c)) -R- x -R- y -R- (Cons -R- z -R- xs) = pushL -R- x -E- (Cons -R- y -R- (Cons -R- z -R- xs)) -R- (step -R- c -R- y -R- z -R- xs)
          in step -R- (S -R- (length -R- xs)) -R- x -R- y -R- xs
    merge :R: (_x27 :R: NList) -> (_x28 :R: NList) -> NList 
      ys :R: NList
        [merge] -R- Nil -R- ys = ys
      xs :R: NList
        [merge] -R- xs -R- Nil = xs
      x :R: Nat xs :R: NList y :R: Nat ys :R: NList
        [merge] -R- (Cons -R- x -R- xs) -R- (Cons -R- y -R- ys) = 
          let f :R: (_x29 :R: Bool) -> NList 
            [f] -R- True = Cons -R- x -R- (merge -R- xs -R- (Cons -R- y -R- ys))
            [f] -R- False = Cons -R- y -R- (merge -R- (Cons -R- x -R- xs) -R- ys)
          in f -R- (leq -R- x -R- y)
    shorterL :E: (xs :E: NList) -> (y :E: Nat) -> (ys :E: NList) -> Shorter -E- xs -E- (append -E- xs -E- (Cons -E- y -E- ys)) 
      y :E: Nat ys :E: NList
        [shorterL] -E- Nil -E- y -E- ys = LES -E- Z -E- (length -E- ys) -E- (LEZ -E- (length -E- ys))
      x :E: Nat xs :E: NList y :E: Nat ys :E: NList
        [shorterL] -E- (Cons -E- x -E- xs) -E- y -E- ys = LES -E- (S -E- (length -E- xs)) -E- (length -E- (append -E- xs -E- (Cons -E- y -E- ys))) -E- (shorterL -E- xs -E- y -E- ys)
    shorterR :E: (x :E: Nat) -> (xs :E: NList) -> (ys :E: NList) -> Shorter -E- ys -E- (Cons -E- x -E- (append -E- xs -E- ys)) 
      x :E: Nat ys :E: NList
        [shorterR] -E- x -E- Nil -E- ys = LES -E- (length -E- ys) -E- (length -E- ys) -E- (leRefl -E- (length -E- ys))
      x :E: Nat z :E: Nat xs :E: NList ys :E: NList
        [shorterR] -E- x -E- (Cons -E- z -E- xs) -E- ys = leS -E- (S -E- (length -E- ys)) -E- (length -E- (Cons -E- z -E- (append -E- xs -E- ys))) -E- (shorterR -E- z -E- xs -E- ys)
    msort' :R: (xs :R: NList) -> (acc :E: Acc -E- NList -E- Shorter -E- xs) -> NList = (\xs :R: NList. (\acc :E: Acc -E- NList -E- Shorter -E- xs. 
      let fx :R: (xs :E: NList) -> (acc :E: Acc -E- NList -E- Shorter -E- xs) -> (_x0 :R: Split -E- xs) -> NList 
        acc :E: Acc -E- NList -E- Shorter -E- Nil
          [fx] -E- [Nil] -E- acc -R- SNil = Nil
        x :R: Nat acc :E: Acc -E- NList -E- Shorter -E- (Cons -R- x -R- Nil)
          [fx] -E- [Cons -R- x -R- Nil] -E- acc -R- (SOne -R- x) = Cons -R- x -R- Nil
        y :R: Nat ys :R: NList z :R: Nat zs :R: NList acc :E: (qs :E: NList) -> (_x1 :E: Shorter -E- qs -E- (append -E- (Cons -E- y -E- ys) -E- (Cons -R- z -R- zs))) -> Acc -E- NList -E- Shorter -E- qs
          [fx] -E- [append -E- (Cons -E- y -E- ys) -E- (Cons -R- z -R- zs)] -E- ({MkAcc} -E- [NList] -E- [Shorter] -E- [append -E- (Cons -E- y -E- ys) -E- (Cons -R- z -R- zs)] -E- acc) -R- (SMore -R- y -R- ys -R- z -R- zs) = merge -R- (msort' -R- (Cons -R- y -R- ys) -E- (acc -E- (Cons -E- y -E- ys) -E- (shorterL -E- (Cons -E- y -E- ys) -E- z -E- zs))) -R- (msort' -R- (Cons -R- z -R- zs) -E- (acc -E- (Cons -E- z -E- zs) -E- (shorterR -E- y -E- ys -E- (Cons -E- z -E- zs))))
      in fx -E- xs -E- acc -R- (split -R- xs)))
    msort :R: (xs :R: NList) -> NList = (\xs :R: NList. msort' -R- xs -E- (wfShorter -E- xs))
    main :R: NList = msort -R- someList
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Z : Nat
    postulate S : (n) -> Nat
    postulate True : Bool
    postulate False : Bool
    postulate Nil : NList
    postulate Cons : (x) -> (xs) -> NList
    someList = Cons 9 (Cons 5 (Cons 1 (Cons 3 (Cons 1 (Cons 5 (Cons 2 Nil))))))
    length 
      [_] Nil = Z
      [_] (Cons _ xs) = S (length xs)
    leq 
      [_] Z _ = True
      [_] (S _) Z = False
      [_] (S x) (S y) = leq x y
    postulate SNil : Split
    postulate SOne : (x) -> Split
    postulate SMore : (x) -> (xs) -> (y) -> (ys) -> Split
    pushL 
      [_] x SNil = SOne x
      [_] x (SOne y) = SMore x Nil y Nil
      [_] x (SMore y ys z zs) = SMore x (Cons y ys) z zs
    split 
      [_] Nil = SNil
      [_] (Cons x Nil) = SOne x
      [_] (Cons x (Cons y xs)) = 
        let step 
          [_] Z x y xs = SMore x Nil y xs
          [_] (S Z) x y xs = SMore x Nil y xs
          [_] (S (S _)) x y Nil = SMore x Nil y Nil
          [_] (S (S c)) x y (Cons z xs) = pushL x (step c y z xs)
        in step (S (length xs)) x y xs
    merge 
      [_] Nil ys = ys
      [_] xs Nil = xs
      [_] (Cons x xs) (Cons y ys) = 
        let f 
          [_] True = Cons x (merge xs (Cons y ys))
          [_] False = Cons y (merge (Cons x xs) ys)
        in f (leq x y)
    msort' = (\xs. 
      let fx 
        [_] SNil = Nil
        [_] (SOne x) = Cons x Nil
        [_] (SMore y ys z zs) = merge (msort' (Cons y ys)) (msort' (Cons z zs))
      in fx (split xs))
    msort = (\xs. msort' xs)
    main = msort someList
  in main

### Normal forms ###

unerased:
  
  let
    postulate Nat : Type
    postulate Z : Nat
    postulate S : (n :R: Nat) -> Nat
    postulate NList : Type
    postulate Nil : NList
    postulate Cons : (x :R: Nat) -> (xs :R: NList) -> NList
  in Cons 1 (Cons 1 (Cons 2 (Cons 3 (Cons 5 (Cons 5 (Cons 9 Nil))))))

erased:
  
  let
    postulate Z : Nat
    postulate S : (n) -> Nat
    postulate Nil : NList
    postulate Cons : (x) -> (xs) -> NList
  in Cons 1 (Cons 1 (Cons 2 (Cons 3 (Cons 5 (Cons 5 (Cons 9 Nil))))))

