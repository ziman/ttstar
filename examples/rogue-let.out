-- vim: ft=agda

### Desugared ###

  let
    postulate Bool : Type
    postulate T : Bool
    postulate F : Bool
    not : (x : Bool) -> Bool = \(x : Bool).
      case x of
        T
          => F
        F
          => T
    main : (x#0 : Bool) -> Bool = not
  in main

### Metaified ###

  let
    postulate Bool :1: Type
    postulate T :2: Bool
    postulate F :3: Bool
    not :4: (x :5: Bool) -> Bool = \(x :6: Bool).
      case -7- x of
        T/8
          => F
        F/9
          => T
    main :10: (x#0 :11: Bool) -> Bool = not
  in main

### Constraints ###

[] -> [2,3,4,5,6,7,8,9,11,R]
[R] -> [10]

### Solution ###

[2,3,4,5,6,7,8,9,10,11,R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
      case -R- x of
        T/R
          => F
        F/R
          => T
    main :R: (x#0 :R: Bool) -> Bool = not
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
      case -R- x of
        T/R
          => F
        F/R
          => T
    main :R: (x#0 :R: Bool) -> Bool = not
  in main

### Final annotation ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
      case -R- x of
        T/R
          => F
        F/R
          => T
    main :R: (x#0 :R: Bool) -> Bool = not
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate T : Bool
    postulate F : Bool
    not = \x.
      case x of
        T
          => F
        F
          => T
    main = not
  in main

### Normal forms ###

unerased:
  
  let not : (x : Bool) -> Bool = \(x : Bool).
    case x of
      T
        => F
      F
        => T
  in not

erased:
  
  let not = \x.
    case x of
      T
        => F
      F
        => T
  in not

