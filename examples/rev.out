-- vim: ft=agda

### Desugared ###

  let
    postulate Id : (a : Type) -> (x : a) -> (y : a) -> Type
    postulate Refl : (a : Type) -> (x : a) -> Id a x x
    id : (a : Type) -> (_ : a) -> a = (\a : Type. (\x : a. x))
    subst : (a : Type) -> (P : (_ : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (_ : P x) -> P y = \(a : Type) (P : (_ : a) -> Type) (x : a) (y : a) (eq : Id a x y).
      case eq of
        Refl (a' : Type) (x' : a)
          | a' = a
          | x' = x
          | y = x
          => (\w : P x. w)
    cong : (a : Type) -> (b : Type) -> (f : (_ : a) -> b) -> (x : a) -> (y : a) -> (eq : Id a x y) -> Id b (f x) (f y) = \(a : Type) (b : Type) (f : (_ : a) -> b) (x : a) (y : a) (eq : Id a x y).
      case eq of
        Refl (a' : Type) (x' : a)
          | a' = a
          | x' = x
          | y = x
          => Refl b (f x)
    postulate Bool : Type
    postulate T : Bool
    postulate F : Bool
    postulate List : Type
    postulate Nil : List
    postulate Cons : (x :R: Bool) -> (xs :R: List) -> List
    one : (x : Bool) -> List = (\x : Bool. Cons x Nil)
    app : (xs : List) -> (ys : List) -> List = \(xs : List) (ys : List).
      case xs of
        Nil
          => ys
        Cons (x : Bool) (xs' : List)
          => Cons x (app xs' ys)
    appRightNeutral : (ys : List) -> Id List ys (app ys Nil) = \(ys : List).
      case ys of
        Nil
          => Refl List Nil
        Cons (x : Bool) (xs : List)
          => cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs)
    appAssoc : (xs : List) -> (ys : List) -> (zs : List) -> Id List (app (app xs ys) zs) (app xs (app ys zs)) = \(xs : List) (ys : List) (zs : List).
      case xs of
        Nil
          => Refl List (app ys zs)
        Cons (x : Bool) (xs' : List)
          => cong List List (Cons x) (app (app xs' ys) zs) (app xs' (app ys zs)) (appAssoc xs' ys zs)
    postulate Rev : (_ : List) -> Type
    postulate RNil : Rev Nil
    postulate RSnoc : (xs : List) -> (x : Bool) -> (rxs : Rev xs) -> Rev (app xs (one x))
    rev' : (xs : List) -> (rxs : Rev xs) -> (ys : List) -> Rev (app xs ys) = \(xs : List) (rxs : Rev xs) (ys : List).
      case ys of
        Nil
          => subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
        Cons (y : Bool) (ys' : List)
          => subst List Rev (app (app xs (one y)) ys') (app xs (Cons y ys')) (appAssoc xs (one y) ys') (rev' (app xs (one y)) (RSnoc xs y rxs) ys')
    rev : (xs : List) -> Rev xs = (\xs : List. rev' Nil RNil xs)
    reverse' : (xs : List) -> (rxs : Rev xs) -> List = \(xs : List) (rxs : Rev xs).
      case rxs of
        RNil
          | xs = Nil
          => Nil
        RSnoc (xs' : List) (x : Bool) (rxs' : Rev xs')
          | xs = app xs' (one x)
          => Cons x (reverse' xs' rxs')
    reverse : (xs : List) -> List = (\xs : List. reverse' xs (rev xs))
    main : List = reverse (Cons T (Cons F (Cons T (Cons F Nil))))
  in main

### Metaified ###

  let
    postulate Id :1: (a :2: Type) -> (x :3: a) -> (y :4: a) -> Type
    postulate Refl :5: (a :6: Type) -> (x :7: a) -> Id -10- a -9- x -8- x
    id :11: (a :12: Type) -> (_ :13: a) -> a = (\a :14: Type. (\x :15: a. x))
    subst :16: (a :17: Type) -> (P :18: (_ :19: a) -> Type) -> (x :20: a) -> (y :21: a) -> (eq :22: Id -25- a -24- x -23- y) -> (_ :26: P -27- x) -> P -28- y = \(a :29: Type) (P :30: (_ :31: a) -> Type) (x :32: a) (y :33: a) (eq :34: Id -37- a -36- x -35- y).
      case -38- eq of
        Refl/39 (a' :40: Type) (x' :41: a)
          | a' = a
          | x' = x
          | y = x
          => (\w :42: P -43- x. w)
    cong :44: (a :45: Type) -> (b :46: Type) -> (f :47: (_ :48: a) -> b) -> (x :49: a) -> (y :50: a) -> (eq :51: Id -54- a -53- x -52- y) -> Id -57- b -56- (f -58- x) -55- (f -59- y) = \(a :60: Type) (b :61: Type) (f :62: (_ :63: a) -> b) (x :64: a) (y :65: a) (eq :66: Id -69- a -68- x -67- y).
      case -70- eq of
        Refl/71 (a' :72: Type) (x' :73: a)
          | a' = a
          | x' = x
          | y = x
          => Refl -75- b -74- (f -76- x)
    postulate Bool :77: Type
    postulate T :78: Bool
    postulate F :79: Bool
    postulate List :80: Type
    postulate Nil :81: List
    postulate Cons :82: (x :R: Bool) -> (xs :R: List) -> List
    one :83: (x :84: Bool) -> List = (\x :85: Bool. Cons -87- x -86- Nil)
    app :88: (xs :89: List) -> (ys :90: List) -> List = \(xs :91: List) (ys :92: List).
      case -93- xs of
        Nil/94
          => ys
        Cons/95 (x :96: Bool) (xs' :97: List)
          => Cons -99- x -98- (app -101- xs' -100- ys)
    appRightNeutral :102: (ys :103: List) -> Id -106- List -105- ys -104- (app -108- ys -107- Nil) = \(ys :109: List).
      case -110- ys of
        Nil/111
          => Refl -113- List -112- Nil
        Cons/114 (x :115: Bool) (xs :116: List)
          => cong -122- List -121- List -120- (Cons -123- x) -119- xs -118- (app -125- xs -124- Nil) -117- (appRightNeutral -126- xs)
    appAssoc :127: (xs :128: List) -> (ys :129: List) -> (zs :130: List) -> Id -133- List -132- (app -135- (app -137- xs -136- ys) -134- zs) -131- (app -139- xs -138- (app -141- ys -140- zs)) = \(xs :142: List) (ys :143: List) (zs :144: List).
      case -145- xs of
        Nil/146
          => Refl -148- List -147- (app -150- ys -149- zs)
        Cons/151 (x :152: Bool) (xs' :153: List)
          => cong -159- List -158- List -157- (Cons -160- x) -156- (app -162- (app -164- xs' -163- ys) -161- zs) -155- (app -166- xs' -165- (app -168- ys -167- zs)) -154- (appAssoc -171- xs' -170- ys -169- zs)
    postulate Rev :172: (_ :173: List) -> Type
    postulate RNil :174: Rev -175- Nil
    postulate RSnoc :176: (xs :177: List) -> (x :178: Bool) -> (rxs :179: Rev -180- xs) -> Rev -181- (app -183- xs -182- (one -184- x))
    rev' :185: (xs :186: List) -> (rxs :187: Rev -188- xs) -> (ys :189: List) -> Rev -190- (app -192- xs -191- ys) = \(xs :193: List) (rxs :194: Rev -195- xs) (ys :196: List).
      case -197- ys of
        Nil/198
          => subst -204- List -203- Rev -202- xs -201- (app -206- xs -205- Nil) -200- (appRightNeutral -207- xs) -199- rxs
        Cons/208 (y :209: Bool) (ys' :210: List)
          => subst -216- List -215- Rev -214- (app -218- (app -220- xs -219- (one -221- y)) -217- ys') -213- (app -223- xs -222- (Cons -225- y -224- ys')) -212- (appAssoc -228- xs -227- (one -229- y) -226- ys') -211- (rev' -232- (app -234- xs -233- (one -235- y)) -231- (RSnoc -238- xs -237- y -236- rxs) -230- ys')
    rev :239: (xs :240: List) -> Rev -241- xs = (\xs :242: List. rev' -245- Nil -244- RNil -243- xs)
    reverse' :246: (xs :247: List) -> (rxs :248: Rev -249- xs) -> List = \(xs :250: List) (rxs :251: Rev -252- xs).
      case -253- rxs of
        RNil/254
          | xs = Nil
          => Nil
        RSnoc/255 (xs' :256: List) (x :257: Bool) (rxs' :258: Rev -259- xs')
          | xs = app -261- xs' -260- (one -262- x)
          => Cons -264- x -263- (reverse' -266- xs' -265- rxs')
    reverse :267: (xs :268: List) -> List = (\xs :269: List. reverse' -271- xs -270- (rev -272- xs))
    main :273: List = reverse -274- (Cons -276- T -275- (Cons -278- F -277- (Cons -280- T -279- (Cons -282- F -281- Nil))))
  in main

### Constraints ###

[] -> [16,26,42,78,79,81,82,174,176,178,179,185,187,189,194,196,197,198,199,208,209,210,211,224,225,230,231,236,237,239,240,242,243,244,246,248,251,253,254,255,257,258,263,264,265,267,268,269,270,272,274,275,276,277,278,279,280,281,282,R]
[5] -> [39]
[6] -> [22,40]
[6,22] -> [51,61,72,75,80,113,148]
[7] -> [22,41]
[7,22] -> [51,62,73,74,88,89,90,91,92,93,94,95,96,97,98,99,100,101,112,147]
[7,22,63] -> [64,76]
[7,22,76] -> [63]
[7,22,89] -> [143,150]
[7,22,90] -> [144,149]
[7,22,149] -> [90]
[7,22,150] -> [89]
[8] -> [22,23]
[8,22] -> [51,52,55,104,131]
[9] -> [22,24]
[9,22] -> [51,53,56,105,132]
[10] -> [22,25]
[10,22] -> [51,54,57,106,133]
[17] -> [29,80,204,216]
[18] -> [30,172,203,215]
[18,19] -> [173]
[18,173] -> [19]
[19] -> [18,31]
[20] -> [32,88,89,90,91,92,93,94,95,96,97,98,99,100,101,193,202,214]
[20,84,89,90] -> [221]
[20,89] -> [88,89,90,91,92,93,94,95,96,97,98,99,100,101,193,218,220]
[20,89,90] -> [83,84,85,86,87,219]
[20,89,90,221] -> [84]
[20,89,219] -> [90]
[20,89,220] -> [89]
[20,90] -> [217]
[20,217] -> [90]
[20,218] -> [89]
[21] -> [33,88,89,90,91,92,93,94,95,96,97,98,99,100,101,201,213]
[21,89] -> [193,206,223]
[21,90] -> [205,222]
[21,205] -> [90]
[21,206] -> [89]
[21,222] -> [90]
[21,223] -> [89]
[22] -> [5,34,44,71,98,99,102,103,109,110,111,114,127,128,142,145,146,151,200,212]
[22,23] -> [104,131]
[22,24] -> [105,132]
[22,25] -> [106,133]
[22,45] -> [60,80,122,159]
[22,46] -> [61,80,121,158]
[22,47] -> [48,62,115,120,123,152,157,160]
[22,48] -> [47,63]
[22,49] -> [64,88,89,90,91,92,93,94,95,96,97,98,99,100,101,116,119,156]
[22,49,89] -> [88,89,90,91,92,93,94,95,96,97,98,99,100,101,153,162,164]
[22,49,89,90] -> [143,163]
[22,49,89,163] -> [90]
[22,49,89,164] -> [89]
[22,49,90] -> [144,161]
[22,49,161] -> [90]
[22,49,162] -> [89]
[22,50] -> [65,88,89,90,91,92,93,94,95,96,97,98,99,100,101,118,155]
[22,50,89] -> [116,125,153,166]
[22,50,89,90] -> [143,168]
[22,50,90] -> [88,89,90,91,92,93,94,95,96,97,98,99,100,101,124,144,165,167]
[22,50,90,167] -> [90]
[22,50,90,168] -> [89]
[22,50,124] -> [90]
[22,50,125] -> [89]
[22,50,165] -> [90]
[22,50,166] -> [89]
[22,51] -> [66,102,116,117,126,127,153,154,171]
[22,51,52] -> [104,131]
[22,51,53] -> [105,132]
[22,51,54] -> [106,133]
[22,51,104] -> [52]
[22,51,105] -> [53]
[22,51,106] -> [54]
[22,51,107] -> [124]
[22,51,108] -> [125]
[22,51,124] -> [107]
[22,51,125] -> [108]
[22,51,129] -> [143,170]
[22,51,130] -> [144,169]
[22,51,131] -> [52]
[22,51,132] -> [53]
[22,51,133] -> [54]
[22,51,134] -> [161]
[22,51,135] -> [162]
[22,51,136] -> [163]
[22,51,137] -> [164]
[22,51,138] -> [165]
[22,51,139] -> [166]
[22,51,140] -> [167]
[22,51,141] -> [168]
[22,51,161] -> [134]
[22,51,162] -> [135]
[22,51,163] -> [136]
[22,51,164] -> [137]
[22,51,165] -> [138]
[22,51,166] -> [139]
[22,51,167] -> [140]
[22,51,168] -> [141]
[22,51,169] -> [130]
[22,51,170] -> [129]
[22,52] -> [8,51]
[22,53] -> [9,51]
[22,54] -> [10,51]
[22,55] -> [8,104,131]
[22,56] -> [9,105,132]
[22,57] -> [10,106,133]
[22,58] -> [76,98,116]
[22,59] -> [76,98]
[22,60] -> [45]
[22,61] -> [46]
[22,62] -> [47]
[22,63] -> [47,48]
[22,64] -> [49]
[22,65] -> [50]
[22,66] -> [51]
[22,70] -> [66]
[22,72] -> [6,51,70]
[22,73] -> [7,51,70]
[22,74] -> [7]
[22,75] -> [6]
[22,76] -> [58,59]
[22,84,129] -> [229]
[22,86] -> [86]
[22,87] -> [87]
[22,98] -> [58,59]
[22,99] -> [123,160]
[22,100] -> [124,161,163,165]
[22,101] -> [125,162,164,166]
[22,103] -> [193,207]
[22,104] -> [8,23,55]
[22,105] -> [9,24,56]
[22,106] -> [10,25,57]
[22,107] -> [205]
[22,108] -> [206]
[22,112] -> [7]
[22,113] -> [6]
[22,115] -> [123]
[22,116] -> [58]
[22,117] -> [51]
[22,118] -> [50]
[22,119] -> [49]
[22,120] -> [47]
[22,121] -> [46]
[22,122] -> [45]
[22,123] -> [99,115]
[22,124] -> [100]
[22,125] -> [101]
[22,128] -> [193,228]
[22,129] -> [83,84,85,86,87,143,227]
[22,129,229] -> [84]
[22,130] -> [144,226]
[22,131] -> [8,23,55]
[22,132] -> [9,24,56]
[22,133] -> [10,25,57]
[22,134] -> [149,217]
[22,135] -> [150,218]
[22,136] -> [219]
[22,137] -> [220]
[22,138] -> [222]
[22,139] -> [223]
[22,140] -> [149,167]
[22,141] -> [150,168]
[22,143] -> [129]
[22,144] -> [130]
[22,147] -> [7]
[22,148] -> [6]
[22,149] -> [134,140]
[22,150] -> [135,141]
[22,154] -> [51]
[22,155] -> [50]
[22,156] -> [49]
[22,157] -> [47]
[22,158] -> [46]
[22,159] -> [45]
[22,160] -> [99]
[22,161] -> [100]
[22,162] -> [101]
[22,163] -> [100]
[22,164] -> [101]
[22,165] -> [100]
[22,166] -> [101]
[22,167] -> [140]
[22,168] -> [141]
[22,205] -> [107]
[22,206] -> [108]
[22,207] -> [103]
[22,217] -> [134]
[22,218] -> [135]
[22,219] -> [136]
[22,220] -> [137]
[22,222] -> [138]
[22,223] -> [139]
[22,226] -> [130]
[22,227] -> [129]
[22,228] -> [128]
[23] -> [8,22]
[24] -> [9,22]
[25] -> [10,22]
[27] -> [43,190,195]
[28] -> [43,190]
[29] -> [17]
[30] -> [18]
[31] -> [18,19]
[32] -> [20]
[33] -> [21]
[34] -> [22]
[38] -> [34]
[39] -> [5]
[40] -> [6,22,38]
[41] -> [7,22,38]
[43] -> [27,28]
[84,90,186] -> [235]
[86] -> [86]
[87] -> [87]
[89,186] -> [193,234]
[90,186] -> [83,84,85,86,87,233]
[90,186,235] -> [84]
[175] -> [188,249]
[177] -> [193,238,256]
[180] -> [195,259]
[181] -> [188,249]
[182] -> [233,260]
[183] -> [234,261]
[186] -> [88,89,90,91,92,93,94,95,96,97,98,99,100,101,193,232,245]
[186,233] -> [90]
[186,234] -> [89]
[188] -> [175,181,195]
[190] -> [27,28,241]
[191] -> [205,217,222]
[192] -> [206,218,223]
[193] -> [186]
[195] -> [27,180,188]
[200] -> [22]
[201] -> [21]
[202] -> [20]
[203] -> [18]
[204] -> [17]
[205] -> [191]
[206] -> [192]
[212] -> [22]
[213] -> [21]
[214] -> [20]
[215] -> [18]
[216] -> [17]
[217] -> [191]
[218] -> [192]
[219] -> [233]
[220] -> [234]
[222] -> [191]
[223] -> [192]
[232] -> [186]
[233] -> [182,219]
[234] -> [183,220]
[238] -> [177]
[241] -> [190,249]
[245] -> [186]
[247] -> [250,256,266,271]
[249] -> [175,181,241,259]
[250] -> [247]
[256] -> [177]
[259] -> [180,249]
[260] -> [182]
[261] -> [183]
[266] -> [247]
[271] -> [247]
[R] -> [273]

### Solution ###

[16,26,42,78,79,81,82,174,176,178,179,185,187,189,194,196,197,198,199,208,209,210,211,224,225,230,231,236,237,239,240,242,243,244,246,248,251,253,254,255,257,258,263,264,265,267,268,269,270,272,273,274,275,276,277,278,279,280,281,282,R]

### Annotated ###

  let
    postulate Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    postulate Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    id :E: (a :E: Type) -> (_ :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    subst :R: (a :E: Type) -> (P :E: (_ :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_ :R: P -E- x) -> P -E- y = \(a :E: Type) (P :E: (_ :E: a) -> Type) (x :E: a) (y :E: a) (eq :E: Id -E- a -E- x -E- y).
      case -E- eq of
        Refl/E (a' :E: Type) (x' :E: a)
          | a' = a
          | x' = x
          | y = x
          => (\w :R: P -E- x. w)
    cong :E: (a :E: Type) -> (b :E: Type) -> (f :E: (_ :E: a) -> b) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> Id -E- b -E- (f -E- x) -E- (f -E- y) = \(a :E: Type) (b :E: Type) (f :E: (_ :E: a) -> b) (x :E: a) (y :E: a) (eq :E: Id -E- a -E- x -E- y).
      case -E- eq of
        Refl/E (a' :E: Type) (x' :E: a)
          | a' = a
          | x' = x
          | y = x
          => Refl -E- b -E- (f -E- x)
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate List :E: Type
    postulate Nil :R: List
    postulate Cons :R: (x :R: Bool) -> (xs :R: List) -> List
    one :E: (x :E: Bool) -> List = (\x :E: Bool. Cons -E- x -E- Nil)
    app :E: (xs :E: List) -> (ys :E: List) -> List = \(xs :E: List) (ys :E: List).
      case -E- xs of
        Nil/E
          => ys
        Cons/E (x :E: Bool) (xs' :E: List)
          => Cons -E- x -E- (app -E- xs' -E- ys)
    appRightNeutral :E: (ys :E: List) -> Id -E- List -E- ys -E- (app -E- ys -E- Nil) = \(ys :E: List).
      case -E- ys of
        Nil/E
          => Refl -E- List -E- Nil
        Cons/E (x :E: Bool) (xs :E: List)
          => cong -E- List -E- List -E- (Cons -E- x) -E- xs -E- (app -E- xs -E- Nil) -E- (appRightNeutral -E- xs)
    appAssoc :E: (xs :E: List) -> (ys :E: List) -> (zs :E: List) -> Id -E- List -E- (app -E- (app -E- xs -E- ys) -E- zs) -E- (app -E- xs -E- (app -E- ys -E- zs)) = \(xs :E: List) (ys :E: List) (zs :E: List).
      case -E- xs of
        Nil/E
          => Refl -E- List -E- (app -E- ys -E- zs)
        Cons/E (x :E: Bool) (xs' :E: List)
          => cong -E- List -E- List -E- (Cons -E- x) -E- (app -E- (app -E- xs' -E- ys) -E- zs) -E- (app -E- xs' -E- (app -E- ys -E- zs)) -E- (appAssoc -E- xs' -E- ys -E- zs)
    postulate Rev :E: (_ :E: List) -> Type
    postulate RNil :R: Rev -E- Nil
    postulate RSnoc :R: (xs :E: List) -> (x :R: Bool) -> (rxs :R: Rev -E- xs) -> Rev -E- (app -E- xs -E- (one -E- x))
    rev' :R: (xs :E: List) -> (rxs :R: Rev -E- xs) -> (ys :R: List) -> Rev -E- (app -E- xs -E- ys) = \(xs :E: List) (rxs :R: Rev -E- xs) (ys :R: List).
      case -R- ys of
        Nil/R
          => subst -E- List -E- Rev -E- xs -E- (app -E- xs -E- Nil) -E- (appRightNeutral -E- xs) -R- rxs
        Cons/R (y :R: Bool) (ys' :R: List)
          => subst -E- List -E- Rev -E- (app -E- (app -E- xs -E- (one -E- y)) -E- ys') -E- (app -E- xs -E- (Cons -R- y -R- ys')) -E- (appAssoc -E- xs -E- (one -E- y) -E- ys') -R- (rev' -E- (app -E- xs -E- (one -E- y)) -R- (RSnoc -E- xs -R- y -R- rxs) -R- ys')
    rev :R: (xs :R: List) -> Rev -E- xs = (\xs :R: List. rev' -E- Nil -R- RNil -R- xs)
    reverse' :R: (xs :E: List) -> (rxs :R: Rev -E- xs) -> List = \(xs :E: List) (rxs :R: Rev -E- xs).
      case -R- rxs of
        RNil/R
          | xs = Nil
          => Nil
        RSnoc/R (xs' :E: List) (x :R: Bool) (rxs' :R: Rev -E- xs')
          | xs = app -E- xs' -E- (one -E- x)
          => Cons -R- x -R- (reverse' -E- xs' -R- rxs')
    reverse :R: (xs :R: List) -> List = (\xs :R: List. reverse' -E- xs -R- (rev -R- xs))
    main :R: List = reverse -R- (Cons -R- T -R- (Cons -R- F -R- (Cons -R- T -R- (Cons -R- F -R- Nil))))
  in main

### Specialised ###

  let
    postulate Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    postulate Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    id :E: (a :E: Type) -> (_ :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    subst :R: (a :E: Type) -> (P :E: (_ :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_ :R: P -E- x) -> P -E- y = \(a :E: Type) (P :E: (_ :E: a) -> Type) (x :E: a) (y :E: a) (eq :E: Id -E- a -E- x -E- y).
      case -E- eq of
        Refl/E (a' :E: Type) (x' :E: a)
          | a' = a
          | x' = x
          | y = x
          => (\w :R: P -E- x. w)
    cong :E: (a :E: Type) -> (b :E: Type) -> (f :E: (_ :E: a) -> b) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> Id -E- b -E- (f -E- x) -E- (f -E- y) = \(a :E: Type) (b :E: Type) (f :E: (_ :E: a) -> b) (x :E: a) (y :E: a) (eq :E: Id -E- a -E- x -E- y).
      case -E- eq of
        Refl/E (a' :E: Type) (x' :E: a)
          | a' = a
          | x' = x
          | y = x
          => Refl -E- b -E- (f -E- x)
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate List :E: Type
    postulate Nil :R: List
    postulate Cons :R: (x :R: Bool) -> (xs :R: List) -> List
    one :E: (x :E: Bool) -> List = (\x :E: Bool. Cons -E- x -E- Nil)
    app :E: (xs :E: List) -> (ys :E: List) -> List = \(xs :E: List) (ys :E: List).
      case -E- xs of
        Nil/E
          => ys
        Cons/E (x :E: Bool) (xs' :E: List)
          => Cons -E- x -E- (app -E- xs' -E- ys)
    appRightNeutral :E: (ys :E: List) -> Id -E- List -E- ys -E- (app -E- ys -E- Nil) = \(ys :E: List).
      case -E- ys of
        Nil/E
          => Refl -E- List -E- Nil
        Cons/E (x :E: Bool) (xs :E: List)
          => cong -E- List -E- List -E- (Cons -E- x) -E- xs -E- (app -E- xs -E- Nil) -E- (appRightNeutral -E- xs)
    appAssoc :E: (xs :E: List) -> (ys :E: List) -> (zs :E: List) -> Id -E- List -E- (app -E- (app -E- xs -E- ys) -E- zs) -E- (app -E- xs -E- (app -E- ys -E- zs)) = \(xs :E: List) (ys :E: List) (zs :E: List).
      case -E- xs of
        Nil/E
          => Refl -E- List -E- (app -E- ys -E- zs)
        Cons/E (x :E: Bool) (xs' :E: List)
          => cong -E- List -E- List -E- (Cons -E- x) -E- (app -E- (app -E- xs' -E- ys) -E- zs) -E- (app -E- xs' -E- (app -E- ys -E- zs)) -E- (appAssoc -E- xs' -E- ys -E- zs)
    postulate Rev :E: (_ :E: List) -> Type
    postulate RNil :R: Rev -E- Nil
    postulate RSnoc :R: (xs :E: List) -> (x :R: Bool) -> (rxs :R: Rev -E- xs) -> Rev -E- (app -E- xs -E- (one -E- x))
    rev' :R: (xs :E: List) -> (rxs :R: Rev -E- xs) -> (ys :R: List) -> Rev -E- (app -E- xs -E- ys) = \(xs :E: List) (rxs :R: Rev -E- xs) (ys :R: List).
      case -R- ys of
        Nil/R
          => subst -E- List -E- Rev -E- xs -E- (app -E- xs -E- Nil) -E- (appRightNeutral -E- xs) -R- rxs
        Cons/R (y :R: Bool) (ys' :R: List)
          => subst -E- List -E- Rev -E- (app -E- (app -E- xs -E- (one -E- y)) -E- ys') -E- (app -E- xs -E- (Cons -R- y -R- ys')) -E- (appAssoc -E- xs -E- (one -E- y) -E- ys') -R- (rev' -E- (app -E- xs -E- (one -E- y)) -R- (RSnoc -E- xs -R- y -R- rxs) -R- ys')
    rev :R: (xs :R: List) -> Rev -E- xs = (\xs :R: List. rev' -E- Nil -R- RNil -R- xs)
    reverse' :R: (xs :E: List) -> (rxs :R: Rev -E- xs) -> List = \(xs :E: List) (rxs :R: Rev -E- xs).
      case -R- rxs of
        RNil/R
          | xs = Nil
          => Nil
        RSnoc/R (xs' :E: List) (x :R: Bool) (rxs' :R: Rev -E- xs')
          | xs = app -E- xs' -E- (one -E- x)
          => Cons -R- x -R- (reverse' -E- xs' -R- rxs')
    reverse :R: (xs :R: List) -> List = (\xs :R: List. reverse' -E- xs -R- (rev -R- xs))
    main :R: List = reverse -R- (Cons -R- T -R- (Cons -R- F -R- (Cons -R- T -R- (Cons -R- F -R- Nil))))
  in main

### Constraints ###

[E] -> [E]
[R] -> [R]

### Solution ###

[R]

### Annotated ###

  let
    postulate Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    postulate Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    id :E: (a :E: Type) -> (_ :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    subst :R: (a :E: Type) -> (P :E: (_ :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_ :R: P -E- x) -> P -E- y = \(a :E: Type) (P :E: (_ :E: a) -> Type) (x :E: a) (y :E: a) (eq :E: Id -E- a -E- x -E- y).
      case -E- eq of
        Refl/E (a' :E: Type) (x' :E: a)
          | a' = a
          | x' = x
          | y = x
          => (\w :R: P -E- x. w)
    cong :E: (a :E: Type) -> (b :E: Type) -> (f :E: (_ :E: a) -> b) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> Id -E- b -E- (f -E- x) -E- (f -E- y) = \(a :E: Type) (b :E: Type) (f :E: (_ :E: a) -> b) (x :E: a) (y :E: a) (eq :E: Id -E- a -E- x -E- y).
      case -E- eq of
        Refl/E (a' :E: Type) (x' :E: a)
          | a' = a
          | x' = x
          | y = x
          => Refl -E- b -E- (f -E- x)
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate List :E: Type
    postulate Nil :R: List
    postulate Cons :R: (x :R: Bool) -> (xs :R: List) -> List
    one :E: (x :E: Bool) -> List = (\x :E: Bool. Cons -E- x -E- Nil)
    app :E: (xs :E: List) -> (ys :E: List) -> List = \(xs :E: List) (ys :E: List).
      case -E- xs of
        Nil/E
          => ys
        Cons/E (x :E: Bool) (xs' :E: List)
          => Cons -E- x -E- (app -E- xs' -E- ys)
    appRightNeutral :E: (ys :E: List) -> Id -E- List -E- ys -E- (app -E- ys -E- Nil) = \(ys :E: List).
      case -E- ys of
        Nil/E
          => Refl -E- List -E- Nil
        Cons/E (x :E: Bool) (xs :E: List)
          => cong -E- List -E- List -E- (Cons -E- x) -E- xs -E- (app -E- xs -E- Nil) -E- (appRightNeutral -E- xs)
    appAssoc :E: (xs :E: List) -> (ys :E: List) -> (zs :E: List) -> Id -E- List -E- (app -E- (app -E- xs -E- ys) -E- zs) -E- (app -E- xs -E- (app -E- ys -E- zs)) = \(xs :E: List) (ys :E: List) (zs :E: List).
      case -E- xs of
        Nil/E
          => Refl -E- List -E- (app -E- ys -E- zs)
        Cons/E (x :E: Bool) (xs' :E: List)
          => cong -E- List -E- List -E- (Cons -E- x) -E- (app -E- (app -E- xs' -E- ys) -E- zs) -E- (app -E- xs' -E- (app -E- ys -E- zs)) -E- (appAssoc -E- xs' -E- ys -E- zs)
    postulate Rev :E: (_ :E: List) -> Type
    postulate RNil :R: Rev -E- Nil
    postulate RSnoc :R: (xs :E: List) -> (x :R: Bool) -> (rxs :R: Rev -E- xs) -> Rev -E- (app -E- xs -E- (one -E- x))
    rev' :R: (xs :E: List) -> (rxs :R: Rev -E- xs) -> (ys :R: List) -> Rev -E- (app -E- xs -E- ys) = \(xs :E: List) (rxs :R: Rev -E- xs) (ys :R: List).
      case -R- ys of
        Nil/R
          => subst -E- List -E- Rev -E- xs -E- (app -E- xs -E- Nil) -E- (appRightNeutral -E- xs) -R- rxs
        Cons/R (y :R: Bool) (ys' :R: List)
          => subst -E- List -E- Rev -E- (app -E- (app -E- xs -E- (one -E- y)) -E- ys') -E- (app -E- xs -E- (Cons -R- y -R- ys')) -E- (appAssoc -E- xs -E- (one -E- y) -E- ys') -R- (rev' -E- (app -E- xs -E- (one -E- y)) -R- (RSnoc -E- xs -R- y -R- rxs) -R- ys')
    rev :R: (xs :R: List) -> Rev -E- xs = (\xs :R: List. rev' -E- Nil -R- RNil -R- xs)
    reverse' :R: (xs :E: List) -> (rxs :R: Rev -E- xs) -> List = \(xs :E: List) (rxs :R: Rev -E- xs).
      case -R- rxs of
        RNil/R
          | xs = Nil
          => Nil
        RSnoc/R (xs' :E: List) (x :R: Bool) (rxs' :R: Rev -E- xs')
          | xs = app -E- xs' -E- (one -E- x)
          => Cons -R- x -R- (reverse' -E- xs' -R- rxs')
    reverse :R: (xs :R: List) -> List = (\xs :R: List. reverse' -E- xs -R- (rev -R- xs))
    main :R: List = reverse -R- (Cons -R- T -R- (Cons -R- F -R- (Cons -R- T -R- (Cons -R- F -R- Nil))))
  in main

### Specialised ###

  let
    postulate Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    postulate Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    id :E: (a :E: Type) -> (_ :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    subst :R: (a :E: Type) -> (P :E: (_ :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_ :R: P -E- x) -> P -E- y = \(a :E: Type) (P :E: (_ :E: a) -> Type) (x :E: a) (y :E: a) (eq :E: Id -E- a -E- x -E- y).
      case -E- eq of
        Refl/E (a' :E: Type) (x' :E: a)
          | a' = a
          | x' = x
          | y = x
          => (\w :R: P -E- x. w)
    cong :E: (a :E: Type) -> (b :E: Type) -> (f :E: (_ :E: a) -> b) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> Id -E- b -E- (f -E- x) -E- (f -E- y) = \(a :E: Type) (b :E: Type) (f :E: (_ :E: a) -> b) (x :E: a) (y :E: a) (eq :E: Id -E- a -E- x -E- y).
      case -E- eq of
        Refl/E (a' :E: Type) (x' :E: a)
          | a' = a
          | x' = x
          | y = x
          => Refl -E- b -E- (f -E- x)
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate List :E: Type
    postulate Nil :R: List
    postulate Cons :R: (x :R: Bool) -> (xs :R: List) -> List
    one :E: (x :E: Bool) -> List = (\x :E: Bool. Cons -E- x -E- Nil)
    app :E: (xs :E: List) -> (ys :E: List) -> List = \(xs :E: List) (ys :E: List).
      case -E- xs of
        Nil/E
          => ys
        Cons/E (x :E: Bool) (xs' :E: List)
          => Cons -E- x -E- (app -E- xs' -E- ys)
    appRightNeutral :E: (ys :E: List) -> Id -E- List -E- ys -E- (app -E- ys -E- Nil) = \(ys :E: List).
      case -E- ys of
        Nil/E
          => Refl -E- List -E- Nil
        Cons/E (x :E: Bool) (xs :E: List)
          => cong -E- List -E- List -E- (Cons -E- x) -E- xs -E- (app -E- xs -E- Nil) -E- (appRightNeutral -E- xs)
    appAssoc :E: (xs :E: List) -> (ys :E: List) -> (zs :E: List) -> Id -E- List -E- (app -E- (app -E- xs -E- ys) -E- zs) -E- (app -E- xs -E- (app -E- ys -E- zs)) = \(xs :E: List) (ys :E: List) (zs :E: List).
      case -E- xs of
        Nil/E
          => Refl -E- List -E- (app -E- ys -E- zs)
        Cons/E (x :E: Bool) (xs' :E: List)
          => cong -E- List -E- List -E- (Cons -E- x) -E- (app -E- (app -E- xs' -E- ys) -E- zs) -E- (app -E- xs' -E- (app -E- ys -E- zs)) -E- (appAssoc -E- xs' -E- ys -E- zs)
    postulate Rev :E: (_ :E: List) -> Type
    postulate RNil :R: Rev -E- Nil
    postulate RSnoc :R: (xs :E: List) -> (x :R: Bool) -> (rxs :R: Rev -E- xs) -> Rev -E- (app -E- xs -E- (one -E- x))
    rev' :R: (xs :E: List) -> (rxs :R: Rev -E- xs) -> (ys :R: List) -> Rev -E- (app -E- xs -E- ys) = \(xs :E: List) (rxs :R: Rev -E- xs) (ys :R: List).
      case -R- ys of
        Nil/R
          => subst -E- List -E- Rev -E- xs -E- (app -E- xs -E- Nil) -E- (appRightNeutral -E- xs) -R- rxs
        Cons/R (y :R: Bool) (ys' :R: List)
          => subst -E- List -E- Rev -E- (app -E- (app -E- xs -E- (one -E- y)) -E- ys') -E- (app -E- xs -E- (Cons -R- y -R- ys')) -E- (appAssoc -E- xs -E- (one -E- y) -E- ys') -R- (rev' -E- (app -E- xs -E- (one -E- y)) -R- (RSnoc -E- xs -R- y -R- rxs) -R- ys')
    rev :R: (xs :R: List) -> Rev -E- xs = (\xs :R: List. rev' -E- Nil -R- RNil -R- xs)
    reverse' :R: (xs :E: List) -> (rxs :R: Rev -E- xs) -> List = \(xs :E: List) (rxs :R: Rev -E- xs).
      case -R- rxs of
        RNil/R
          | xs = Nil
          => Nil
        RSnoc/R (xs' :E: List) (x :R: Bool) (rxs' :R: Rev -E- xs')
          | xs = app -E- xs' -E- (one -E- x)
          => Cons -R- x -R- (reverse' -E- xs' -R- rxs')
    reverse :R: (xs :R: List) -> List = (\xs :R: List. reverse' -E- xs -R- (rev -R- xs))
    main :R: List = reverse -R- (Cons -R- T -R- (Cons -R- F -R- (Cons -R- T -R- (Cons -R- F -R- Nil))))
  in main

### Final annotation ###

  let
    postulate Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    postulate Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    id :E: (a :E: Type) -> (_ :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    subst :R: (a :E: Type) -> (P :E: (_ :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_ :R: P -E- x) -> P -E- y = \(a :E: Type) (P :E: (_ :E: a) -> Type) (x :E: a) (y :E: a) (eq :E: Id -E- a -E- x -E- y).
      case -E- eq of
        Refl/E (a' :E: Type) (x' :E: a)
          | a' = a
          | x' = x
          | y = x
          => (\w :R: P -E- x. w)
    cong :E: (a :E: Type) -> (b :E: Type) -> (f :E: (_ :E: a) -> b) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> Id -E- b -E- (f -E- x) -E- (f -E- y) = \(a :E: Type) (b :E: Type) (f :E: (_ :E: a) -> b) (x :E: a) (y :E: a) (eq :E: Id -E- a -E- x -E- y).
      case -E- eq of
        Refl/E (a' :E: Type) (x' :E: a)
          | a' = a
          | x' = x
          | y = x
          => Refl -E- b -E- (f -E- x)
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate List :E: Type
    postulate Nil :R: List
    postulate Cons :R: (x :R: Bool) -> (xs :R: List) -> List
    one :E: (x :E: Bool) -> List = (\x :E: Bool. Cons -E- x -E- Nil)
    app :E: (xs :E: List) -> (ys :E: List) -> List = \(xs :E: List) (ys :E: List).
      case -E- xs of
        Nil/E
          => ys
        Cons/E (x :E: Bool) (xs' :E: List)
          => Cons -E- x -E- (app -E- xs' -E- ys)
    appRightNeutral :E: (ys :E: List) -> Id -E- List -E- ys -E- (app -E- ys -E- Nil) = \(ys :E: List).
      case -E- ys of
        Nil/E
          => Refl -E- List -E- Nil
        Cons/E (x :E: Bool) (xs :E: List)
          => cong -E- List -E- List -E- (Cons -E- x) -E- xs -E- (app -E- xs -E- Nil) -E- (appRightNeutral -E- xs)
    appAssoc :E: (xs :E: List) -> (ys :E: List) -> (zs :E: List) -> Id -E- List -E- (app -E- (app -E- xs -E- ys) -E- zs) -E- (app -E- xs -E- (app -E- ys -E- zs)) = \(xs :E: List) (ys :E: List) (zs :E: List).
      case -E- xs of
        Nil/E
          => Refl -E- List -E- (app -E- ys -E- zs)
        Cons/E (x :E: Bool) (xs' :E: List)
          => cong -E- List -E- List -E- (Cons -E- x) -E- (app -E- (app -E- xs' -E- ys) -E- zs) -E- (app -E- xs' -E- (app -E- ys -E- zs)) -E- (appAssoc -E- xs' -E- ys -E- zs)
    postulate Rev :E: (_ :E: List) -> Type
    postulate RNil :R: Rev -E- Nil
    postulate RSnoc :R: (xs :E: List) -> (x :R: Bool) -> (rxs :R: Rev -E- xs) -> Rev -E- (app -E- xs -E- (one -E- x))
    rev' :R: (xs :E: List) -> (rxs :R: Rev -E- xs) -> (ys :R: List) -> Rev -E- (app -E- xs -E- ys) = \(xs :E: List) (rxs :R: Rev -E- xs) (ys :R: List).
      case -R- ys of
        Nil/R
          => subst -E- List -E- Rev -E- xs -E- (app -E- xs -E- Nil) -E- (appRightNeutral -E- xs) -R- rxs
        Cons/R (y :R: Bool) (ys' :R: List)
          => subst -E- List -E- Rev -E- (app -E- (app -E- xs -E- (one -E- y)) -E- ys') -E- (app -E- xs -E- (Cons -R- y -R- ys')) -E- (appAssoc -E- xs -E- (one -E- y) -E- ys') -R- (rev' -E- (app -E- xs -E- (one -E- y)) -R- (RSnoc -E- xs -R- y -R- rxs) -R- ys')
    rev :R: (xs :R: List) -> Rev -E- xs = (\xs :R: List. rev' -E- Nil -R- RNil -R- xs)
    reverse' :R: (xs :E: List) -> (rxs :R: Rev -E- xs) -> List = \(xs :E: List) (rxs :R: Rev -E- xs).
      case -R- rxs of
        RNil/R
          | xs = Nil
          => Nil
        RSnoc/R (xs' :E: List) (x :R: Bool) (rxs' :R: Rev -E- xs')
          | xs = app -E- xs' -E- (one -E- x)
          => Cons -R- x -R- (reverse' -E- xs' -R- rxs')
    reverse :R: (xs :R: List) -> List = (\xs :R: List. reverse' -E- xs -R- (rev -R- xs))
    main :R: List = reverse -R- (Cons -R- T -R- (Cons -R- F -R- (Cons -R- T -R- (Cons -R- F -R- Nil))))
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    subst = (\w. w)
    postulate T : Bool
    postulate F : Bool
    postulate Nil : List
    postulate Cons : (x) -> (xs) -> List
    postulate RNil : Rev
    postulate RSnoc : (x) -> (rxs) -> Rev
    rev' = \rxs ys.
      case ys of
        Nil
          => subst rxs
        Cons y ys'
          => subst (rev' (RSnoc y rxs) ys')
    rev = (\xs. rev' RNil xs)
    reverse' = \rxs.
      case rxs of
        RNil
          => Nil
        RSnoc x rxs'
          => Cons x (reverse' rxs')
    reverse = (\xs. reverse' (rev xs))
    main = reverse (Cons T (Cons F (Cons T (Cons F Nil))))
  in main

### Normal forms ###

unerased:
  
  let
    postulate T : Bool
    postulate F : Bool
    postulate Nil : List
    postulate Cons : (x :R: Bool) -> (xs :R: List) -> List
  in Cons F (Cons T (Cons F (Cons T Nil)))

erased:
  
  let
    postulate T : Bool
    postulate F : Bool
    postulate Nil : List
    postulate Cons : (x) -> (xs) -> List
  in Cons F (Cons T (Cons F (Cons T Nil)))

