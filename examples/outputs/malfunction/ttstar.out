-- vim: ft=ttstar

### Desugared ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        plus Z n = n
      m : Nat n : Nat
        plus (S m) n = S (plus m n)
    times : (_x2 : Nat) -> (_x3 : Nat) -> Nat 
      n : Nat
        times Z n = Z
      m : Nat n : Nat
        times (S m) n = plus n (times m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x4 : Bool) -> Bool 
      not True = False
      not False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x5 : Type) -> (_x6 : Type) -> Type
    constructor MkPair : (a : Type) -> (b : Type) -> (_x7 : a) -> (_x8 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x9 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        fst a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x10 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        snd a b ([MkPair] [a] [b] x y) = y
    constructor Either : (_x11 : Type) -> (_x12 : Type) -> Type
    constructor Left : (a : Type) -> (b : Type) -> (_x13 : a) -> Either a b
    constructor Right : (a : Type) -> (b : Type) -> (_x14 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x15 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x16 : Fin n) -> Fin (S n)
    constructor Vect : (_x17 : Nat) -> (_x18 : Type) -> Type
    constructor VN : (a : Type) -> Vect Z a
    constructor VC : (n : Nat) -> (a : Type) -> (x : a) -> (xs : Vect n a) -> Vect (S n) a
    constructor List : (_x19 : Type) -> Type
    constructor Nil : (a : Type) -> List a
    constructor Cons : (a : Type) -> (x : a) -> (xs : List a) -> List a
    constructor State : (_x0 : Type) -> (_x1 : Type) -> Type
    constructor MkSt : (st : Type) -> (a : Type) -> (run : (_x2 : st) -> Pair st a) -> State st a
    runState : (st : Type) -> (a : Type) -> (_x3 : State st a) -> (_x4 : st) -> Pair st a 
      st : Type a : Type run : (_x5 : st) -> Pair st a
        runState st a ([MkSt] [st] [a] run) = run
    execState : (st : Type) -> (a : Type) -> (x : State st a) -> (s : st) -> a = (\st : Type. (\a : Type. (\x : State st a. (\s : st. snd st a (runState st a x s)))))
    stGet : (st : Type) -> State st st = (\st : Type. MkSt st st (\s : st. MkPair st st s s))
    stReturn : (st : Type) -> (a : Type) -> (x : a) -> State st a = (\st : Type. (\a : Type. (\x : a. MkSt st a (\s : st. MkPair st a s x))))
    stBind : (st : Type) -> (a : Type) -> (b : Type) -> (x : State st a) -> (y : (z : a) -> State st b) -> State st b 
      st : Type a : Type b : Type f : (_x6 : st) -> Pair st a g : (_x7 : a) -> State st b
        stBind st a b ([MkSt] [st] [a] f) g = 
          let
            stBind3 : (st : Type) -> (b : Type) -> (_x8 : st) -> (_x9 : State st b) -> Pair st b 
              st : Type b : Type s : st f : (_x10 : st) -> Pair st b
                stBind3 st b s ([MkSt] [st] [b] f) = f s
            stBind2 : (st : Type) -> (a : Type) -> (b : Type) -> (g : (_x11 : a) -> State st b) -> (r : Pair st a) -> Pair st b 
              st : Type a : Type b : Type g : (_x12 : a) -> State st b x : a s : st
                stBind2 st a b g ([MkPair] [st] [a] s x) = stBind3 st b s (g x)
          in MkSt st b (\s : st. stBind2 st a b g (f s))
    postulate RealWorld : Type
    IO : (_x0 : Type) -> Type = State RealWorld
    ioReturn : (a : Type) -> (x : a) -> IO a = (\a : Type. (\x : a. stReturn RealWorld a x))
    ioBind : (a : Type) -> (b : Type) -> (x : IO a) -> (y : (_x1 : a) -> IO b) -> IO b = (\a : Type. (\b : Type. (\x : IO a. (\y : (_x1 : a) -> IO b. stBind RealWorld a b x y))))
    ioWrapImpure : (a : Type) -> (impureF : (w :R: RealWorld) -> a) -> IO a = (\a : Type. (\impureF : (w :R: RealWorld) -> a. stBind RealWorld RealWorld a (stGet RealWorld) (\w : RealWorld. stReturn RealWorld a (impureF w))))
    unsafePerformIO : (a : Type) -> (x : IO a) -> a = (\a : Type. (\x : IO a. 
      let postulate TheWorld : RealWorld
      in execState RealWorld a x TheWorld))
    postulate Int : Type
    foreign int1 : Int
    foreign int0 : Int
    postulate String : Type
    foreign plusInt : (x :R: Int) -> (y :R: Int) -> Int
    foreign minusInt : (x :R: Int) -> (y :R: Int) -> Int
    foreign timesInt : (x :R: Int) -> (y :R: Int) -> Int
    foreign intToString : (i :R: Int) -> String
    foreign ifRaw : (a :E: Type) -> (x :R: Int) -> (then :R: a) -> (else :R: a) -> a
    isZero : (x : Int) -> Bool = (\x : Int. ifRaw Bool x False True)
    isNonzero : (x : Int) -> Bool = (\x : Int. ifRaw Bool x True False)
    eqInt : (x : Int) -> (y : Int) -> Bool = (\x : Int. (\y : Int. 
      let foreign eqInt_I : (x :R: Int) -> (y :R: Int) -> Int
      in isNonzero (eqInt_I x y)))
    postulate Unspec : Type
    printString : (s : String) -> IO Unspec = (\s : String. 
      let foreign nativePrint : (x :R: String) -> Unspec
      in ioWrapImpure Unspec (\w : RealWorld. nativePrint s))
    printInt : (i : Int) -> IO Unspec = (\i : Int. printString (intToString i))
    natToInt : (_x0 : Nat) -> Int 
      natToInt Z = int0
      n : Nat
        natToInt (S n) = plusInt int1 (natToInt n)
    printNat : (n : Nat) -> IO Unspec = (\n : Nat. printInt (natToInt n))
    sumFor : (n : Int) -> (f : (_x0 : Int) -> Int) -> Int = (\n : Int. (\f : (_x0 : Int) -> Int. 
      let g : (_x1 : Bool) -> Int 
        g True = int0
        g False = plusInt (f n) (sumFor (minusInt n int1) f)
      in g (isZero n)))
    boolToInt : (_x2 : Bool) -> Int 
      boolToInt True = int1
      boolToInt False = int0
    isPythag : (x : Int) -> (y : Int) -> (z : Int) -> Int = (\x : Int. (\y : Int. (\z : Int. boolToInt (eqInt (timesInt x x) (plusInt (timesInt y y) (timesInt z z))))))
    pythag : (n : Int) -> Int = (\n : Int. sumFor n (\x : Int. sumFor x (\y : Int. sumFor y (\z : Int. isPythag x y z))))
    main : Unspec = unsafePerformIO Unspec 
      let
        int2 : Int = plusInt int1 int1
        int4 : Int = timesInt int2 int2
        int16 : Int = timesInt int4 int4
        int256 : Int = timesInt int16 int16
        int512 : Int = timesInt int256 int2
      in printInt (pythag int512)
  in main

### Elaborated ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        plus Z n = n
      m : Nat n : Nat
        plus (S m) n = S (plus m n)
    times : (_x2 : Nat) -> (_x3 : Nat) -> Nat 
      n : Nat
        times Z n = Z
      m : Nat n : Nat
        times (S m) n = plus n (times m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x4 : Bool) -> Bool 
      not True = False
      not False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x5 : Type) -> (_x6 : Type) -> Type
    constructor MkPair : (a : Type) -> (b : Type) -> (_x7 : a) -> (_x8 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x9 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        fst a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x10 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        snd a b ([MkPair] [a] [b] x y) = y
    constructor Either : (_x11 : Type) -> (_x12 : Type) -> Type
    constructor Left : (a : Type) -> (b : Type) -> (_x13 : a) -> Either a b
    constructor Right : (a : Type) -> (b : Type) -> (_x14 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x15 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x16 : Fin n) -> Fin (S n)
    constructor Vect : (_x17 : Nat) -> (_x18 : Type) -> Type
    constructor VN : (a : Type) -> Vect Z a
    constructor VC : (n : Nat) -> (a : Type) -> (x : a) -> (xs : Vect n a) -> Vect (S n) a
    constructor List : (_x19 : Type) -> Type
    constructor Nil : (a : Type) -> List a
    constructor Cons : (a : Type) -> (x : a) -> (xs : List a) -> List a
    constructor State : (_x0 : Type) -> (_x1 : Type) -> Type
    constructor MkSt : (st : Type) -> (a : Type) -> (run : (_x2 : st) -> Pair st a) -> State st a
    runState : (st : Type) -> (a : Type) -> (_x3 : State st a) -> (_x4 : st) -> Pair st a 
      st : Type a : Type run : (_x5 : st) -> Pair st a
        runState st a ([MkSt] [st] [a] run) = run
    execState : (st : Type) -> (a : Type) -> (x : State st a) -> (s : st) -> a = (\st : Type. (\a : Type. (\x : State st a. (\s : st. snd st a (runState st a x s)))))
    stGet : (st : Type) -> State st st = (\st : Type. MkSt st st (\s : st. MkPair st st s s))
    stReturn : (st : Type) -> (a : Type) -> (x : a) -> State st a = (\st : Type. (\a : Type. (\x : a. MkSt st a (\s : st. MkPair st a s x))))
    stBind : (st : Type) -> (a : Type) -> (b : Type) -> (x : State st a) -> (y : (z : a) -> State st b) -> State st b 
      st : Type a : Type b : Type f : (_x6 : st) -> Pair st a g : (_x7 : a) -> State st b
        stBind st a b ([MkSt] [st] [a] f) g = 
          let
            stBind3 : (st : Type) -> (b : Type) -> (_x8 : st) -> (_x9 : State st b) -> Pair st b 
              st : Type b : Type s : st f : (_x10 : st) -> Pair st b
                stBind3 st b s ([MkSt] [st] [b] f) = f s
            stBind2 : (st : Type) -> (a : Type) -> (b : Type) -> (g : (_x11 : a) -> State st b) -> (r : Pair st a) -> Pair st b 
              st : Type a : Type b : Type g : (_x12 : a) -> State st b x : a s : st
                stBind2 st a b g ([MkPair] [st] [a] s x) = stBind3 st b s (g x)
          in MkSt st b (\s : st. stBind2 st a b g (f s))
    postulate RealWorld : Type
    IO : (_x0 : Type) -> Type = State RealWorld
    ioReturn : (a : Type) -> (x : a) -> IO a = (\a : Type. (\x : a. stReturn RealWorld a x))
    ioBind : (a : Type) -> (b : Type) -> (x : IO a) -> (y : (_x1 : a) -> IO b) -> IO b = (\a : Type. (\b : Type. (\x : IO a. (\y : (_x1 : a) -> IO b. stBind RealWorld a b x y))))
    ioWrapImpure : (a : Type) -> (impureF : (w :R: RealWorld) -> a) -> IO a = (\a : Type. (\impureF : (w :R: RealWorld) -> a. stBind RealWorld RealWorld a (stGet RealWorld) (\w : RealWorld. stReturn RealWorld a (impureF w))))
    unsafePerformIO : (a : Type) -> (x : IO a) -> a = (\a : Type. (\x : IO a. 
      let postulate TheWorld : RealWorld
      in execState RealWorld a x TheWorld))
    postulate Int : Type
    foreign int1 : Int
    foreign int0 : Int
    postulate String : Type
    foreign plusInt : (x :R: Int) -> (y :R: Int) -> Int
    foreign minusInt : (x :R: Int) -> (y :R: Int) -> Int
    foreign timesInt : (x :R: Int) -> (y :R: Int) -> Int
    foreign intToString : (i :R: Int) -> String
    foreign ifRaw : (a :E: Type) -> (x :R: Int) -> (then :R: a) -> (else :R: a) -> a
    isZero : (x : Int) -> Bool = (\x : Int. ifRaw Bool x False True)
    isNonzero : (x : Int) -> Bool = (\x : Int. ifRaw Bool x True False)
    eqInt : (x : Int) -> (y : Int) -> Bool = (\x : Int. (\y : Int. 
      let foreign eqInt_I : (x :R: Int) -> (y :R: Int) -> Int
      in isNonzero (eqInt_I x y)))
    postulate Unspec : Type
    printString : (s : String) -> IO Unspec = (\s : String. 
      let foreign nativePrint : (x :R: String) -> Unspec
      in ioWrapImpure Unspec (\w : RealWorld. nativePrint s))
    printInt : (i : Int) -> IO Unspec = (\i : Int. printString (intToString i))
    natToInt : (_x0 : Nat) -> Int 
      natToInt Z = int0
      n : Nat
        natToInt (S n) = plusInt int1 (natToInt n)
    printNat : (n : Nat) -> IO Unspec = (\n : Nat. printInt (natToInt n))
    sumFor : (n : Int) -> (f : (_x0 : Int) -> Int) -> Int = (\n : Int. (\f : (_x0 : Int) -> Int. 
      let g : (_x1 : Bool) -> Int 
        g True = int0
        g False = plusInt (f n) (sumFor (minusInt n int1) f)
      in g (isZero n)))
    boolToInt : (_x2 : Bool) -> Int 
      boolToInt True = int1
      boolToInt False = int0
    isPythag : (x : Int) -> (y : Int) -> (z : Int) -> Int = (\x : Int. (\y : Int. (\z : Int. boolToInt (eqInt (timesInt x x) (plusInt (timesInt y y) (timesInt z z))))))
    pythag : (n : Int) -> Int = (\n : Int. sumFor n (\x : Int. sumFor x (\y : Int. sumFor y (\z : Int. isPythag x y z))))
    main : Unspec = unsafePerformIO Unspec 
      let
        int2 : Int = plusInt int1 int1
        int4 : Int = timesInt int2 int2
        int16 : Int = timesInt int4 int4
        int256 : Int = timesInt int16 int16
        int512 : Int = timesInt int256 int2
      in printInt (pythag int512)
  in main

### Evarified ###

  let
    constructor Nat :1: Type
    constructor Z :2: Nat
    constructor S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        plus -9- Z -8- n = n
      m :10: Nat n :11: Nat
        plus -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    times :18: (_x2 :19: Nat) -> (_x3 :20: Nat) -> Nat 
      n :21: Nat
        times -23- Z -22- n = Z
      m :24: Nat n :25: Nat
        times -27- (S -28- m) -26- n = plus -30- n -29- (times -32- m -31- n)
    constructor Bool :33: Type
    constructor True :34: Bool
    constructor False :35: Bool
    not :36: (_x4 :37: Bool) -> Bool 
      not -38- True = False
      not -39- False = True
    constructor Unit :40: Type
    constructor MkUnit :41: Unit
    constructor Pair :42: (_x5 :43: Type) -> (_x6 :44: Type) -> Type
    constructor MkPair :45: (a :46: Type) -> (b :47: Type) -> (_x7 :48: a) -> (_x8 :49: b) -> Pair -51- a -50- b
    fst :52: (a :53: Type) -> (b :54: Type) -> (_x9 :55: Pair -57- a -56- b) -> a 
      a :58: Type b :59: Type x :60: a y :61: b
        fst -64- a -63- b -62- ([MkPair] -68- [a] -67- [b] -66- x -65- y) = x
    snd :69: (a :70: Type) -> (b :71: Type) -> (_x10 :72: Pair -74- a -73- b) -> b 
      a :75: Type b :76: Type x :77: a y :78: b
        snd -81- a -80- b -79- ([MkPair] -85- [a] -84- [b] -83- x -82- y) = y
    constructor Either :86: (_x11 :87: Type) -> (_x12 :88: Type) -> Type
    constructor Left :89: (a :90: Type) -> (b :91: Type) -> (_x13 :92: a) -> Either -94- a -93- b
    constructor Right :95: (a :96: Type) -> (b :97: Type) -> (_x14 :98: b) -> Either -100- a -99- b
    id :101: (a :102: Type) -> (x :103: a) -> a = (\a :104: Type. (\x :105: a. x))
    constructor Fin :106: (_x15 :107: Nat) -> Type
    constructor FZ :108: (n :109: Nat) -> Fin -110- (S -111- n)
    constructor FS :112: (n :113: Nat) -> (_x16 :114: Fin -115- n) -> Fin -116- (S -117- n)
    constructor Vect :118: (_x17 :119: Nat) -> (_x18 :120: Type) -> Type
    constructor VN :121: (a :122: Type) -> Vect -124- Z -123- a
    constructor VC :125: (n :126: Nat) -> (a :127: Type) -> (x :128: a) -> (xs :129: Vect -131- n -130- a) -> Vect -133- (S -134- n) -132- a
    constructor List :135: (_x19 :136: Type) -> Type
    constructor Nil :137: (a :138: Type) -> List -139- a
    constructor Cons :140: (a :141: Type) -> (x :142: a) -> (xs :143: List -144- a) -> List -145- a
    constructor State :146: (_x0 :147: Type) -> (_x1 :148: Type) -> Type
    constructor MkSt :149: (st :150: Type) -> (a :151: Type) -> (run :152: (_x2 :153: st) -> Pair -155- st -154- a) -> State -157- st -156- a
    runState :158: (st :159: Type) -> (a :160: Type) -> (_x3 :161: State -163- st -162- a) -> (_x4 :164: st) -> Pair -166- st -165- a 
      st :167: Type a :168: Type run :169: (_x5 :170: st) -> Pair -172- st -171- a
        runState -175- st -174- a -173- ([MkSt] -178- [st] -177- [a] -176- run) = run
    execState :179: (st :180: Type) -> (a :181: Type) -> (x :182: State -184- st -183- a) -> (s :185: st) -> a = (\st :186: Type. (\a :187: Type. (\x :188: State -190- st -189- a. (\s :191: st. snd -194- st -193- a -192- (runState -198- st -197- a -196- x -195- s)))))
    stGet :199: (st :200: Type) -> State -202- st -201- st = (\st :203: Type. MkSt -206- st -205- st -204- (\s :207: st. MkPair -211- st -210- st -209- s -208- s))
    stReturn :212: (st :213: Type) -> (a :214: Type) -> (x :215: a) -> State -217- st -216- a = (\st :218: Type. (\a :219: Type. (\x :220: a. MkSt -223- st -222- a -221- (\s :224: st. MkPair -228- st -227- a -226- s -225- x))))
    stBind :229: (st :230: Type) -> (a :231: Type) -> (b :232: Type) -> (x :233: State -235- st -234- a) -> (y :236: (z :237: a) -> State -239- st -238- b) -> State -241- st -240- b 
      st :242: Type a :243: Type b :244: Type f :245: (_x6 :246: st) -> Pair -248- st -247- a g :249: (_x7 :250: a) -> State -252- st -251- b
        stBind -257- st -256- a -255- b -254- ([MkSt] -260- [st] -259- [a] -258- f) -253- g = 
          let
            stBind3 :261: (st :262: Type) -> (b :263: Type) -> (_x8 :264: st) -> (_x9 :265: State -267- st -266- b) -> Pair -269- st -268- b 
              st :270: Type b :271: Type s :272: st f :273: (_x10 :274: st) -> Pair -276- st -275- b
                stBind3 -280- st -279- b -278- s -277- ([MkSt] -283- [st] -282- [b] -281- f) = f -284- s
            stBind2 :285: (st :286: Type) -> (a :287: Type) -> (b :288: Type) -> (g :289: (_x11 :290: a) -> State -292- st -291- b) -> (r :293: Pair -295- st -294- a) -> Pair -297- st -296- b 
              st :298: Type a :299: Type b :300: Type g :301: (_x12 :302: a) -> State -304- st -303- b x :305: a s :306: st
                stBind2 -311- st -310- a -309- b -308- g -307- ([MkPair] -315- [st] -314- [a] -313- s -312- x) = stBind3 -319- st -318- b -317- s -316- (g -320- x)
          in MkSt -323- st -322- b -321- (\s :324: st. stBind2 -329- st -328- a -327- b -326- g -325- (f -330- s))
    postulate RealWorld :331: Type
    IO :332: (_x0 :333: Type) -> Type = State -334- RealWorld
    ioReturn :335: (a :336: Type) -> (x :337: a) -> IO -338- a = (\a :339: Type. (\x :340: a. stReturn -343- RealWorld -342- a -341- x))
    ioBind :344: (a :345: Type) -> (b :346: Type) -> (x :347: IO -348- a) -> (y :349: (_x1 :350: a) -> IO -351- b) -> IO -352- b = (\a :353: Type. (\b :354: Type. (\x :355: IO -356- a. (\y :357: (_x1 :358: a) -> IO -359- b. stBind -364- RealWorld -363- a -362- b -361- x -360- y))))
    ioWrapImpure :365: (a :366: Type) -> (impureF :367: (w :R: RealWorld) -> a) -> IO -368- a = (\a :369: Type. (\impureF :370: (w :R: RealWorld) -> a. stBind -375- RealWorld -374- RealWorld -373- a -372- (stGet -376- RealWorld) -371- (\w :377: RealWorld. stReturn -380- RealWorld -379- a -378- (impureF -381- w))))
    unsafePerformIO :382: (a :383: Type) -> (x :384: IO -385- a) -> a = (\a :386: Type. (\x :387: IO -388- a. 
      let postulate TheWorld :389: RealWorld
      in execState -393- RealWorld -392- a -391- x -390- TheWorld))
    postulate Int :394: Type
    foreign int1 :395: Int
    foreign int0 :396: Int
    postulate String :397: Type
    foreign plusInt :398: (x :R: Int) -> (y :R: Int) -> Int
    foreign minusInt :399: (x :R: Int) -> (y :R: Int) -> Int
    foreign timesInt :400: (x :R: Int) -> (y :R: Int) -> Int
    foreign intToString :401: (i :R: Int) -> String
    foreign ifRaw :402: (a :E: Type) -> (x :R: Int) -> (then :R: a) -> (else :R: a) -> a
    isZero :403: (x :404: Int) -> Bool = (\x :405: Int. ifRaw -409- Bool -408- x -407- False -406- True)
    isNonzero :410: (x :411: Int) -> Bool = (\x :412: Int. ifRaw -416- Bool -415- x -414- True -413- False)
    eqInt :417: (x :418: Int) -> (y :419: Int) -> Bool = (\x :420: Int. (\y :421: Int. 
      let foreign eqInt_I :422: (x :R: Int) -> (y :R: Int) -> Int
      in isNonzero -423- (eqInt_I -425- x -424- y)))
    postulate Unspec :426: Type
    printString :427: (s :428: String) -> IO -429- Unspec = (\s :430: String. 
      let foreign nativePrint :431: (x :R: String) -> Unspec
      in ioWrapImpure -433- Unspec -432- (\w :434: RealWorld. nativePrint -435- s))
    printInt :436: (i :437: Int) -> IO -438- Unspec = (\i :439: Int. printString -440- (intToString -441- i))
    natToInt :442: (_x0 :443: Nat) -> Int 
      natToInt -444- Z = int0
      n :445: Nat
        natToInt -446- (S -447- n) = plusInt -449- int1 -448- (natToInt -450- n)
    printNat :451: (n :452: Nat) -> IO -453- Unspec = (\n :454: Nat. printInt -455- (natToInt -456- n))
    sumFor :457: (n :458: Int) -> (f :459: (_x0 :460: Int) -> Int) -> Int = (\n :461: Int. (\f :462: (_x0 :463: Int) -> Int. 
      let g :464: (_x1 :465: Bool) -> Int 
        g -466- True = int0
        g -467- False = plusInt -469- (f -470- n) -468- (sumFor -472- (minusInt -474- n -473- int1) -471- f)
      in g -475- (isZero -476- n)))
    boolToInt :477: (_x2 :478: Bool) -> Int 
      boolToInt -479- True = int1
      boolToInt -480- False = int0
    isPythag :481: (x :482: Int) -> (y :483: Int) -> (z :484: Int) -> Int = (\x :485: Int. (\y :486: Int. (\z :487: Int. boolToInt -488- (eqInt -490- (timesInt -492- x -491- x) -489- (plusInt -494- (timesInt -496- y -495- y) -493- (timesInt -498- z -497- z))))))
    pythag :499: (n :500: Int) -> Int = (\n :501: Int. sumFor -503- n -502- (\x :504: Int. sumFor -506- x -505- (\y :507: Int. sumFor -509- y -508- (\z :510: Int. isPythag -513- x -512- y -511- z))))
    main :514: Unspec = unsafePerformIO -516- Unspec -515- 
      let
        int2 :517: Int = plusInt -519- int1 -518- int1
        int4 :520: Int = timesInt -522- int2 -521- int2
        int16 :523: Int = timesInt -525- int4 -524- int4
        int256 :526: Int = timesInt -528- int16 -527- int16
        int512 :529: Int = timesInt -531- int256 -530- int2
      in printInt -532- (pythag -533- int512)
  in main

### Constraints ###

[] -> [14,15,28,111,117,134,381,406,407,408,413,414,415,424,425,434,435,441,447,448,449,468,469,473,474,491,492,493,494,495,496,497,498,514,518,519,521,522,524,525,527,528,530,531]
[4] -> [2,3,7,9,13]
[4,8] -> [7]
[4,12] -> [11]
[4,13,14] -> [10]
[4,15,16] -> [11]
[4,15,17] -> [10]
[5] -> [9,13,17,30]
[6] -> [8,12,16,29]
[7] -> [4,8]
[8] -> [6]
[9] -> [5]
[10] -> [4,13,14]
[11] -> [4,12]
[12] -> [6]
[13] -> [5]
[16] -> [6]
[17] -> [5]
[18] -> [2,3,4,23,27]
[18,22] -> [21]
[18,26] -> [25]
[18,27,28] -> [24]
[18,29,31] -> [25]
[18,29,32] -> [24]
[18,30] -> [25]
[19] -> [23,27,32]
[20] -> [22,26,31]
[21] -> [18,22]
[22] -> [20]
[23] -> [19]
[24] -> [18,27,28]
[25] -> [18,26]
[26] -> [20]
[27] -> [19]
[29] -> [6]
[30] -> [5]
[31] -> [20]
[32] -> [19]
[36] -> [34,35,38,39]
[37] -> [38,39]
[38] -> [37]
[39] -> [37]
[43] -> [51,57,74,155,166,172,248,269,276,295,297]
[44] -> [50,56,73,154,165,171,247,268,275,294,296]
[46] -> [68,85,211,228,315]
[47] -> [67,84,210,227,314]
[48] -> [66,83,209,226,313]
[49] -> [65,82,208,225,312]
[50] -> [44,56,73,154,294]
[51] -> [43]
[52] -> [60]
[52,62] -> [45]
[52,62,65] -> [61]
[52,62,66] -> [60]
[52,62,67] -> [59]
[52,62,68] -> [58]
[52,63] -> [59]
[52,64] -> [58]
[53] -> [64]
[54] -> [63]
[55] -> [62]
[56] -> [44,50]
[57] -> [43]
[58] -> [52,64]
[59] -> [52,63]
[60] -> [52,62,66]
[61] -> [52,62,65]
[62] -> [55]
[63] -> [54]
[64] -> [53]
[65] -> [49]
[66] -> [48]
[67] -> [47]
[68] -> [46]
[69] -> [78]
[69,79] -> [45]
[69,79,82] -> [78]
[69,79,83] -> [77]
[69,79,84] -> [76]
[69,79,85] -> [75]
[69,80] -> [76]
[69,81] -> [75]
[70] -> [81,194]
[71] -> [80,193]
[72] -> [79,192]
[73] -> [44,50,165]
[74] -> [43]
[75] -> [69,81]
[76] -> [69,80]
[77] -> [69,79,83]
[78] -> [69,79,82]
[79] -> [72]
[80] -> [71]
[81] -> [70]
[82] -> [49]
[83] -> [48]
[84] -> [47]
[85] -> [46]
[87] -> [94,100]
[88] -> [93,99]
[93] -> [88]
[94] -> [87]
[99] -> [88]
[100] -> [87]
[101] -> [105]
[102] -> [104]
[103] -> [105]
[104] -> [102]
[105] -> [103]
[107] -> [110,115,116]
[110] -> [107]
[115] -> [107]
[116] -> [107]
[119] -> [124,131,133]
[120] -> [123,130,132]
[123] -> [120]
[124] -> [119]
[130] -> [120]
[131] -> [119]
[132] -> [120]
[133] -> [119]
[136] -> [139,144,145]
[139] -> [136]
[144] -> [136]
[145] -> [136]
[147] -> [157,163,184,190,202,217,235,239,241,252,267,292,304,334]
[148] -> [156,162,183,189,201,216,234,238,240,251,266,291,303,333]
[150] -> [178,206,223,260,283,323]
[151] -> [177,205,222,259,282,322]
[152] -> [176,204,221,258,281,321]
[153] -> [170,207,224,246,274,324]
[154] -> [44,50,171,247,275,296]
[155] -> [43]
[156] -> [148,162,201,216,234,240,266]
[157] -> [147]
[158] -> [169]
[158,173] -> [149]
[158,173,176] -> [169]
[158,173,177] -> [168]
[158,173,178] -> [167]
[158,174] -> [168]
[158,175] -> [167]
[159] -> [175,198]
[160] -> [174,197]
[161] -> [173,196]
[162] -> [148,156,189]
[163] -> [147]
[164] -> [170,195]
[165] -> [44,73,171]
[166] -> [43]
[167] -> [158,175]
[168] -> [158,174]
[169] -> [158,173,176]
[170] -> [153,164]
[171] -> [44,154,165]
[172] -> [43]
[173] -> [161]
[174] -> [160]
[175] -> [159]
[176] -> [152]
[177] -> [151]
[178] -> [150]
[179] -> [69]
[179,192] -> [158]
[179,192,195] -> [191]
[179,192,196] -> [188]
[179,192,197] -> [187]
[179,192,198] -> [186]
[179,193] -> [187]
[179,194] -> [186]
[180] -> [186,393]
[181] -> [187,392]
[182] -> [188,391]
[183] -> [148,189,388]
[184] -> [147]
[185] -> [191,390]
[186] -> [180]
[187] -> [181]
[188] -> [182]
[189] -> [148,162,183]
[190] -> [147]
[191] -> [185]
[192] -> [72]
[193] -> [71]
[194] -> [70]
[195] -> [164]
[196] -> [161]
[197] -> [160]
[198] -> [159]
[199] -> [149]
[199,204] -> [45]
[199,204,208] -> [207]
[199,204,209] -> [207]
[199,204,210] -> [203]
[199,204,211] -> [203]
[199,205] -> [203]
[199,206] -> [203]
[200] -> [203,376]
[201] -> [148,156,234]
[202] -> [147]
[203] -> [200]
[204] -> [152]
[205] -> [151]
[206] -> [150]
[207] -> [153]
[208] -> [49]
[209] -> [48]
[210] -> [47]
[211] -> [46]
[212] -> [149]
[212,221] -> [45]
[212,221,225] -> [220]
[212,221,226] -> [224]
[212,221,227] -> [219]
[212,221,228] -> [218]
[212,222] -> [219]
[212,223] -> [218]
[213] -> [218,343,380]
[214] -> [219,342,379]
[215] -> [220,341,378]
[216] -> [148,156,238,338]
[217] -> [147]
[218] -> [213]
[219] -> [214]
[220] -> [215]
[221] -> [152]
[222] -> [151]
[223] -> [150]
[224] -> [153]
[225] -> [49]
[226] -> [48]
[227] -> [47]
[228] -> [46]
[229] -> [149]
[229,253] -> [249]
[229,254] -> [149]
[229,254,258] -> [245]
[229,254,259] -> [243]
[229,254,260] -> [242]
[229,255] -> [244]
[229,256] -> [243]
[229,257] -> [242]
[229,321] -> [285]
[229,321,325] -> [245]
[229,321,325,330] -> [324]
[229,321,326] -> [249]
[229,321,327] -> [244]
[229,321,328] -> [243]
[229,321,329] -> [242]
[229,322] -> [244]
[229,323] -> [242]
[230] -> [257,364,375]
[231] -> [256,363,374]
[232] -> [255,362,373]
[233] -> [254,361,372]
[234] -> [148,156,201,356]
[235] -> [147]
[236] -> [253,360,371]
[237] -> [250,358,377]
[238] -> [148,216,251,359]
[239] -> [147]
[240] -> [148,156,352,368]
[241] -> [147]
[242] -> [229,257]
[243] -> [229,256]
[244] -> [229,255]
[245] -> [229,254,258]
[246] -> [153,330]
[247] -> [44,154,294]
[248] -> [43]
[249] -> [229,253]
[250] -> [237,290]
[251] -> [148,238,291]
[252] -> [147]
[253] -> [236]
[254] -> [233]
[255] -> [232]
[256] -> [231]
[257] -> [230]
[258] -> [152]
[259] -> [151]
[260] -> [150]
[261] -> [273]
[261,277] -> [149]
[261,277,281] -> [273]
[261,277,282] -> [271]
[261,277,283] -> [270]
[261,278] -> [272]
[261,279] -> [271]
[261,280] -> [270]
[261,284] -> [272]
[262] -> [280,319]
[263] -> [279,318]
[264] -> [278,317]
[265] -> [277,316]
[266] -> [148,156,303]
[267] -> [147]
[268] -> [44,275,296]
[269] -> [43]
[270] -> [261,280]
[271] -> [261,279]
[272] -> [261,278]
[273] -> [261,277,281]
[274] -> [153,284]
[275] -> [44,154,268]
[276] -> [43]
[277] -> [265]
[278] -> [264]
[279] -> [263]
[280] -> [262]
[281] -> [152]
[282] -> [151]
[283] -> [150]
[284] -> [274]
[285] -> [261]
[285,307] -> [45]
[285,307,312] -> [305]
[285,307,313] -> [306]
[285,307,314] -> [299]
[285,307,315] -> [298]
[285,308] -> [301]
[285,309] -> [300]
[285,310] -> [299]
[285,311] -> [298]
[285,316] -> [301]
[285,316,320] -> [305]
[285,317] -> [306]
[285,318] -> [300]
[285,319] -> [298]
[286] -> [311,329]
[287] -> [310,328]
[288] -> [309,327]
[289] -> [308,326]
[290] -> [250,302]
[291] -> [148,251,303]
[292] -> [147]
[293] -> [307,325]
[294] -> [44,50,247]
[295] -> [43]
[296] -> [44,154,268]
[297] -> [43]
[298] -> [285,311]
[299] -> [285,310]
[300] -> [285,309]
[301] -> [285,308]
[302] -> [290,320]
[303] -> [148,266,291]
[304] -> [147]
[305] -> [285,307,312]
[306] -> [285,307,313]
[307] -> [293]
[308] -> [289]
[309] -> [288]
[310] -> [287]
[311] -> [286]
[312] -> [49]
[313] -> [48]
[314] -> [47]
[315] -> [46]
[316] -> [265]
[317] -> [264]
[318] -> [263]
[319] -> [262]
[320] -> [302]
[321] -> [152]
[322] -> [151]
[323] -> [150]
[324] -> [153]
[325] -> [293]
[326] -> [289]
[327] -> [288]
[328] -> [287]
[329] -> [286]
[330] -> [246]
[332] -> [146]
[332,334] -> [331]
[333] -> [148,338,348,351,352,356,359,368,385,388,429,438,453]
[334] -> [147]
[335] -> [212]
[335,341] -> [340]
[335,342] -> [339]
[335,343] -> [331]
[336] -> [339]
[337] -> [340]
[338] -> [216,333]
[339] -> [336]
[340] -> [337]
[341] -> [215]
[342] -> [214]
[343] -> [213]
[344] -> [229]
[344,360] -> [357]
[344,361] -> [355]
[344,362] -> [354]
[344,363] -> [353]
[344,364] -> [331]
[345] -> [353]
[346] -> [354]
[347] -> [355]
[348] -> [333,356]
[349] -> [357]
[350] -> [358]
[351] -> [333,359]
[352] -> [240,333]
[353] -> [345]
[354] -> [346]
[355] -> [347]
[356] -> [234,333,348]
[357] -> [349]
[358] -> [237,350]
[359] -> [238,333,351]
[360] -> [236]
[361] -> [233]
[362] -> [232]
[363] -> [231]
[364] -> [230]
[365] -> [229]
[365,371] -> [212]
[365,371,378] -> [370]
[365,371,378,381] -> [377]
[365,371,379] -> [369]
[365,371,380] -> [331]
[365,372] -> [199]
[365,372,376] -> [331]
[365,373] -> [369]
[365,374] -> [331]
[365,375] -> [331]
[366] -> [369,433]
[367] -> [370,432]
[368] -> [240,333,429]
[369] -> [366]
[370] -> [367]
[371] -> [236]
[372] -> [233]
[373] -> [232]
[374] -> [231]
[375] -> [230]
[376] -> [200]
[377] -> [237]
[378] -> [215]
[379] -> [214]
[380] -> [213]
[382] -> [179]
[382,390] -> [389]
[382,391] -> [387]
[382,392] -> [386]
[382,393] -> [331]
[383] -> [386,516]
[384] -> [387,515]
[385] -> [333,388,438]
[386] -> [383]
[387] -> [384]
[388] -> [183,333,385]
[390] -> [185]
[391] -> [182]
[392] -> [181]
[393] -> [180]
[403] -> [402]
[403,406] -> [34]
[403,407] -> [35]
[403,408] -> [405]
[403,409] -> [33]
[404] -> [405,476]
[405] -> [404]
[409] -> [E]
[410] -> [402]
[410,413] -> [35]
[410,414] -> [34]
[410,415] -> [412]
[410,416] -> [33]
[411] -> [412,423]
[412] -> [411]
[416] -> [E]
[417] -> [410]
[417,423] -> [422]
[417,423,424] -> [421]
[417,423,425] -> [420]
[418] -> [420,490]
[419] -> [421,489]
[420] -> [418]
[421] -> [419]
[423] -> [411]
[427] -> [365]
[427,432] -> [431]
[427,432,435] -> [430]
[427,433] -> [426]
[428] -> [430,440]
[429] -> [333,368,438]
[430] -> [428]
[432] -> [367]
[433] -> [366]
[436] -> [427]
[436,440] -> [401]
[436,440,441] -> [439]
[437] -> [439,455,532]
[438] -> [333,385,429,453]
[439] -> [437]
[440] -> [428]
[442] -> [2,3,396,398,444,446]
[442,446,447] -> [445]
[442,448,450] -> [445]
[442,449] -> [395]
[443] -> [444,446,450,456]
[444] -> [443]
[445] -> [442,446,447]
[446] -> [443]
[450] -> [443]
[451] -> [436]
[451,455] -> [442]
[451,455,456] -> [454]
[452] -> [454]
[453] -> [333,438]
[454] -> [452]
[455] -> [437]
[456] -> [443]
[457] -> [464]
[457,475] -> [403]
[457,475,476] -> [461]
[458] -> [461,472,503,506,509]
[459] -> [462,471,502,505,508]
[460] -> [463,504,507,510]
[461] -> [458]
[462] -> [459]
[463] -> [460,470]
[464] -> [34,35,396,398,466,467]
[464,468] -> [457]
[464,468,471] -> [462]
[464,468,472] -> [399]
[464,468,472,473] -> [395]
[464,468,472,474] -> [461]
[464,469] -> [462]
[464,469,470] -> [461]
[465] -> [466,467,475]
[466] -> [465]
[467] -> [465]
[470] -> [463]
[471] -> [459]
[472] -> [458]
[475] -> [465]
[476] -> [404]
[477] -> [34,35,395,396,479,480]
[478] -> [479,480,488]
[479] -> [478]
[480] -> [478]
[481] -> [477]
[481,488] -> [417]
[481,488,489] -> [398]
[481,488,489,493] -> [400]
[481,488,489,493,497] -> [487]
[481,488,489,493,498] -> [487]
[481,488,489,494] -> [400]
[481,488,489,494,495] -> [486]
[481,488,489,494,496] -> [486]
[481,488,490] -> [400]
[481,488,490,491] -> [485]
[481,488,490,492] -> [485]
[482] -> [485,513]
[483] -> [486,512]
[484] -> [487,511]
[485] -> [482]
[486] -> [483]
[487] -> [484]
[488] -> [478]
[489] -> [419]
[490] -> [418]
[499] -> [457]
[499,502] -> [457]
[499,502,505] -> [457]
[499,502,505,508] -> [481]
[499,502,505,508,511] -> [510]
[499,502,505,508,512] -> [507]
[499,502,505,508,513] -> [504]
[499,502,505,509] -> [507]
[499,502,506] -> [504]
[499,503] -> [501]
[500] -> [501,533]
[501] -> [500]
[502] -> [459]
[503] -> [458]
[504] -> [460]
[505] -> [459]
[506] -> [458]
[507] -> [460]
[508] -> [459]
[509] -> [458]
[510] -> [460]
[511] -> [484]
[512] -> [483]
[513] -> [482]
[514] -> [382]
[514,515] -> [436]
[514,515,532] -> [499]
[514,515,532,533] -> [529]
[514,516] -> [426]
[515] -> [384]
[516] -> [383]
[517] -> [398]
[517,518] -> [395]
[517,519] -> [395]
[520] -> [400]
[520,521] -> [517]
[520,522] -> [517]
[523] -> [400]
[523,524] -> [520]
[523,525] -> [520]
[526] -> [400]
[526,527] -> [523]
[526,528] -> [523]
[529] -> [400]
[529,530] -> [517]
[529,531] -> [526]
[532] -> [437]
[533] -> [500]

### Solution ###

[14,15,28,34,35,45,48,49,65,66,69,72,77,78,79,82,83,111,117,134,149,152,153,158,161,164,169,170,173,176,179,182,185,188,191,192,195,196,199,204,207,208,209,212,215,220,221,224,225,226,229,233,236,237,245,246,249,250,253,254,258,261,264,265,272,273,274,277,278,281,284,285,289,290,293,301,302,305,306,307,308,312,313,316,317,320,321,324,325,326,330,341,350,358,360,361,365,367,370,371,372,377,378,381,382,384,387,389,390,391,395,396,398,399,400,401,402,403,404,405,406,407,408,410,411,412,413,414,415,417,418,419,420,421,422,423,424,425,427,428,430,431,432,434,435,436,437,439,440,441,447,448,449,455,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,R]

### Annotated ###

  let
    constructor Nat :E: Type
    constructor Z :E: Nat
    constructor S :E: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :R: (a :E: Type) -> (b :E: Type) -> (_x7 :R: a) -> (_x8 :R: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = x
    snd :R: (a :E: Type) -> (b :E: Type) -> (_x10 :R: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :R: a y :R: b
        snd -E- a -E- b -R- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: (_x19 :E: Type) -> Type
    constructor Nil :E: (a :E: Type) -> List -E- a
    constructor Cons :E: (a :E: Type) -> (x :E: a) -> (xs :E: List -E- a) -> List -E- a
    constructor State :E: (_x0 :E: Type) -> (_x1 :E: Type) -> Type
    constructor MkSt :R: (st :E: Type) -> (a :E: Type) -> (run :R: (_x2 :R: st) -> Pair -E- st -E- a) -> State -E- st -E- a
    runState :R: (st :E: Type) -> (a :E: Type) -> (_x3 :R: State -E- st -E- a) -> (_x4 :R: st) -> Pair -E- st -E- a 
      st :E: Type a :E: Type run :R: (_x5 :R: st) -> Pair -E- st -E- a
        runState -E- st -E- a -R- ([MkSt] -E- [st] -E- [a] -R- run) = run
    execState :R: (st :E: Type) -> (a :E: Type) -> (x :R: State -E- st -E- a) -> (s :R: st) -> a = (\st :E: Type. (\a :E: Type. (\x :R: State -E- st -E- a. (\s :R: st. snd -E- st -E- a -R- (runState -E- st -E- a -R- x -R- s)))))
    stGet :R: (st :E: Type) -> State -E- st -E- st = (\st :E: Type. MkSt -E- st -E- st -R- (\s :R: st. MkPair -E- st -E- st -R- s -R- s))
    stReturn :R: (st :E: Type) -> (a :E: Type) -> (x :R: a) -> State -E- st -E- a = (\st :E: Type. (\a :E: Type. (\x :R: a. MkSt -E- st -E- a -R- (\s :R: st. MkPair -E- st -E- a -R- s -R- x))))
    stBind :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (x :R: State -E- st -E- a) -> (y :R: (z :R: a) -> State -E- st -E- b) -> State -E- st -E- b 
      st :E: Type a :E: Type b :E: Type f :R: (_x6 :R: st) -> Pair -E- st -E- a g :R: (_x7 :R: a) -> State -E- st -E- b
        stBind -E- st -E- a -E- b -R- ([MkSt] -E- [st] -E- [a] -R- f) -R- g = 
          let
            stBind3 :R: (st :E: Type) -> (b :E: Type) -> (_x8 :R: st) -> (_x9 :R: State -E- st -E- b) -> Pair -E- st -E- b 
              st :E: Type b :E: Type s :R: st f :R: (_x10 :R: st) -> Pair -E- st -E- b
                stBind3 -E- st -E- b -R- s -R- ([MkSt] -E- [st] -E- [b] -R- f) = f -R- s
            stBind2 :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (g :R: (_x11 :R: a) -> State -E- st -E- b) -> (r :R: Pair -E- st -E- a) -> Pair -E- st -E- b 
              st :E: Type a :E: Type b :E: Type g :R: (_x12 :R: a) -> State -E- st -E- b x :R: a s :R: st
                stBind2 -E- st -E- a -E- b -R- g -R- ([MkPair] -E- [st] -E- [a] -R- s -R- x) = stBind3 -E- st -E- b -R- s -R- (g -R- x)
          in MkSt -E- st -E- b -R- (\s :R: st. stBind2 -E- st -E- a -E- b -R- g -R- (f -R- s))
    postulate RealWorld :E: Type
    IO :E: (_x0 :E: Type) -> Type = State -E- RealWorld
    ioReturn :E: (a :E: Type) -> (x :E: a) -> IO -E- a = (\a :E: Type. (\x :E: a. stReturn -E- RealWorld -E- a -R- x))
    ioBind :E: (a :E: Type) -> (b :E: Type) -> (x :E: IO -E- a) -> (y :E: (_x1 :R: a) -> IO -E- b) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\x :E: IO -E- a. (\y :E: (_x1 :R: a) -> IO -E- b. stBind -E- RealWorld -E- a -E- b -R- x -R- y))))
    ioWrapImpure :R: (a :E: Type) -> (impureF :R: (w :R: RealWorld) -> a) -> IO -E- a = (\a :E: Type. (\impureF :R: (w :R: RealWorld) -> a. stBind -E- RealWorld -E- RealWorld -E- a -R- (stGet -E- RealWorld) -R- (\w :R: RealWorld. stReturn -E- RealWorld -E- a -R- (impureF -R- w))))
    unsafePerformIO :R: (a :E: Type) -> (x :R: IO -E- a) -> a = (\a :E: Type. (\x :R: IO -E- a. 
      let postulate TheWorld :R: RealWorld
      in execState -E- RealWorld -E- a -R- x -R- TheWorld))
    postulate Int :E: Type
    foreign int1 :R: Int
    foreign int0 :R: Int
    postulate String :E: Type
    foreign plusInt :R: (x :R: Int) -> (y :R: Int) -> Int
    foreign minusInt :R: (x :R: Int) -> (y :R: Int) -> Int
    foreign timesInt :R: (x :R: Int) -> (y :R: Int) -> Int
    foreign intToString :R: (i :R: Int) -> String
    foreign ifRaw :R: (a :E: Type) -> (x :R: Int) -> (then :R: a) -> (else :R: a) -> a
    isZero :R: (x :R: Int) -> Bool = (\x :R: Int. ifRaw -E- Bool -R- x -R- False -R- True)
    isNonzero :R: (x :R: Int) -> Bool = (\x :R: Int. ifRaw -E- Bool -R- x -R- True -R- False)
    eqInt :R: (x :R: Int) -> (y :R: Int) -> Bool = (\x :R: Int. (\y :R: Int. 
      let foreign eqInt_I :R: (x :R: Int) -> (y :R: Int) -> Int
      in isNonzero -R- (eqInt_I -R- x -R- y)))
    postulate Unspec :E: Type
    printString :R: (s :R: String) -> IO -E- Unspec = (\s :R: String. 
      let foreign nativePrint :R: (x :R: String) -> Unspec
      in ioWrapImpure -E- Unspec -R- (\w :R: RealWorld. nativePrint -R- s))
    printInt :R: (i :R: Int) -> IO -E- Unspec = (\i :R: Int. printString -R- (intToString -R- i))
    natToInt :E: (_x0 :E: Nat) -> Int 
      natToInt -E- Z = int0
      n :E: Nat
        natToInt -E- (S -R- n) = plusInt -R- int1 -R- (natToInt -E- n)
    printNat :E: (n :E: Nat) -> IO -E- Unspec = (\n :E: Nat. printInt -R- (natToInt -E- n))
    sumFor :R: (n :R: Int) -> (f :R: (_x0 :R: Int) -> Int) -> Int = (\n :R: Int. (\f :R: (_x0 :R: Int) -> Int. 
      let g :R: (_x1 :R: Bool) -> Int 
        g -R- True = int0
        g -R- False = plusInt -R- (f -R- n) -R- (sumFor -R- (minusInt -R- n -R- int1) -R- f)
      in g -R- (isZero -R- n)))
    boolToInt :R: (_x2 :R: Bool) -> Int 
      boolToInt -R- True = int1
      boolToInt -R- False = int0
    isPythag :R: (x :R: Int) -> (y :R: Int) -> (z :R: Int) -> Int = (\x :R: Int. (\y :R: Int. (\z :R: Int. boolToInt -R- (eqInt -R- (timesInt -R- x -R- x) -R- (plusInt -R- (timesInt -R- y -R- y) -R- (timesInt -R- z -R- z))))))
    pythag :R: (n :R: Int) -> Int = (\n :R: Int. sumFor -R- n -R- (\x :R: Int. sumFor -R- x -R- (\y :R: Int. sumFor -R- y -R- (\z :R: Int. isPythag -R- x -R- y -R- z))))
    main :R: Unspec = unsafePerformIO -E- Unspec -R- 
      let
        int2 :R: Int = plusInt -R- int1 -R- int1
        int4 :R: Int = timesInt -R- int2 -R- int2
        int16 :R: Int = timesInt -R- int4 -R- int4
        int256 :R: Int = timesInt -R- int16 -R- int16
        int512 :R: Int = timesInt -R- int256 -R- int2
      in printInt -R- (pythag -R- int512)
  in main

### Specialised ###

  let
    constructor Nat :E: Type
    constructor Z :E: Nat
    constructor S :E: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :R: (a :E: Type) -> (b :E: Type) -> (_x7 :R: a) -> (_x8 :R: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = x
    snd :R: (a :E: Type) -> (b :E: Type) -> (_x10 :R: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :R: a y :R: b
        snd -E- a -E- b -R- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: (_x19 :E: Type) -> Type
    constructor Nil :E: (a :E: Type) -> List -E- a
    constructor Cons :E: (a :E: Type) -> (x :E: a) -> (xs :E: List -E- a) -> List -E- a
    constructor State :E: (_x0 :E: Type) -> (_x1 :E: Type) -> Type
    constructor MkSt :R: (st :E: Type) -> (a :E: Type) -> (run :R: (_x2 :R: st) -> Pair -E- st -E- a) -> State -E- st -E- a
    runState :R: (st :E: Type) -> (a :E: Type) -> (_x3 :R: State -E- st -E- a) -> (_x4 :R: st) -> Pair -E- st -E- a 
      st :E: Type a :E: Type run :R: (_x5 :R: st) -> Pair -E- st -E- a
        runState -E- st -E- a -R- ([MkSt] -E- [st] -E- [a] -R- run) = run
    execState :R: (st :E: Type) -> (a :E: Type) -> (x :R: State -E- st -E- a) -> (s :R: st) -> a = (\st :E: Type. (\a :E: Type. (\x :R: State -E- st -E- a. (\s :R: st. snd -E- st -E- a -R- (runState -E- st -E- a -R- x -R- s)))))
    stGet :R: (st :E: Type) -> State -E- st -E- st = (\st :E: Type. MkSt -E- st -E- st -R- (\s :R: st. MkPair -E- st -E- st -R- s -R- s))
    stReturn :R: (st :E: Type) -> (a :E: Type) -> (x :R: a) -> State -E- st -E- a = (\st :E: Type. (\a :E: Type. (\x :R: a. MkSt -E- st -E- a -R- (\s :R: st. MkPair -E- st -E- a -R- s -R- x))))
    stBind :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (x :R: State -E- st -E- a) -> (y :R: (z :R: a) -> State -E- st -E- b) -> State -E- st -E- b 
      st :E: Type a :E: Type b :E: Type f :R: (_x6 :R: st) -> Pair -E- st -E- a g :R: (_x7 :R: a) -> State -E- st -E- b
        stBind -E- st -E- a -E- b -R- ([MkSt] -E- [st] -E- [a] -R- f) -R- g = 
          let
            stBind3 :R: (st :E: Type) -> (b :E: Type) -> (_x8 :R: st) -> (_x9 :R: State -E- st -E- b) -> Pair -E- st -E- b 
              st :E: Type b :E: Type s :R: st f :R: (_x10 :R: st) -> Pair -E- st -E- b
                stBind3 -E- st -E- b -R- s -R- ([MkSt] -E- [st] -E- [b] -R- f) = f -R- s
            stBind2 :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (g :R: (_x11 :R: a) -> State -E- st -E- b) -> (r :R: Pair -E- st -E- a) -> Pair -E- st -E- b 
              st :E: Type a :E: Type b :E: Type g :R: (_x12 :R: a) -> State -E- st -E- b x :R: a s :R: st
                stBind2 -E- st -E- a -E- b -R- g -R- ([MkPair] -E- [st] -E- [a] -R- s -R- x) = stBind3 -E- st -E- b -R- s -R- (g -R- x)
          in MkSt -E- st -E- b -R- (\s :R: st. stBind2 -E- st -E- a -E- b -R- g -R- (f -R- s))
    postulate RealWorld :E: Type
    IO :E: (_x0 :E: Type) -> Type = State -E- RealWorld
    ioReturn :E: (a :E: Type) -> (x :E: a) -> IO -E- a = (\a :E: Type. (\x :E: a. stReturn -E- RealWorld -E- a -R- x))
    ioBind :E: (a :E: Type) -> (b :E: Type) -> (x :E: IO -E- a) -> (y :E: (_x1 :R: a) -> IO -E- b) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\x :E: IO -E- a. (\y :E: (_x1 :R: a) -> IO -E- b. stBind -E- RealWorld -E- a -E- b -R- x -R- y))))
    ioWrapImpure :R: (a :E: Type) -> (impureF :R: (w :R: RealWorld) -> a) -> IO -E- a = (\a :E: Type. (\impureF :R: (w :R: RealWorld) -> a. stBind -E- RealWorld -E- RealWorld -E- a -R- (stGet -E- RealWorld) -R- (\w :R: RealWorld. stReturn -E- RealWorld -E- a -R- (impureF -R- w))))
    unsafePerformIO :R: (a :E: Type) -> (x :R: IO -E- a) -> a = (\a :E: Type. (\x :R: IO -E- a. 
      let postulate TheWorld :R: RealWorld
      in execState -E- RealWorld -E- a -R- x -R- TheWorld))
    postulate Int :E: Type
    foreign int1 :R: Int
    foreign int0 :R: Int
    postulate String :E: Type
    foreign plusInt :R: (x :R: Int) -> (y :R: Int) -> Int
    foreign minusInt :R: (x :R: Int) -> (y :R: Int) -> Int
    foreign timesInt :R: (x :R: Int) -> (y :R: Int) -> Int
    foreign intToString :R: (i :R: Int) -> String
    foreign ifRaw :R: (a :E: Type) -> (x :R: Int) -> (then :R: a) -> (else :R: a) -> a
    isZero :R: (x :R: Int) -> Bool = (\x :R: Int. ifRaw -E- Bool -R- x -R- False -R- True)
    isNonzero :R: (x :R: Int) -> Bool = (\x :R: Int. ifRaw -E- Bool -R- x -R- True -R- False)
    eqInt :R: (x :R: Int) -> (y :R: Int) -> Bool = (\x :R: Int. (\y :R: Int. 
      let foreign eqInt_I :R: (x :R: Int) -> (y :R: Int) -> Int
      in isNonzero -R- (eqInt_I -R- x -R- y)))
    postulate Unspec :E: Type
    printString :R: (s :R: String) -> IO -E- Unspec = (\s :R: String. 
      let foreign nativePrint :R: (x :R: String) -> Unspec
      in ioWrapImpure -E- Unspec -R- (\w :R: RealWorld. nativePrint -R- s))
    printInt :R: (i :R: Int) -> IO -E- Unspec = (\i :R: Int. printString -R- (intToString -R- i))
    natToInt :E: (_x0 :E: Nat) -> Int 
      natToInt -E- Z = int0
      n :E: Nat
        natToInt -E- (S -R- n) = plusInt -R- int1 -R- (natToInt -E- n)
    printNat :E: (n :E: Nat) -> IO -E- Unspec = (\n :E: Nat. printInt -R- (natToInt -E- n))
    sumFor :R: (n :R: Int) -> (f :R: (_x0 :R: Int) -> Int) -> Int = (\n :R: Int. (\f :R: (_x0 :R: Int) -> Int. 
      let g :R: (_x1 :R: Bool) -> Int 
        g -R- True = int0
        g -R- False = plusInt -R- (f -R- n) -R- (sumFor -R- (minusInt -R- n -R- int1) -R- f)
      in g -R- (isZero -R- n)))
    boolToInt :R: (_x2 :R: Bool) -> Int 
      boolToInt -R- True = int1
      boolToInt -R- False = int0
    isPythag :R: (x :R: Int) -> (y :R: Int) -> (z :R: Int) -> Int = (\x :R: Int. (\y :R: Int. (\z :R: Int. boolToInt -R- (eqInt -R- (timesInt -R- x -R- x) -R- (plusInt -R- (timesInt -R- y -R- y) -R- (timesInt -R- z -R- z))))))
    pythag :R: (n :R: Int) -> Int = (\n :R: Int. sumFor -R- n -R- (\x :R: Int. sumFor -R- x -R- (\y :R: Int. sumFor -R- y -R- (\z :R: Int. isPythag -R- x -R- y -R- z))))
    main :R: Unspec = unsafePerformIO -E- Unspec -R- 
      let
        int2 :R: Int = plusInt -R- int1 -R- int1
        int4 :R: Int = timesInt -R- int2 -R- int2
        int16 :R: Int = timesInt -R- int4 -R- int4
        int256 :R: Int = timesInt -R- int16 -R- int16
        int512 :R: Int = timesInt -R- int256 -R- int2
      in printInt -R- (pythag -R- int512)
  in main

### Final annotation ###

  let
    constructor Nat :E: Type
    constructor Z :E: Nat
    constructor S :E: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :R: (a :E: Type) -> (b :E: Type) -> (_x7 :R: a) -> (_x8 :R: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = x
    snd :R: (a :E: Type) -> (b :E: Type) -> (_x10 :R: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :R: a y :R: b
        snd -E- a -E- b -R- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: (_x19 :E: Type) -> Type
    constructor Nil :E: (a :E: Type) -> List -E- a
    constructor Cons :E: (a :E: Type) -> (x :E: a) -> (xs :E: List -E- a) -> List -E- a
    constructor State :E: (_x0 :E: Type) -> (_x1 :E: Type) -> Type
    constructor MkSt :R: (st :E: Type) -> (a :E: Type) -> (run :R: (_x2 :R: st) -> Pair -E- st -E- a) -> State -E- st -E- a
    runState :R: (st :E: Type) -> (a :E: Type) -> (_x3 :R: State -E- st -E- a) -> (_x4 :R: st) -> Pair -E- st -E- a 
      st :E: Type a :E: Type run :R: (_x5 :R: st) -> Pair -E- st -E- a
        runState -E- st -E- a -R- ([MkSt] -E- [st] -E- [a] -R- run) = run
    execState :R: (st :E: Type) -> (a :E: Type) -> (x :R: State -E- st -E- a) -> (s :R: st) -> a = (\st :E: Type. (\a :E: Type. (\x :R: State -E- st -E- a. (\s :R: st. snd -E- st -E- a -R- (runState -E- st -E- a -R- x -R- s)))))
    stGet :R: (st :E: Type) -> State -E- st -E- st = (\st :E: Type. MkSt -E- st -E- st -R- (\s :R: st. MkPair -E- st -E- st -R- s -R- s))
    stReturn :R: (st :E: Type) -> (a :E: Type) -> (x :R: a) -> State -E- st -E- a = (\st :E: Type. (\a :E: Type. (\x :R: a. MkSt -E- st -E- a -R- (\s :R: st. MkPair -E- st -E- a -R- s -R- x))))
    stBind :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (x :R: State -E- st -E- a) -> (y :R: (z :R: a) -> State -E- st -E- b) -> State -E- st -E- b 
      st :E: Type a :E: Type b :E: Type f :R: (_x6 :R: st) -> Pair -E- st -E- a g :R: (_x7 :R: a) -> State -E- st -E- b
        stBind -E- st -E- a -E- b -R- ([MkSt] -E- [st] -E- [a] -R- f) -R- g = 
          let
            stBind3 :R: (st :E: Type) -> (b :E: Type) -> (_x8 :R: st) -> (_x9 :R: State -E- st -E- b) -> Pair -E- st -E- b 
              st :E: Type b :E: Type s :R: st f :R: (_x10 :R: st) -> Pair -E- st -E- b
                stBind3 -E- st -E- b -R- s -R- ([MkSt] -E- [st] -E- [b] -R- f) = f -R- s
            stBind2 :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (g :R: (_x11 :R: a) -> State -E- st -E- b) -> (r :R: Pair -E- st -E- a) -> Pair -E- st -E- b 
              st :E: Type a :E: Type b :E: Type g :R: (_x12 :R: a) -> State -E- st -E- b x :R: a s :R: st
                stBind2 -E- st -E- a -E- b -R- g -R- ([MkPair] -E- [st] -E- [a] -R- s -R- x) = stBind3 -E- st -E- b -R- s -R- (g -R- x)
          in MkSt -E- st -E- b -R- (\s :R: st. stBind2 -E- st -E- a -E- b -R- g -R- (f -R- s))
    postulate RealWorld :E: Type
    IO :E: (_x0 :E: Type) -> Type = State -E- RealWorld
    ioReturn :E: (a :E: Type) -> (x :E: a) -> IO -E- a = (\a :E: Type. (\x :E: a. stReturn -E- RealWorld -E- a -R- x))
    ioBind :E: (a :E: Type) -> (b :E: Type) -> (x :E: IO -E- a) -> (y :E: (_x1 :R: a) -> IO -E- b) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\x :E: IO -E- a. (\y :E: (_x1 :R: a) -> IO -E- b. stBind -E- RealWorld -E- a -E- b -R- x -R- y))))
    ioWrapImpure :R: (a :E: Type) -> (impureF :R: (w :R: RealWorld) -> a) -> IO -E- a = (\a :E: Type. (\impureF :R: (w :R: RealWorld) -> a. stBind -E- RealWorld -E- RealWorld -E- a -R- (stGet -E- RealWorld) -R- (\w :R: RealWorld. stReturn -E- RealWorld -E- a -R- (impureF -R- w))))
    unsafePerformIO :R: (a :E: Type) -> (x :R: IO -E- a) -> a = (\a :E: Type. (\x :R: IO -E- a. 
      let postulate TheWorld :R: RealWorld
      in execState -E- RealWorld -E- a -R- x -R- TheWorld))
    postulate Int :E: Type
    foreign int1 :R: Int
    foreign int0 :R: Int
    postulate String :E: Type
    foreign plusInt :R: (x :R: Int) -> (y :R: Int) -> Int
    foreign minusInt :R: (x :R: Int) -> (y :R: Int) -> Int
    foreign timesInt :R: (x :R: Int) -> (y :R: Int) -> Int
    foreign intToString :R: (i :R: Int) -> String
    foreign ifRaw :R: (a :E: Type) -> (x :R: Int) -> (then :R: a) -> (else :R: a) -> a
    isZero :R: (x :R: Int) -> Bool = (\x :R: Int. ifRaw -E- Bool -R- x -R- False -R- True)
    isNonzero :R: (x :R: Int) -> Bool = (\x :R: Int. ifRaw -E- Bool -R- x -R- True -R- False)
    eqInt :R: (x :R: Int) -> (y :R: Int) -> Bool = (\x :R: Int. (\y :R: Int. 
      let foreign eqInt_I :R: (x :R: Int) -> (y :R: Int) -> Int
      in isNonzero -R- (eqInt_I -R- x -R- y)))
    postulate Unspec :E: Type
    printString :R: (s :R: String) -> IO -E- Unspec = (\s :R: String. 
      let foreign nativePrint :R: (x :R: String) -> Unspec
      in ioWrapImpure -E- Unspec -R- (\w :R: RealWorld. nativePrint -R- s))
    printInt :R: (i :R: Int) -> IO -E- Unspec = (\i :R: Int. printString -R- (intToString -R- i))
    natToInt :E: (_x0 :E: Nat) -> Int 
      natToInt -E- Z = int0
      n :E: Nat
        natToInt -E- (S -R- n) = plusInt -R- int1 -R- (natToInt -E- n)
    printNat :E: (n :E: Nat) -> IO -E- Unspec = (\n :E: Nat. printInt -R- (natToInt -E- n))
    sumFor :R: (n :R: Int) -> (f :R: (_x0 :R: Int) -> Int) -> Int = (\n :R: Int. (\f :R: (_x0 :R: Int) -> Int. 
      let g :R: (_x1 :R: Bool) -> Int 
        g -R- True = int0
        g -R- False = plusInt -R- (f -R- n) -R- (sumFor -R- (minusInt -R- n -R- int1) -R- f)
      in g -R- (isZero -R- n)))
    boolToInt :R: (_x2 :R: Bool) -> Int 
      boolToInt -R- True = int1
      boolToInt -R- False = int0
    isPythag :R: (x :R: Int) -> (y :R: Int) -> (z :R: Int) -> Int = (\x :R: Int. (\y :R: Int. (\z :R: Int. boolToInt -R- (eqInt -R- (timesInt -R- x -R- x) -R- (plusInt -R- (timesInt -R- y -R- y) -R- (timesInt -R- z -R- z))))))
    pythag :R: (n :R: Int) -> Int = (\n :R: Int. sumFor -R- n -R- (\x :R: Int. sumFor -R- x -R- (\y :R: Int. sumFor -R- y -R- (\z :R: Int. isPythag -R- x -R- y -R- z))))
    main :R: Unspec = unsafePerformIO -E- Unspec -R- 
      let
        int2 :R: Int = plusInt -R- int1 -R- int1
        int4 :R: Int = timesInt -R- int2 -R- int2
        int16 :R: Int = timesInt -R- int4 -R- int4
        int256 :R: Int = timesInt -R- int16 -R- int16
        int512 :R: Int = timesInt -R- int256 -R- int2
      in printInt -R- (pythag -R- int512)
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor True : Bool
    constructor False : Bool
    constructor MkPair : (_x7) -> (_x8) -> Pair
    snd 
      snd ([_] x y) = y
    constructor MkSt : (run) -> State
    runState 
      runState ([_] run) = run
    execState = (\x. (\s. snd (runState x s)))
    stGet = MkSt (\s. MkPair s s)
    stReturn = (\x. MkSt (\s. MkPair s x))
    stBind 
      stBind ([_] f) g = 
        let
          stBind3 
            stBind3 s ([_] f) = f s
          stBind2 
            stBind2 g ([_] s x) = stBind3 s (g x)
        in MkSt (\s. stBind2 g (f s))
    ioWrapImpure = (\impureF. stBind stGet (\w. stReturn (impureF w)))
    unsafePerformIO = (\x. 
      let postulate TheWorld : RealWorld
      in execState x TheWorld)
    foreign int1
    foreign int0
    foreign plusInt
    foreign minusInt
    foreign timesInt
    foreign intToString
    foreign ifRaw
    isZero = (\x. ifRaw x False True)
    isNonzero = (\x. ifRaw x True False)
    eqInt = (\x. (\y. 
      let foreign eqInt_I
      in isNonzero (eqInt_I x y)))
    printString = (\s. 
      let foreign nativePrint
      in ioWrapImpure (\w. nativePrint s))
    printInt = (\i. printString (intToString i))
    sumFor = (\n. (\f. 
      let g 
        g True = int0
        g False = plusInt (f n) (sumFor (minusInt n int1) f)
      in g (isZero n)))
    boolToInt 
      boolToInt True = int1
      boolToInt False = int0
    isPythag = (\x. (\y. (\z. boolToInt (eqInt (timesInt x x) (plusInt (timesInt y y) (timesInt z z))))))
    pythag = (\n. sumFor n (\x. sumFor x (\y. sumFor y (\z. isPythag x y z))))
    main = unsafePerformIO 
      let
        int2 = plusInt int1 int1
        int4 = timesInt int2 int2
        int16 = timesInt int4 int4
        int256 = timesInt int16 int16
        int512 = timesInt int256 int2
      in printInt (pythag int512)
  in main

### Intermediate representation ###

let True = constructor 0
  in let False = constructor 0
    in let MkPair = constructor 2
      in let snd = \_pv0.
        case _pv0 of
          _ _pv1 _pv2 => _pv2
        in let MkSt = constructor 1
          in let runState = \_pv0.
            case _pv0 of
              _ _pv1 => _pv1
            in let execState = \x. \s. (snd ((runState x) s))
              in let stGet = (MkSt \s. ((MkPair s) s))
                in let stReturn = \x. (MkSt \s. ((MkPair s) x))
                  in let stBind = \_pv0. \_pv1.
                    case _pv0 of
                      _ _pv2 => let stBind3 = \_pv3. \_pv4.
                        case _pv4 of
                          _ _pv5 => (_pv5 _pv3)
                        in let stBind2 = \_pv3. \_pv4.
                          case _pv4 of
                            _ _pv5 _pv6 => ((stBind3 _pv5) (_pv3 _pv6))
                          in (MkSt \s. ((stBind2 _pv1) (_pv2 s)))
                    in let ioWrapImpure = \impureF. ((stBind stGet) \w. (stReturn (impureF w)))
                      in let unsafePerformIO = \x. let TheWorld = constructor 0
                        in ((execState x) TheWorld)
                        in let int1 = foreign "1"
                          in let int0 = foreign "0"
                            in let plusInt = foreign "(lambda ($x $y) (+ $x $y))"
                              in let minusInt = foreign "(lambda ($x $y) (- $x $y))"
                                in let timesInt = foreign "(lambda ($x $y) (* $x $y))"
                                  in let intToString = foreign "(global $Pervasives $string_of_int)"
                                    in let ifRaw = foreign "(lambda ($x $then $else) (switch $x (0 $else) (_ $then)))"
                                      in let isZero = \x. (((ifRaw x) False) True)
                                        in let isNonzero = \x. (((ifRaw x) True) False)
                                          in let eqInt = \x. \y. let eqInt_I = foreign "(lambda ($x $y) (== $x $y))"
                                            in (isNonzero ((eqInt_I x) y))
                                            in let printString = \s. let nativePrint = foreign "(global $Pervasives $print_endline)"
                                              in (ioWrapImpure \w. (nativePrint s))
                                              in let printInt = \i. (printString (intToString i))
                                                in let sumFor = \n. \f. let g = \_pv0.
                                                  case _pv0 of
                                                    False => ((plusInt (f n)) ((sumFor ((minusInt n) int1)) f))
                                                    True => int0
                                                  in (g (isZero n))
                                                  in let boolToInt = \_pv0.
                                                    case _pv0 of
                                                      False => int0
                                                      True => int1
                                                    in let isPythag = \x. \y. \z. (boolToInt ((eqInt ((timesInt x) x)) ((plusInt ((timesInt y) y)) ((timesInt z) z))))
                                                      in let pythag = \n. ((sumFor n) \x. ((sumFor x) \y. ((sumFor y) \z. (((isPythag x) y) z))))
                                                        in let main = (unsafePerformIO let int2 = ((plusInt int1) int1)
                                                          in let int4 = ((timesInt int2) int2)
                                                            in let int16 = ((timesInt int4) int4)
                                                              in let int256 = ((timesInt int16) int16)
                                                                in let int512 = ((timesInt int256) int2)
                                                                  in (printInt (pythag int512)))
                                                          in main

### Normal forms ###

unerased:
  
  let
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    postulate Int : Type
    foreign int1 : Int
    foreign int0 : Int
    postulate String : Type
    foreign plusInt : (x :R: Int) -> (y :R: Int) -> Int
    foreign minusInt : (x :R: Int) -> (y :R: Int) -> Int
    foreign timesInt : (x :R: Int) -> (y :R: Int) -> Int
    foreign intToString : (i :R: Int) -> String
    foreign ifRaw : (a :E: Type) -> (x :R: Int) -> (then :R: a) -> (else :R: a) -> a
    isZero : (x : Int) -> Bool = (\x : Int. ifRaw Bool x False True)
    postulate Unspec : Type
    sumFor : (n : Int) -> (f : (_x0 : Int) -> Int) -> Int = (\n : Int. (\f : (_x0 : Int) -> Int. 
      let g : (_x1 : Bool) -> Int 
        g True = int0
        g False = plusInt (f n) (sumFor (minusInt n int1) f)
      in g (isZero n)))
    boolToInt : (_x2 : Bool) -> Int 
      boolToInt True = int1
      boolToInt False = int0
  in 
    let foreign nativePrint : (x :R: String) -> Unspec
    in 
      let g : (_x1 : Bool) -> Int 
        g True = int0
        g False = plusInt ((\x : Int. 
          let g : (_x1 : Bool) -> Int 
            g True = int0
            g False = plusInt ((\y : Int. 
              let g : (_x1 : Bool) -> Int 
                g True = int0
                g False = plusInt ((\z : Int. 
                  let foreign eqInt_I : (x :R: Int) -> (y :R: Int) -> Int
                  in boolToInt (ifRaw Bool (eqInt_I (timesInt x x) (plusInt (timesInt y y) (timesInt z z))) True False)) y) (sumFor (minusInt y int1) (\z : Int. 
                  let foreign eqInt_I : (x :R: Int) -> (y :R: Int) -> Int
                  in boolToInt (ifRaw Bool (eqInt_I (timesInt x x) (plusInt (timesInt y y) (timesInt z z))) True False)))
              in g (ifRaw Bool y False True)) x) (sumFor (minusInt x int1) (\y : Int. 
              let g : (_x1 : Bool) -> Int 
                g True = int0
                g False = plusInt ((\z : Int. 
                  let foreign eqInt_I : (x :R: Int) -> (y :R: Int) -> Int
                  in boolToInt (ifRaw Bool (eqInt_I (timesInt x x) (plusInt (timesInt y y) (timesInt z z))) True False)) y) (sumFor (minusInt y int1) (\z : Int. 
                  let foreign eqInt_I : (x :R: Int) -> (y :R: Int) -> Int
                  in boolToInt (ifRaw Bool (eqInt_I (timesInt x x) (plusInt (timesInt y y) (timesInt z z))) True False)))
              in g (ifRaw Bool y False True)))
          in g (ifRaw Bool x False True)) (timesInt (timesInt (timesInt (timesInt (plusInt int1 int1) (plusInt int1 int1)) (timesInt (plusInt int1 int1) (plusInt int1 int1))) (timesInt (timesInt (plusInt int1 int1) (plusInt int1 int1)) (timesInt (plusInt int1 int1) (plusInt int1 int1)))) (plusInt int1 int1))) (sumFor (minusInt (timesInt (timesInt (timesInt (timesInt (plusInt int1 int1) (plusInt int1 int1)) (timesInt (plusInt int1 int1) (plusInt int1 int1))) (timesInt (timesInt (plusInt int1 int1) (plusInt int1 int1)) (timesInt (plusInt int1 int1) (plusInt int1 int1)))) (plusInt int1 int1)) int1) (\x : Int. 
          let g : (_x1 : Bool) -> Int 
            g True = int0
            g False = plusInt ((\y : Int. 
              let g : (_x1 : Bool) -> Int 
                g True = int0
                g False = plusInt ((\z : Int. 
                  let foreign eqInt_I : (x :R: Int) -> (y :R: Int) -> Int
                  in boolToInt (ifRaw Bool (eqInt_I (timesInt x x) (plusInt (timesInt y y) (timesInt z z))) True False)) y) (sumFor (minusInt y int1) (\z : Int. 
                  let foreign eqInt_I : (x :R: Int) -> (y :R: Int) -> Int
                  in boolToInt (ifRaw Bool (eqInt_I (timesInt x x) (plusInt (timesInt y y) (timesInt z z))) True False)))
              in g (ifRaw Bool y False True)) x) (sumFor (minusInt x int1) (\y : Int. 
              let g : (_x1 : Bool) -> Int 
                g True = int0
                g False = plusInt ((\z : Int. 
                  let foreign eqInt_I : (x :R: Int) -> (y :R: Int) -> Int
                  in boolToInt (ifRaw Bool (eqInt_I (timesInt x x) (plusInt (timesInt y y) (timesInt z z))) True False)) y) (sumFor (minusInt y int1) (\z : Int. 
                  let foreign eqInt_I : (x :R: Int) -> (y :R: Int) -> Int
                  in boolToInt (ifRaw Bool (eqInt_I (timesInt x x) (plusInt (timesInt y y) (timesInt z z))) True False)))
              in g (ifRaw Bool y False True)))
          in g (ifRaw Bool x False True)))
      in nativePrint (intToString (g (ifRaw Bool (timesInt (timesInt (timesInt (timesInt (plusInt int1 int1) (plusInt int1 int1)) (timesInt (plusInt int1 int1) (plusInt int1 int1))) (timesInt (timesInt (plusInt int1 int1) (plusInt int1 int1)) (timesInt (plusInt int1 int1) (plusInt int1 int1)))) (plusInt int1 int1)) False True)))

erased:
  
  let
    constructor True : Bool
    constructor False : Bool
    foreign int1
    foreign int0
    foreign plusInt
    foreign minusInt
    foreign timesInt
    foreign intToString
    foreign ifRaw
    isZero = (\x. ifRaw x False True)
    sumFor = (\n. (\f. 
      let g 
        g True = int0
        g False = plusInt (f n) (sumFor (minusInt n int1) f)
      in g (isZero n)))
    boolToInt 
      boolToInt True = int1
      boolToInt False = int0
  in 
    let foreign nativePrint
    in 
      let g 
        g True = int0
        g False = plusInt ((\x. 
          let g 
            g True = int0
            g False = plusInt ((\y. 
              let g 
                g True = int0
                g False = plusInt ((\z. 
                  let foreign eqInt_I
                  in boolToInt (ifRaw (eqInt_I (timesInt x x) (plusInt (timesInt y y) (timesInt z z))) True False)) y) (sumFor (minusInt y int1) (\z. 
                  let foreign eqInt_I
                  in boolToInt (ifRaw (eqInt_I (timesInt x x) (plusInt (timesInt y y) (timesInt z z))) True False)))
              in g (ifRaw y False True)) x) (sumFor (minusInt x int1) (\y. 
              let g 
                g True = int0
                g False = plusInt ((\z. 
                  let foreign eqInt_I
                  in boolToInt (ifRaw (eqInt_I (timesInt x x) (plusInt (timesInt y y) (timesInt z z))) True False)) y) (sumFor (minusInt y int1) (\z. 
                  let foreign eqInt_I
                  in boolToInt (ifRaw (eqInt_I (timesInt x x) (plusInt (timesInt y y) (timesInt z z))) True False)))
              in g (ifRaw y False True)))
          in g (ifRaw x False True)) (timesInt (timesInt (timesInt (timesInt (plusInt int1 int1) (plusInt int1 int1)) (timesInt (plusInt int1 int1) (plusInt int1 int1))) (timesInt (timesInt (plusInt int1 int1) (plusInt int1 int1)) (timesInt (plusInt int1 int1) (plusInt int1 int1)))) (plusInt int1 int1))) (sumFor (minusInt (timesInt (timesInt (timesInt (timesInt (plusInt int1 int1) (plusInt int1 int1)) (timesInt (plusInt int1 int1) (plusInt int1 int1))) (timesInt (timesInt (plusInt int1 int1) (plusInt int1 int1)) (timesInt (plusInt int1 int1) (plusInt int1 int1)))) (plusInt int1 int1)) int1) (\x. 
          let g 
            g True = int0
            g False = plusInt ((\y. 
              let g 
                g True = int0
                g False = plusInt ((\z. 
                  let foreign eqInt_I
                  in boolToInt (ifRaw (eqInt_I (timesInt x x) (plusInt (timesInt y y) (timesInt z z))) True False)) y) (sumFor (minusInt y int1) (\z. 
                  let foreign eqInt_I
                  in boolToInt (ifRaw (eqInt_I (timesInt x x) (plusInt (timesInt y y) (timesInt z z))) True False)))
              in g (ifRaw y False True)) x) (sumFor (minusInt x int1) (\y. 
              let g 
                g True = int0
                g False = plusInt ((\z. 
                  let foreign eqInt_I
                  in boolToInt (ifRaw (eqInt_I (timesInt x x) (plusInt (timesInt y y) (timesInt z z))) True False)) y) (sumFor (minusInt y int1) (\z. 
                  let foreign eqInt_I
                  in boolToInt (ifRaw (eqInt_I (timesInt x x) (plusInt (timesInt y y) (timesInt z z))) True False)))
              in g (ifRaw y False True)))
          in g (ifRaw x False True)))
      in nativePrint (intToString (g (ifRaw (timesInt (timesInt (timesInt (timesInt (plusInt int1 int1) (plusInt int1 int1)) (timesInt (plusInt int1 int1) (plusInt int1 int1))) (timesInt (timesInt (plusInt int1 int1) (plusInt int1 int1)) (timesInt (plusInt int1 int1) (plusInt int1 int1)))) (plusInt int1 int1)) False True)))

