-- vim: ft=ttstar

### Desugared ###

  let
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    const : (a : Type) -> (x : a) -> (y : a) -> a = (\a : Type. (\x : a. (\y : a. x)))
    constructor B : Type
    constructor T : B
    constructor F : B
    f : (g : (a : Type) -> (x :E: a) -> (y :R: a) -> a) -> B = (\g : (a : Type) -> (x :E: a) -> (y :R: a) -> a. g B T F)
    main : Id B (f const) T = Refl B T
  in main

### Evarified ###

  let
    constructor Id :1: (a :2: Type) -> (x :3: a) -> (y :4: a) -> Type
    constructor Refl :5: (a :6: Type) -> (x :7: a) -> Id -10- a -9- x -8- x
    const :11: (a :12: Type) -> (x :13: a) -> (y :14: a) -> a = (\a :15: Type. (\x :16: a. (\y :17: a. x)))
    constructor B :18: Type
    constructor T :19: B
    constructor F :20: B
    f :21: (g :22: (a :23: Type) -> (x :E: a) -> (y :R: a) -> a) -> B = (\g :24: (a :25: Type) -> (x :E: a) -> (y :R: a) -> a. g -28- B -27- T -26- F)
    main :29: Id -32- B -31- (f -33- const) -30- T = Refl -35- B -34- T
  in main

### Constraints ###

[] -> [5,R]
[6] -> [35]
[7] -> [34]
[8] -> [30]
[9] -> [31]
[10] -> [32]
[30] -> [8]
[31] -> [9]
[32] -> [10]
[34] -> [7,19]
[35] -> [6,18]
[R] -> [29]

### Solution ###

[5,29,R]

### Annotated ###

  let
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :R: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    const :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> a = (\a :E: Type. (\x :E: a. (\y :E: a. x)))
    constructor B :E: Type
    constructor T :E: B
    constructor F :E: B
    f :E: (g :E: (a :E: Type) -> (x :E: a) -> (y :R: a) -> a) -> B = (\g :E: (a :E: Type) -> (x :E: a) -> (y :R: a) -> a. g -E- B -E- T -E- F)
    main :R: Id -E- B -E- (f -E- const) -E- T = Refl -E- B -E- T
  in main

### Specialised ###

  let
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :R: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    const :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> a = (\a :E: Type. (\x :E: a. (\y :E: a. x)))
    constructor B :E: Type
    constructor T :E: B
    constructor F :E: B
    f :E: (g :E: (a :E: Type) -> (x :E: a) -> (y :R: a) -> a) -> B = (\g :E: (a :E: Type) -> (x :E: a) -> (y :R: a) -> a. g -E- B -E- T -E- F)
    main :R: Id -E- B -E- (f -E- const) -E- T = Refl -E- B -E- T
  in main

### Final annotation ###

  let
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :R: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    const :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> a = (\a :E: Type. (\x :E: a. (\y :E: a. x)))
    constructor B :E: Type
    constructor T :E: B
    constructor F :E: B
    f :E: (g :E: (a :E: Type) -> (x :E: a) -> (y :R: a) -> a) -> B = (\g :E: (a :E: Type) -> (x :E: a) -> (y :R: a) -> a. g -E- B -E- T -E- F)
    main :R: Id -E- B -E- (f -E- const) -E- T = Refl -E- B -E- T
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Refl : Id
    main = Refl
  in main

### Intermediate representation ###

let Refl = constructor 0
  in let main = Refl
    in main

### Normal forms ###

unerased:
  
  let
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    constructor B : Type
    constructor T : B
  in Refl B T

erased:
  
  let constructor Refl : Id
  in Refl

