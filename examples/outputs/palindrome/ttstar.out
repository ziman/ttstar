-- vim: ft=ttstar

### Desugared ###

  let
    constructor N : Type
    constructor Z : N
    constructor S : (_x0 : N) -> N
    constructor B : Type
    constructor T : B
    constructor F : B
    constructor List : Type
    constructor Cons : (_x1 : B) -> (_x2 : List) -> List
    constructor Nil : List
    constructor Maybe : (_x3 : Type) -> Type
    constructor Nothing : (a : Type) -> Maybe a
    constructor Just : (a : Type) -> (x : a) -> Maybe a
    not : (_x4 : B) -> B 
      not T = F
      not F = T
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    id : (a : Type) -> (_x5 : a) -> a = (\a : _0. (\x : _1. x))
    subst : (a : Type) -> (P : (_x6 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (w : P x) -> P y 
      a : Type P : (_x7 : a) -> Type x : a
        subst a P x [x] [Refl a x] = (\w : P x. w)
    cong : (a : Type) -> (b : Type) -> (f : (_x8 : a) -> b) -> (x : a) -> (y : a) -> (eq : Id a x y) -> Id b (f x) (f y) 
      a : Type b : Type f : (_x9 : a) -> b x : a
        cong a b f x [x] [Refl a x] = Refl b (f x)
    one : (x : B) -> List = (\x : B. Cons x Nil)
    app : (_x10 : List) -> (_x11 : List) -> List 
      ys : List
        app Nil ys = ys
      x : B xs : List ys : List
        app (Cons x xs) ys = Cons x (app xs ys)
    appRightNeutral : (ys : List) -> Id List ys (app ys Nil) 
      appRightNeutral Nil = Refl List Nil
      x : B xs : List
        appRightNeutral (Cons x xs) = cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs)
    appAssoc : (xs : List) -> (ys : List) -> (zs : List) -> Id List (app (app xs ys) zs) (app xs (app ys zs)) 
      ys : List zs : List
        appAssoc Nil ys zs = Refl List (app ys zs)
      x : B xs : List ys : List zs : List
        appAssoc (Cons x xs) ys zs = cong List List (Cons x) (app (app xs ys) zs) (app xs (app ys zs)) (appAssoc xs ys zs)
    constructor Rev : (_x12 : List) -> Type
    constructor RNil : Rev Nil
    constructor RSnoc : (xs : List) -> (x : B) -> (rxs : Rev xs) -> Rev (app xs (one x))
    rev' : (xs : List) -> (rxs : Rev xs) -> (ys : List) -> Rev (app xs ys) 
      xs : List rxs : Rev xs
        rev' xs rxs Nil = subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
      xs : List rxs : Rev xs y : B ys : List
        rev' xs rxs (Cons y ys) = subst List Rev (app (app xs (one y)) ys) (app xs (Cons y ys)) (appAssoc xs (one y) ys) (rev' (app xs (one y)) (RSnoc xs y rxs) ys)
    rev : (xs : List) -> Rev xs = (\xs : List. rev' Nil RNil xs)
    reverse' : (xs : List) -> (rxs : Rev xs) -> List 
      reverse' [Nil] RNil = Nil
      xs : List x : B rxs : Rev xs
        reverse' [app xs (one x)] (RSnoc xs x rxs) = Cons x (reverse' xs rxs)
    reverse : (xs : List) -> List = (\xs : List. reverse' xs (rev xs))
    constructor V : (_x13 : List) -> Type
    constructor VNil : V Nil
    constructor VOne : (x : B) -> V (Cons x Nil)
    constructor VTwo : (x : B) -> (xs : List) -> (u : V xs) -> (y : B) -> V (Cons x (app xs (one y)))
    length : (_x14 : List) -> N 
      length Nil = Z
      x : B xs : List
        length (Cons x xs) = S (length xs)
    index : (_x15 : N) -> (_x16 : List) -> (_x17 : List) -> List 
      xs : List ys : List
        index Z xs ys = Nil
      x : B xs : List y : B ys : List
        index (S Z) (Cons x xs) (Cons y ys) = Cons x Nil
      n : N x : B xs : List y : B ys : List
        index (S (S n)) (Cons x xs) (Cons y ys) = Cons x (app (index n xs ys) (one y))
      n : N
        index (S n) Nil Nil = Nil
    build : (n : N) -> (xs : List) -> (ys : List) -> V (index n xs ys) 
      xs : List ys : List
        build Z xs ys = VNil
      x : B xs : List y : B ys : List
        build (S Z) (Cons x xs) (Cons y ys) = VOne x
      n : N x : B xs : List y : B ys : List
        build (S (S n)) (Cons x xs) (Cons y ys) = VTwo x (index n xs ys) (build n xs ys) y
      n : N
        build (S n) Nil Nil = VNil
    postulate eq : (xs : List) -> Id List (index (length xs) xs (reverse xs)) xs
    toV : (xs : List) -> V xs = (\xs : List. subst List V (index (length xs) xs (reverse xs)) xs (eq xs) (build (length xs) xs (reverse xs)))
    constructor IsPalindrome : (_x18 : List) -> Type
    constructor PNil : IsPalindrome Nil
    constructor POne : (b : B) -> IsPalindrome (Cons b Nil)
    constructor PTwo : (b : B) -> (xs : List) -> (pf : IsPalindrome xs) -> IsPalindrome (Cons b (app xs (one b)))
    decEq : (x : B) -> (y : B) -> Maybe (Id B x y) 
      decEq T T = Just (Id B T T) (Refl B T)
      decEq F F = Just (Id B F F) (Refl B F)
      decEq T F = Nothing (Id B T F)
      decEq F T = Nothing (Id B F T)
    isPalinV : (xs : List) -> (v : V xs) -> Maybe (IsPalindrome xs) 
      isPalinV [Nil] VNil = Just (IsPalindrome Nil) PNil
      x : B
        isPalinV [Cons x Nil] (VOne x) = Just (IsPalindrome (Cons x Nil)) (POne x)
      x : B xs : List y : B v : V xs
        isPalinV [Cons x (app xs (one y))] (VTwo x xs v y) = 
          let isPalinV' : (x : B) -> (y : B) -> (xs : List) -> (v : V xs) -> (pfB : Maybe (Id B x y)) -> (pfV : Maybe (IsPalindrome xs)) -> Maybe (IsPalindrome (Cons x (app xs (one y)))) 
            x : B xs : List v : V xs pfV : IsPalindrome xs
              isPalinV' x [x] xs v (Just [Id B x x] [Refl B x]) (Just [IsPalindrome xs] pfV) = Just (IsPalindrome (Cons x (app xs (one x)))) (PTwo x xs pfV)
            x : B y : B xs : List v : V xs pfB : Maybe (Id B x y) pfV : Maybe (IsPalindrome xs)
              isPalinV' x y xs v pfB pfV = Nothing (IsPalindrome (Cons x (app xs (one y))))
          in isPalinV' x y xs v (decEq x y) (isPalinV xs v)
    isPalindrome : (xs : List) -> Maybe (IsPalindrome xs) = (\xs : List. isPalinV xs (toV xs))
    genList : (_x19 : B) -> (_x20 : N) -> List 
      b : B
        genList b Z = Nil
      b : B n : N
        genList b (S n) = Cons b (genList (not b) n)
    isJust : (a : Type) -> (x : Maybe a) -> B 
      a : Type x : a
        isJust a (Just [a] x) = T
      a : Type
        isJust a (Nothing [a]) = F
    main : B = 
      let
        foreign inputSize : N
        inputList : List = genList T inputSize
      in isJust (IsPalindrome inputList) (isPalindrome inputList)
  in main

### Elaborated ###

  let
    constructor N : Type
    constructor Z : N
    constructor S : (_x0 : N) -> N
    constructor B : Type
    constructor T : B
    constructor F : B
    constructor List : Type
    constructor Cons : (_x1 : B) -> (_x2 : List) -> List
    constructor Nil : List
    constructor Maybe : (_x3 : Type) -> Type
    constructor Nothing : (a : Type) -> Maybe a
    constructor Just : (a : Type) -> (x : a) -> Maybe a
    not : (_x4 : B) -> B 
      not T = F
      not F = T
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    id : (a : Type) -> (_x5 : a) -> a = (\a : Type. (\x : a. x))
    subst : (a : Type) -> (P : (_x6 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (w : P x) -> P y 
      a : Type P : (_x7 : a) -> Type x : a
        subst a P x [x] [Refl a x] = (\w : P x. w)
    cong : (a : Type) -> (b : Type) -> (f : (_x8 : a) -> b) -> (x : a) -> (y : a) -> (eq : Id a x y) -> Id b (f x) (f y) 
      a : Type b : Type f : (_x9 : a) -> b x : a
        cong a b f x [x] [Refl a x] = Refl b (f x)
    one : (x : B) -> List = (\x : B. Cons x Nil)
    app : (_x10 : List) -> (_x11 : List) -> List 
      ys : List
        app Nil ys = ys
      x : B xs : List ys : List
        app (Cons x xs) ys = Cons x (app xs ys)
    appRightNeutral : (ys : List) -> Id List ys (app ys Nil) 
      appRightNeutral Nil = Refl List Nil
      x : B xs : List
        appRightNeutral (Cons x xs) = cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs)
    appAssoc : (xs : List) -> (ys : List) -> (zs : List) -> Id List (app (app xs ys) zs) (app xs (app ys zs)) 
      ys : List zs : List
        appAssoc Nil ys zs = Refl List (app ys zs)
      x : B xs : List ys : List zs : List
        appAssoc (Cons x xs) ys zs = cong List List (Cons x) (app (app xs ys) zs) (app xs (app ys zs)) (appAssoc xs ys zs)
    constructor Rev : (_x12 : List) -> Type
    constructor RNil : Rev Nil
    constructor RSnoc : (xs : List) -> (x : B) -> (rxs : Rev xs) -> Rev (app xs (one x))
    rev' : (xs : List) -> (rxs : Rev xs) -> (ys : List) -> Rev (app xs ys) 
      xs : List rxs : Rev xs
        rev' xs rxs Nil = subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
      xs : List rxs : Rev xs y : B ys : List
        rev' xs rxs (Cons y ys) = subst List Rev (app (app xs (one y)) ys) (app xs (Cons y ys)) (appAssoc xs (one y) ys) (rev' (app xs (one y)) (RSnoc xs y rxs) ys)
    rev : (xs : List) -> Rev xs = (\xs : List. rev' Nil RNil xs)
    reverse' : (xs : List) -> (rxs : Rev xs) -> List 
      reverse' [Nil] RNil = Nil
      xs : List x : B rxs : Rev xs
        reverse' [app xs (one x)] (RSnoc xs x rxs) = Cons x (reverse' xs rxs)
    reverse : (xs : List) -> List = (\xs : List. reverse' xs (rev xs))
    constructor V : (_x13 : List) -> Type
    constructor VNil : V Nil
    constructor VOne : (x : B) -> V (Cons x Nil)
    constructor VTwo : (x : B) -> (xs : List) -> (u : V xs) -> (y : B) -> V (Cons x (app xs (one y)))
    length : (_x14 : List) -> N 
      length Nil = Z
      x : B xs : List
        length (Cons x xs) = S (length xs)
    index : (_x15 : N) -> (_x16 : List) -> (_x17 : List) -> List 
      xs : List ys : List
        index Z xs ys = Nil
      x : B xs : List y : B ys : List
        index (S Z) (Cons x xs) (Cons y ys) = Cons x Nil
      n : N x : B xs : List y : B ys : List
        index (S (S n)) (Cons x xs) (Cons y ys) = Cons x (app (index n xs ys) (one y))
      n : N
        index (S n) Nil Nil = Nil
    build : (n : N) -> (xs : List) -> (ys : List) -> V (index n xs ys) 
      xs : List ys : List
        build Z xs ys = VNil
      x : B xs : List y : B ys : List
        build (S Z) (Cons x xs) (Cons y ys) = VOne x
      n : N x : B xs : List y : B ys : List
        build (S (S n)) (Cons x xs) (Cons y ys) = VTwo x (index n xs ys) (build n xs ys) y
      n : N
        build (S n) Nil Nil = VNil
    postulate eq : (xs : List) -> Id List (index (length xs) xs (reverse xs)) xs
    toV : (xs : List) -> V xs = (\xs : List. subst List V (index (length xs) xs (reverse xs)) xs (eq xs) (build (length xs) xs (reverse xs)))
    constructor IsPalindrome : (_x18 : List) -> Type
    constructor PNil : IsPalindrome Nil
    constructor POne : (b : B) -> IsPalindrome (Cons b Nil)
    constructor PTwo : (b : B) -> (xs : List) -> (pf : IsPalindrome xs) -> IsPalindrome (Cons b (app xs (one b)))
    decEq : (x : B) -> (y : B) -> Maybe (Id B x y) 
      decEq T T = Just (Id B T T) (Refl B T)
      decEq F F = Just (Id B F F) (Refl B F)
      decEq T F = Nothing (Id B T F)
      decEq F T = Nothing (Id B F T)
    isPalinV : (xs : List) -> (v : V xs) -> Maybe (IsPalindrome xs) 
      isPalinV [Nil] VNil = Just (IsPalindrome Nil) PNil
      x : B
        isPalinV [Cons x Nil] (VOne x) = Just (IsPalindrome (Cons x Nil)) (POne x)
      x : B xs : List y : B v : V xs
        isPalinV [Cons x (app xs (one y))] (VTwo x xs v y) = 
          let isPalinV' : (x : B) -> (y : B) -> (xs : List) -> (v : V xs) -> (pfB : Maybe (Id B x y)) -> (pfV : Maybe (IsPalindrome xs)) -> Maybe (IsPalindrome (Cons x (app xs (one y)))) 
            x : B xs : List v : V xs pfV : IsPalindrome xs
              isPalinV' x [x] xs v (Just [Id B x x] [Refl B x]) (Just [IsPalindrome xs] pfV) = Just (IsPalindrome (Cons x (app xs (one x)))) (PTwo x xs pfV)
            x : B y : B xs : List v : V xs pfB : Maybe (Id B x y) pfV : Maybe (IsPalindrome xs)
              isPalinV' x y xs v pfB pfV = Nothing (IsPalindrome (Cons x (app xs (one y))))
          in isPalinV' x y xs v (decEq x y) (isPalinV xs v)
    isPalindrome : (xs : List) -> Maybe (IsPalindrome xs) = (\xs : List. isPalinV xs (toV xs))
    genList : (_x19 : B) -> (_x20 : N) -> List 
      b : B
        genList b Z = Nil
      b : B n : N
        genList b (S n) = Cons b (genList (not b) n)
    isJust : (a : Type) -> (x : Maybe a) -> B 
      a : Type x : a
        isJust a (Just [a] x) = T
      a : Type
        isJust a (Nothing [a]) = F
    main : B = 
      let
        foreign inputSize : N
        inputList : List = genList T inputSize
      in isJust (IsPalindrome inputList) (isPalindrome inputList)
  in main

### Evarified ###

  let
    constructor N :1: Type
    constructor Z :2: N
    constructor S :3: (_x0 :4: N) -> N
    constructor B :5: Type
    constructor T :6: B
    constructor F :7: B
    constructor List :8: Type
    constructor Cons :9: (_x1 :10: B) -> (_x2 :11: List) -> List
    constructor Nil :12: List
    constructor Maybe :13: (_x3 :14: Type) -> Type
    constructor Nothing :15: (a :16: Type) -> Maybe -17- a
    constructor Just :18: (a :19: Type) -> (x :20: a) -> Maybe -21- a
    not :22: (_x4 :23: B) -> B 
      not -24- T = F
      not -25- F = T
    constructor Id :26: (a :27: Type) -> (x :28: a) -> (y :29: a) -> Type
    constructor Refl :30: (a :31: Type) -> (x :32: a) -> Id -35- a -34- x -33- x
    id :36: (a :37: Type) -> (_x5 :38: a) -> a = (\a :39: Type. (\x :40: a. x))
    subst :41: (a :42: Type) -> (P :43: (_x6 :44: a) -> Type) -> (x :45: a) -> (y :46: a) -> (eq :47: Id -50- a -49- x -48- y) -> (w :51: P -52- x) -> P -53- y 
      a :54: Type P :55: (_x7 :56: a) -> Type x :57: a
        subst -62- a -61- P -60- x -59- [x] -58- [Refl -64- a -63- x] = (\w :65: P -66- x. w)
    cong :67: (a :68: Type) -> (b :69: Type) -> (f :70: (_x8 :71: a) -> b) -> (x :72: a) -> (y :73: a) -> (eq :74: Id -77- a -76- x -75- y) -> Id -80- b -79- (f -81- x) -78- (f -82- y) 
      a :83: Type b :84: Type f :85: (_x9 :86: a) -> b x :87: a
        cong -93- a -92- b -91- f -90- x -89- [x] -88- [Refl -95- a -94- x] = Refl -97- b -96- (f -98- x)
    one :99: (x :100: B) -> List = (\x :101: B. Cons -103- x -102- Nil)
    app :104: (_x10 :105: List) -> (_x11 :106: List) -> List 
      ys :107: List
        app -109- Nil -108- ys = ys
      x :110: B xs :111: List ys :112: List
        app -114- (Cons -116- x -115- xs) -113- ys = Cons -118- x -117- (app -120- xs -119- ys)
    appRightNeutral :121: (ys :122: List) -> Id -125- List -124- ys -123- (app -127- ys -126- Nil) 
      appRightNeutral -128- Nil = Refl -130- List -129- Nil
      x :131: B xs :132: List
        appRightNeutral -133- (Cons -135- x -134- xs) = cong -141- List -140- List -139- (Cons -142- x) -138- xs -137- (app -144- xs -143- Nil) -136- (appRightNeutral -145- xs)
    appAssoc :146: (xs :147: List) -> (ys :148: List) -> (zs :149: List) -> Id -152- List -151- (app -154- (app -156- xs -155- ys) -153- zs) -150- (app -158- xs -157- (app -160- ys -159- zs)) 
      ys :161: List zs :162: List
        appAssoc -165- Nil -164- ys -163- zs = Refl -167- List -166- (app -169- ys -168- zs)
      x :170: B xs :171: List ys :172: List zs :173: List
        appAssoc -176- (Cons -178- x -177- xs) -175- ys -174- zs = cong -184- List -183- List -182- (Cons -185- x) -181- (app -187- (app -189- xs -188- ys) -186- zs) -180- (app -191- xs -190- (app -193- ys -192- zs)) -179- (appAssoc -196- xs -195- ys -194- zs)
    constructor Rev :197: (_x12 :198: List) -> Type
    constructor RNil :199: Rev -200- Nil
    constructor RSnoc :201: (xs :202: List) -> (x :203: B) -> (rxs :204: Rev -205- xs) -> Rev -206- (app -208- xs -207- (one -209- x))
    rev' :210: (xs :211: List) -> (rxs :212: Rev -213- xs) -> (ys :214: List) -> Rev -215- (app -217- xs -216- ys) 
      xs :218: List rxs :219: Rev -220- xs
        rev' -223- xs -222- rxs -221- Nil = subst -229- List -228- Rev -227- xs -226- (app -231- xs -230- Nil) -225- (appRightNeutral -232- xs) -224- rxs
      xs :233: List rxs :234: Rev -235- xs y :236: B ys :237: List
        rev' -240- xs -239- rxs -238- (Cons -242- y -241- ys) = subst -248- List -247- Rev -246- (app -250- (app -252- xs -251- (one -253- y)) -249- ys) -245- (app -255- xs -254- (Cons -257- y -256- ys)) -244- (appAssoc -260- xs -259- (one -261- y) -258- ys) -243- (rev' -264- (app -266- xs -265- (one -267- y)) -263- (RSnoc -270- xs -269- y -268- rxs) -262- ys)
    rev :271: (xs :272: List) -> Rev -273- xs = (\xs :274: List. rev' -277- Nil -276- RNil -275- xs)
    reverse' :278: (xs :279: List) -> (rxs :280: Rev -281- xs) -> List 
      reverse' -283- [Nil] -282- RNil = Nil
      xs :284: List x :285: B rxs :286: Rev -287- xs
        reverse' -289- [app -291- xs -290- (one -292- x)] -288- (RSnoc -295- xs -294- x -293- rxs) = Cons -297- x -296- (reverse' -299- xs -298- rxs)
    reverse :300: (xs :301: List) -> List = (\xs :302: List. reverse' -304- xs -303- (rev -305- xs))
    constructor V :306: (_x13 :307: List) -> Type
    constructor VNil :308: V -309- Nil
    constructor VOne :310: (x :311: B) -> V -312- (Cons -314- x -313- Nil)
    constructor VTwo :315: (x :316: B) -> (xs :317: List) -> (u :318: V -319- xs) -> (y :320: B) -> V -321- (Cons -323- x -322- (app -325- xs -324- (one -326- y)))
    length :327: (_x14 :328: List) -> N 
      length -329- Nil = Z
      x :330: B xs :331: List
        length -332- (Cons -334- x -333- xs) = S -335- (length -336- xs)
    index :337: (_x15 :338: N) -> (_x16 :339: List) -> (_x17 :340: List) -> List 
      xs :341: List ys :342: List
        index -345- Z -344- xs -343- ys = Nil
      x :346: B xs :347: List y :348: B ys :349: List
        index -352- (S -353- Z) -351- (Cons -355- x -354- xs) -350- (Cons -357- y -356- ys) = Cons -359- x -358- Nil
      n :360: N x :361: B xs :362: List y :363: B ys :364: List
        index -367- (S -368- (S -369- n)) -366- (Cons -371- x -370- xs) -365- (Cons -373- y -372- ys) = Cons -375- x -374- (app -377- (index -380- n -379- xs -378- ys) -376- (one -381- y))
      n :382: N
        index -385- (S -386- n) -384- Nil -383- Nil = Nil
    build :387: (n :388: N) -> (xs :389: List) -> (ys :390: List) -> V -391- (index -394- n -393- xs -392- ys) 
      xs :395: List ys :396: List
        build -399- Z -398- xs -397- ys = VNil
      x :400: B xs :401: List y :402: B ys :403: List
        build -406- (S -407- Z) -405- (Cons -409- x -408- xs) -404- (Cons -411- y -410- ys) = VOne -412- x
      n :413: N x :414: B xs :415: List y :416: B ys :417: List
        build -420- (S -421- (S -422- n)) -419- (Cons -424- x -423- xs) -418- (Cons -426- y -425- ys) = VTwo -430- x -429- (index -433- n -432- xs -431- ys) -428- (build -436- n -435- xs -434- ys) -427- y
      n :437: N
        build -440- (S -441- n) -439- Nil -438- Nil = VNil
    postulate eq :442: (xs :443: List) -> Id -446- List -445- (index -449- (length -450- xs) -448- xs -447- (reverse -451- xs)) -444- xs
    toV :452: (xs :453: List) -> V -454- xs = (\xs :455: List. subst -461- List -460- V -459- (index -464- (length -465- xs) -463- xs -462- (reverse -466- xs)) -458- xs -457- (eq -467- xs) -456- (build -470- (length -471- xs) -469- xs -468- (reverse -472- xs)))
    constructor IsPalindrome :473: (_x18 :474: List) -> Type
    constructor PNil :475: IsPalindrome -476- Nil
    constructor POne :477: (b :478: B) -> IsPalindrome -479- (Cons -481- b -480- Nil)
    constructor PTwo :482: (b :483: B) -> (xs :484: List) -> (pf :485: IsPalindrome -486- xs) -> IsPalindrome -487- (Cons -489- b -488- (app -491- xs -490- (one -492- b)))
    decEq :493: (x :494: B) -> (y :495: B) -> Maybe -496- (Id -499- B -498- x -497- y) 
      decEq -501- T -500- T = Just -503- (Id -506- B -505- T -504- T) -502- (Refl -508- B -507- T)
      decEq -510- F -509- F = Just -512- (Id -515- B -514- F -513- F) -511- (Refl -517- B -516- F)
      decEq -519- T -518- F = Nothing -520- (Id -523- B -522- T -521- F)
      decEq -525- F -524- T = Nothing -526- (Id -529- B -528- F -527- T)
    isPalinV :530: (xs :531: List) -> (v :532: V -533- xs) -> Maybe -534- (IsPalindrome -535- xs) 
      isPalinV -537- [Nil] -536- VNil = Just -539- (IsPalindrome -540- Nil) -538- PNil
      x :541: B
        isPalinV -543- [Cons -545- x -544- Nil] -542- (VOne -546- x) = Just -548- (IsPalindrome -549- (Cons -551- x -550- Nil)) -547- (POne -552- x)
      x :553: B xs :554: List y :555: B v :556: V -557- xs
        isPalinV -559- [Cons -561- x -560- (app -563- xs -562- (one -564- y))] -558- (VTwo -568- x -567- xs -566- v -565- y) = 
          let isPalinV' :569: (x :570: B) -> (y :571: B) -> (xs :572: List) -> (v :573: V -574- xs) -> (pfB :575: Maybe -576- (Id -579- B -578- x -577- y)) -> (pfV :580: Maybe -581- (IsPalindrome -582- xs)) -> Maybe -583- (IsPalindrome -584- (Cons -586- x -585- (app -588- xs -587- (one -589- y)))) 
            x :590: B xs :591: List v :592: V -593- xs pfV :594: IsPalindrome -595- xs
              isPalinV' -601- x -600- [x] -599- xs -598- v -597- (Just -603- [Id -606- B -605- x -604- x] -602- [Refl -608- B -607- x]) -596- (Just -610- [IsPalindrome -611- xs] -609- pfV) = Just -613- (IsPalindrome -614- (Cons -616- x -615- (app -618- xs -617- (one -619- x)))) -612- (PTwo -622- x -621- xs -620- pfV)
            x :623: B y :624: B xs :625: List v :626: V -627- xs pfB :628: Maybe -629- (Id -632- B -631- x -630- y) pfV :633: Maybe -634- (IsPalindrome -635- xs)
              isPalinV' -641- x -640- y -639- xs -638- v -637- pfB -636- pfV = Nothing -642- (IsPalindrome -643- (Cons -645- x -644- (app -647- xs -646- (one -648- y))))
          in isPalinV' -654- x -653- y -652- xs -651- v -650- (decEq -656- x -655- y) -649- (isPalinV -658- xs -657- v)
    isPalindrome :659: (xs :660: List) -> Maybe -661- (IsPalindrome -662- xs) = (\xs :663: List. isPalinV -665- xs -664- (toV -666- xs))
    genList :667: (_x19 :668: B) -> (_x20 :669: N) -> List 
      b :670: B
        genList -672- b -671- Z = Nil
      b :673: B n :674: N
        genList -676- b -675- (S -677- n) = Cons -679- b -678- (genList -681- (not -682- b) -680- n)
    isJust :683: (a :684: Type) -> (x :685: Maybe -686- a) -> B 
      a :687: Type x :688: a
        isJust -690- a -689- (Just -692- [a] -691- x) = T
      a :693: Type
        isJust -695- a -694- (Nothing -696- [a]) = F
    main :697: B = 
      let
        foreign inputSize :698: N
        inputList :699: List = genList -701- T -700- inputSize
      in isJust -703- (IsPalindrome -704- inputList) -702- (isPalindrome -705- inputList)
  in main

### Constraints ###

[] -> [697]
[4] -> [335,353,368,369,386,407,421,422,441,677]
[10] -> [103,116,118,135,142,178,185,242,257,297,314,323,334,355,357,359,371,373,375,409,411,424,426,481,489,545,551,561,586,616,645,679]
[11] -> [71,102,115,117,134,177,241,256,296,313,322,333,354,356,358,370,372,374,408,410,423,425,480,488,544,550,560,585,615,644,678]
[14] -> [17,21,496,534,576,581,583,629,634,661,686]
[16] -> [520,526,642,696]
[17] -> [14,496,583,686]
[19] -> [503,512,539,548,603,610,613,692]
[20] -> [502,511,538,547,602,609,612,691]
[21] -> [14,496,534,576,581,583,686]
[22] -> [6,7,24,25]
[23] -> [24,25,682]
[24] -> [23]
[25] -> [23]
[27] -> [35,50,77,80,125,152,446,499,506,515,523,529,579,606,632]
[28] -> [34,49,76,79,124,151,445,498,505,514,522,528,578,605,631]
[29] -> [33,48,75,78,123,150,444,497,504,513,521,527,577,604,630]
[31] -> [64,95,97,130,167,508,517,608]
[32] -> [63,94,96,129,166,507,516,607]
[33] -> [29,48,75,78,123,150,504,513,604]
[34] -> [28]
[35] -> [27]
[36] -> [40]
[37] -> [39]
[38] -> [40]
[39] -> [37]
[40] -> [38]
[41] -> [65]
[41,58] -> [30]
[41,58,63] -> [57]
[41,58,64] -> [54]
[41,59] -> [57]
[41,60] -> [57]
[41,61] -> [55]
[41,62] -> [54]
[42] -> [62,229,248,461]
[43] -> [61,228,247,460]
[44] -> [52,53,56,198,307]
[45] -> [60,227,246,459]
[46] -> [59,226,245,458]
[47] -> [58,225,244,457]
[48] -> [29,33,123,150,444]
[49] -> [28]
[50] -> [27]
[51] -> [65,224,243,456]
[52] -> [44,66,215,220,391]
[53] -> [44,66,215,454]
[54] -> [41,62]
[55] -> [41,61]
[56] -> [44,66]
[57] -> [41,60]
[58] -> [47]
[59] -> [46]
[60] -> [45]
[61] -> [43]
[62] -> [42]
[63] -> [32]
[64] -> [31]
[65] -> [51]
[66] -> [52,53,56]
[67] -> [30]
[67,88] -> [30]
[67,88,94] -> [87]
[67,88,95] -> [83]
[67,89] -> [87]
[67,90] -> [87]
[67,91] -> [85]
[67,92] -> [84]
[67,93] -> [83]
[67,96] -> [85]
[67,96,98] -> [87]
[67,97] -> [84]
[68] -> [93,141,184]
[69] -> [92,140,183]
[70] -> [91,139,182]
[71] -> [11,81,82,86]
[72] -> [90,138,181]
[73] -> [89,137,180]
[74] -> [88,136,179]
[75] -> [29,33,123,150]
[76] -> [28]
[77] -> [27]
[78] -> [29,33,123,150]
[79] -> [28]
[80] -> [27]
[81] -> [71]
[82] -> [71]
[83] -> [67,93]
[84] -> [67,92]
[85] -> [67,91]
[86] -> [71,98]
[87] -> [67,90]
[88] -> [74]
[89] -> [73]
[90] -> [72]
[91] -> [70]
[92] -> [69]
[93] -> [68]
[94] -> [32]
[95] -> [31]
[96] -> [32]
[97] -> [31]
[98] -> [86]
[99] -> [9]
[99,102] -> [12]
[99,103] -> [101]
[100] -> [101,209,253,261,267,292,326,381,492,564,589,619,648]
[101] -> [100]
[102] -> [11]
[103] -> [10]
[104] -> [9,12,107,109,114]
[104,108] -> [107]
[104,113] -> [112]
[104,114,115] -> [111]
[104,114,116] -> [110]
[104,117,119] -> [112]
[104,117,120] -> [111]
[104,118] -> [110]
[105] -> [109,114,120,127,144,154,156,158,160,169,187,189,191,193,208,217,231,250,252,255,266,291,325,377,491,563,588,618,647]
[106] -> [108,113,119,126,143,153,155,157,159,168,186,188,190,192,207,216,230,249,251,254,265,290,324,376,490,562,587,617,646]
[107] -> [104,108]
[108] -> [106]
[109] -> [105]
[110] -> [104,114,116]
[111] -> [104,114,115]
[112] -> [104,113]
[113] -> [106]
[114] -> [105]
[115] -> [11]
[116] -> [10]
[117] -> [11]
[118] -> [10]
[119] -> [106]
[120] -> [105]
[121] -> [9,12,30,67,128,133]
[121,129] -> [12]
[121,130] -> [8]
[121,133,134] -> [132]
[121,133,135] -> [131]
[121,136,145] -> [132]
[121,137] -> [104]
[121,137,143] -> [12]
[121,137,144] -> [132]
[121,138] -> [132]
[121,139] -> [9]
[121,139,142] -> [131]
[121,140] -> [8]
[121,141] -> [8]
[122] -> [128,133,145,232]
[123] -> [29,33,48,75,78]
[124] -> [28]
[125] -> [27]
[126] -> [106]
[127] -> [105]
[128] -> [122]
[129] -> [32]
[130] -> [31]
[131] -> [121,133,135]
[132] -> [121,133,134]
[133] -> [122]
[134] -> [11]
[135] -> [10]
[136] -> [74]
[137] -> [73]
[138] -> [72]
[139] -> [70]
[140] -> [69]
[141] -> [68]
[142] -> [10]
[143] -> [106]
[144] -> [105]
[145] -> [122]
[146] -> [9,12,30,67,165,176]
[146,163] -> [162]
[146,164] -> [161]
[146,166] -> [104]
[146,166,168] -> [162]
[146,166,169] -> [161]
[146,167] -> [8]
[146,174] -> [173]
[146,175] -> [172]
[146,176,177] -> [171]
[146,176,178] -> [170]
[146,179,194] -> [173]
[146,179,195] -> [172]
[146,179,196] -> [171]
[146,180] -> [104]
[146,180,190] -> [104]
[146,180,190,192] -> [173]
[146,180,190,193] -> [172]
[146,180,191] -> [171]
[146,181] -> [104]
[146,181,186] -> [173]
[146,181,187] -> [104]
[146,181,187,188] -> [172]
[146,181,187,189] -> [171]
[146,182] -> [9]
[146,182,185] -> [170]
[146,183] -> [8]
[146,184] -> [8]
[147] -> [165,176,196,260]
[148] -> [164,175,195,259]
[149] -> [163,174,194,258]
[150] -> [29,33,48,75,78]
[151] -> [28]
[152] -> [27]
[153] -> [106]
[154] -> [105]
[155] -> [106]
[156] -> [105]
[157] -> [106]
[158] -> [105]
[159] -> [106]
[160] -> [105]
[161] -> [146,164]
[162] -> [146,163]
[163] -> [149]
[164] -> [148]
[165] -> [147]
[166] -> [32]
[167] -> [31]
[168] -> [106]
[169] -> [105]
[170] -> [146,176,178]
[171] -> [146,176,177]
[172] -> [146,175]
[173] -> [146,174]
[174] -> [149]
[175] -> [148]
[176] -> [147]
[177] -> [11]
[178] -> [10]
[179] -> [74]
[180] -> [73]
[181] -> [72]
[182] -> [70]
[183] -> [69]
[184] -> [68]
[185] -> [10]
[186] -> [106]
[187] -> [105]
[188] -> [106]
[189] -> [105]
[190] -> [106]
[191] -> [105]
[192] -> [106]
[193] -> [105]
[194] -> [149]
[195] -> [148]
[196] -> [147]
[198] -> [44,200,205,206,213,215,220,235,273,281,287]
[200] -> [198,213,281]
[202] -> [270,295]
[203] -> [269,294]
[204] -> [268,293]
[205] -> [198,235,287]
[206] -> [198,213,281]
[207] -> [106]
[208] -> [105]
[209] -> [100]
[210] -> [9,12,41,221,238]
[210,222] -> [219]
[210,223] -> [218]
[210,224] -> [219]
[210,225] -> [121]
[210,225,232] -> [218]
[210,226] -> [104]
[210,226,230] -> [12]
[210,226,231] -> [218]
[210,227] -> [218]
[210,228] -> [197]
[210,229] -> [8]
[210,238,241] -> [237]
[210,238,242] -> [236]
[210,239] -> [234]
[210,240] -> [233]
[210,243,262] -> [237]
[210,243,263] -> [201]
[210,243,263,268] -> [234]
[210,243,263,269] -> [236]
[210,243,263,270] -> [233]
[210,243,264] -> [104]
[210,243,264,265] -> [99]
[210,243,264,265,267] -> [236]
[210,243,264,266] -> [233]
[210,244] -> [146]
[210,244,258] -> [237]
[210,244,259] -> [99]
[210,244,259,261] -> [236]
[210,244,260] -> [233]
[210,245] -> [104]
[210,245,254] -> [9]
[210,245,254,256] -> [237]
[210,245,254,257] -> [236]
[210,245,255] -> [233]
[210,246] -> [104]
[210,246,249] -> [237]
[210,246,250] -> [104]
[210,246,250,251] -> [99]
[210,246,250,251,253] -> [236]
[210,246,250,252] -> [233]
[210,247] -> [197]
[210,248] -> [8]
[211] -> [223,240,264,277]
[212] -> [222,239,263,276]
[213] -> [198,200,206,220,235]
[214] -> [221,238,262,275]
[215] -> [52,53,198,273]
[216] -> [106]
[217] -> [105]
[218] -> [210,223]
[219] -> [210,222]
[220] -> [52,198,213]
[221] -> [214]
[222] -> [212]
[223] -> [211]
[224] -> [51]
[225] -> [47]
[226] -> [46]
[227] -> [45]
[228] -> [43]
[229] -> [42]
[230] -> [106]
[231] -> [105]
[232] -> [122]
[233] -> [210,240]
[234] -> [210,239]
[235] -> [198,205,213]
[236] -> [210,238,242]
[237] -> [210,238,241]
[238] -> [214]
[239] -> [212]
[240] -> [211]
[241] -> [11]
[242] -> [10]
[243] -> [51]
[244] -> [47]
[245] -> [46]
[246] -> [45]
[247] -> [43]
[248] -> [42]
[249] -> [106]
[250] -> [105]
[251] -> [106]
[252] -> [105]
[253] -> [100]
[254] -> [106]
[255] -> [105]
[256] -> [11]
[257] -> [10]
[258] -> [149]
[259] -> [148]
[260] -> [147]
[261] -> [100]
[262] -> [214]
[263] -> [212]
[264] -> [211]
[265] -> [106]
[266] -> [105]
[267] -> [100]
[268] -> [204]
[269] -> [203]
[270] -> [202]
[271] -> [210]
[271,275] -> [274]
[271,276] -> [199]
[271,277] -> [12]
[272] -> [274,305]
[273] -> [198,215,281]
[274] -> [272]
[275] -> [214]
[276] -> [212]
[277] -> [211]
[278] -> [9,12,199,201,282,288]
[278,283] -> [12]
[278,288,293] -> [286]
[278,288,294] -> [285]
[278,288,295] -> [284]
[278,289] -> [104]
[278,289,290] -> [99]
[278,289,290,292] -> [285]
[278,289,291] -> [284]
[278,296,298] -> [286]
[278,296,299] -> [284]
[278,297] -> [285]
[279] -> [283,289,299,304]
[280] -> [282,288,298,303]
[281] -> [198,200,206,273,287]
[282] -> [280]
[283] -> [279]
[284] -> [278,288,295]
[285] -> [278,288,294]
[286] -> [278,288,293]
[287] -> [198,205,281]
[288] -> [280]
[289] -> [279]
[290] -> [106]
[291] -> [105]
[292] -> [100]
[293] -> [204]
[294] -> [203]
[295] -> [202]
[296] -> [11]
[297] -> [10]
[298] -> [280]
[299] -> [279]
[300] -> [278]
[300,303] -> [271]
[300,303,305] -> [302]
[300,304] -> [302]
[301] -> [302,451,466,472]
[302] -> [301]
[303] -> [280]
[304] -> [279]
[305] -> [272]
[307] -> [44,309,312,319,321,391,454,533,557,574,593,627]
[309] -> [307,391,533]
[311] -> [412,546]
[312] -> [307,391,533]
[313] -> [11]
[314] -> [10]
[316] -> [430,568]
[317] -> [429,567]
[318] -> [428,566]
[319] -> [307,391,557]
[320] -> [427,565]
[321] -> [307,391,533]
[322] -> [11]
[323] -> [10]
[324] -> [106]
[325] -> [105]
[326] -> [100]
[327] -> [2,3,9,12,329,332]
[327,332,333] -> [331]
[327,332,334] -> [330]
[327,335,336] -> [331]
[328] -> [329,332,336,450,465,471]
[329] -> [328]
[330] -> [327,332,334]
[331] -> [327,332,333]
[332] -> [328]
[333] -> [11]
[334] -> [10]
[335] -> [4]
[336] -> [328]
[337] -> [2,3,9,12,345,350,351,352,353,365,366,367,368,383,384,385]
[337,343] -> [342]
[337,344] -> [341]
[337,350,356] -> [349]
[337,350,357] -> [348]
[337,351,354] -> [347]
[337,351,355] -> [346]
[337,358] -> [12]
[337,359] -> [346]
[337,365,372] -> [364]
[337,365,373] -> [363]
[337,366,370] -> [362]
[337,366,371] -> [361]
[337,367,368,369] -> [360]
[337,374] -> [104]
[337,374,376] -> [99]
[337,374,376,381] -> [363]
[337,374,377,378] -> [364]
[337,374,377,379] -> [362]
[337,374,377,380] -> [360]
[337,375] -> [361]
[337,385,386] -> [382]
[338] -> [345,352,367,380,385,394,433,449,464]
[339] -> [344,351,366,379,384,393,432,448,463]
[340] -> [343,350,365,378,383,392,431,447,462]
[341] -> [337,344]
[342] -> [337,343]
[343] -> [340]
[344] -> [339]
[345] -> [338]
[346] -> [337,351,355]
[347] -> [337,351,354]
[348] -> [337,350,357]
[349] -> [337,350,356]
[350] -> [340]
[351] -> [339]
[352] -> [338]
[353] -> [4]
[354] -> [11]
[355] -> [10]
[356] -> [11]
[357] -> [10]
[358] -> [11]
[359] -> [10]
[360] -> [337,367,368,369]
[361] -> [337,366,371]
[362] -> [337,366,370]
[363] -> [337,365,373]
[364] -> [337,365,372]
[365] -> [340]
[366] -> [339]
[367] -> [338]
[368] -> [4]
[369] -> [4]
[370] -> [11]
[371] -> [10]
[372] -> [11]
[373] -> [10]
[374] -> [11]
[375] -> [10]
[376] -> [106]
[377] -> [105]
[378] -> [340]
[379] -> [339]
[380] -> [338]
[381] -> [100]
[382] -> [337,385,386]
[383] -> [340]
[384] -> [339]
[385] -> [338]
[386] -> [4]
[387] -> [2,3,9,12,308,310,315,399,404,405,406,407,418,419,420,421,438,439,440]
[387,397] -> [396]
[387,398] -> [395]
[387,404,410] -> [403]
[387,404,411] -> [402]
[387,405,408] -> [401]
[387,405,409] -> [400]
[387,412] -> [400]
[387,418,425] -> [417]
[387,418,426] -> [416]
[387,419,423] -> [415]
[387,419,424] -> [414]
[387,420,421,422] -> [413]
[387,427] -> [416]
[387,428,434] -> [417]
[387,428,435] -> [415]
[387,428,436] -> [413]
[387,429] -> [337]
[387,429,431] -> [417]
[387,429,432] -> [415]
[387,429,433] -> [413]
[387,430] -> [414]
[387,440,441] -> [437]
[388] -> [399,406,420,436,440,470]
[389] -> [398,405,419,435,439,469]
[390] -> [397,404,418,434,438,468]
[391] -> [52,307,309,312,319,321]
[392] -> [340]
[393] -> [339]
[394] -> [338]
[395] -> [387,398]
[396] -> [387,397]
[397] -> [390]
[398] -> [389]
[399] -> [388]
[400] -> [387,405,409]
[401] -> [387,405,408]
[402] -> [387,404,411]
[403] -> [387,404,410]
[404] -> [390]
[405] -> [389]
[406] -> [388]
[407] -> [4]
[408] -> [11]
[409] -> [10]
[410] -> [11]
[411] -> [10]
[412] -> [311]
[413] -> [387,420,421,422]
[414] -> [387,419,424]
[415] -> [387,419,423]
[416] -> [387,418,426]
[417] -> [387,418,425]
[418] -> [390]
[419] -> [389]
[420] -> [388]
[421] -> [4]
[422] -> [4]
[423] -> [11]
[424] -> [10]
[425] -> [11]
[426] -> [10]
[427] -> [320]
[428] -> [318]
[429] -> [317]
[430] -> [316]
[431] -> [340]
[432] -> [339]
[433] -> [338]
[434] -> [390]
[435] -> [389]
[436] -> [388]
[437] -> [387,440,441]
[438] -> [390]
[439] -> [389]
[440] -> [388]
[441] -> [4]
[443] -> [467]
[444] -> [29,48]
[445] -> [28]
[446] -> [27]
[447] -> [340]
[448] -> [339]
[449] -> [338]
[450] -> [328]
[451] -> [301]
[452] -> [41]
[452,456] -> [387]
[452,456,468] -> [300]
[452,456,468,472] -> [455]
[452,456,469] -> [455]
[452,456,470] -> [327]
[452,456,470,471] -> [455]
[452,457] -> [442]
[452,457,467] -> [455]
[452,458] -> [455]
[452,459] -> [337]
[452,459,462] -> [300]
[452,459,462,466] -> [455]
[452,459,463] -> [455]
[452,459,464] -> [327]
[452,459,464,465] -> [455]
[452,460] -> [306]
[452,461] -> [8]
[453] -> [455,666]
[454] -> [53,307,533]
[455] -> [453]
[456] -> [51]
[457] -> [47]
[458] -> [46]
[459] -> [45]
[460] -> [43]
[461] -> [42]
[462] -> [340]
[463] -> [339]
[464] -> [338]
[465] -> [328]
[466] -> [301]
[467] -> [443]
[468] -> [390]
[469] -> [389]
[470] -> [388]
[471] -> [328]
[472] -> [301]
[474] -> [476,479,486,487,535,540,549,582,584,595,611,614,635,643,662,704]
[476] -> [474,540]
[478] -> [552]
[479] -> [474,549]
[480] -> [11]
[481] -> [10]
[483] -> [622]
[484] -> [621]
[485] -> [620]
[486] -> [474,595]
[487] -> [474,614]
[488] -> [11]
[489] -> [10]
[490] -> [106]
[491] -> [105]
[492] -> [100]
[493] -> [6,7,15,18,500,501,509,510,518,519,524,525]
[493,502] -> [30]
[493,502,507] -> [6]
[493,502,508] -> [5]
[493,503] -> [26]
[493,503,504] -> [6]
[493,503,505] -> [6]
[493,503,506] -> [5]
[493,511] -> [30]
[493,511,516] -> [7]
[493,511,517] -> [5]
[493,512] -> [26]
[493,512,513] -> [7]
[493,512,514] -> [7]
[493,512,515] -> [5]
[493,520] -> [26]
[493,520,521] -> [7]
[493,520,522] -> [6]
[493,520,523] -> [5]
[493,526] -> [26]
[493,526,527] -> [6]
[493,526,528] -> [7]
[493,526,529] -> [5]
[494] -> [501,510,519,525,656]
[495] -> [500,509,518,524,655]
[496] -> [14,17,21,576]
[497] -> [29]
[498] -> [28]
[499] -> [27]
[500] -> [495]
[501] -> [494]
[502] -> [20]
[503] -> [19]
[504] -> [29,33]
[505] -> [28]
[506] -> [27]
[507] -> [32]
[508] -> [31]
[509] -> [495]
[510] -> [494]
[511] -> [20]
[512] -> [19]
[513] -> [29,33]
[514] -> [28]
[515] -> [27]
[516] -> [32]
[517] -> [31]
[518] -> [495]
[519] -> [494]
[520] -> [16]
[521] -> [29]
[522] -> [28]
[523] -> [27]
[524] -> [495]
[525] -> [494]
[526] -> [16]
[527] -> [29]
[528] -> [28]
[529] -> [27]
[530] -> [18,308,310,315,536,542,558,569]
[530,537] -> [12]
[530,538] -> [475]
[530,539] -> [473]
[530,539,540] -> [12]
[530,542,546] -> [541]
[530,543] -> [9]
[530,543,544] -> [12]
[530,543,545] -> [541]
[530,547] -> [477]
[530,547,552] -> [541]
[530,548] -> [473]
[530,548,549] -> [9]
[530,548,549,550] -> [12]
[530,548,549,551] -> [541]
[530,558,565] -> [555]
[530,558,566] -> [556]
[530,558,567] -> [554]
[530,558,568] -> [553]
[530,559] -> [9]
[530,559,560] -> [104]
[530,559,560,562] -> [99]
[530,559,560,562,564] -> [555]
[530,559,560,563] -> [554]
[530,559,561] -> [553]
[530,649,657] -> [556]
[530,649,658] -> [554]
[530,650] -> [493]
[530,650,655] -> [555]
[530,650,656] -> [553]
[530,651] -> [556]
[530,652] -> [554]
[530,653] -> [555]
[530,654] -> [553]
[531] -> [537,543,559,658,665]
[532] -> [536,542,558,657,664]
[533] -> [307,309,312,321,454,557]
[534] -> [14,21,581,583,661]
[535] -> [474]
[536] -> [532]
[537] -> [531]
[538] -> [20]
[539] -> [19]
[540] -> [474,476]
[541] -> [530,542,546]
[542] -> [532]
[543] -> [531]
[544] -> [11]
[545] -> [10]
[546] -> [311]
[547] -> [20]
[548] -> [19]
[549] -> [474,479]
[550] -> [11]
[551] -> [10]
[552] -> [478]
[553] -> [530,558,568]
[554] -> [530,558,567]
[555] -> [530,558,565]
[556] -> [530,558,566]
[557] -> [307,319,533,574]
[558] -> [532]
[559] -> [531]
[560] -> [11]
[561] -> [10]
[562] -> [106]
[563] -> [105]
[564] -> [100]
[565] -> [320]
[566] -> [318]
[567] -> [317]
[568] -> [316]
[569] -> [15,18,596,597]
[569,596,609] -> [594]
[569,596,610] -> [473]
[569,596,610,611] -> [591]
[569,597,602] -> [30]
[569,597,602,607] -> [590]
[569,597,602,608] -> [5]
[569,597,603] -> [26]
[569,597,603,604] -> [590]
[569,597,603,605] -> [590]
[569,597,603,606] -> [5]
[569,598] -> [592]
[569,599] -> [591]
[569,600] -> [590]
[569,601] -> [590]
[569,612] -> [482]
[569,612,620] -> [594]
[569,612,621] -> [591]
[569,612,622] -> [590]
[569,613] -> [473]
[569,613,614] -> [9]
[569,613,614,615] -> [104]
[569,613,614,615,617] -> [99]
[569,613,614,615,617,619] -> [590]
[569,613,614,615,618] -> [591]
[569,613,614,616] -> [590]
[569,636] -> [633]
[569,637] -> [628]
[569,638] -> [626]
[569,639] -> [625]
[569,640] -> [624]
[569,641] -> [623]
[569,642] -> [473]
[569,642,643] -> [9]
[569,642,643,644] -> [104]
[569,642,643,644,646] -> [99]
[569,642,643,644,646,648] -> [624]
[569,642,643,644,647] -> [625]
[569,642,643,645] -> [623]
[570] -> [601,641,654]
[571] -> [600,640,653]
[572] -> [599,639,652]
[573] -> [598,638,651]
[574] -> [307,557,593,627]
[575] -> [597,637,650]
[576] -> [14,21,496,629]
[577] -> [29]
[578] -> [28]
[579] -> [27]
[580] -> [596,636,649]
[581] -> [14,21,534,634]
[582] -> [474]
[583] -> [14,17,21,534]
[584] -> [474]
[585] -> [11]
[586] -> [10]
[587] -> [106]
[588] -> [105]
[589] -> [100]
[590] -> [569,601]
[591] -> [569,599]
[592] -> [569,598]
[593] -> [307,574]
[594] -> [569,596,609]
[595] -> [474,486,611]
[596] -> [580]
[597] -> [575]
[598] -> [573]
[599] -> [572]
[600] -> [571]
[601] -> [570]
[602] -> [20]
[603] -> [19]
[604] -> [29,33]
[605] -> [28]
[606] -> [27]
[607] -> [32]
[608] -> [31]
[609] -> [20]
[610] -> [19]
[611] -> [474,595]
[612] -> [20]
[613] -> [19]
[614] -> [474,487]
[615] -> [11]
[616] -> [10]
[617] -> [106]
[618] -> [105]
[619] -> [100]
[620] -> [485]
[621] -> [484]
[622] -> [483]
[623] -> [569,641]
[624] -> [569,640]
[625] -> [569,639]
[626] -> [569,638]
[627] -> [307,574]
[628] -> [569,637]
[629] -> [14,576]
[630] -> [29]
[631] -> [28]
[632] -> [27]
[633] -> [569,636]
[634] -> [14,581]
[635] -> [474]
[636] -> [580]
[637] -> [575]
[638] -> [573]
[639] -> [572]
[640] -> [571]
[641] -> [570]
[642] -> [16]
[643] -> [474]
[644] -> [11]
[645] -> [10]
[646] -> [106]
[647] -> [105]
[648] -> [100]
[649] -> [580]
[650] -> [575]
[651] -> [573]
[652] -> [572]
[653] -> [571]
[654] -> [570]
[655] -> [495]
[656] -> [494]
[657] -> [532]
[658] -> [531]
[659] -> [530]
[659,664] -> [452]
[659,664,666] -> [663]
[659,665] -> [663]
[660] -> [663,705]
[661] -> [14,534,686]
[662] -> [474]
[663] -> [660]
[664] -> [532]
[665] -> [531]
[666] -> [453]
[667] -> [2,3,9,12,671,675]
[667,672] -> [670]
[667,675,677] -> [674]
[667,676] -> [673]
[667,678,680] -> [674]
[667,678,681] -> [22]
[667,678,681,682] -> [673]
[667,679] -> [673]
[668] -> [672,676,681,701]
[669] -> [671,675,680,700]
[670] -> [667,672]
[671] -> [669]
[672] -> [668]
[673] -> [667,676]
[674] -> [667,675,677]
[675] -> [669]
[676] -> [668]
[677] -> [4]
[678] -> [11]
[679] -> [10]
[680] -> [669]
[681] -> [668]
[682] -> [23]
[683] -> [6,7,15,18,689,694]
[683,689,691] -> [688]
[683,689,692] -> [687]
[683,690] -> [687]
[683,694,696] -> [693]
[683,695] -> [693]
[684] -> [690,695,703]
[685] -> [689,694,702]
[686] -> [14,17,21,661]
[687] -> [683,690]
[688] -> [683,689,691]
[689] -> [685]
[690] -> [684]
[691] -> [20]
[692] -> [19]
[693] -> [683,695]
[694] -> [685]
[695] -> [684]
[696] -> [16]
[697] -> [683]
[697,702] -> [659]
[697,702,705] -> [699]
[697,703] -> [473]
[697,703,704] -> [699]
[699] -> [667]
[699,700] -> [698]
[699,701] -> [6]
[700] -> [669]
[701] -> [668]
[702] -> [685]
[703] -> [684]
[704] -> [474]
[705] -> [660]

### Solution ###

[2,3,4,6,7,9,10,11,12,15,18,22,23,24,25,41,51,65,71,81,82,86,98,102,103,115,116,117,118,134,135,142,177,178,185,199,201,203,204,210,212,214,219,221,222,224,234,236,237,238,239,241,242,243,256,257,262,263,268,269,271,272,274,275,276,278,280,282,285,286,288,293,294,296,297,298,300,301,302,303,305,308,310,313,314,315,316,318,320,322,323,327,328,329,330,331,332,333,334,335,336,353,354,355,356,357,358,359,368,369,370,371,372,373,374,375,386,387,388,389,390,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,430,434,435,436,437,438,439,440,441,450,451,452,453,455,456,465,466,468,469,470,471,472,480,481,488,489,493,494,495,500,501,509,510,518,519,524,525,530,532,536,542,544,545,550,551,553,555,556,558,560,561,565,566,568,569,575,580,585,586,596,597,615,616,628,633,636,637,644,645,649,650,655,656,657,659,660,663,664,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,685,689,694,697,698,699,700,701,702,705,R]

### Annotated ###

  let
    constructor N :E: Type
    constructor Z :R: N
    constructor S :R: (_x0 :R: N) -> N
    constructor B :E: Type
    constructor T :R: B
    constructor F :R: B
    constructor List :E: Type
    constructor Cons :R: (_x1 :R: B) -> (_x2 :R: List) -> List
    constructor Nil :R: List
    constructor Maybe :E: (_x3 :E: Type) -> Type
    constructor Nothing :R: (a :E: Type) -> Maybe -E- a
    constructor Just :R: (a :E: Type) -> (x :E: a) -> Maybe -E- a
    not :R: (_x4 :R: B) -> B 
      not -R- T = F
      not -R- F = T
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    id :E: (a :E: Type) -> (_x5 :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    subst :R: (a :E: Type) -> (P :E: (_x6 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (w :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x7 :E: a) -> Type x :E: a
        subst -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\w :R: P -E- x. w)
    cong :E: (a :E: Type) -> (b :E: Type) -> (f :E: (_x8 :R: a) -> b) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> Id -E- b -E- (f -R- x) -E- (f -R- y) 
      a :E: Type b :E: Type f :E: (_x9 :R: a) -> b x :E: a
        cong -E- a -E- b -E- f -E- x -E- [x] -E- [Refl -E- a -E- x] = Refl -E- b -E- (f -R- x)
    one :E: (x :E: B) -> List = (\x :E: B. Cons -R- x -R- Nil)
    app :E: (_x10 :E: List) -> (_x11 :E: List) -> List 
      ys :E: List
        app -E- Nil -E- ys = ys
      x :E: B xs :E: List ys :E: List
        app -E- (Cons -R- x -R- xs) -E- ys = Cons -R- x -R- (app -E- xs -E- ys)
    appRightNeutral :E: (ys :E: List) -> Id -E- List -E- ys -E- (app -E- ys -E- Nil) 
      appRightNeutral -E- Nil = Refl -E- List -E- Nil
      x :E: B xs :E: List
        appRightNeutral -E- (Cons -R- x -R- xs) = cong -E- List -E- List -E- (Cons -R- x) -E- xs -E- (app -E- xs -E- Nil) -E- (appRightNeutral -E- xs)
    appAssoc :E: (xs :E: List) -> (ys :E: List) -> (zs :E: List) -> Id -E- List -E- (app -E- (app -E- xs -E- ys) -E- zs) -E- (app -E- xs -E- (app -E- ys -E- zs)) 
      ys :E: List zs :E: List
        appAssoc -E- Nil -E- ys -E- zs = Refl -E- List -E- (app -E- ys -E- zs)
      x :E: B xs :E: List ys :E: List zs :E: List
        appAssoc -E- (Cons -R- x -R- xs) -E- ys -E- zs = cong -E- List -E- List -E- (Cons -R- x) -E- (app -E- (app -E- xs -E- ys) -E- zs) -E- (app -E- xs -E- (app -E- ys -E- zs)) -E- (appAssoc -E- xs -E- ys -E- zs)
    constructor Rev :E: (_x12 :E: List) -> Type
    constructor RNil :R: Rev -E- Nil
    constructor RSnoc :R: (xs :E: List) -> (x :R: B) -> (rxs :R: Rev -E- xs) -> Rev -E- (app -E- xs -E- (one -E- x))
    rev' :R: (xs :E: List) -> (rxs :R: Rev -E- xs) -> (ys :R: List) -> Rev -E- (app -E- xs -E- ys) 
      xs :E: List rxs :R: Rev -E- xs
        rev' -E- xs -R- rxs -R- Nil = subst -E- List -E- Rev -E- xs -E- (app -E- xs -E- Nil) -E- (appRightNeutral -E- xs) -R- rxs
      xs :E: List rxs :R: Rev -E- xs y :R: B ys :R: List
        rev' -E- xs -R- rxs -R- (Cons -R- y -R- ys) = subst -E- List -E- Rev -E- (app -E- (app -E- xs -E- (one -E- y)) -E- ys) -E- (app -E- xs -E- (Cons -R- y -R- ys)) -E- (appAssoc -E- xs -E- (one -E- y) -E- ys) -R- (rev' -E- (app -E- xs -E- (one -E- y)) -R- (RSnoc -E- xs -R- y -R- rxs) -R- ys)
    rev :R: (xs :R: List) -> Rev -E- xs = (\xs :R: List. rev' -E- Nil -R- RNil -R- xs)
    reverse' :R: (xs :E: List) -> (rxs :R: Rev -E- xs) -> List 
      reverse' -E- [Nil] -R- RNil = Nil
      xs :E: List x :R: B rxs :R: Rev -E- xs
        reverse' -E- [app -E- xs -E- (one -E- x)] -R- (RSnoc -E- xs -R- x -R- rxs) = Cons -R- x -R- (reverse' -E- xs -R- rxs)
    reverse :R: (xs :R: List) -> List = (\xs :R: List. reverse' -E- xs -R- (rev -R- xs))
    constructor V :E: (_x13 :E: List) -> Type
    constructor VNil :R: V -E- Nil
    constructor VOne :R: (x :E: B) -> V -E- (Cons -R- x -R- Nil)
    constructor VTwo :R: (x :R: B) -> (xs :E: List) -> (u :R: V -E- xs) -> (y :R: B) -> V -E- (Cons -R- x -R- (app -E- xs -E- (one -E- y)))
    length :R: (_x14 :R: List) -> N 
      length -R- Nil = Z
      x :R: B xs :R: List
        length -R- (Cons -R- x -R- xs) = S -R- (length -R- xs)
    index :E: (_x15 :E: N) -> (_x16 :E: List) -> (_x17 :E: List) -> List 
      xs :E: List ys :E: List
        index -E- Z -E- xs -E- ys = Nil
      x :E: B xs :E: List y :E: B ys :E: List
        index -E- (S -R- Z) -E- (Cons -R- x -R- xs) -E- (Cons -R- y -R- ys) = Cons -R- x -R- Nil
      n :E: N x :E: B xs :E: List y :E: B ys :E: List
        index -E- (S -R- (S -R- n)) -E- (Cons -R- x -R- xs) -E- (Cons -R- y -R- ys) = Cons -R- x -R- (app -E- (index -E- n -E- xs -E- ys) -E- (one -E- y))
      n :E: N
        index -E- (S -R- n) -E- Nil -E- Nil = Nil
    build :R: (n :R: N) -> (xs :R: List) -> (ys :R: List) -> V -E- (index -E- n -E- xs -E- ys) 
      xs :R: List ys :R: List
        build -R- Z -R- xs -R- ys = VNil
      x :R: B xs :R: List y :R: B ys :R: List
        build -R- (S -R- Z) -R- (Cons -R- x -R- xs) -R- (Cons -R- y -R- ys) = VOne -E- x
      n :R: N x :R: B xs :R: List y :R: B ys :R: List
        build -R- (S -R- (S -R- n)) -R- (Cons -R- x -R- xs) -R- (Cons -R- y -R- ys) = VTwo -R- x -E- (index -E- n -E- xs -E- ys) -R- (build -R- n -R- xs -R- ys) -R- y
      n :R: N
        build -R- (S -R- n) -R- Nil -R- Nil = VNil
    postulate eq :E: (xs :E: List) -> Id -E- List -E- (index -E- (length -R- xs) -E- xs -E- (reverse -R- xs)) -E- xs
    toV :R: (xs :R: List) -> V -E- xs = (\xs :R: List. subst -E- List -E- V -E- (index -E- (length -R- xs) -E- xs -E- (reverse -R- xs)) -E- xs -E- (eq -E- xs) -R- (build -R- (length -R- xs) -R- xs -R- (reverse -R- xs)))
    constructor IsPalindrome :E: (_x18 :E: List) -> Type
    constructor PNil :E: IsPalindrome -E- Nil
    constructor POne :E: (b :E: B) -> IsPalindrome -E- (Cons -R- b -R- Nil)
    constructor PTwo :E: (b :E: B) -> (xs :E: List) -> (pf :E: IsPalindrome -E- xs) -> IsPalindrome -E- (Cons -R- b -R- (app -E- xs -E- (one -E- b)))
    decEq :R: (x :R: B) -> (y :R: B) -> Maybe -E- (Id -E- B -E- x -E- y) 
      decEq -R- T -R- T = Just -E- (Id -E- B -E- T -E- T) -E- (Refl -E- B -E- T)
      decEq -R- F -R- F = Just -E- (Id -E- B -E- F -E- F) -E- (Refl -E- B -E- F)
      decEq -R- T -R- F = Nothing -E- (Id -E- B -E- T -E- F)
      decEq -R- F -R- T = Nothing -E- (Id -E- B -E- F -E- T)
    isPalinV :R: (xs :E: List) -> (v :R: V -E- xs) -> Maybe -E- (IsPalindrome -E- xs) 
      isPalinV -E- [Nil] -R- VNil = Just -E- (IsPalindrome -E- Nil) -E- PNil
      x :E: B
        isPalinV -E- [Cons -R- x -R- Nil] -R- (VOne -E- x) = Just -E- (IsPalindrome -E- (Cons -R- x -R- Nil)) -E- (POne -E- x)
      x :R: B xs :E: List y :R: B v :R: V -E- xs
        isPalinV -E- [Cons -R- x -R- (app -E- xs -E- (one -E- y))] -R- (VTwo -R- x -E- xs -R- v -R- y) = 
          let isPalinV' :R: (x :E: B) -> (y :E: B) -> (xs :E: List) -> (v :E: V -E- xs) -> (pfB :R: Maybe -E- (Id -E- B -E- x -E- y)) -> (pfV :R: Maybe -E- (IsPalindrome -E- xs)) -> Maybe -E- (IsPalindrome -E- (Cons -R- x -R- (app -E- xs -E- (one -E- y)))) 
            x :E: B xs :E: List v :E: V -E- xs pfV :E: IsPalindrome -E- xs
              isPalinV' -E- x -E- [x] -E- xs -E- v -R- (Just -E- [Id -E- B -E- x -E- x] -E- [Refl -E- B -E- x]) -R- (Just -E- [IsPalindrome -E- xs] -E- pfV) = Just -E- (IsPalindrome -E- (Cons -R- x -R- (app -E- xs -E- (one -E- x)))) -E- (PTwo -E- x -E- xs -E- pfV)
            x :E: B y :E: B xs :E: List v :E: V -E- xs pfB :R: Maybe -E- (Id -E- B -E- x -E- y) pfV :R: Maybe -E- (IsPalindrome -E- xs)
              isPalinV' -E- x -E- y -E- xs -E- v -R- pfB -R- pfV = Nothing -E- (IsPalindrome -E- (Cons -R- x -R- (app -E- xs -E- (one -E- y))))
          in isPalinV' -E- x -E- y -E- xs -E- v -R- (decEq -R- x -R- y) -R- (isPalinV -E- xs -R- v)
    isPalindrome :R: (xs :R: List) -> Maybe -E- (IsPalindrome -E- xs) = (\xs :R: List. isPalinV -E- xs -R- (toV -R- xs))
    genList :R: (_x19 :R: B) -> (_x20 :R: N) -> List 
      b :R: B
        genList -R- b -R- Z = Nil
      b :R: B n :R: N
        genList -R- b -R- (S -R- n) = Cons -R- b -R- (genList -R- (not -R- b) -R- n)
    isJust :R: (a :E: Type) -> (x :R: Maybe -E- a) -> B 
      a :E: Type x :E: a
        isJust -E- a -R- (Just -E- [a] -E- x) = T
      a :E: Type
        isJust -E- a -R- (Nothing -E- [a]) = F
    main :R: B = 
      let
        foreign inputSize :R: N
        inputList :R: List = genList -R- T -R- inputSize
      in isJust -E- (IsPalindrome -E- inputList) -R- (isPalindrome -R- inputList)
  in main

### Specialised ###

  let
    constructor N :E: Type
    constructor Z :R: N
    constructor S :R: (_x0 :R: N) -> N
    constructor B :E: Type
    constructor T :R: B
    constructor F :R: B
    constructor List :E: Type
    constructor Cons :R: (_x1 :R: B) -> (_x2 :R: List) -> List
    constructor Nil :R: List
    constructor Maybe :E: (_x3 :E: Type) -> Type
    constructor Nothing :R: (a :E: Type) -> Maybe -E- a
    constructor Just :R: (a :E: Type) -> (x :E: a) -> Maybe -E- a
    not :R: (_x4 :R: B) -> B 
      not -R- T = F
      not -R- F = T
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    id :E: (a :E: Type) -> (_x5 :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    subst :R: (a :E: Type) -> (P :E: (_x6 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (w :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x7 :E: a) -> Type x :E: a
        subst -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\w :R: P -E- x. w)
    cong :E: (a :E: Type) -> (b :E: Type) -> (f :E: (_x8 :R: a) -> b) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> Id -E- b -E- (f -R- x) -E- (f -R- y) 
      a :E: Type b :E: Type f :E: (_x9 :R: a) -> b x :E: a
        cong -E- a -E- b -E- f -E- x -E- [x] -E- [Refl -E- a -E- x] = Refl -E- b -E- (f -R- x)
    one :E: (x :E: B) -> List = (\x :E: B. Cons -R- x -R- Nil)
    app :E: (_x10 :E: List) -> (_x11 :E: List) -> List 
      ys :E: List
        app -E- Nil -E- ys = ys
      x :E: B xs :E: List ys :E: List
        app -E- (Cons -R- x -R- xs) -E- ys = Cons -R- x -R- (app -E- xs -E- ys)
    appRightNeutral :E: (ys :E: List) -> Id -E- List -E- ys -E- (app -E- ys -E- Nil) 
      appRightNeutral -E- Nil = Refl -E- List -E- Nil
      x :E: B xs :E: List
        appRightNeutral -E- (Cons -R- x -R- xs) = cong -E- List -E- List -E- (Cons -R- x) -E- xs -E- (app -E- xs -E- Nil) -E- (appRightNeutral -E- xs)
    appAssoc :E: (xs :E: List) -> (ys :E: List) -> (zs :E: List) -> Id -E- List -E- (app -E- (app -E- xs -E- ys) -E- zs) -E- (app -E- xs -E- (app -E- ys -E- zs)) 
      ys :E: List zs :E: List
        appAssoc -E- Nil -E- ys -E- zs = Refl -E- List -E- (app -E- ys -E- zs)
      x :E: B xs :E: List ys :E: List zs :E: List
        appAssoc -E- (Cons -R- x -R- xs) -E- ys -E- zs = cong -E- List -E- List -E- (Cons -R- x) -E- (app -E- (app -E- xs -E- ys) -E- zs) -E- (app -E- xs -E- (app -E- ys -E- zs)) -E- (appAssoc -E- xs -E- ys -E- zs)
    constructor Rev :E: (_x12 :E: List) -> Type
    constructor RNil :R: Rev -E- Nil
    constructor RSnoc :R: (xs :E: List) -> (x :R: B) -> (rxs :R: Rev -E- xs) -> Rev -E- (app -E- xs -E- (one -E- x))
    rev' :R: (xs :E: List) -> (rxs :R: Rev -E- xs) -> (ys :R: List) -> Rev -E- (app -E- xs -E- ys) 
      xs :E: List rxs :R: Rev -E- xs
        rev' -E- xs -R- rxs -R- Nil = subst -E- List -E- Rev -E- xs -E- (app -E- xs -E- Nil) -E- (appRightNeutral -E- xs) -R- rxs
      xs :E: List rxs :R: Rev -E- xs y :R: B ys :R: List
        rev' -E- xs -R- rxs -R- (Cons -R- y -R- ys) = subst -E- List -E- Rev -E- (app -E- (app -E- xs -E- (one -E- y)) -E- ys) -E- (app -E- xs -E- (Cons -R- y -R- ys)) -E- (appAssoc -E- xs -E- (one -E- y) -E- ys) -R- (rev' -E- (app -E- xs -E- (one -E- y)) -R- (RSnoc -E- xs -R- y -R- rxs) -R- ys)
    rev :R: (xs :R: List) -> Rev -E- xs = (\xs :R: List. rev' -E- Nil -R- RNil -R- xs)
    reverse' :R: (xs :E: List) -> (rxs :R: Rev -E- xs) -> List 
      reverse' -E- [Nil] -R- RNil = Nil
      xs :E: List x :R: B rxs :R: Rev -E- xs
        reverse' -E- [app -E- xs -E- (one -E- x)] -R- (RSnoc -E- xs -R- x -R- rxs) = Cons -R- x -R- (reverse' -E- xs -R- rxs)
    reverse :R: (xs :R: List) -> List = (\xs :R: List. reverse' -E- xs -R- (rev -R- xs))
    constructor V :E: (_x13 :E: List) -> Type
    constructor VNil :R: V -E- Nil
    constructor VOne :R: (x :E: B) -> V -E- (Cons -R- x -R- Nil)
    constructor VTwo :R: (x :R: B) -> (xs :E: List) -> (u :R: V -E- xs) -> (y :R: B) -> V -E- (Cons -R- x -R- (app -E- xs -E- (one -E- y)))
    length :R: (_x14 :R: List) -> N 
      length -R- Nil = Z
      x :R: B xs :R: List
        length -R- (Cons -R- x -R- xs) = S -R- (length -R- xs)
    index :E: (_x15 :E: N) -> (_x16 :E: List) -> (_x17 :E: List) -> List 
      xs :E: List ys :E: List
        index -E- Z -E- xs -E- ys = Nil
      x :E: B xs :E: List y :E: B ys :E: List
        index -E- (S -R- Z) -E- (Cons -R- x -R- xs) -E- (Cons -R- y -R- ys) = Cons -R- x -R- Nil
      n :E: N x :E: B xs :E: List y :E: B ys :E: List
        index -E- (S -R- (S -R- n)) -E- (Cons -R- x -R- xs) -E- (Cons -R- y -R- ys) = Cons -R- x -R- (app -E- (index -E- n -E- xs -E- ys) -E- (one -E- y))
      n :E: N
        index -E- (S -R- n) -E- Nil -E- Nil = Nil
    build :R: (n :R: N) -> (xs :R: List) -> (ys :R: List) -> V -E- (index -E- n -E- xs -E- ys) 
      xs :R: List ys :R: List
        build -R- Z -R- xs -R- ys = VNil
      x :R: B xs :R: List y :R: B ys :R: List
        build -R- (S -R- Z) -R- (Cons -R- x -R- xs) -R- (Cons -R- y -R- ys) = VOne -E- x
      n :R: N x :R: B xs :R: List y :R: B ys :R: List
        build -R- (S -R- (S -R- n)) -R- (Cons -R- x -R- xs) -R- (Cons -R- y -R- ys) = VTwo -R- x -E- (index -E- n -E- xs -E- ys) -R- (build -R- n -R- xs -R- ys) -R- y
      n :R: N
        build -R- (S -R- n) -R- Nil -R- Nil = VNil
    postulate eq :E: (xs :E: List) -> Id -E- List -E- (index -E- (length -R- xs) -E- xs -E- (reverse -R- xs)) -E- xs
    toV :R: (xs :R: List) -> V -E- xs = (\xs :R: List. subst -E- List -E- V -E- (index -E- (length -R- xs) -E- xs -E- (reverse -R- xs)) -E- xs -E- (eq -E- xs) -R- (build -R- (length -R- xs) -R- xs -R- (reverse -R- xs)))
    constructor IsPalindrome :E: (_x18 :E: List) -> Type
    constructor PNil :E: IsPalindrome -E- Nil
    constructor POne :E: (b :E: B) -> IsPalindrome -E- (Cons -R- b -R- Nil)
    constructor PTwo :E: (b :E: B) -> (xs :E: List) -> (pf :E: IsPalindrome -E- xs) -> IsPalindrome -E- (Cons -R- b -R- (app -E- xs -E- (one -E- b)))
    decEq :R: (x :R: B) -> (y :R: B) -> Maybe -E- (Id -E- B -E- x -E- y) 
      decEq -R- T -R- T = Just -E- (Id -E- B -E- T -E- T) -E- (Refl -E- B -E- T)
      decEq -R- F -R- F = Just -E- (Id -E- B -E- F -E- F) -E- (Refl -E- B -E- F)
      decEq -R- T -R- F = Nothing -E- (Id -E- B -E- T -E- F)
      decEq -R- F -R- T = Nothing -E- (Id -E- B -E- F -E- T)
    isPalinV :R: (xs :E: List) -> (v :R: V -E- xs) -> Maybe -E- (IsPalindrome -E- xs) 
      isPalinV -E- [Nil] -R- VNil = Just -E- (IsPalindrome -E- Nil) -E- PNil
      x :E: B
        isPalinV -E- [Cons -R- x -R- Nil] -R- (VOne -E- x) = Just -E- (IsPalindrome -E- (Cons -R- x -R- Nil)) -E- (POne -E- x)
      x :R: B xs :E: List y :R: B v :R: V -E- xs
        isPalinV -E- [Cons -R- x -R- (app -E- xs -E- (one -E- y))] -R- (VTwo -R- x -E- xs -R- v -R- y) = 
          let isPalinV' :R: (x :E: B) -> (y :E: B) -> (xs :E: List) -> (v :E: V -E- xs) -> (pfB :R: Maybe -E- (Id -E- B -E- x -E- y)) -> (pfV :R: Maybe -E- (IsPalindrome -E- xs)) -> Maybe -E- (IsPalindrome -E- (Cons -R- x -R- (app -E- xs -E- (one -E- y)))) 
            x :E: B xs :E: List v :E: V -E- xs pfV :E: IsPalindrome -E- xs
              isPalinV' -E- x -E- [x] -E- xs -E- v -R- (Just -E- [Id -E- B -E- x -E- x] -E- [Refl -E- B -E- x]) -R- (Just -E- [IsPalindrome -E- xs] -E- pfV) = Just -E- (IsPalindrome -E- (Cons -R- x -R- (app -E- xs -E- (one -E- x)))) -E- (PTwo -E- x -E- xs -E- pfV)
            x :E: B y :E: B xs :E: List v :E: V -E- xs pfB :R: Maybe -E- (Id -E- B -E- x -E- y) pfV :R: Maybe -E- (IsPalindrome -E- xs)
              isPalinV' -E- x -E- y -E- xs -E- v -R- pfB -R- pfV = Nothing -E- (IsPalindrome -E- (Cons -R- x -R- (app -E- xs -E- (one -E- y))))
          in isPalinV' -E- x -E- y -E- xs -E- v -R- (decEq -R- x -R- y) -R- (isPalinV -E- xs -R- v)
    isPalindrome :R: (xs :R: List) -> Maybe -E- (IsPalindrome -E- xs) = (\xs :R: List. isPalinV -E- xs -R- (toV -R- xs))
    genList :R: (_x19 :R: B) -> (_x20 :R: N) -> List 
      b :R: B
        genList -R- b -R- Z = Nil
      b :R: B n :R: N
        genList -R- b -R- (S -R- n) = Cons -R- b -R- (genList -R- (not -R- b) -R- n)
    isJust :R: (a :E: Type) -> (x :R: Maybe -E- a) -> B 
      a :E: Type x :E: a
        isJust -E- a -R- (Just -E- [a] -E- x) = T
      a :E: Type
        isJust -E- a -R- (Nothing -E- [a]) = F
    main :R: B = 
      let
        foreign inputSize :R: N
        inputList :R: List = genList -R- T -R- inputSize
      in isJust -E- (IsPalindrome -E- inputList) -R- (isPalindrome -R- inputList)
  in main

### Final annotation ###

  let
    constructor N :E: Type
    constructor Z :R: N
    constructor S :R: (_x0 :R: N) -> N
    constructor B :E: Type
    constructor T :R: B
    constructor F :R: B
    constructor List :E: Type
    constructor Cons :R: (_x1 :R: B) -> (_x2 :R: List) -> List
    constructor Nil :R: List
    constructor Maybe :E: (_x3 :E: Type) -> Type
    constructor Nothing :R: (a :E: Type) -> Maybe -E- a
    constructor Just :R: (a :E: Type) -> (x :E: a) -> Maybe -E- a
    not :R: (_x4 :R: B) -> B 
      not -R- T = F
      not -R- F = T
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    id :E: (a :E: Type) -> (_x5 :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    subst :R: (a :E: Type) -> (P :E: (_x6 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (w :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x7 :E: a) -> Type x :E: a
        subst -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\w :R: P -E- x. w)
    cong :E: (a :E: Type) -> (b :E: Type) -> (f :E: (_x8 :R: a) -> b) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> Id -E- b -E- (f -R- x) -E- (f -R- y) 
      a :E: Type b :E: Type f :E: (_x9 :R: a) -> b x :E: a
        cong -E- a -E- b -E- f -E- x -E- [x] -E- [Refl -E- a -E- x] = Refl -E- b -E- (f -R- x)
    one :E: (x :E: B) -> List = (\x :E: B. Cons -R- x -R- Nil)
    app :E: (_x10 :E: List) -> (_x11 :E: List) -> List 
      ys :E: List
        app -E- Nil -E- ys = ys
      x :E: B xs :E: List ys :E: List
        app -E- (Cons -R- x -R- xs) -E- ys = Cons -R- x -R- (app -E- xs -E- ys)
    appRightNeutral :E: (ys :E: List) -> Id -E- List -E- ys -E- (app -E- ys -E- Nil) 
      appRightNeutral -E- Nil = Refl -E- List -E- Nil
      x :E: B xs :E: List
        appRightNeutral -E- (Cons -R- x -R- xs) = cong -E- List -E- List -E- (Cons -R- x) -E- xs -E- (app -E- xs -E- Nil) -E- (appRightNeutral -E- xs)
    appAssoc :E: (xs :E: List) -> (ys :E: List) -> (zs :E: List) -> Id -E- List -E- (app -E- (app -E- xs -E- ys) -E- zs) -E- (app -E- xs -E- (app -E- ys -E- zs)) 
      ys :E: List zs :E: List
        appAssoc -E- Nil -E- ys -E- zs = Refl -E- List -E- (app -E- ys -E- zs)
      x :E: B xs :E: List ys :E: List zs :E: List
        appAssoc -E- (Cons -R- x -R- xs) -E- ys -E- zs = cong -E- List -E- List -E- (Cons -R- x) -E- (app -E- (app -E- xs -E- ys) -E- zs) -E- (app -E- xs -E- (app -E- ys -E- zs)) -E- (appAssoc -E- xs -E- ys -E- zs)
    constructor Rev :E: (_x12 :E: List) -> Type
    constructor RNil :R: Rev -E- Nil
    constructor RSnoc :R: (xs :E: List) -> (x :R: B) -> (rxs :R: Rev -E- xs) -> Rev -E- (app -E- xs -E- (one -E- x))
    rev' :R: (xs :E: List) -> (rxs :R: Rev -E- xs) -> (ys :R: List) -> Rev -E- (app -E- xs -E- ys) 
      xs :E: List rxs :R: Rev -E- xs
        rev' -E- xs -R- rxs -R- Nil = subst -E- List -E- Rev -E- xs -E- (app -E- xs -E- Nil) -E- (appRightNeutral -E- xs) -R- rxs
      xs :E: List rxs :R: Rev -E- xs y :R: B ys :R: List
        rev' -E- xs -R- rxs -R- (Cons -R- y -R- ys) = subst -E- List -E- Rev -E- (app -E- (app -E- xs -E- (one -E- y)) -E- ys) -E- (app -E- xs -E- (Cons -R- y -R- ys)) -E- (appAssoc -E- xs -E- (one -E- y) -E- ys) -R- (rev' -E- (app -E- xs -E- (one -E- y)) -R- (RSnoc -E- xs -R- y -R- rxs) -R- ys)
    rev :R: (xs :R: List) -> Rev -E- xs = (\xs :R: List. rev' -E- Nil -R- RNil -R- xs)
    reverse' :R: (xs :E: List) -> (rxs :R: Rev -E- xs) -> List 
      reverse' -E- [Nil] -R- RNil = Nil
      xs :E: List x :R: B rxs :R: Rev -E- xs
        reverse' -E- [app -E- xs -E- (one -E- x)] -R- (RSnoc -E- xs -R- x -R- rxs) = Cons -R- x -R- (reverse' -E- xs -R- rxs)
    reverse :R: (xs :R: List) -> List = (\xs :R: List. reverse' -E- xs -R- (rev -R- xs))
    constructor V :E: (_x13 :E: List) -> Type
    constructor VNil :R: V -E- Nil
    constructor VOne :R: (x :E: B) -> V -E- (Cons -R- x -R- Nil)
    constructor VTwo :R: (x :R: B) -> (xs :E: List) -> (u :R: V -E- xs) -> (y :R: B) -> V -E- (Cons -R- x -R- (app -E- xs -E- (one -E- y)))
    length :R: (_x14 :R: List) -> N 
      length -R- Nil = Z
      x :R: B xs :R: List
        length -R- (Cons -R- x -R- xs) = S -R- (length -R- xs)
    index :E: (_x15 :E: N) -> (_x16 :E: List) -> (_x17 :E: List) -> List 
      xs :E: List ys :E: List
        index -E- Z -E- xs -E- ys = Nil
      x :E: B xs :E: List y :E: B ys :E: List
        index -E- (S -R- Z) -E- (Cons -R- x -R- xs) -E- (Cons -R- y -R- ys) = Cons -R- x -R- Nil
      n :E: N x :E: B xs :E: List y :E: B ys :E: List
        index -E- (S -R- (S -R- n)) -E- (Cons -R- x -R- xs) -E- (Cons -R- y -R- ys) = Cons -R- x -R- (app -E- (index -E- n -E- xs -E- ys) -E- (one -E- y))
      n :E: N
        index -E- (S -R- n) -E- Nil -E- Nil = Nil
    build :R: (n :R: N) -> (xs :R: List) -> (ys :R: List) -> V -E- (index -E- n -E- xs -E- ys) 
      xs :R: List ys :R: List
        build -R- Z -R- xs -R- ys = VNil
      x :R: B xs :R: List y :R: B ys :R: List
        build -R- (S -R- Z) -R- (Cons -R- x -R- xs) -R- (Cons -R- y -R- ys) = VOne -E- x
      n :R: N x :R: B xs :R: List y :R: B ys :R: List
        build -R- (S -R- (S -R- n)) -R- (Cons -R- x -R- xs) -R- (Cons -R- y -R- ys) = VTwo -R- x -E- (index -E- n -E- xs -E- ys) -R- (build -R- n -R- xs -R- ys) -R- y
      n :R: N
        build -R- (S -R- n) -R- Nil -R- Nil = VNil
    postulate eq :E: (xs :E: List) -> Id -E- List -E- (index -E- (length -R- xs) -E- xs -E- (reverse -R- xs)) -E- xs
    toV :R: (xs :R: List) -> V -E- xs = (\xs :R: List. subst -E- List -E- V -E- (index -E- (length -R- xs) -E- xs -E- (reverse -R- xs)) -E- xs -E- (eq -E- xs) -R- (build -R- (length -R- xs) -R- xs -R- (reverse -R- xs)))
    constructor IsPalindrome :E: (_x18 :E: List) -> Type
    constructor PNil :E: IsPalindrome -E- Nil
    constructor POne :E: (b :E: B) -> IsPalindrome -E- (Cons -R- b -R- Nil)
    constructor PTwo :E: (b :E: B) -> (xs :E: List) -> (pf :E: IsPalindrome -E- xs) -> IsPalindrome -E- (Cons -R- b -R- (app -E- xs -E- (one -E- b)))
    decEq :R: (x :R: B) -> (y :R: B) -> Maybe -E- (Id -E- B -E- x -E- y) 
      decEq -R- T -R- T = Just -E- (Id -E- B -E- T -E- T) -E- (Refl -E- B -E- T)
      decEq -R- F -R- F = Just -E- (Id -E- B -E- F -E- F) -E- (Refl -E- B -E- F)
      decEq -R- T -R- F = Nothing -E- (Id -E- B -E- T -E- F)
      decEq -R- F -R- T = Nothing -E- (Id -E- B -E- F -E- T)
    isPalinV :R: (xs :E: List) -> (v :R: V -E- xs) -> Maybe -E- (IsPalindrome -E- xs) 
      isPalinV -E- [Nil] -R- VNil = Just -E- (IsPalindrome -E- Nil) -E- PNil
      x :E: B
        isPalinV -E- [Cons -R- x -R- Nil] -R- (VOne -E- x) = Just -E- (IsPalindrome -E- (Cons -R- x -R- Nil)) -E- (POne -E- x)
      x :R: B xs :E: List y :R: B v :R: V -E- xs
        isPalinV -E- [Cons -R- x -R- (app -E- xs -E- (one -E- y))] -R- (VTwo -R- x -E- xs -R- v -R- y) = 
          let isPalinV' :R: (x :E: B) -> (y :E: B) -> (xs :E: List) -> (v :E: V -E- xs) -> (pfB :R: Maybe -E- (Id -E- B -E- x -E- y)) -> (pfV :R: Maybe -E- (IsPalindrome -E- xs)) -> Maybe -E- (IsPalindrome -E- (Cons -R- x -R- (app -E- xs -E- (one -E- y)))) 
            x :E: B xs :E: List v :E: V -E- xs pfV :E: IsPalindrome -E- xs
              isPalinV' -E- x -E- [x] -E- xs -E- v -R- (Just -E- [Id -E- B -E- x -E- x] -E- [Refl -E- B -E- x]) -R- (Just -E- [IsPalindrome -E- xs] -E- pfV) = Just -E- (IsPalindrome -E- (Cons -R- x -R- (app -E- xs -E- (one -E- x)))) -E- (PTwo -E- x -E- xs -E- pfV)
            x :E: B y :E: B xs :E: List v :E: V -E- xs pfB :R: Maybe -E- (Id -E- B -E- x -E- y) pfV :R: Maybe -E- (IsPalindrome -E- xs)
              isPalinV' -E- x -E- y -E- xs -E- v -R- pfB -R- pfV = Nothing -E- (IsPalindrome -E- (Cons -R- x -R- (app -E- xs -E- (one -E- y))))
          in isPalinV' -E- x -E- y -E- xs -E- v -R- (decEq -R- x -R- y) -R- (isPalinV -E- xs -R- v)
    isPalindrome :R: (xs :R: List) -> Maybe -E- (IsPalindrome -E- xs) = (\xs :R: List. isPalinV -E- xs -R- (toV -R- xs))
    genList :R: (_x19 :R: B) -> (_x20 :R: N) -> List 
      b :R: B
        genList -R- b -R- Z = Nil
      b :R: B n :R: N
        genList -R- b -R- (S -R- n) = Cons -R- b -R- (genList -R- (not -R- b) -R- n)
    isJust :R: (a :E: Type) -> (x :R: Maybe -E- a) -> B 
      a :E: Type x :E: a
        isJust -E- a -R- (Just -E- [a] -E- x) = T
      a :E: Type
        isJust -E- a -R- (Nothing -E- [a]) = F
    main :R: B = 
      let
        foreign inputSize :R: N
        inputList :R: List = genList -R- T -R- inputSize
      in isJust -E- (IsPalindrome -E- inputList) -R- (isPalindrome -R- inputList)
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Z : N
    constructor S : (_x0) -> N
    constructor T : B
    constructor F : B
    constructor Cons : (_x1) -> (_x2) -> List
    constructor Nil : List
    constructor Nothing : Maybe
    constructor Just : Maybe
    not 
      not T = F
      not F = T
    subst 
      subst = (\w. w)
    constructor RNil : Rev
    constructor RSnoc : (x) -> (rxs) -> Rev
    rev' 
      rev' rxs Nil = subst rxs
      rev' rxs (Cons y ys) = subst (rev' (RSnoc y rxs) ys)
    rev = (\xs. rev' RNil xs)
    reverse' 
      reverse' RNil = Nil
      reverse' (RSnoc x rxs) = Cons x (reverse' rxs)
    reverse = (\xs. reverse' (rev xs))
    constructor VNil : V
    constructor VOne : V
    constructor VTwo : (x) -> (u) -> (y) -> V
    length 
      length Nil = Z
      length (Cons x xs) = S (length xs)
    build 
      build Z xs ys = VNil
      build (S Z) (Cons x xs) (Cons y ys) = VOne
      build (S (S n)) (Cons x xs) (Cons y ys) = VTwo x (build n xs ys) y
      build (S n) Nil Nil = VNil
    toV = (\xs. subst (build (length xs) xs (reverse xs)))
    decEq 
      decEq T T = Just
      decEq F F = Just
      decEq T F = Nothing
      decEq F T = Nothing
    isPalinV 
      isPalinV VNil = Just
      isPalinV VOne = Just
      isPalinV (VTwo x v y) = 
        let isPalinV' 
          isPalinV' Just Just = Just
          isPalinV' pfB pfV = Nothing
        in isPalinV' (decEq x y) (isPalinV v)
    isPalindrome = (\xs. isPalinV (toV xs))
    genList 
      genList b Z = Nil
      genList b (S n) = Cons b (genList (not b) n)
    isJust 
      isJust Just = T
      isJust Nothing = F
    main = 
      let
        foreign inputSize
        inputList = genList T inputSize
      in isJust (isPalindrome inputList)
  in main

### Intermediate representation ###

let Z = constructor 0
  in let S = constructor 1
    in let T = constructor 0
      in let F = constructor 0
        in let Cons = constructor 2
          in let Nil = constructor 0
            in let Nothing = constructor 0
              in let Just = constructor 0
                in let not = \_pv0.
                  case _pv0 of
                    F => T
                    T => F
                  in let subst = \w. w
                    in let RNil = constructor 0
                      in let RSnoc = constructor 2
                        in let rev' = \_pv0. \_pv1.
                          case _pv1 of
                            Cons _pv2 _pv3 => (subst ((rev' ((RSnoc _pv2) _pv0)) _pv3))
                            Nil => (subst _pv0)
                          in let rev = \xs. ((rev' RNil) xs)
                            in let reverse' = \_pv0.
                              case _pv0 of
                                RNil => Nil
                                RSnoc _pv1 _pv2 => ((Cons _pv1) (reverse' _pv2))
                              in let reverse = \xs. (reverse' (rev xs))
                                in let VNil = constructor 0
                                  in let VOne = constructor 0
                                    in let VTwo = constructor 3
                                      in let length = \_pv0.
                                        case _pv0 of
                                          Cons _pv1 _pv2 => (S (length _pv2))
                                          Nil => Z
                                        in let build = \_pv0. \_pv1. \_pv2.
                                          case _pv0 of
                                            S _pv3 => case _pv3 of
                                              S _pv4 => case _pv1 of
                                                Cons _pv5 _pv6 => case _pv2 of
                                                  Cons _pv7 _pv8 => (((VTwo _pv5) (((build _pv4) _pv6) _pv8)) _pv7)
                                                  _ => VNil
                                                _ => VNil
                                              Z => case _pv1 of
                                                Cons _pv4 _pv5 => case _pv2 of
                                                  Cons _pv6 _pv7 => VOne
                                                  _ => VNil
                                                _ => VNil
                                              _ => VNil
                                            Z => VNil
                                          in let toV = \xs. (subst (((build (length xs)) xs) (reverse xs)))
                                            in let decEq = \_pv0. \_pv1.
                                              case _pv0 of
                                                F => case _pv1 of
                                                  F => Just
                                                  T => Nothing
                                                T => case _pv1 of
                                                  F => Nothing
                                                  T => Just
                                              in let isPalinV = \_pv0.
                                                case _pv0 of
                                                  VNil => Just
                                                  VOne => Just
                                                  VTwo _pv1 _pv2 _pv3 => let isPalinV' = \_pv4. \_pv5.
                                                    case _pv4 of
                                                      Just => case _pv5 of
                                                        Just => Just
                                                        _ => Nothing
                                                      _ => Nothing
                                                    in ((isPalinV' ((decEq _pv1) _pv3)) (isPalinV _pv2))
                                                in let isPalindrome = \xs. (isPalinV (toV xs))
                                                  in let genList = \_pv0. \_pv1.
                                                    case _pv1 of
                                                      S _pv2 => ((Cons _pv0) ((genList (not _pv0)) _pv2))
                                                      Z => Nil
                                                    in let isJust = \_pv0.
                                                      case _pv0 of
                                                        Just => T
                                                        Nothing => F
                                                      in let main = let inputSize = foreign "(rts-arg-peano 'Z 'S 0)"
                                                        in let inputList = ((genList T) inputSize)
                                                          in (isJust (isPalindrome inputList))
                                                        in main

### Normal forms ###

unerased:
  
  let
    constructor N : Type
    constructor Z : N
    constructor S : (_x0 : N) -> N
    constructor B : Type
    constructor T : B
    constructor F : B
    constructor List : Type
    constructor Cons : (_x1 : B) -> (_x2 : List) -> List
    constructor Nil : List
    constructor Maybe : (_x3 : Type) -> Type
    constructor Nothing : (a : Type) -> Maybe a
    constructor Just : (a : Type) -> (x : a) -> Maybe a
    not : (_x4 : B) -> B 
      not T = F
      not F = T
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    subst : (a : Type) -> (P : (_x6 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (w : P x) -> P y 
      a : Type P : (_x7 : a) -> Type x : a
        subst a P x [x] [Refl a x] = (\w : P x. w)
    cong : (a : Type) -> (b : Type) -> (f : (_x8 : a) -> b) -> (x : a) -> (y : a) -> (eq : Id a x y) -> Id b (f x) (f y) 
      a : Type b : Type f : (_x9 : a) -> b x : a
        cong a b f x [x] [Refl a x] = Refl b (f x)
    one : (x : B) -> List = (\x : B. Cons x Nil)
    app : (_x10 : List) -> (_x11 : List) -> List 
      ys : List
        app Nil ys = ys
      x : B xs : List ys : List
        app (Cons x xs) ys = Cons x (app xs ys)
    appRightNeutral : (ys : List) -> Id List ys (app ys Nil) 
      appRightNeutral Nil = Refl List Nil
      x : B xs : List
        appRightNeutral (Cons x xs) = cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs)
    appAssoc : (xs : List) -> (ys : List) -> (zs : List) -> Id List (app (app xs ys) zs) (app xs (app ys zs)) 
      ys : List zs : List
        appAssoc Nil ys zs = Refl List (app ys zs)
      x : B xs : List ys : List zs : List
        appAssoc (Cons x xs) ys zs = cong List List (Cons x) (app (app xs ys) zs) (app xs (app ys zs)) (appAssoc xs ys zs)
    constructor Rev : (_x12 : List) -> Type
    constructor RNil : Rev Nil
    constructor RSnoc : (xs : List) -> (x : B) -> (rxs : Rev xs) -> Rev (app xs (one x))
    rev' : (xs : List) -> (rxs : Rev xs) -> (ys : List) -> Rev (app xs ys) 
      xs : List rxs : Rev xs
        rev' xs rxs Nil = subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs
      xs : List rxs : Rev xs y : B ys : List
        rev' xs rxs (Cons y ys) = subst List Rev (app (app xs (one y)) ys) (app xs (Cons y ys)) (appAssoc xs (one y) ys) (rev' (app xs (one y)) (RSnoc xs y rxs) ys)
    reverse' : (xs : List) -> (rxs : Rev xs) -> List 
      reverse' [Nil] RNil = Nil
      xs : List x : B rxs : Rev xs
        reverse' [app xs (one x)] (RSnoc xs x rxs) = Cons x (reverse' xs rxs)
    constructor V : (_x13 : List) -> Type
    constructor VNil : V Nil
    constructor VOne : (x : B) -> V (Cons x Nil)
    constructor VTwo : (x : B) -> (xs : List) -> (u : V xs) -> (y : B) -> V (Cons x (app xs (one y)))
    length : (_x14 : List) -> N 
      length Nil = Z
      x : B xs : List
        length (Cons x xs) = S (length xs)
    index : (_x15 : N) -> (_x16 : List) -> (_x17 : List) -> List 
      xs : List ys : List
        index Z xs ys = Nil
      x : B xs : List y : B ys : List
        index (S Z) (Cons x xs) (Cons y ys) = Cons x Nil
      n : N x : B xs : List y : B ys : List
        index (S (S n)) (Cons x xs) (Cons y ys) = Cons x (app (index n xs ys) (one y))
      n : N
        index (S n) Nil Nil = Nil
    build : (n : N) -> (xs : List) -> (ys : List) -> V (index n xs ys) 
      xs : List ys : List
        build Z xs ys = VNil
      x : B xs : List y : B ys : List
        build (S Z) (Cons x xs) (Cons y ys) = VOne x
      n : N x : B xs : List y : B ys : List
        build (S (S n)) (Cons x xs) (Cons y ys) = VTwo x (index n xs ys) (build n xs ys) y
      n : N
        build (S n) Nil Nil = VNil
    constructor IsPalindrome : (_x18 : List) -> Type
    constructor PNil : IsPalindrome Nil
    constructor POne : (b : B) -> IsPalindrome (Cons b Nil)
    constructor PTwo : (b : B) -> (xs : List) -> (pf : IsPalindrome xs) -> IsPalindrome (Cons b (app xs (one b)))
    decEq : (x : B) -> (y : B) -> Maybe (Id B x y) 
      decEq T T = Just (Id B T T) (Refl B T)
      decEq F F = Just (Id B F F) (Refl B F)
      decEq T F = Nothing (Id B T F)
      decEq F T = Nothing (Id B F T)
    isPalinV : (xs : List) -> (v : V xs) -> Maybe (IsPalindrome xs) 
      isPalinV [Nil] VNil = Just (IsPalindrome Nil) PNil
      x : B
        isPalinV [Cons x Nil] (VOne x) = Just (IsPalindrome (Cons x Nil)) (POne x)
      x : B xs : List y : B v : V xs
        isPalinV [Cons x (app xs (one y))] (VTwo x xs v y) = 
          let isPalinV' : (x : B) -> (y : B) -> (xs : List) -> (v : V xs) -> (pfB : Maybe (Id B x y)) -> (pfV : Maybe (IsPalindrome xs)) -> Maybe (IsPalindrome (Cons x (app xs (one y)))) 
            x : B xs : List v : V xs pfV : IsPalindrome xs
              isPalinV' x [x] xs v (Just [Id B x x] [Refl B x]) (Just [IsPalindrome xs] pfV) = Just (IsPalindrome (Cons x (app xs (one x)))) (PTwo x xs pfV)
            x : B y : B xs : List v : V xs pfB : Maybe (Id B x y) pfV : Maybe (IsPalindrome xs)
              isPalinV' x y xs v pfB pfV = Nothing (IsPalindrome (Cons x (app xs (one y))))
          in isPalinV' x y xs v (decEq x y) (isPalinV xs v)
    genList : (_x19 : B) -> (_x20 : N) -> List 
      b : B
        genList b Z = Nil
      b : B n : N
        genList b (S n) = Cons b (genList (not b) n)
    isJust : (a : Type) -> (x : Maybe a) -> B 
      a : Type x : a
        isJust a (Just [a] x) = T
      a : Type
        isJust a (Nothing [a]) = F
  in 
    let foreign inputSize : N
    in isJust (IsPalindrome (genList T inputSize)) (isPalinV (genList T inputSize) (build (length (genList T inputSize)) (genList T inputSize) (reverse' (genList T inputSize) (rev' Nil RNil (genList T inputSize)))))

erased:
  
  let
    constructor Z : N
    constructor S : (_x0) -> N
    constructor T : B
    constructor F : B
    constructor Cons : (_x1) -> (_x2) -> List
    constructor Nil : List
    constructor Nothing : Maybe
    constructor Just : Maybe
    not 
      not T = F
      not F = T
    subst 
      subst = (\w. w)
    constructor RNil : Rev
    constructor RSnoc : (x) -> (rxs) -> Rev
    rev' 
      rev' rxs Nil = subst rxs
      rev' rxs (Cons y ys) = subst (rev' (RSnoc y rxs) ys)
    reverse' 
      reverse' RNil = Nil
      reverse' (RSnoc x rxs) = Cons x (reverse' rxs)
    constructor VNil : V
    constructor VOne : V
    constructor VTwo : (x) -> (u) -> (y) -> V
    length 
      length Nil = Z
      length (Cons x xs) = S (length xs)
    build 
      build Z xs ys = VNil
      build (S Z) (Cons x xs) (Cons y ys) = VOne
      build (S (S n)) (Cons x xs) (Cons y ys) = VTwo x (build n xs ys) y
      build (S n) Nil Nil = VNil
    decEq 
      decEq T T = Just
      decEq F F = Just
      decEq T F = Nothing
      decEq F T = Nothing
    isPalinV 
      isPalinV VNil = Just
      isPalinV VOne = Just
      isPalinV (VTwo x v y) = 
        let isPalinV' 
          isPalinV' Just Just = Just
          isPalinV' pfB pfV = Nothing
        in isPalinV' (decEq x y) (isPalinV v)
    genList 
      genList b Z = Nil
      genList b (S n) = Cons b (genList (not b) n)
    isJust 
      isJust Just = T
      isJust Nothing = F
  in 
    let foreign inputSize
    in isJust (isPalinV (build (length (genList T inputSize)) (genList T inputSize) (reverse' (rev' RNil (genList T inputSize)))))

