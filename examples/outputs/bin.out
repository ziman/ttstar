-- vim: ft=ttstar

### Desugared ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x2 : Bool) -> Bool 
      [not] True = False
      [not] False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x3 : Type) -> (_x4 : Type) -> Type
    constructor MkPair : (a : Type) -> (b : Type) -> (_x5 : a) -> (_x6 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x7 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        [fst] a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x8 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        [snd] a b ([MkPair] [a] [b] x y) = y
    constructor Either : (_x9 : Type) -> (_x10 : Type) -> Type
    constructor Left : (a : Type) -> (b : Type) -> (_x11 : a) -> Either a b
    constructor Right : (a : Type) -> (b : Type) -> (_x12 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x13 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x14 : Fin n) -> Fin (S n)
    constructor Vect : (_x15 : Nat) -> (_x16 : Type) -> Type
    constructor VN : (a : Type) -> Vect Z a
    constructor VC : (n : Nat) -> (a : Type) -> (x : a) -> (xs : Vect n a) -> Vect (S n) a
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    subst : (a : Type) -> (P : (_x0 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (_x1 : P x) -> P y 
      a : Type P : (_x2 : a) -> Type x : a
        [subst] a P x [x] [Refl a x] = (\z : P x. z)
    constructor Bit : (_x0 : Nat) -> Type
    constructor I : Bit 1
    constructor O : Bit Z
    double : (_x1 : Nat) -> Nat 
      [double] Z = Z
      n : Nat
        [double] (S n) = S (S (double n))
    constructor Bin : (width : Nat) -> (value : Nat) -> Type
    constructor N : Bin Z Z
    constructor C : (width : Nat) -> (lsbVal : Nat) -> (lsb : Bit lsbVal) -> (restVal : Nat) -> (rest :R: Bin width restVal) -> Bin (S width) (plus lsbVal (double restVal))
    constructor TwoBits : (_x2 : Nat) -> (_x3 : Nat) -> (_x4 : Nat) -> Type
    constructor TB : (c : Nat) -> (x : Nat) -> (y : Nat) -> (hi' : Nat) -> (hi : Bit hi') -> (lo' : Nat) -> (lo : Bit lo') -> (pf : Id Nat (plus c (plus x y)) (plus lo' (double hi'))) -> TwoBits c x y
    adb : (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x5 : Bit c) -> (_x6 : Bit x) -> (_x7 : Bit y) -> TwoBits c x y 
      [adb] [Z] [Z] [Z] O O O = TB Z Z Z Z O Z O (Refl Nat Z)
      [adb] [1] [Z] [Z] I O O = TB 1 Z Z Z O 1 I (Refl Nat 1)
      [adb] [Z] [1] [Z] O I O = TB Z 1 Z Z O 1 I (Refl Nat 1)
      [adb] [Z] [Z] [1] O O I = TB Z Z 1 Z O 1 I (Refl Nat 1)
      [adb] [1] [1] [Z] I I O = TB 1 1 Z 1 I Z O (Refl Nat 2)
      [adb] [1] [Z] [1] I O I = TB 1 Z 1 1 I Z O (Refl Nat 2)
      [adb] [Z] [1] [1] O I I = TB Z 1 1 1 I Z O (Refl Nat 2)
      [adb] [1] [1] [1] I I I = TB 1 1 1 1 I 1 I (Refl Nat 3)
    add' : (w : Nat) -> (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x8 : Bit c) -> (_x9 : Bin w x) -> (_x10 : Bin w y) -> Bin (S w) (plus c (plus x y)) 
      c : Nat cb : Bit c
        [add'] [Z] c [Z] [Z] cb N N = C Z c cb Z N
      w : Nat c : Nat cb : Bit c xb' : Nat xb : Bit xb' xn' : Nat xn : Bin w xn' yb' : Nat yb : Bit yb' yn' : Nat yn : Bin w yn'
        [add'] ([S] w) c [plus xb' (double xn')] [plus yb' (double yn')] cb (C [w] xb' xb xn' xn) (C [w] yb' yb yn' yn) = 
          let f : (_x11 : TwoBits c xb' yb') -> Bin (S (S w)) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) 
            hi' : Nat hi : Bit hi' lo' : Nat lo : Bit lo' pf : Id Nat (plus c (plus xb' yb')) (plus lo' (double hi'))
              [f] ([TB] [c] [xb'] [yb'] hi' hi lo' lo pf) = 
                let postulate eq : Id Nat (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn'))))
                in subst Nat (Bin (S (S w))) (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) eq (C (S w) lo' lo (plus hi' (plus xn' yn')) (add' w hi' xn' yn' hi xn yn))
          in f (adb c xb' yb' cb xb yb)
    add : (w : Nat) -> (x : Nat) -> (y : Nat) -> (bx : Bin w x) -> (by : Bin w y) -> Bin (S w) (plus x y) = (\w : Nat. (\x : Nat. (\y : Nat. (\bx : Bin w x. (\by : Bin w y. add' w Z x y O bx by)))))
    foreign inputSize : Nat
    binVal : (_x12 : Bool) -> (_x13 : Nat) -> Nat 
      b : Bool
        [binVal] b Z = Z
      n : Nat
        [binVal] True (S n) = S (double (binVal False n))
      n : Nat
        [binVal] False (S n) = double (binVal True n)
    mkBin : (b : Bool) -> (w : Nat) -> Bin w (binVal b w) 
      b : Bool
        [mkBin] b Z = N
      n : Nat
        [mkBin] True (S n) = C n 1 I (binVal False n) (mkBin False n)
      n : Nat
        [mkBin] False (S n) = C n Z O (binVal True n) (mkBin True n)
    main : Bin (S inputSize) (plus (binVal True inputSize) (binVal False inputSize)) = 
      let
        x : Bin inputSize (binVal True inputSize) = mkBin True inputSize
        y : Bin inputSize (binVal False inputSize) = mkBin False inputSize
      in add inputSize (binVal True inputSize) (binVal False inputSize) x y
  in main

### Evarified ###

  let
    constructor Nat :1: Type
    constructor Z :2: Nat
    constructor S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        [plus] -9- Z -8- n = n
      m :10: Nat n :11: Nat
        [plus] -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    constructor Bool :18: Type
    constructor True :19: Bool
    constructor False :20: Bool
    not :21: (_x2 :22: Bool) -> Bool 
      [not] -23- True = False
      [not] -24- False = True
    constructor Unit :25: Type
    constructor MkUnit :26: Unit
    constructor Pair :27: (_x3 :28: Type) -> (_x4 :29: Type) -> Type
    constructor MkPair :30: (a :31: Type) -> (b :32: Type) -> (_x5 :33: a) -> (_x6 :34: b) -> Pair -36- a -35- b
    fst :37: (a :38: Type) -> (b :39: Type) -> (_x7 :40: Pair -42- a -41- b) -> a 
      a :43: Type b :44: Type x :45: a y :46: b
        [fst] -49- a -48- b -47- ([MkPair] -53- [a] -52- [b] -51- x -50- y) = x
    snd :54: (a :55: Type) -> (b :56: Type) -> (_x8 :57: Pair -59- a -58- b) -> b 
      a :60: Type b :61: Type x :62: a y :63: b
        [snd] -66- a -65- b -64- ([MkPair] -70- [a] -69- [b] -68- x -67- y) = y
    constructor Either :71: (_x9 :72: Type) -> (_x10 :73: Type) -> Type
    constructor Left :74: (a :75: Type) -> (b :76: Type) -> (_x11 :77: a) -> Either -79- a -78- b
    constructor Right :80: (a :81: Type) -> (b :82: Type) -> (_x12 :83: b) -> Either -85- a -84- b
    id :86: (a :87: Type) -> (x :88: a) -> a = (\a :89: Type. (\x :90: a. x))
    constructor Fin :91: (_x13 :92: Nat) -> Type
    constructor FZ :93: (n :94: Nat) -> Fin -95- (S -96- n)
    constructor FS :97: (n :98: Nat) -> (_x14 :99: Fin -100- n) -> Fin -101- (S -102- n)
    constructor Vect :103: (_x15 :104: Nat) -> (_x16 :105: Type) -> Type
    constructor VN :106: (a :107: Type) -> Vect -109- Z -108- a
    constructor VC :110: (n :111: Nat) -> (a :112: Type) -> (x :113: a) -> (xs :114: Vect -116- n -115- a) -> Vect -118- (S -119- n) -117- a
    constructor Id :120: (a :121: Type) -> (x :122: a) -> (y :123: a) -> Type
    constructor Refl :124: (a :125: Type) -> (x :126: a) -> Id -129- a -128- x -127- x
    subst :130: (a :131: Type) -> (P :132: (_x0 :133: a) -> Type) -> (x :134: a) -> (y :135: a) -> (eq :136: Id -139- a -138- x -137- y) -> (_x1 :140: P -141- x) -> P -142- y 
      a :143: Type P :144: (_x2 :145: a) -> Type x :146: a
        [subst] -151- a -150- P -149- x -148- [x] -147- [Refl -153- a -152- x] = (\z :154: P -155- x. z)
    constructor Bit :156: (_x0 :157: Nat) -> Type
    constructor I :158: Bit -159- 1
    constructor O :161: Bit -162- Z
    double :163: (_x1 :164: Nat) -> Nat 
      [double] -165- Z = Z
      n :166: Nat
        [double] -167- (S -168- n) = S -169- (S -170- (double -171- n))
    constructor Bin :172: (width :173: Nat) -> (value :174: Nat) -> Type
    constructor N :175: Bin -177- Z -176- Z
    constructor C :178: (width :179: Nat) -> (lsbVal :180: Nat) -> (lsb :181: Bit -182- lsbVal) -> (restVal :183: Nat) -> (rest :R: Bin -185- width -184- restVal) -> Bin -187- (S -188- width) -186- (plus -190- lsbVal -189- (double -191- restVal))
    constructor TwoBits :192: (_x2 :193: Nat) -> (_x3 :194: Nat) -> (_x4 :195: Nat) -> Type
    constructor TB :196: (c :197: Nat) -> (x :198: Nat) -> (y :199: Nat) -> (hi' :200: Nat) -> (hi :201: Bit -202- hi') -> (lo' :203: Nat) -> (lo :204: Bit -205- lo') -> (pf :206: Id -209- Nat -208- (plus -211- c -210- (plus -213- x -212- y)) -207- (plus -215- lo' -214- (double -216- hi'))) -> TwoBits -219- c -218- x -217- y
    adb :220: (c :221: Nat) -> (x :222: Nat) -> (y :223: Nat) -> (_x5 :224: Bit -225- c) -> (_x6 :226: Bit -227- x) -> (_x7 :228: Bit -229- y) -> TwoBits -232- c -231- x -230- y 
      [adb] -238- [Z] -237- [Z] -236- [Z] -235- O -234- O -233- O = TB -246- Z -245- Z -244- Z -243- Z -242- O -241- Z -240- O -239- (Refl -248- Nat -247- Z)
      [adb] -254- [1] -253- [Z] -252- [Z] -251- I -250- O -249- O = TB -263- 1 -262- Z -261- Z -260- Z -259- O -258- 1 -257- I -256- (Refl -267- Nat -266- 1)
      [adb] -274- [Z] -273- [1] -272- [Z] -271- O -270- I -269- O = TB -283- Z -282- 1 -281- Z -280- Z -279- O -278- 1 -277- I -276- (Refl -287- Nat -286- 1)
      [adb] -294- [Z] -293- [Z] -292- [1] -291- O -290- O -289- I = TB -303- Z -302- Z -301- 1 -300- Z -299- O -298- 1 -297- I -296- (Refl -307- Nat -306- 1)
      [adb] -314- [1] -313- [1] -312- [Z] -311- I -310- I -309- O = TB -324- 1 -323- 1 -322- Z -321- 1 -320- I -319- Z -318- O -317- (Refl -329- Nat -328- 2)
      [adb] -337- [1] -336- [Z] -335- [1] -334- I -333- O -332- I = TB -347- 1 -346- Z -345- 1 -344- 1 -343- I -342- Z -341- O -340- (Refl -352- Nat -351- 2)
      [adb] -360- [Z] -359- [1] -358- [1] -357- O -356- I -355- I = TB -370- Z -369- 1 -368- 1 -367- 1 -366- I -365- Z -364- O -363- (Refl -375- Nat -374- 2)
      [adb] -383- [1] -382- [1] -381- [1] -380- I -379- I -378- I = TB -394- 1 -393- 1 -392- 1 -391- 1 -390- I -389- 1 -388- I -387- (Refl -401- Nat -400- 3)
    add' :405: (w :406: Nat) -> (c :407: Nat) -> (x :408: Nat) -> (y :409: Nat) -> (_x8 :410: Bit -411- c) -> (_x9 :412: Bin -414- w -413- x) -> (_x10 :415: Bin -417- w -416- y) -> Bin -419- (S -420- w) -418- (plus -422- c -421- (plus -424- x -423- y)) 
      c :425: Nat cb :426: Bit -427- c
        [add'] -434- [Z] -433- c -432- [Z] -431- [Z] -430- cb -429- N -428- N = C -439- Z -438- c -437- cb -436- Z -435- N
      w :440: Nat c :441: Nat cb :442: Bit -443- c xb' :444: Nat xb :445: Bit -446- xb' xn' :447: Nat xn :448: Bin -450- w -449- xn' yb' :451: Nat yb :452: Bit -453- yb' yn' :454: Nat yn :455: Bin -457- w -456- yn'
        [add'] -464- ([S] -465- w) -463- c -462- [plus -467- xb' -466- (double -468- xn')] -461- [plus -470- yb' -469- (double -471- yn')] -460- cb -459- (C -476- [w] -475- xb' -474- xb -473- xn' -472- xn) -458- (C -481- [w] -480- yb' -479- yb -478- yn' -477- yn) = 
          let f :482: (_x11 :483: TwoBits -486- c -485- xb' -484- yb') -> Bin -488- (S -489- (S -490- w)) -487- (plus -492- c -491- (plus -494- (plus -496- xb' -495- (double -497- xn')) -493- (plus -499- yb' -498- (double -500- yn')))) 
            hi' :501: Nat hi :502: Bit -503- hi' lo' :504: Nat lo :505: Bit -506- lo' pf :507: Id -510- Nat -509- (plus -512- c -511- (plus -514- xb' -513- yb')) -508- (plus -516- lo' -515- (double -517- hi'))
              [f] -518- ([TB] -526- [c] -525- [xb'] -524- [yb'] -523- hi' -522- hi -521- lo' -520- lo -519- pf) = 
                let postulate eq :527: Id -530- Nat -529- (plus -532- lo' -531- (double -533- (plus -535- hi' -534- (plus -537- xn' -536- yn')))) -528- (plus -539- c -538- (plus -541- (plus -543- xb' -542- (double -544- xn')) -540- (plus -546- yb' -545- (double -547- yn'))))
                in subst -553- Nat -552- (Bin -554- (S -555- (S -556- w))) -551- (plus -558- lo' -557- (double -559- (plus -561- hi' -560- (plus -563- xn' -562- yn')))) -550- (plus -565- c -564- (plus -567- (plus -569- xb' -568- (double -570- xn')) -566- (plus -572- yb' -571- (double -573- yn')))) -549- eq -548- (C -578- (S -579- w) -577- lo' -576- lo -575- (plus -581- hi' -580- (plus -583- xn' -582- yn')) -574- (add' -590- w -589- hi' -588- xn' -587- yn' -586- hi -585- xn -584- yn))
          in f -591- (adb -597- c -596- xb' -595- yb' -594- cb -593- xb -592- yb)
    add :598: (w :599: Nat) -> (x :600: Nat) -> (y :601: Nat) -> (bx :602: Bin -604- w -603- x) -> (by :605: Bin -607- w -606- y) -> Bin -609- (S -610- w) -608- (plus -612- x -611- y) = (\w :613: Nat. (\x :614: Nat. (\y :615: Nat. (\bx :616: Bin -618- w -617- x. (\by :619: Bin -621- w -620- y. add' -628- w -627- Z -626- x -625- y -624- O -623- bx -622- by)))))
    foreign inputSize :629: Nat
    binVal :630: (_x12 :631: Bool) -> (_x13 :632: Nat) -> Nat 
      b :633: Bool
        [binVal] -635- b -634- Z = Z
      n :636: Nat
        [binVal] -638- True -637- (S -639- n) = S -640- (double -641- (binVal -643- False -642- n))
      n :644: Nat
        [binVal] -646- False -645- (S -647- n) = double -648- (binVal -650- True -649- n)
    mkBin :651: (b :652: Bool) -> (w :653: Nat) -> Bin -655- w -654- (binVal -657- b -656- w) 
      b :658: Bool
        [mkBin] -660- b -659- Z = N
      n :661: Nat
        [mkBin] -663- True -662- (S -664- n) = C -669- n -668- 1 -667- I -666- (binVal -672- False -671- n) -665- (mkBin -674- False -673- n)
      n :675: Nat
        [mkBin] -677- False -676- (S -678- n) = C -683- n -682- Z -681- O -680- (binVal -685- True -684- n) -679- (mkBin -687- True -686- n)
    main :688: Bin -690- (S -691- inputSize) -689- (plus -693- (binVal -695- True -694- inputSize) -692- (binVal -697- False -696- inputSize)) = 
      let
        x :698: Bin -700- inputSize -699- (binVal -702- True -701- inputSize) = mkBin -704- True -703- inputSize
        y :705: Bin -707- inputSize -706- (binVal -709- False -708- inputSize) = mkBin -711- False -710- inputSize
      in add -716- inputSize -715- (binVal -718- True -717- inputSize) -714- (binVal -720- False -719- inputSize) -713- x -712- y
  in main

### Constraints ###

[] -> [2,3,19,20,130,140,154,175,178,188,405,406,412,415,420,428,429,434,435,440,448,455,458,459,464,465,472,477,482,489,490,548,555,556,574,579,584,585,590,598,599,602,605,610,613,616,619,622,623,628,629,651,652,653,659,660,661,662,663,664,665,673,674,675,676,677,678,679,686,687,691,698,703,704,705,710,711,712,713,716,R]
[5,461] -> [470]
[5,462] -> [467]
[5,550] -> [565]
[5,550,564] -> [567]
[5,550,564,566] -> [572]
[5,550,564,567] -> [569]
[5,551] -> [558]
[5,551,557,559] -> [561]
[5,551,557,559,560] -> [563]
[5,575] -> [581]
[5,575,580] -> [583]
[6,461] -> [469]
[6,462] -> [466]
[6,550] -> [564]
[6,550,564] -> [566]
[6,550,564,566] -> [571]
[6,550,564,567] -> [568]
[6,551] -> [557]
[6,551,557,559] -> [560]
[6,551,557,559,560] -> [562]
[6,575] -> [580]
[6,575,580] -> [582]
[15] -> [640]
[15,256,591] -> [268]
[15,276,591] -> [288]
[15,296,591] -> [308]
[15,317,591] -> [330,331]
[15,340,591] -> [353]
[15,363,591] -> [376]
[15,387,591] -> [402,403]
[125,147] -> [153]
[125,239,591] -> [248]
[125,256,591] -> [267]
[125,276,591] -> [287]
[125,296,591] -> [307]
[125,317,591] -> [329]
[125,340,591] -> [352]
[125,363,591] -> [375]
[125,387,591] -> [401]
[126,147] -> [152]
[126,239,591] -> [247]
[126,256,591] -> [266]
[126,276,591] -> [286]
[126,296,591] -> [306]
[126,317,591] -> [328]
[126,340,591] -> [351]
[126,363,591] -> [374]
[126,387,591] -> [400]
[127,147] -> [137]
[127,239,591] -> [207]
[127,256,591] -> [207]
[127,276,591] -> [207]
[127,296,591] -> [207]
[127,317,591] -> [207]
[127,340,591] -> [207]
[127,363,591] -> [207]
[127,387,591] -> [207]
[128,147] -> [138]
[128,239,591] -> [208]
[128,256,591] -> [208]
[128,276,591] -> [208]
[128,296,591] -> [208]
[128,317,591] -> [208]
[128,340,591] -> [208]
[128,363,591] -> [208]
[128,387,591] -> [208]
[129,147] -> [139]
[129,239,591] -> [209]
[129,256,591] -> [209]
[129,276,591] -> [209]
[129,296,591] -> [209]
[129,317,591] -> [209]
[129,340,591] -> [209]
[129,363,591] -> [209]
[129,387,591] -> [209]
[131] -> [151,553]
[132] -> [150,552]
[133,150] -> [145]
[133,552] -> [174]
[134] -> [149,551]
[135] -> [148,550]
[136] -> [147,549]
[137,147] -> [127]
[137,549] -> [528]
[138,147] -> [128]
[138,549] -> [529]
[139,147] -> [129]
[139,549] -> [530]
[141] -> [155,186]
[142] -> [155,487]
[143] -> [151]
[144] -> [150]
[145,150] -> [133]
[146] -> [149]
[147] -> [124,136]
[147,152] -> [126,146]
[147,153] -> [125,143]
[148] -> [135,146]
[149] -> [134]
[150] -> [132]
[151] -> [131]
[155] -> [141,142]
[159,257,591] -> [205]
[159,277,591] -> [205]
[159,297,591] -> [205]
[159,320,591] -> [202]
[159,343,591] -> [202]
[159,366,591] -> [202]
[159,388,591] -> [205]
[159,390,591] -> [202]
[159,591] -> [225,227,229]
[159,667] -> [182]
[160,257,591] -> [265]
[160,277,591] -> [285]
[160,297,591] -> [305]
[160,320,591] -> [327]
[160,343,591] -> [350]
[160,366,591] -> [373]
[160,388,591] -> [399]
[160,390,591] -> [398]
[160,591] -> [255,275,295,315,316,338,339,361,362,384,385,386]
[160,667] -> [670]
[162,240,591] -> [205]
[162,242,591] -> [202]
[162,259,591] -> [202]
[162,279,591] -> [202]
[162,299,591] -> [202]
[162,318,591] -> [205]
[162,341,591] -> [205]
[162,364,591] -> [205]
[162,591] -> [225,227,229]
[162,624] -> [411]
[162,681] -> [182]
[164,461,469] -> [471]
[164,462,466] -> [468]
[164,550,564,566,571] -> [573]
[164,550,564,567,568] -> [570]
[164,551,557] -> [559]
[169,317,591] -> [330]
[169,340,591] -> [353]
[169,363,591] -> [376]
[169,387,591] -> [403]
[170,317,591] -> [331]
[170,340,591] -> [354]
[170,363,591] -> [377]
[170,387,591] -> [404]
[173,552] -> [554]
[174,552] -> [133]
[176] -> [184,413,416,654]
[177] -> [185,414,417,655]
[179] -> [439,476,481,578,669,683]
[180] -> [438,475,480,577,668,682]
[181] -> [437,474,479,576,667,681]
[182,437] -> [427]
[182,474] -> [446]
[182,479] -> [453]
[182,576] -> [506]
[182,667] -> [159]
[182,681] -> [162]
[183] -> [436,473,478,575,666,680]
[184] -> [176,418,449,456,654]
[185] -> [177,419,450,457,655]
[186] -> [141,413,416,418,654]
[187] -> [414,417,419,554,655]
[189] -> [421,466,469,557]
[190] -> [422,467,470,558]
[191] -> [468,471,559,641,648]
[197,518] -> [526]
[197,591] -> [246,263,283,303,324,347,370,394]
[198,518] -> [525]
[198,591] -> [245,262,282,302,323,346,369,393]
[199,518] -> [524]
[199,591] -> [244,261,281,301,322,345,368,392]
[200,518] -> [523]
[200,591] -> [243,260,280,300,321,344,367,391]
[201,518] -> [522]
[201,591] -> [242,259,279,299,320,343,366,390]
[202,242,591] -> [162]
[202,259,591] -> [162]
[202,279,591] -> [162]
[202,299,591] -> [162]
[202,320,591] -> [159]
[202,343,591] -> [159]
[202,366,591] -> [159]
[202,390,591] -> [159]
[202,522] -> [503]
[203,518] -> [521]
[203,591] -> [241,258,278,298,319,342,365,389]
[204,518] -> [520]
[204,591] -> [240,257,277,297,318,341,364,388]
[205,240,591] -> [162]
[205,257,591] -> [159]
[205,277,591] -> [159]
[205,297,591] -> [159]
[205,318,591] -> [162]
[205,341,591] -> [162]
[205,364,591] -> [162]
[205,388,591] -> [159]
[205,520] -> [506]
[206,518] -> [519]
[206,591] -> [239,256,276,296,317,340,363,387]
[207,239,591] -> [127]
[207,256,591] -> [127]
[207,276,591] -> [127]
[207,296,591] -> [127]
[207,317,591] -> [127]
[207,340,591] -> [127]
[207,363,591] -> [127]
[207,387,591] -> [127]
[207,519] -> [508]
[208,239,591] -> [128]
[208,256,591] -> [128]
[208,276,591] -> [128]
[208,296,591] -> [128]
[208,317,591] -> [128]
[208,340,591] -> [128]
[208,363,591] -> [128]
[208,387,591] -> [128]
[208,519] -> [509]
[209,239,591] -> [129]
[209,256,591] -> [129]
[209,276,591] -> [129]
[209,296,591] -> [129]
[209,317,591] -> [129]
[209,340,591] -> [129]
[209,363,591] -> [129]
[209,387,591] -> [129]
[209,519] -> [510]
[210,519] -> [511]
[211,519] -> [512]
[212,519] -> [513]
[213,519] -> [514]
[214,519] -> [515]
[215,519] -> [516]
[216,519] -> [517]
[217,518] -> [484]
[217,591] -> [230]
[218,518] -> [485]
[218,591] -> [231]
[219,518] -> [486]
[219,591] -> [232]
[221,591] -> [238,254,274,294,314,337,360,383,597]
[222,591] -> [237,253,273,293,313,336,359,382,596]
[223,591] -> [236,252,272,292,312,335,358,381,595]
[224,591] -> [594]
[225,591] -> [159,162]
[225,591,594] -> [443]
[226,591] -> [593]
[227,591] -> [159,162]
[227,591,593] -> [446]
[228,591] -> [592]
[229,591] -> [159,162]
[229,591,592] -> [453]
[230,591] -> [217,484]
[231,591] -> [218,485]
[232,591] -> [219,486]
[236,591] -> [223]
[237,591] -> [222]
[238,591] -> [221]
[239,247,591] -> [126]
[239,248,591] -> [1,125]
[239,591] -> [124,206]
[240,591] -> [204]
[241,591] -> [203]
[242,591] -> [201]
[243,591] -> [200]
[244,591] -> [199]
[245,591] -> [198]
[246,591] -> [197]
[252,591] -> [223]
[253,591] -> [222]
[254,591] -> [221,255]
[255,591] -> [160,264]
[256,266,591] -> [126,268]
[256,267,591] -> [1,125]
[256,268,591] -> [15]
[256,591] -> [124,206]
[257,265,591] -> [160]
[257,591] -> [204]
[258,591] -> [203,265]
[259,591] -> [201]
[260,591] -> [200]
[261,591] -> [199]
[262,591] -> [198]
[263,591] -> [197,264]
[264,591] -> [255]
[272,591] -> [223]
[273,591] -> [222,275]
[274,591] -> [221]
[275,591] -> [160,284]
[276,286,591] -> [126,288]
[276,287,591] -> [1,125]
[276,288,591] -> [15]
[276,591] -> [124,206]
[277,285,591] -> [160]
[277,591] -> [204]
[278,591] -> [203,285]
[279,591] -> [201]
[280,591] -> [200]
[281,591] -> [199]
[282,591] -> [198,284]
[283,591] -> [197]
[284,591] -> [275]
[292,591] -> [223,295]
[293,591] -> [222]
[294,591] -> [221]
[295,591] -> [160,304]
[296,304,591] -> [308]
[296,306,591] -> [126,308]
[296,307,591] -> [1,125]
[296,308,591] -> [15,304]
[296,591] -> [124,206]
[297,305,591] -> [160]
[297,591] -> [204]
[298,591] -> [203,305]
[299,591] -> [201]
[300,591] -> [200]
[301,591] -> [199,304]
[302,591] -> [198]
[303,591] -> [197]
[304,591] -> [295]
[312,591] -> [223]
[313,591] -> [222,316]
[314,591] -> [221,315]
[315,591] -> [160,325]
[316,591] -> [160,326]
[317,328,330,591] -> [331]
[317,328,591] -> [126,330]
[317,329,591] -> [1,125]
[317,330,591] -> [15,169]
[317,331,591] -> [15,170]
[317,591] -> [124,206]
[318,591] -> [204]
[319,591] -> [203]
[320,327,591] -> [160]
[320,591] -> [201]
[321,591] -> [200,327]
[322,591] -> [199]
[323,591] -> [198,326]
[324,591] -> [197,325]
[325,591] -> [315]
[326,591] -> [316]
[335,591] -> [223,339]
[336,591] -> [222]
[337,591] -> [221,338]
[338,591] -> [160,348]
[339,591] -> [160,349]
[340,349,591] -> [354]
[340,351,353,591] -> [354]
[340,351,591] -> [126,353]
[340,352,591] -> [1,125]
[340,353,591] -> [15,169]
[340,354,591] -> [170,349]
[340,591] -> [124,206]
[341,591] -> [204]
[342,591] -> [203]
[343,350,591] -> [160]
[343,591] -> [201]
[344,591] -> [200,350]
[345,591] -> [199,349]
[346,591] -> [198]
[347,591] -> [197,348]
[348,591] -> [338]
[349,591] -> [339]
[358,591] -> [223,362]
[359,591] -> [222,361]
[360,591] -> [221]
[361,591] -> [160,371]
[362,591] -> [160,372]
[363,372,591] -> [377]
[363,374,376,591] -> [377]
[363,374,591] -> [126,376]
[363,375,591] -> [1,125]
[363,376,591] -> [15,169]
[363,377,591] -> [170,372]
[363,591] -> [124,206]
[364,591] -> [204]
[365,591] -> [203]
[366,373,591] -> [160]
[366,591] -> [201]
[367,591] -> [200,373]
[368,591] -> [199,372]
[369,591] -> [198,371]
[370,591] -> [197]
[371,591] -> [361]
[372,591] -> [362]
[381,591] -> [223,386]
[382,591] -> [222,385]
[383,591] -> [221,384]
[384,591] -> [160,395]
[385,591] -> [160,396]
[386,591] -> [160,397]
[387,397,591] -> [404]
[387,400,402,403,591] -> [404]
[387,400,402,591] -> [403]
[387,400,591] -> [126,402]
[387,401,591] -> [1,125]
[387,402,591] -> [15]
[387,403,591] -> [15,169]
[387,404,591] -> [170,397]
[387,591] -> [124,206]
[388,399,591] -> [160]
[388,591] -> [204]
[389,591] -> [203,399]
[390,398,591] -> [160]
[390,591] -> [201]
[391,591] -> [200,398]
[392,591] -> [199,397]
[393,591] -> [198,396]
[394,591] -> [197,395]
[395,591] -> [384]
[396,591] -> [385]
[397,591] -> [386]
[407] -> [433,463,589,627]
[408] -> [432,462,588,626]
[409] -> [431,461,587,625]
[410] -> [430,460,586,624]
[411,430] -> [427]
[411,460] -> [443]
[411,586] -> [503]
[411,624] -> [162]
[413] -> [176,186,449,617]
[414] -> [177,187,450,618]
[416] -> [176,186,456,620]
[417] -> [177,187,457,621]
[418] -> [184,186,487,608]
[419] -> [185,187,488,609]
[421] -> [189,491,580]
[422] -> [190,492,581]
[423] -> [493,582,611]
[424] -> [494,583,612]
[425] -> [433]
[426] -> [430]
[427,430] -> [411]
[427,437] -> [182]
[430] -> [410]
[431] -> [409]
[432] -> [408]
[433] -> [407]
[436] -> [183]
[437] -> [181,426]
[438] -> [180,425]
[439] -> [179]
[441] -> [463]
[442] -> [460]
[443,460] -> [411]
[443,591,594] -> [225]
[444] -> [475]
[445] -> [474]
[446,474] -> [182]
[446,591,593] -> [227]
[447] -> [473]
[449] -> [184,413]
[450] -> [185,414]
[451] -> [480]
[452] -> [479]
[453,479] -> [182]
[453,591,592] -> [229]
[454] -> [478]
[456] -> [184,416]
[457] -> [185,417]
[460] -> [410]
[461] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,409]
[461,469] -> [6,163,164,165,166,167,168,169,170,171]
[461,469,471] -> [164,454]
[461,470] -> [5,451]
[462] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,408]
[462,466] -> [6,163,164,165,166,167,168,169,170,171]
[462,466,468] -> [164,447]
[462,467] -> [5,444]
[463] -> [407]
[466] -> [189,495]
[467] -> [190,496]
[468] -> [191,497]
[469] -> [189,498]
[470] -> [190,499]
[471] -> [191,500]
[473] -> [183]
[474] -> [181]
[475] -> [180]
[476] -> [179]
[478] -> [183]
[479] -> [181]
[480] -> [180]
[481] -> [179]
[483] -> [518,591]
[484,518] -> [217]
[484,591] -> [230]
[485,518] -> [218]
[485,591] -> [231]
[486,518] -> [219]
[486,591] -> [232]
[487] -> [142,418]
[488] -> [419,554]
[491] -> [421,564]
[492] -> [422,565]
[493] -> [423,566]
[494] -> [424,567]
[495] -> [466,568]
[496] -> [467,569]
[497] -> [468,570]
[498] -> [469,571]
[499] -> [470,572]
[500] -> [471,573]
[501] -> [523]
[502] -> [522]
[503,522] -> [202]
[503,586] -> [411]
[504] -> [521]
[505] -> [520]
[506,520] -> [205]
[506,576] -> [182]
[507] -> [519]
[508,519] -> [207]
[509,519] -> [208]
[510,519] -> [209]
[511,519] -> [210]
[512,519] -> [211]
[513,519] -> [212]
[514,519] -> [213]
[515,519] -> [214]
[516,519] -> [215]
[517,519] -> [216]
[518] -> [196,483]
[518,519] -> [206]
[518,520] -> [204]
[518,521] -> [203]
[518,522] -> [201]
[518,523] -> [200]
[518,524] -> [199]
[518,525] -> [198]
[518,526] -> [197]
[519] -> [518]
[520] -> [518]
[521] -> [518]
[522] -> [518]
[523] -> [518]
[524] -> [451,518]
[525] -> [444,518]
[526] -> [441,518]
[528,549] -> [137]
[529,549] -> [138]
[530,549] -> [139]
[531,549] -> [557]
[532,549] -> [558]
[533,549] -> [559]
[534,549] -> [560]
[535,549] -> [561]
[536,549] -> [562]
[537,549] -> [563]
[538,549] -> [564]
[539,549] -> [565]
[540,549] -> [566]
[541,549] -> [567]
[542,549] -> [568]
[543,549] -> [569]
[544,549] -> [570]
[545,549] -> [571]
[546,549] -> [572]
[547,549] -> [573]
[549] -> [136,527]
[549,557] -> [531]
[549,558] -> [532]
[549,559] -> [533]
[549,560] -> [534]
[549,561] -> [535]
[549,562] -> [536]
[549,563] -> [537]
[549,564] -> [538]
[549,565] -> [539]
[549,566] -> [540]
[549,567] -> [541]
[549,568] -> [542]
[549,569] -> [543]
[549,570] -> [544]
[549,571] -> [545]
[549,572] -> [546]
[549,573] -> [547]
[550] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,135]
[550,564] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17]
[550,564,566] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17]
[550,564,566,571] -> [6,163,164,165,166,167,168,169,170,171]
[550,564,566,571,573] -> [164,454]
[550,564,566,572] -> [5,451]
[550,564,567] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17]
[550,564,567,568] -> [6,163,164,165,166,167,168,169,170,171]
[550,564,567,568,570] -> [164,447]
[550,564,567,569] -> [5,444]
[550,565] -> [5,441]
[551] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,134]
[551,557] -> [6,163,164,165,166,167,168,169,170,171]
[551,557,559] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,164]
[551,557,559,560] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17]
[551,557,559,560,562] -> [6,454]
[551,557,559,560,563] -> [5,447]
[551,557,559,561] -> [5,501]
[551,558] -> [5,504]
[552] -> [132,172]
[552,554] -> [173]
[553] -> [1,131]
[554] -> [187,488]
[557] -> [189]
[558] -> [190]
[559] -> [191]
[560] -> [580]
[561] -> [581]
[562] -> [582]
[563] -> [583]
[564] -> [491]
[565] -> [492]
[566] -> [493]
[567] -> [494]
[568] -> [495]
[569] -> [496]
[570] -> [497]
[571] -> [498]
[572] -> [499]
[573] -> [500]
[575] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,183]
[575,580] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17]
[575,580,582] -> [6,454]
[575,580,583] -> [5,447]
[575,581] -> [5,501]
[576] -> [181,505]
[577] -> [180,504]
[578] -> [179]
[580] -> [421,560]
[581] -> [422,561]
[582] -> [423,562]
[583] -> [424,563]
[586] -> [410,502]
[587] -> [409,454]
[588] -> [408,447]
[589] -> [407,501]
[591] -> [158,161,196,220,224,226,228,233,234,235,249,250,251,269,270,271,289,290,291,309,310,311,332,333,334,355,356,357,378,379,380,483]
[591,592] -> [228,452]
[591,593] -> [226,445]
[591,594] -> [224,442]
[591,595] -> [223,451]
[591,596] -> [222,444]
[591,597] -> [221,441]
[600] -> [614,715]
[601] -> [615,714]
[603] -> [617,699]
[604] -> [618,700]
[606] -> [620,706]
[607] -> [621,707]
[608] -> [418,689]
[609] -> [419,690]
[611] -> [423,692]
[612] -> [424,693]
[614] -> [600]
[615] -> [601]
[617] -> [413,603]
[618] -> [414,604]
[620] -> [416,606]
[621] -> [417,607]
[624] -> [161,410]
[625] -> [409,615]
[626] -> [408,614]
[627] -> [407]
[631,666] -> [672]
[631,680] -> [685]
[631,714] -> [720]
[631,715] -> [718]
[632,666] -> [671]
[632,680] -> [684]
[632,714] -> [719]
[632,715] -> [717]
[640] -> [15]
[641] -> [191]
[642] -> [671]
[643] -> [672]
[648] -> [191]
[649] -> [684]
[650] -> [685]
[654] -> [176,184,186,699,706]
[655] -> [177,185,187,700,707]
[656] -> [671,684,701,708]
[657] -> [672,685,702,709]
[666] -> [163,164,165,166,167,168,169,170,171,183,630,631,632,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650]
[666,671] -> [632]
[666,672] -> [631]
[667] -> [158,181]
[667,670] -> [160]
[668] -> [180,670]
[669] -> [179]
[671] -> [642,656]
[672] -> [643,657]
[680] -> [163,164,165,166,167,168,169,170,171,183,630,631,632,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650]
[680,684] -> [632]
[680,685] -> [631]
[681] -> [161,181]
[682] -> [180]
[683] -> [179]
[684] -> [649,656]
[685] -> [650,657]
[689] -> [608]
[690] -> [609]
[692] -> [611]
[693] -> [612]
[694] -> [717]
[695] -> [718]
[696] -> [719]
[697] -> [720]
[699] -> [603,654]
[700] -> [604,655]
[701] -> [656,717]
[702] -> [657,718]
[706] -> [606,654]
[707] -> [607,655]
[708] -> [656,719]
[709] -> [657,720]
[714] -> [163,164,165,166,167,168,169,170,171,601,630,631,632,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650]
[714,719] -> [632]
[714,720] -> [631]
[715] -> [163,164,165,166,167,168,169,170,171,600,630,631,632,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650]
[715,717] -> [632]
[715,718] -> [631]
[717] -> [694,701]
[718] -> [695,702]
[719] -> [696,708]
[720] -> [697,709]
[R] -> [688]

### Solution ###

[2,3,19,20,130,140,154,175,178,188,405,406,412,415,420,428,429,434,435,440,448,455,458,459,464,465,472,477,482,489,490,548,555,556,574,579,584,585,590,598,599,602,605,610,613,616,619,622,623,628,629,651,652,653,659,660,661,662,663,664,665,673,674,675,676,677,678,679,686,687,688,691,698,703,704,705,710,711,712,713,716,R]

### Annotated ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x13 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x14 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x15 :E: Nat) -> (_x16 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        [subst] -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :E: Bit -E- 1
    constructor O :E: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      [double] -E- Z = Z
      n :E: Nat
        [double] -E- (S -E- n) = S -E- (S -E- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :E: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :E: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :E: Bit -E- hi') -> (lo' :E: Nat) -> (lo :E: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :E: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :E: Bit -E- c) -> (_x6 :E: Bit -E- x) -> (_x7 :E: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      [adb] -E- [Z] -E- [Z] -E- [Z] -E- O -E- O -E- O = TB -E- Z -E- Z -E- Z -E- Z -E- O -E- Z -E- O -E- (Refl -E- Nat -E- Z)
      [adb] -E- [1] -E- [Z] -E- [Z] -E- I -E- O -E- O = TB -E- 1 -E- Z -E- Z -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [1] -E- [Z] -E- O -E- I -E- O = TB -E- Z -E- 1 -E- Z -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [Z] -E- [1] -E- O -E- O -E- I = TB -E- Z -E- Z -E- 1 -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [1] -E- [1] -E- [Z] -E- I -E- I -E- O = TB -E- 1 -E- 1 -E- Z -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [Z] -E- [1] -E- I -E- O -E- I = TB -E- 1 -E- Z -E- 1 -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [Z] -E- [1] -E- [1] -E- O -E- I -E- I = TB -E- Z -E- 1 -E- 1 -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [1] -E- [1] -E- I -E- I -E- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -E- I -E- 1 -E- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :R: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :E: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :E: Bit -E- c
        [add'] -R- [Z] -E- c -E- [Z] -E- [Z] -E- cb -R- N -R- N = C -E- Z -E- c -E- cb -E- Z -R- N
      w :R: Nat c :E: Nat cb :E: Bit -E- c xb' :E: Nat xb :E: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :E: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        [add'] -R- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -E- cb -R- (C -E- [w] -E- xb' -E- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -E- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :E: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :E: Bit -E- hi' lo' :E: Nat lo :E: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              [f] -E- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -E- hi -E- lo' -E- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -E- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -R- w -E- hi' -E- xn' -E- yn' -E- hi -R- xn -R- yn))
          in f -E- (adb -E- c -E- xb' -E- yb' -E- cb -E- xb -E- yb)
    add :R: (w :R: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :R: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -R- w -E- Z -E- x -E- y -E- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        [binVal] -E- b -E- Z = Z
      n :E: Nat
        [binVal] -E- True -E- (S -E- n) = S -E- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        [binVal] -E- False -E- (S -E- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :E: Bool
        [mkBin] -R- b -R- Z = N
      n :R: Nat
        [mkBin] -R- True -R- (S -R- n) = C -E- n -E- 1 -E- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        [mkBin] -R- False -R- (S -R- n) = C -E- n -E- Z -E- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -R- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Specialised ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x13 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x14 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x15 :E: Nat) -> (_x16 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        [subst] -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :E: Bit -E- 1
    constructor O :E: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      [double] -E- Z = Z
      n :E: Nat
        [double] -E- (S -E- n) = S -E- (S -E- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :E: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :E: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :E: Bit -E- hi') -> (lo' :E: Nat) -> (lo :E: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :E: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :E: Bit -E- c) -> (_x6 :E: Bit -E- x) -> (_x7 :E: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      [adb] -E- [Z] -E- [Z] -E- [Z] -E- O -E- O -E- O = TB -E- Z -E- Z -E- Z -E- Z -E- O -E- Z -E- O -E- (Refl -E- Nat -E- Z)
      [adb] -E- [1] -E- [Z] -E- [Z] -E- I -E- O -E- O = TB -E- 1 -E- Z -E- Z -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [1] -E- [Z] -E- O -E- I -E- O = TB -E- Z -E- 1 -E- Z -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [Z] -E- [1] -E- O -E- O -E- I = TB -E- Z -E- Z -E- 1 -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [1] -E- [1] -E- [Z] -E- I -E- I -E- O = TB -E- 1 -E- 1 -E- Z -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [Z] -E- [1] -E- I -E- O -E- I = TB -E- 1 -E- Z -E- 1 -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [Z] -E- [1] -E- [1] -E- O -E- I -E- I = TB -E- Z -E- 1 -E- 1 -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [1] -E- [1] -E- I -E- I -E- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -E- I -E- 1 -E- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :R: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :E: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :E: Bit -E- c
        [add'] -R- [Z] -E- c -E- [Z] -E- [Z] -E- cb -R- N -R- N = C -E- Z -E- c -E- cb -E- Z -R- N
      w :R: Nat c :E: Nat cb :E: Bit -E- c xb' :E: Nat xb :E: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :E: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        [add'] -R- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -E- cb -R- (C -E- [w] -E- xb' -E- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -E- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :E: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :E: Bit -E- hi' lo' :E: Nat lo :E: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              [f] -E- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -E- hi -E- lo' -E- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -E- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -R- w -E- hi' -E- xn' -E- yn' -E- hi -R- xn -R- yn))
          in f -E- (adb -E- c -E- xb' -E- yb' -E- cb -E- xb -E- yb)
    add :R: (w :R: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :R: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -R- w -E- Z -E- x -E- y -E- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        [binVal] -E- b -E- Z = Z
      n :E: Nat
        [binVal] -E- True -E- (S -E- n) = S -E- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        [binVal] -E- False -E- (S -E- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :E: Bool
        [mkBin] -R- b -R- Z = N
      n :R: Nat
        [mkBin] -R- True -R- (S -R- n) = C -E- n -E- 1 -E- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        [mkBin] -R- False -R- (S -R- n) = C -E- n -E- Z -E- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -R- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Final annotation ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x13 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x14 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x15 :E: Nat) -> (_x16 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        [subst] -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :E: Bit -E- 1
    constructor O :E: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      [double] -E- Z = Z
      n :E: Nat
        [double] -E- (S -E- n) = S -E- (S -E- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :E: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :E: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :E: Bit -E- hi') -> (lo' :E: Nat) -> (lo :E: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :E: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :E: Bit -E- c) -> (_x6 :E: Bit -E- x) -> (_x7 :E: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      [adb] -E- [Z] -E- [Z] -E- [Z] -E- O -E- O -E- O = TB -E- Z -E- Z -E- Z -E- Z -E- O -E- Z -E- O -E- (Refl -E- Nat -E- Z)
      [adb] -E- [1] -E- [Z] -E- [Z] -E- I -E- O -E- O = TB -E- 1 -E- Z -E- Z -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [1] -E- [Z] -E- O -E- I -E- O = TB -E- Z -E- 1 -E- Z -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [Z] -E- [1] -E- O -E- O -E- I = TB -E- Z -E- Z -E- 1 -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [1] -E- [1] -E- [Z] -E- I -E- I -E- O = TB -E- 1 -E- 1 -E- Z -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [Z] -E- [1] -E- I -E- O -E- I = TB -E- 1 -E- Z -E- 1 -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [Z] -E- [1] -E- [1] -E- O -E- I -E- I = TB -E- Z -E- 1 -E- 1 -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [1] -E- [1] -E- I -E- I -E- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -E- I -E- 1 -E- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :R: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :E: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :E: Bit -E- c
        [add'] -R- [Z] -E- c -E- [Z] -E- [Z] -E- cb -R- N -R- N = C -E- Z -E- c -E- cb -E- Z -R- N
      w :R: Nat c :E: Nat cb :E: Bit -E- c xb' :E: Nat xb :E: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :E: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        [add'] -R- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -E- cb -R- (C -E- [w] -E- xb' -E- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -E- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :E: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :E: Bit -E- hi' lo' :E: Nat lo :E: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              [f] -E- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -E- hi -E- lo' -E- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -E- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -R- w -E- hi' -E- xn' -E- yn' -E- hi -R- xn -R- yn))
          in f -E- (adb -E- c -E- xb' -E- yb' -E- cb -E- xb -E- yb)
    add :R: (w :R: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :R: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -R- w -E- Z -E- x -E- y -E- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        [binVal] -E- b -E- Z = Z
      n :E: Nat
        [binVal] -E- True -E- (S -E- n) = S -E- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        [binVal] -E- False -E- (S -E- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :E: Bool
        [mkBin] -R- b -R- Z = N
      n :R: Nat
        [mkBin] -R- True -R- (S -R- n) = C -E- n -E- 1 -E- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        [mkBin] -R- False -R- (S -R- n) = C -E- n -E- Z -E- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -R- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    subst = (\z. z)
    constructor N : Bin
    constructor C : (rest) -> Bin
    add' 
      [_] [_] N N = C N
      [_] ([_] w) (C xn) (C yn) = 
        let f = subst (C (add' w xn yn))
        in f
    add = (\w. (\bx. (\by. add' w bx by)))
    foreign inputSize
    mkBin 
      [_] _ Z = N
      [_] True (S n) = C (mkBin False n)
      [_] False (S n) = C (mkBin True n)
    main = 
      let
        x = mkBin True inputSize
        y = mkBin False inputSize
      in add inputSize x y
  in main

### Normal forms ###

unerased:
  
  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    subst : (a : Type) -> (P : (_x0 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (_x1 : P x) -> P y 
      a : Type P : (_x2 : a) -> Type x : a
        [subst] a P x [x] [Refl a x] = (\z : P x. z)
    constructor Bit : (_x0 : Nat) -> Type
    constructor I : Bit 1
    constructor O : Bit Z
    double : (_x1 : Nat) -> Nat 
      [double] Z = Z
      n : Nat
        [double] (S n) = S (S (double n))
    constructor Bin : (width : Nat) -> (value : Nat) -> Type
    constructor N : Bin Z Z
    constructor C : (width : Nat) -> (lsbVal : Nat) -> (lsb : Bit lsbVal) -> (restVal : Nat) -> (rest :R: Bin width restVal) -> Bin (S width) (plus lsbVal (double restVal))
    constructor TwoBits : (_x2 : Nat) -> (_x3 : Nat) -> (_x4 : Nat) -> Type
    constructor TB : (c : Nat) -> (x : Nat) -> (y : Nat) -> (hi' : Nat) -> (hi : Bit hi') -> (lo' : Nat) -> (lo : Bit lo') -> (pf : Id Nat (plus c (plus x y)) (plus lo' (double hi'))) -> TwoBits c x y
    adb : (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x5 : Bit c) -> (_x6 : Bit x) -> (_x7 : Bit y) -> TwoBits c x y 
      [adb] [Z] [Z] [Z] O O O = TB Z Z Z Z O Z O (Refl Nat Z)
      [adb] [1] [Z] [Z] I O O = TB 1 Z Z Z O 1 I (Refl Nat 1)
      [adb] [Z] [1] [Z] O I O = TB Z 1 Z Z O 1 I (Refl Nat 1)
      [adb] [Z] [Z] [1] O O I = TB Z Z 1 Z O 1 I (Refl Nat 1)
      [adb] [1] [1] [Z] I I O = TB 1 1 Z 1 I Z O (Refl Nat 2)
      [adb] [1] [Z] [1] I O I = TB 1 Z 1 1 I Z O (Refl Nat 2)
      [adb] [Z] [1] [1] O I I = TB Z 1 1 1 I Z O (Refl Nat 2)
      [adb] [1] [1] [1] I I I = TB 1 1 1 1 I 1 I (Refl Nat 3)
    add' : (w : Nat) -> (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x8 : Bit c) -> (_x9 : Bin w x) -> (_x10 : Bin w y) -> Bin (S w) (plus c (plus x y)) 
      c : Nat cb : Bit c
        [add'] [Z] c [Z] [Z] cb N N = C Z c cb Z N
      w : Nat c : Nat cb : Bit c xb' : Nat xb : Bit xb' xn' : Nat xn : Bin w xn' yb' : Nat yb : Bit yb' yn' : Nat yn : Bin w yn'
        [add'] ([S] w) c [plus xb' (double xn')] [plus yb' (double yn')] cb (C [w] xb' xb xn' xn) (C [w] yb' yb yn' yn) = 
          let f : (_x11 : TwoBits c xb' yb') -> Bin (S (S w)) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) 
            hi' : Nat hi : Bit hi' lo' : Nat lo : Bit lo' pf : Id Nat (plus c (plus xb' yb')) (plus lo' (double hi'))
              [f] ([TB] [c] [xb'] [yb'] hi' hi lo' lo pf) = 
                let postulate eq : Id Nat (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn'))))
                in subst Nat (Bin (S (S w))) (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) eq (C (S w) lo' lo (plus hi' (plus xn' yn')) (add' w hi' xn' yn' hi xn yn))
          in f (adb c xb' yb' cb xb yb)
    foreign inputSize : Nat
    binVal : (_x12 : Bool) -> (_x13 : Nat) -> Nat 
      b : Bool
        [binVal] b Z = Z
      n : Nat
        [binVal] True (S n) = S (double (binVal False n))
      n : Nat
        [binVal] False (S n) = double (binVal True n)
    mkBin : (b : Bool) -> (w : Nat) -> Bin w (binVal b w) 
      b : Bool
        [mkBin] b Z = N
      n : Nat
        [mkBin] True (S n) = C n 1 I (binVal False n) (mkBin False n)
      n : Nat
        [mkBin] False (S n) = C n Z O (binVal True n) (mkBin True n)
  in add' inputSize Z (binVal True inputSize) (binVal False inputSize) O (mkBin True inputSize) (mkBin False inputSize)

erased:
  
  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    subst = (\z. z)
    constructor N : Bin
    constructor C : (rest) -> Bin
    add' 
      [_] [_] N N = C N
      [_] ([_] w) (C xn) (C yn) = 
        let f = subst (C (add' w xn yn))
        in f
    foreign inputSize
    mkBin 
      [_] _ Z = N
      [_] True (S n) = C (mkBin False n)
      [_] False (S n) = C (mkBin True n)
  in add' inputSize (mkBin True inputSize) (mkBin False inputSize)

