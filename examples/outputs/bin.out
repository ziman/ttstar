-- vim: ft=idris

### Desugared ###

  let
    postulate Nat : Type
    postulate Z : Nat
    postulate S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    postulate Bool : Type
    postulate True : Bool
    postulate False : Bool
    not : (_x2 : Bool) -> Bool 
      [not] True = False
      [not] False = True
    postulate Unit : Type
    postulate MkUnit : Unit
    postulate Pair : (_x3 : Type) -> (_x4 : Type) -> Type
    postulate MkPair : (a : Type) -> (b : Type) -> (_x5 : a) -> (_x6 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x7 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        [fst] a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x8 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        [snd] a b ([MkPair] [a] [b] x y) = y
    postulate Either : (_x9 : Type) -> (_x10 : Type) -> Type
    postulate Left : (a : Type) -> (b : Type) -> (_x11 : a) -> Either a b
    postulate Right : (a : Type) -> (b : Type) -> (_x12 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    postulate Id : (a : Type) -> (x : a) -> (y : a) -> Type
    postulate Refl : (a : Type) -> (x : a) -> Id a x x
    subst : (a : Type) -> (P : (_x0 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (_x1 : P x) -> P y 
      a : Type P : (_x2 : a) -> Type x : a
        [subst] a P x [x] [Refl a x] = (\z : P x. z)
    postulate Bit : (_x0 : Nat) -> Type
    postulate I : Bit 1
    postulate O : Bit Z
    double : (_x1 : Nat) -> Nat 
      [double] Z = Z
      n : Nat
        [double] (S n) = S (S (double n))
    postulate Bin : (width : Nat) -> (value : Nat) -> Type
    postulate N : Bin Z Z
    postulate C : (width : Nat) -> (lsbVal : Nat) -> (lsb : Bit lsbVal) -> (restVal : Nat) -> (rest :R: Bin width restVal) -> Bin (S width) (plus lsbVal (double restVal))
    postulate TwoBits : (_x2 : Nat) -> (_x3 : Nat) -> (_x4 : Nat) -> Type
    postulate TB : (c : Nat) -> (x : Nat) -> (y : Nat) -> (hi' : Nat) -> (hi : Bit hi') -> (lo' : Nat) -> (lo : Bit lo') -> (pf : Id Nat (plus c (plus x y)) (plus lo' (double hi'))) -> TwoBits c x y
    adb : (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x5 : Bit c) -> (_x6 : Bit x) -> (_x7 : Bit y) -> TwoBits c x y 
      [adb] [Z] [Z] [Z] O O O = TB Z Z Z Z O Z O (Refl Nat Z)
      [adb] [1] [Z] [Z] I O O = TB 1 Z Z Z O 1 I (Refl Nat 1)
      [adb] [Z] [1] [Z] O I O = TB Z 1 Z Z O 1 I (Refl Nat 1)
      [adb] [Z] [Z] [1] O O I = TB Z Z 1 Z O 1 I (Refl Nat 1)
      [adb] [1] [1] [Z] I I O = TB 1 1 Z 1 I Z O (Refl Nat 2)
      [adb] [1] [Z] [1] I O I = TB 1 Z 1 1 I Z O (Refl Nat 2)
      [adb] [Z] [1] [1] O I I = TB Z 1 1 1 I Z O (Refl Nat 2)
      [adb] [1] [1] [1] I I I = TB 1 1 1 1 I 1 I (Refl Nat 3)
    add' : (w : Nat) -> (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x8 : Bit c) -> (_x9 : Bin w x) -> (_x10 : Bin w y) -> Bin (S w) (plus c (plus x y)) 
      c : Nat cb : Bit c
        [add'] [Z] c [Z] [Z] cb N N = C Z c cb Z N
      w : Nat c : Nat cb : Bit c xb' : Nat xb : Bit xb' xn' : Nat xn : Bin w xn' yb' : Nat yb : Bit yb' yn' : Nat yn : Bin w yn'
        [add'] ([S] w) c [plus xb' (double xn')] [plus yb' (double yn')] cb (C [w] xb' xb xn' xn) (C [w] yb' yb yn' yn) = 
          let f : (_x11 : TwoBits c xb' yb') -> Bin (S (S w)) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) 
            hi' : Nat hi : Bit hi' lo' : Nat lo : Bit lo' pf : Id Nat (plus c (plus xb' yb')) (plus lo' (double hi'))
              [f] (TB [c] [xb'] [yb'] hi' hi lo' lo pf) = 
                let postulate eq : Id Nat (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn'))))
                in subst Nat (Bin (S (S w))) (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) eq (C (S w) lo' lo (plus hi' (plus xn' yn')) (add' w hi' xn' yn' hi xn yn))
          in f (adb c xb' yb' cb xb yb)
    add : (w : Nat) -> (x : Nat) -> (y : Nat) -> (bx : Bin w x) -> (by : Bin w y) -> Bin (S w) (plus x y) = (\w : Nat. (\x : Nat. (\y : Nat. (\bx : Bin w x. (\by : Bin w y. add' w Z x y O bx by)))))
    foreign inputSize : Nat
    binVal : (_x12 : Bool) -> (_x13 : Nat) -> Nat 
      b : Bool
        [binVal] b Z = Z
      n : Nat
        [binVal] True (S n) = S (double (binVal False n))
      n : Nat
        [binVal] False (S n) = double (binVal True n)
    mkBin : (b : Bool) -> (w : Nat) -> Bin w (binVal b w) 
      b : Bool
        [mkBin] b Z = N
      n : Nat
        [mkBin] True (S n) = C n 1 I (binVal False n) (mkBin False n)
      n : Nat
        [mkBin] False (S n) = C n Z O (binVal True n) (mkBin True n)
    main : Bin (S inputSize) (plus (binVal True inputSize) (binVal False inputSize)) = 
      let
        x : Bin inputSize (binVal True inputSize) = mkBin True inputSize
        y : Bin inputSize (binVal False inputSize) = mkBin False inputSize
      in add inputSize (binVal True inputSize) (binVal False inputSize) x y
  in main

### Evarified ###

  let
    postulate Nat :1: Type
    postulate Z :2: Nat
    postulate S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        [plus] -9- Z -8- n = n
      m :10: Nat n :11: Nat
        [plus] -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    postulate Bool :18: Type
    postulate True :19: Bool
    postulate False :20: Bool
    not :21: (_x2 :22: Bool) -> Bool 
      [not] -23- True = False
      [not] -24- False = True
    postulate Unit :25: Type
    postulate MkUnit :26: Unit
    postulate Pair :27: (_x3 :28: Type) -> (_x4 :29: Type) -> Type
    postulate MkPair :30: (a :31: Type) -> (b :32: Type) -> (_x5 :33: a) -> (_x6 :34: b) -> Pair -36- a -35- b
    fst :37: (a :38: Type) -> (b :39: Type) -> (_x7 :40: Pair -42- a -41- b) -> a 
      a :43: Type b :44: Type x :45: a y :46: b
        [fst] -49- a -48- b -47- ([MkPair] -53- [a] -52- [b] -51- x -50- y) = x
    snd :54: (a :55: Type) -> (b :56: Type) -> (_x8 :57: Pair -59- a -58- b) -> b 
      a :60: Type b :61: Type x :62: a y :63: b
        [snd] -66- a -65- b -64- ([MkPair] -70- [a] -69- [b] -68- x -67- y) = y
    postulate Either :71: (_x9 :72: Type) -> (_x10 :73: Type) -> Type
    postulate Left :74: (a :75: Type) -> (b :76: Type) -> (_x11 :77: a) -> Either -79- a -78- b
    postulate Right :80: (a :81: Type) -> (b :82: Type) -> (_x12 :83: b) -> Either -85- a -84- b
    id :86: (a :87: Type) -> (x :88: a) -> a = (\a :89: Type. (\x :90: a. x))
    postulate Id :91: (a :92: Type) -> (x :93: a) -> (y :94: a) -> Type
    postulate Refl :95: (a :96: Type) -> (x :97: a) -> Id -100- a -99- x -98- x
    subst :101: (a :102: Type) -> (P :103: (_x0 :104: a) -> Type) -> (x :105: a) -> (y :106: a) -> (eq :107: Id -110- a -109- x -108- y) -> (_x1 :111: P -112- x) -> P -113- y 
      a :114: Type P :115: (_x2 :116: a) -> Type x :117: a
        [subst] -122- a -121- P -120- x -119- [x] -118- [Refl -124- a -123- x] = (\z :125: P -126- x. z)
    postulate Bit :127: (_x0 :128: Nat) -> Type
    postulate I :129: Bit -130- 1
    postulate O :132: Bit -133- Z
    double :134: (_x1 :135: Nat) -> Nat 
      [double] -136- Z = Z
      n :137: Nat
        [double] -138- (S -139- n) = S -140- (S -141- (double -142- n))
    postulate Bin :143: (width :144: Nat) -> (value :145: Nat) -> Type
    postulate N :146: Bin -148- Z -147- Z
    postulate C :149: (width :150: Nat) -> (lsbVal :151: Nat) -> (lsb :152: Bit -153- lsbVal) -> (restVal :154: Nat) -> (rest :R: Bin -156- width -155- restVal) -> Bin -158- (S -159- width) -157- (plus -161- lsbVal -160- (double -162- restVal))
    postulate TwoBits :163: (_x2 :164: Nat) -> (_x3 :165: Nat) -> (_x4 :166: Nat) -> Type
    postulate TB :167: (c :168: Nat) -> (x :169: Nat) -> (y :170: Nat) -> (hi' :171: Nat) -> (hi :172: Bit -173- hi') -> (lo' :174: Nat) -> (lo :175: Bit -176- lo') -> (pf :177: Id -180- Nat -179- (plus -182- c -181- (plus -184- x -183- y)) -178- (plus -186- lo' -185- (double -187- hi'))) -> TwoBits -190- c -189- x -188- y
    adb :191: (c :192: Nat) -> (x :193: Nat) -> (y :194: Nat) -> (_x5 :195: Bit -196- c) -> (_x6 :197: Bit -198- x) -> (_x7 :199: Bit -200- y) -> TwoBits -203- c -202- x -201- y 
      [adb] -209- [Z] -208- [Z] -207- [Z] -206- O -205- O -204- O = TB -217- Z -216- Z -215- Z -214- Z -213- O -212- Z -211- O -210- (Refl -219- Nat -218- Z)
      [adb] -225- [1] -224- [Z] -223- [Z] -222- I -221- O -220- O = TB -234- 1 -233- Z -232- Z -231- Z -230- O -229- 1 -228- I -227- (Refl -238- Nat -237- 1)
      [adb] -245- [Z] -244- [1] -243- [Z] -242- O -241- I -240- O = TB -254- Z -253- 1 -252- Z -251- Z -250- O -249- 1 -248- I -247- (Refl -258- Nat -257- 1)
      [adb] -265- [Z] -264- [Z] -263- [1] -262- O -261- O -260- I = TB -274- Z -273- Z -272- 1 -271- Z -270- O -269- 1 -268- I -267- (Refl -278- Nat -277- 1)
      [adb] -285- [1] -284- [1] -283- [Z] -282- I -281- I -280- O = TB -295- 1 -294- 1 -293- Z -292- 1 -291- I -290- Z -289- O -288- (Refl -300- Nat -299- 2)
      [adb] -308- [1] -307- [Z] -306- [1] -305- I -304- O -303- I = TB -318- 1 -317- Z -316- 1 -315- 1 -314- I -313- Z -312- O -311- (Refl -323- Nat -322- 2)
      [adb] -331- [Z] -330- [1] -329- [1] -328- O -327- I -326- I = TB -341- Z -340- 1 -339- 1 -338- 1 -337- I -336- Z -335- O -334- (Refl -346- Nat -345- 2)
      [adb] -354- [1] -353- [1] -352- [1] -351- I -350- I -349- I = TB -365- 1 -364- 1 -363- 1 -362- 1 -361- I -360- 1 -359- I -358- (Refl -372- Nat -371- 3)
    add' :376: (w :377: Nat) -> (c :378: Nat) -> (x :379: Nat) -> (y :380: Nat) -> (_x8 :381: Bit -382- c) -> (_x9 :383: Bin -385- w -384- x) -> (_x10 :386: Bin -388- w -387- y) -> Bin -390- (S -391- w) -389- (plus -393- c -392- (plus -395- x -394- y)) 
      c :396: Nat cb :397: Bit -398- c
        [add'] -405- [Z] -404- c -403- [Z] -402- [Z] -401- cb -400- N -399- N = C -410- Z -409- c -408- cb -407- Z -406- N
      w :411: Nat c :412: Nat cb :413: Bit -414- c xb' :415: Nat xb :416: Bit -417- xb' xn' :418: Nat xn :419: Bin -421- w -420- xn' yb' :422: Nat yb :423: Bit -424- yb' yn' :425: Nat yn :426: Bin -428- w -427- yn'
        [add'] -435- ([S] -436- w) -434- c -433- [plus -438- xb' -437- (double -439- xn')] -432- [plus -441- yb' -440- (double -442- yn')] -431- cb -430- (C -447- [w] -446- xb' -445- xb -444- xn' -443- xn) -429- (C -452- [w] -451- yb' -450- yb -449- yn' -448- yn) = 
          let f :453: (_x11 :454: TwoBits -457- c -456- xb' -455- yb') -> Bin -459- (S -460- (S -461- w)) -458- (plus -463- c -462- (plus -465- (plus -467- xb' -466- (double -468- xn')) -464- (plus -470- yb' -469- (double -471- yn')))) 
            hi' :472: Nat hi :473: Bit -474- hi' lo' :475: Nat lo :476: Bit -477- lo' pf :478: Id -481- Nat -480- (plus -483- c -482- (plus -485- xb' -484- yb')) -479- (plus -487- lo' -486- (double -488- hi'))
              [f] -489- (TB -497- [c] -496- [xb'] -495- [yb'] -494- hi' -493- hi -492- lo' -491- lo -490- pf) = 
                let postulate eq :498: Id -501- Nat -500- (plus -503- lo' -502- (double -504- (plus -506- hi' -505- (plus -508- xn' -507- yn')))) -499- (plus -510- c -509- (plus -512- (plus -514- xb' -513- (double -515- xn')) -511- (plus -517- yb' -516- (double -518- yn'))))
                in subst -524- Nat -523- (Bin -525- (S -526- (S -527- w))) -522- (plus -529- lo' -528- (double -530- (plus -532- hi' -531- (plus -534- xn' -533- yn')))) -521- (plus -536- c -535- (plus -538- (plus -540- xb' -539- (double -541- xn')) -537- (plus -543- yb' -542- (double -544- yn')))) -520- eq -519- (C -549- (S -550- w) -548- lo' -547- lo -546- (plus -552- hi' -551- (plus -554- xn' -553- yn')) -545- (add' -561- w -560- hi' -559- xn' -558- yn' -557- hi -556- xn -555- yn))
          in f -562- (adb -568- c -567- xb' -566- yb' -565- cb -564- xb -563- yb)
    add :569: (w :570: Nat) -> (x :571: Nat) -> (y :572: Nat) -> (bx :573: Bin -575- w -574- x) -> (by :576: Bin -578- w -577- y) -> Bin -580- (S -581- w) -579- (plus -583- x -582- y) = (\w :584: Nat. (\x :585: Nat. (\y :586: Nat. (\bx :587: Bin -589- w -588- x. (\by :590: Bin -592- w -591- y. add' -599- w -598- Z -597- x -596- y -595- O -594- bx -593- by)))))
    foreign inputSize :600: Nat
    binVal :601: (_x12 :602: Bool) -> (_x13 :603: Nat) -> Nat 
      b :604: Bool
        [binVal] -606- b -605- Z = Z
      n :607: Nat
        [binVal] -609- True -608- (S -610- n) = S -611- (double -612- (binVal -614- False -613- n))
      n :615: Nat
        [binVal] -617- False -616- (S -618- n) = double -619- (binVal -621- True -620- n)
    mkBin :622: (b :623: Bool) -> (w :624: Nat) -> Bin -626- w -625- (binVal -628- b -627- w) 
      b :629: Bool
        [mkBin] -631- b -630- Z = N
      n :632: Nat
        [mkBin] -634- True -633- (S -635- n) = C -640- n -639- 1 -638- I -637- (binVal -643- False -642- n) -636- (mkBin -645- False -644- n)
      n :646: Nat
        [mkBin] -648- False -647- (S -649- n) = C -654- n -653- Z -652- O -651- (binVal -656- True -655- n) -650- (mkBin -658- True -657- n)
    main :659: Bin -661- (S -662- inputSize) -660- (plus -664- (binVal -666- True -665- inputSize) -663- (binVal -668- False -667- inputSize)) = 
      let
        x :669: Bin -671- inputSize -670- (binVal -673- True -672- inputSize) = mkBin -675- True -674- inputSize
        y :676: Bin -678- inputSize -677- (binVal -680- False -679- inputSize) = mkBin -682- False -681- inputSize
      in add -687- inputSize -686- (binVal -689- True -688- inputSize) -685- (binVal -691- False -690- inputSize) -684- x -683- y
  in main

### Constraints ###

[] -> [2,3,19,20,101,111,125,129,132,146,149,152,159,167,172,175,191,195,197,199,204,205,206,211,213,220,221,222,228,230,240,241,242,248,250,260,261,262,268,270,280,281,282,289,291,303,304,305,312,314,326,327,328,335,337,349,350,351,359,361,376,377,381,383,386,391,397,399,400,401,405,406,408,411,413,416,419,423,426,429,430,431,435,436,443,445,448,450,453,454,460,461,473,476,489,491,493,519,526,527,545,547,550,555,556,557,561,562,563,564,565,569,570,573,576,581,584,587,590,593,594,595,599,600,622,623,624,630,631,632,633,634,635,636,638,644,645,646,647,648,649,650,652,657,658,662,669,674,675,676,681,682,683,684,687,R]
[5,6,105,135] -> [418,472,532,534]
[5,6,106] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,134,135,136,137,138,139,140,141,142,415,422,538,539,540,543]
[5,6,106,135] -> [418,541]
[5,6,106,539] -> [6]
[5,6,106,540] -> [5]
[5,6,106,541] -> [135]
[5,6,154] -> [418,554]
[5,105] -> [475,529]
[5,106] -> [412,536]
[5,154] -> [472,552]
[5,432] -> [422,441]
[5,433] -> [415,438]
[6,105] -> [134,135,136,137,138,139,140,141,142,528]
[6,105,135] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,425,530,531,533]
[6,105,135,531] -> [6]
[6,105,135,532] -> [5]
[6,105,135,533] -> [6]
[6,105,135,534] -> [5]
[6,105,530] -> [135]
[6,106] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,134,135,136,137,138,139,140,141,142,535,537,542]
[6,106,135] -> [425,544]
[6,106,537] -> [6]
[6,106,538] -> [5]
[6,106,542] -> [6]
[6,106,543] -> [5]
[6,106,544] -> [135]
[6,135,432] -> [425,442]
[6,135,433] -> [418,439]
[6,154] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,425,551,553]
[6,154,553] -> [6]
[6,154,554] -> [5]
[6,432] -> [134,135,136,137,138,139,140,141,142,440]
[6,432,442] -> [135]
[6,433] -> [134,135,136,137,138,139,140,141,142,437]
[6,433,439] -> [135]
[15] -> [611]
[15,177] -> [239,259,279,301,302,324,347,373,374]
[96,118] -> [114,124]
[96,177] -> [1,219,238,258,278,300,323,346,372]
[97,118] -> [117,123]
[97,177] -> [218,237,239,257,259,277,279,299,301,302,322,324,325,345,347,348,371,373,374,375]
[98] -> [108]
[98,177] -> [178]
[99] -> [109]
[99,177] -> [179]
[100] -> [110]
[100,177] -> [180]
[102] -> [1,122,524]
[103] -> [121,143,523]
[103,104] -> [145]
[103,144] -> [525]
[103,145] -> [104]
[103,525] -> [144]
[104] -> [116]
[105] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,120,522]
[105,528] -> [6]
[105,529] -> [5]
[106] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,119,521]
[106,535] -> [6]
[106,536] -> [5]
[107] -> [118,498,520]
[107,108] -> [499]
[107,109] -> [500]
[107,110] -> [501]
[107,499] -> [108]
[107,500] -> [109]
[107,501] -> [110]
[107,502] -> [528]
[107,503] -> [529]
[107,504] -> [530]
[107,505] -> [531]
[107,506] -> [532]
[107,507] -> [533]
[107,508] -> [534]
[107,509] -> [535]
[107,510] -> [536]
[107,511] -> [537]
[107,512] -> [538]
[107,513] -> [539]
[107,514] -> [540]
[107,515] -> [541]
[107,516] -> [542]
[107,517] -> [543]
[107,518] -> [544]
[107,528] -> [502]
[107,529] -> [503]
[107,530] -> [504]
[107,531] -> [505]
[107,532] -> [506]
[107,533] -> [507]
[107,534] -> [508]
[107,535] -> [509]
[107,536] -> [510]
[107,537] -> [511]
[107,538] -> [512]
[107,539] -> [513]
[107,540] -> [514]
[107,541] -> [515]
[107,542] -> [516]
[107,543] -> [517]
[107,544] -> [518]
[108] -> [98]
[109] -> [99]
[110] -> [100]
[112] -> [126,157]
[113] -> [126,458]
[114] -> [122]
[115] -> [121]
[116] -> [104]
[117] -> [120]
[118] -> [95,107]
[118,123] -> [97]
[118,124] -> [96]
[119] -> [106,117]
[120] -> [105]
[121] -> [103]
[122] -> [102]
[126] -> [112,113]
[130] -> [153,173,176,196,198,200]
[131] -> [226,236,246,256,266,276,286,287,298,309,310,321,332,333,344,355,356,357,369,370,641]
[133] -> [153,173,176,196,198,200,382]
[140,177] -> [301,324,347,374]
[141,177] -> [302,325,348,375]
[147] -> [155,384,387,625]
[148] -> [156,385,388,626]
[150] -> [410,447,452,549,640,654]
[151] -> [396,409,446,451,475,548,639,641,653]
[153] -> [130,133,398,417,424,477]
[154] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,134,135,136,137,138,139,140,141,142,407,444,449,546,601,602,603,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,637,651]
[154,551] -> [6]
[154,552] -> [5]
[154,602] -> [643,656]
[154,603] -> [642,655]
[154,642] -> [603]
[154,643] -> [602]
[154,655] -> [603]
[154,656] -> [602]
[155] -> [147,389,420,427,625]
[156] -> [148,390,421,428,626]
[157] -> [112,384,387,389,625]
[158] -> [385,388,390,525,626]
[160] -> [392,437,440,528]
[161] -> [393,438,441,529]
[162] -> [439,442,530,612,619]
[168] -> [217,234,235,254,274,295,296,318,319,341,365,366,497]
[169] -> [216,233,253,255,273,294,297,317,340,342,364,367,496]
[170] -> [215,232,252,272,275,293,316,320,339,343,363,368,495]
[171] -> [214,231,251,271,292,298,315,321,338,344,362,369,494]
[173] -> [130,133,474]
[174] -> [212,229,236,249,256,269,276,290,313,336,360,370,492]
[176] -> [130,133,477]
[177] -> [95,210,227,247,267,288,311,334,358,490]
[177,178] -> [98]
[177,179] -> [99]
[177,180] -> [100]
[177,218] -> [97]
[177,219] -> [96]
[177,237] -> [97]
[177,238] -> [96]
[177,239] -> [15]
[177,257] -> [97]
[177,258] -> [96]
[177,259] -> [15]
[177,275] -> [279]
[177,277] -> [97]
[177,278] -> [96]
[177,279] -> [15,275]
[177,299] -> [97]
[177,300] -> [96]
[177,301] -> [15,140]
[177,302] -> [15,141]
[177,320] -> [325]
[177,322] -> [97]
[177,323] -> [96]
[177,324] -> [15,140]
[177,325] -> [141,320]
[177,343] -> [348]
[177,345] -> [97]
[177,346] -> [96]
[177,347] -> [15,140]
[177,348] -> [141,343]
[177,368] -> [375]
[177,371] -> [97]
[177,372] -> [96]
[177,373] -> [15]
[177,374] -> [15,140]
[177,375] -> [141,368]
[178] -> [479]
[179] -> [480]
[180] -> [481]
[181] -> [482]
[182] -> [483]
[183] -> [484]
[184] -> [485]
[185] -> [486]
[186] -> [487]
[187] -> [488]
[188] -> [201,455]
[189] -> [202,456]
[190] -> [203,457]
[192] -> [209,225,245,265,285,308,331,354,412,568]
[193] -> [208,224,244,264,284,307,330,353,415,567]
[194] -> [207,223,243,263,283,306,329,352,422,566]
[196] -> [130,133,414]
[198] -> [130,133,417]
[200] -> [130,133,424]
[201] -> [188,455]
[202] -> [189,456]
[203] -> [190,457]
[207] -> [194]
[208] -> [193]
[209] -> [192]
[210] -> [177]
[212] -> [174]
[214] -> [171]
[215] -> [170]
[216] -> [169]
[217] -> [168]
[223] -> [194]
[224] -> [193]
[225] -> [192,226]
[226] -> [131,235]
[227] -> [177]
[229] -> [174]
[231] -> [171]
[232] -> [170]
[233] -> [169]
[234] -> [168]
[235] -> [226]
[236] -> [131]
[243] -> [194]
[244] -> [193,246]
[245] -> [192]
[246] -> [131,255]
[247] -> [177]
[249] -> [174]
[251] -> [171]
[252] -> [170]
[253] -> [169]
[254] -> [168]
[255] -> [246]
[256] -> [131]
[263] -> [194,266]
[264] -> [193]
[265] -> [192]
[266] -> [131,275]
[267] -> [177]
[269] -> [174]
[271] -> [171]
[272] -> [170]
[273] -> [169]
[274] -> [168]
[275] -> [266]
[276] -> [131]
[283] -> [194]
[284] -> [193,287]
[285] -> [192,286]
[286] -> [131,296]
[287] -> [131,297]
[288] -> [177]
[290] -> [174]
[292] -> [171]
[293] -> [170]
[294] -> [169]
[295] -> [168]
[296] -> [286]
[297] -> [287]
[298] -> [131]
[306] -> [194,310]
[307] -> [193]
[308] -> [192,309]
[309] -> [131,319]
[310] -> [131,320]
[311] -> [177]
[313] -> [174]
[315] -> [171]
[316] -> [170]
[317] -> [169]
[318] -> [168]
[319] -> [309]
[320] -> [310]
[321] -> [131]
[329] -> [194,333]
[330] -> [193,332]
[331] -> [192]
[332] -> [131,342]
[333] -> [131,343]
[334] -> [177]
[336] -> [174]
[338] -> [171]
[339] -> [170]
[340] -> [169]
[341] -> [168]
[342] -> [332]
[343] -> [333]
[344] -> [131]
[352] -> [194,357]
[353] -> [193,356]
[354] -> [192,355]
[355] -> [131,366]
[356] -> [131,367]
[357] -> [131,368]
[358] -> [177]
[360] -> [174]
[362] -> [171]
[363] -> [170]
[364] -> [169]
[365] -> [168]
[366] -> [355]
[367] -> [356]
[368] -> [357]
[369] -> [131]
[370] -> [131]
[378] -> [404,434,472,560,598]
[379] -> [403,418,433,559,585,597]
[380] -> [402,425,432,558,586,596]
[382] -> [133,398,414,474]
[384] -> [147,157,420,588]
[385] -> [148,158,421,589]
[387] -> [147,157,427,591]
[388] -> [148,158,428,592]
[389] -> [155,157,458,579]
[390] -> [156,158,459,580]
[392] -> [160,462,551]
[393] -> [161,463,552]
[394] -> [464,553,582]
[395] -> [465,554,583]
[396] -> [404]
[398] -> [153,382]
[402] -> [380]
[403] -> [379]
[404] -> [378]
[407] -> [154]
[409] -> [151]
[410] -> [150]
[412] -> [434]
[414] -> [196,382]
[415] -> [446]
[417] -> [153,198]
[418] -> [444]
[420] -> [155,384]
[421] -> [156,385]
[422] -> [451]
[424] -> [153,200]
[425] -> [449]
[427] -> [155,387]
[428] -> [156,388]
[432] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,380]
[432,440] -> [6]
[432,441] -> [5]
[433] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,379]
[433,437] -> [6]
[433,438] -> [5]
[434] -> [378]
[437] -> [160,466]
[438] -> [161,467]
[439] -> [162,468]
[440] -> [160,469]
[441] -> [161,470]
[442] -> [162,471]
[444] -> [154]
[446] -> [151]
[447] -> [150]
[449] -> [154]
[451] -> [151]
[452] -> [150]
[455] -> [188,201]
[456] -> [189,202]
[457] -> [190,203]
[458] -> [113,389]
[459] -> [390,525]
[462] -> [392,535]
[463] -> [393,536]
[464] -> [394,537]
[465] -> [395,538]
[466] -> [437,539]
[467] -> [438,540]
[468] -> [439,541]
[469] -> [440,542]
[470] -> [441,543]
[471] -> [442,544]
[472] -> [494]
[474] -> [173,382]
[475] -> [492]
[477] -> [153,176]
[478] -> [490]
[479] -> [178]
[480] -> [179]
[481] -> [180]
[482] -> [181]
[483] -> [182]
[484] -> [183]
[485] -> [184]
[486] -> [185]
[487] -> [186]
[488] -> [187]
[490] -> [177]
[492] -> [174]
[494] -> [171]
[495] -> [170,422]
[496] -> [169,415]
[497] -> [168,412]
[520] -> [107]
[521] -> [106]
[522] -> [105]
[523] -> [103]
[524] -> [102]
[525] -> [158,459]
[528] -> [160]
[529] -> [161]
[530] -> [162]
[531] -> [551]
[532] -> [552]
[533] -> [553]
[534] -> [554]
[535] -> [462]
[536] -> [463]
[537] -> [464]
[538] -> [465]
[539] -> [466]
[540] -> [467]
[541] -> [468]
[542] -> [469]
[543] -> [470]
[544] -> [471]
[546] -> [154]
[548] -> [151]
[549] -> [150]
[551] -> [392,531]
[552] -> [393,532]
[553] -> [394,533]
[554] -> [395,534]
[558] -> [380]
[559] -> [379]
[560] -> [378]
[566] -> [194]
[567] -> [193]
[568] -> [192]
[571] -> [134,135,136,137,138,139,140,141,142,585,601,602,603,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,686]
[571,602] -> [689]
[571,603] -> [688]
[571,688] -> [603]
[571,689] -> [602]
[572] -> [134,135,136,137,138,139,140,141,142,586,601,602,603,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,685]
[572,602] -> [691]
[572,603] -> [690]
[572,690] -> [603]
[572,691] -> [602]
[574] -> [588,670]
[575] -> [589,671]
[577] -> [591,677]
[578] -> [592,678]
[579] -> [389,660]
[580] -> [390,661]
[582] -> [394,663]
[583] -> [395,664]
[585] -> [571]
[586] -> [572]
[588] -> [384,574]
[589] -> [385,575]
[591] -> [387,577]
[592] -> [388,578]
[596] -> [380]
[597] -> [379]
[598] -> [378]
[611] -> [15]
[612] -> [162]
[613] -> [642]
[614] -> [643]
[619] -> [162]
[620] -> [655]
[621] -> [656]
[625] -> [147,155,157,670,677]
[626] -> [148,156,158,671,678]
[627] -> [642,655,672,679]
[628] -> [643,656,673,680]
[637] -> [154]
[639] -> [151]
[640] -> [150]
[641] -> [131]
[642] -> [613,627]
[643] -> [614,628]
[651] -> [154]
[653] -> [151]
[654] -> [150]
[655] -> [620,627]
[656] -> [621,628]
[660] -> [579]
[661] -> [580]
[663] -> [582]
[664] -> [583]
[665] -> [688]
[666] -> [689]
[667] -> [690]
[668] -> [691]
[670] -> [574,625]
[671] -> [575,626]
[672] -> [627,688]
[673] -> [628,689]
[677] -> [577,625]
[678] -> [578,626]
[679] -> [627,690]
[680] -> [628,691]
[685] -> [572]
[686] -> [571]
[688] -> [665,672]
[689] -> [666,673]
[690] -> [667,679]
[691] -> [668,680]
[R] -> [659]

### Solution ###

[2,3,19,20,101,111,125,129,132,146,149,152,159,167,172,175,191,195,197,199,204,205,206,211,213,220,221,222,228,230,240,241,242,248,250,260,261,262,268,270,280,281,282,289,291,303,304,305,312,314,326,327,328,335,337,349,350,351,359,361,376,377,381,383,386,391,397,399,400,401,405,406,408,411,413,416,419,423,426,429,430,431,435,436,443,445,448,450,453,454,460,461,473,476,489,491,493,519,526,527,545,547,550,555,556,557,561,562,563,564,565,569,570,573,576,581,584,587,590,593,594,595,599,600,622,623,624,630,631,632,633,634,635,636,638,644,645,646,647,648,649,650,652,657,658,659,662,669,674,675,676,681,682,683,684,687,R]

### Annotated ###

  let
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate True :R: Bool
    postulate False :R: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    postulate Unit :E: Type
    postulate MkUnit :E: Unit
    postulate Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    postulate MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    postulate Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    postulate Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    postulate Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    postulate Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    postulate Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        [subst] -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    postulate Bit :E: (_x0 :E: Nat) -> Type
    postulate I :R: Bit -E- 1
    postulate O :R: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      [double] -E- Z = Z
      n :E: Nat
        [double] -E- (S -E- n) = S -E- (S -E- (double -E- n))
    postulate Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    postulate N :R: Bin -E- Z -E- Z
    postulate C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :R: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    postulate TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    postulate TB :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :R: Bit -E- hi') -> (lo' :E: Nat) -> (lo :R: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :R: Bit -E- c) -> (_x6 :R: Bit -E- x) -> (_x7 :R: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      [adb] -E- [Z] -E- [Z] -E- [Z] -R- O -R- O -R- O = TB -E- Z -E- Z -E- Z -E- Z -R- O -E- Z -R- O -E- (Refl -E- Nat -E- Z)
      [adb] -E- [1] -E- [Z] -E- [Z] -R- I -R- O -R- O = TB -E- 1 -E- Z -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [1] -E- [Z] -R- O -R- I -R- O = TB -E- Z -E- 1 -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [Z] -E- [1] -R- O -R- O -R- I = TB -E- Z -E- Z -E- 1 -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [1] -E- [1] -E- [Z] -R- I -R- I -R- O = TB -E- 1 -E- 1 -E- Z -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [Z] -E- [1] -R- I -R- O -R- I = TB -E- 1 -E- Z -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [Z] -E- [1] -E- [1] -R- O -R- I -R- I = TB -E- Z -E- 1 -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [1] -E- [1] -R- I -R- I -R- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -R- I -E- 1 -R- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :R: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :R: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :R: Bit -E- c
        [add'] -R- [Z] -E- c -E- [Z] -E- [Z] -R- cb -R- N -R- N = C -E- Z -E- c -R- cb -E- Z -R- N
      w :R: Nat c :E: Nat cb :R: Bit -E- c xb' :E: Nat xb :R: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :R: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        [add'] -R- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -R- cb -R- (C -E- [w] -E- xb' -R- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -R- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :R: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :R: Bit -E- hi' lo' :E: Nat lo :R: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              [f] -R- (TB -E- [c] -E- [xb'] -E- [yb'] -E- hi' -R- hi -E- lo' -R- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -R- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -R- w -E- hi' -E- xn' -E- yn' -R- hi -R- xn -R- yn))
          in f -R- (adb -E- c -E- xb' -E- yb' -R- cb -R- xb -R- yb)
    add :R: (w :R: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :R: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -R- w -E- Z -E- x -E- y -R- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        [binVal] -E- b -E- Z = Z
      n :E: Nat
        [binVal] -E- True -E- (S -E- n) = S -E- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        [binVal] -E- False -E- (S -E- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :E: Bool
        [mkBin] -R- b -R- Z = N
      n :R: Nat
        [mkBin] -R- True -R- (S -R- n) = C -E- n -E- 1 -R- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        [mkBin] -R- False -R- (S -R- n) = C -E- n -E- Z -R- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -R- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Specialised ###

  let
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate True :R: Bool
    postulate False :R: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    postulate Unit :E: Type
    postulate MkUnit :E: Unit
    postulate Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    postulate MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    postulate Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    postulate Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    postulate Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    postulate Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    postulate Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        [subst] -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    postulate Bit :E: (_x0 :E: Nat) -> Type
    postulate I :R: Bit -E- 1
    postulate O :R: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      [double] -E- Z = Z
      n :E: Nat
        [double] -E- (S -E- n) = S -E- (S -E- (double -E- n))
    postulate Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    postulate N :R: Bin -E- Z -E- Z
    postulate C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :R: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    postulate TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    postulate TB :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :R: Bit -E- hi') -> (lo' :E: Nat) -> (lo :R: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :R: Bit -E- c) -> (_x6 :R: Bit -E- x) -> (_x7 :R: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      [adb] -E- [Z] -E- [Z] -E- [Z] -R- O -R- O -R- O = TB -E- Z -E- Z -E- Z -E- Z -R- O -E- Z -R- O -E- (Refl -E- Nat -E- Z)
      [adb] -E- [1] -E- [Z] -E- [Z] -R- I -R- O -R- O = TB -E- 1 -E- Z -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [1] -E- [Z] -R- O -R- I -R- O = TB -E- Z -E- 1 -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [Z] -E- [1] -R- O -R- O -R- I = TB -E- Z -E- Z -E- 1 -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [1] -E- [1] -E- [Z] -R- I -R- I -R- O = TB -E- 1 -E- 1 -E- Z -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [Z] -E- [1] -R- I -R- O -R- I = TB -E- 1 -E- Z -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [Z] -E- [1] -E- [1] -R- O -R- I -R- I = TB -E- Z -E- 1 -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [1] -E- [1] -R- I -R- I -R- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -R- I -E- 1 -R- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :R: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :R: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :R: Bit -E- c
        [add'] -R- [Z] -E- c -E- [Z] -E- [Z] -R- cb -R- N -R- N = C -E- Z -E- c -R- cb -E- Z -R- N
      w :R: Nat c :E: Nat cb :R: Bit -E- c xb' :E: Nat xb :R: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :R: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        [add'] -R- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -R- cb -R- (C -E- [w] -E- xb' -R- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -R- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :R: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :R: Bit -E- hi' lo' :E: Nat lo :R: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              [f] -R- (TB -E- [c] -E- [xb'] -E- [yb'] -E- hi' -R- hi -E- lo' -R- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -R- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -R- w -E- hi' -E- xn' -E- yn' -R- hi -R- xn -R- yn))
          in f -R- (adb -E- c -E- xb' -E- yb' -R- cb -R- xb -R- yb)
    add :R: (w :R: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :R: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -R- w -E- Z -E- x -E- y -R- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        [binVal] -E- b -E- Z = Z
      n :E: Nat
        [binVal] -E- True -E- (S -E- n) = S -E- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        [binVal] -E- False -E- (S -E- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :E: Bool
        [mkBin] -R- b -R- Z = N
      n :R: Nat
        [mkBin] -R- True -R- (S -R- n) = C -E- n -E- 1 -R- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        [mkBin] -R- False -R- (S -R- n) = C -E- n -E- Z -R- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -R- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Final annotation ###

  let
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate True :R: Bool
    postulate False :R: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    postulate Unit :E: Type
    postulate MkUnit :E: Unit
    postulate Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    postulate MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    postulate Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    postulate Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    postulate Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    postulate Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    postulate Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        [subst] -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    postulate Bit :E: (_x0 :E: Nat) -> Type
    postulate I :R: Bit -E- 1
    postulate O :R: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      [double] -E- Z = Z
      n :E: Nat
        [double] -E- (S -E- n) = S -E- (S -E- (double -E- n))
    postulate Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    postulate N :R: Bin -E- Z -E- Z
    postulate C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :R: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    postulate TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    postulate TB :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :R: Bit -E- hi') -> (lo' :E: Nat) -> (lo :R: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :R: Bit -E- c) -> (_x6 :R: Bit -E- x) -> (_x7 :R: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      [adb] -E- [Z] -E- [Z] -E- [Z] -R- O -R- O -R- O = TB -E- Z -E- Z -E- Z -E- Z -R- O -E- Z -R- O -E- (Refl -E- Nat -E- Z)
      [adb] -E- [1] -E- [Z] -E- [Z] -R- I -R- O -R- O = TB -E- 1 -E- Z -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [1] -E- [Z] -R- O -R- I -R- O = TB -E- Z -E- 1 -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [Z] -E- [1] -R- O -R- O -R- I = TB -E- Z -E- Z -E- 1 -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [1] -E- [1] -E- [Z] -R- I -R- I -R- O = TB -E- 1 -E- 1 -E- Z -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [Z] -E- [1] -R- I -R- O -R- I = TB -E- 1 -E- Z -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [Z] -E- [1] -E- [1] -R- O -R- I -R- I = TB -E- Z -E- 1 -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [1] -E- [1] -R- I -R- I -R- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -R- I -E- 1 -R- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :R: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :R: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :R: Bit -E- c
        [add'] -R- [Z] -E- c -E- [Z] -E- [Z] -R- cb -R- N -R- N = C -E- Z -E- c -R- cb -E- Z -R- N
      w :R: Nat c :E: Nat cb :R: Bit -E- c xb' :E: Nat xb :R: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :R: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        [add'] -R- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -R- cb -R- (C -E- [w] -E- xb' -R- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -R- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :R: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :R: Bit -E- hi' lo' :E: Nat lo :R: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              [f] -R- (TB -E- [c] -E- [xb'] -E- [yb'] -E- hi' -R- hi -E- lo' -R- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -R- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -R- w -E- hi' -E- xn' -E- yn' -R- hi -R- xn -R- yn))
          in f -R- (adb -E- c -E- xb' -E- yb' -R- cb -R- xb -R- yb)
    add :R: (w :R: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :R: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -R- w -E- Z -E- x -E- y -R- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        [binVal] -E- b -E- Z = Z
      n :E: Nat
        [binVal] -E- True -E- (S -E- n) = S -E- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        [binVal] -E- False -E- (S -E- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :E: Bool
        [mkBin] -R- b -R- Z = N
      n :R: Nat
        [mkBin] -R- True -R- (S -R- n) = C -E- n -E- 1 -R- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        [mkBin] -R- False -R- (S -R- n) = C -E- n -E- Z -R- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -R- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Z : Nat
    postulate S : (x) -> Nat
    postulate True : Bool
    postulate False : Bool
    subst 
      [_] = (\z. z)
    postulate I : Bit
    postulate O : Bit
    postulate N : Bin
    postulate C : (lsb) -> (rest) -> Bin
    postulate TB : (hi) -> (lo) -> TwoBits
    adb 
      [_] O O O = TB O O
      [_] I O O = TB O I
      [_] O I O = TB O I
      [_] O O I = TB O I
      [_] I I O = TB I O
      [_] I O I = TB I O
      [_] O I I = TB I O
      [_] I I I = TB I I
    add' 
      [_] [_] cb N N = C cb N
      [_] ([_] w) cb (C xb xn) (C yb yn) = 
        let f 
          [_] (TB hi lo) = subst (C lo (add' w hi xn yn))
        in f (adb cb xb yb)
    add = (\w. (\bx. (\by. add' w O bx by)))
    foreign inputSize
    mkBin 
      [_] _ Z = N
      [_] True (S n) = C I (mkBin False n)
      [_] False (S n) = C O (mkBin True n)
    main = 
      let
        x = mkBin True inputSize
        y = mkBin False inputSize
      in add inputSize x y
  in main

### Normal forms ###

unerased:
  
  let
    postulate Nat : Type
    postulate Z : Nat
    postulate S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    postulate Bool : Type
    postulate True : Bool
    postulate False : Bool
    postulate Id : (a : Type) -> (x : a) -> (y : a) -> Type
    postulate Refl : (a : Type) -> (x : a) -> Id a x x
    subst : (a : Type) -> (P : (_x0 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (_x1 : P x) -> P y 
      a : Type P : (_x2 : a) -> Type x : a
        [subst] a P x [x] [Refl a x] = (\z : P x. z)
    postulate Bit : (_x0 : Nat) -> Type
    postulate I : Bit 1
    postulate O : Bit Z
    double : (_x1 : Nat) -> Nat 
      [double] Z = Z
      n : Nat
        [double] (S n) = S (S (double n))
    postulate Bin : (width : Nat) -> (value : Nat) -> Type
    postulate N : Bin Z Z
    postulate C : (width : Nat) -> (lsbVal : Nat) -> (lsb : Bit lsbVal) -> (restVal : Nat) -> (rest :R: Bin width restVal) -> Bin (S width) (plus lsbVal (double restVal))
    postulate TwoBits : (_x2 : Nat) -> (_x3 : Nat) -> (_x4 : Nat) -> Type
    postulate TB : (c : Nat) -> (x : Nat) -> (y : Nat) -> (hi' : Nat) -> (hi : Bit hi') -> (lo' : Nat) -> (lo : Bit lo') -> (pf : Id Nat (plus c (plus x y)) (plus lo' (double hi'))) -> TwoBits c x y
    adb : (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x5 : Bit c) -> (_x6 : Bit x) -> (_x7 : Bit y) -> TwoBits c x y 
      [adb] [Z] [Z] [Z] O O O = TB Z Z Z Z O Z O (Refl Nat Z)
      [adb] [1] [Z] [Z] I O O = TB 1 Z Z Z O 1 I (Refl Nat 1)
      [adb] [Z] [1] [Z] O I O = TB Z 1 Z Z O 1 I (Refl Nat 1)
      [adb] [Z] [Z] [1] O O I = TB Z Z 1 Z O 1 I (Refl Nat 1)
      [adb] [1] [1] [Z] I I O = TB 1 1 Z 1 I Z O (Refl Nat 2)
      [adb] [1] [Z] [1] I O I = TB 1 Z 1 1 I Z O (Refl Nat 2)
      [adb] [Z] [1] [1] O I I = TB Z 1 1 1 I Z O (Refl Nat 2)
      [adb] [1] [1] [1] I I I = TB 1 1 1 1 I 1 I (Refl Nat 3)
    add' : (w : Nat) -> (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x8 : Bit c) -> (_x9 : Bin w x) -> (_x10 : Bin w y) -> Bin (S w) (plus c (plus x y)) 
      c : Nat cb : Bit c
        [add'] [Z] c [Z] [Z] cb N N = C Z c cb Z N
      w : Nat c : Nat cb : Bit c xb' : Nat xb : Bit xb' xn' : Nat xn : Bin w xn' yb' : Nat yb : Bit yb' yn' : Nat yn : Bin w yn'
        [add'] ([S] w) c [plus xb' (double xn')] [plus yb' (double yn')] cb (C [w] xb' xb xn' xn) (C [w] yb' yb yn' yn) = 
          let f : (_x11 : TwoBits c xb' yb') -> Bin (S (S w)) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) 
            hi' : Nat hi : Bit hi' lo' : Nat lo : Bit lo' pf : Id Nat (plus c (plus xb' yb')) (plus lo' (double hi'))
              [f] (TB [c] [xb'] [yb'] hi' hi lo' lo pf) = 
                let postulate eq : Id Nat (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn'))))
                in subst Nat (Bin (S (S w))) (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) eq (C (S w) lo' lo (plus hi' (plus xn' yn')) (add' w hi' xn' yn' hi xn yn))
          in f (adb c xb' yb' cb xb yb)
    foreign inputSize : Nat
    binVal : (_x12 : Bool) -> (_x13 : Nat) -> Nat 
      b : Bool
        [binVal] b Z = Z
      n : Nat
        [binVal] True (S n) = S (double (binVal False n))
      n : Nat
        [binVal] False (S n) = double (binVal True n)
    mkBin : (b : Bool) -> (w : Nat) -> Bin w (binVal b w) 
      b : Bool
        [mkBin] b Z = N
      n : Nat
        [mkBin] True (S n) = C n 1 I (binVal False n) (mkBin False n)
      n : Nat
        [mkBin] False (S n) = C n Z O (binVal True n) (mkBin True n)
  in add' inputSize Z (binVal True inputSize) (binVal False inputSize) O (mkBin True inputSize) (mkBin False inputSize)

erased:
  
  let
    postulate Z : Nat
    postulate S : (x) -> Nat
    postulate True : Bool
    postulate False : Bool
    subst 
      [_] = (\z. z)
    postulate I : Bit
    postulate O : Bit
    postulate N : Bin
    postulate C : (lsb) -> (rest) -> Bin
    postulate TB : (hi) -> (lo) -> TwoBits
    adb 
      [_] O O O = TB O O
      [_] I O O = TB O I
      [_] O I O = TB O I
      [_] O O I = TB O I
      [_] I I O = TB I O
      [_] I O I = TB I O
      [_] O I I = TB I O
      [_] I I I = TB I I
    add' 
      [_] [_] cb N N = C cb N
      [_] ([_] w) cb (C xb xn) (C yb yn) = 
        let f 
          [_] (TB hi lo) = subst (C lo (add' w hi xn yn))
        in f (adb cb xb yb)
    foreign inputSize
    mkBin 
      [_] _ Z = N
      [_] True (S n) = C I (mkBin False n)
      [_] False (S n) = C O (mkBin True n)
  in add' inputSize O (mkBin True inputSize) (mkBin False inputSize)

