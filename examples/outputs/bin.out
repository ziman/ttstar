-- vim: ft=ttstar

### Desugared ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x2 : Bool) -> Bool 
      [not] True = False
      [not] False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x3 : Type) -> (_x4 : Type) -> Type
    constructor MkPair : (a : Type) -> (b : Type) -> (_x5 : a) -> (_x6 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x7 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        [fst] a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x8 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        [snd] a b ([MkPair] [a] [b] x y) = y
    constructor Either : (_x9 : Type) -> (_x10 : Type) -> Type
    constructor Left : (a : Type) -> (b : Type) -> (_x11 : a) -> Either a b
    constructor Right : (a : Type) -> (b : Type) -> (_x12 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x13 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x14 : Fin n) -> Fin (S n)
    constructor Vect : (_x15 : Nat) -> (_x16 : Type) -> Type
    constructor VN : (a : Type) -> Vect Z a
    constructor VC : (n : Nat) -> (a : Type) -> (x : a) -> (xs : Vect n a) -> Vect (S n) a
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    subst : (a : Type) -> (P : (_x0 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (_x1 : P x) -> P y 
      a : Type P : (_x2 : a) -> Type x : a
        [subst] a P x [x] [Refl a x] = (\z : P x. z)
    constructor Bit : (_x0 : Nat) -> Type
    constructor I : Bit 1
    constructor O : Bit Z
    double : (_x1 : Nat) -> Nat 
      [double] Z = Z
      n : Nat
        [double] (S n) = S (S (double n))
    constructor Bin : (width : Nat) -> (value : Nat) -> Type
    constructor N : Bin Z Z
    constructor C : (width : Nat) -> (lsbVal : Nat) -> (lsb : Bit lsbVal) -> (restVal : Nat) -> (rest :R: Bin width restVal) -> Bin (S width) (plus lsbVal (double restVal))
    constructor TwoBits : (_x2 : Nat) -> (_x3 : Nat) -> (_x4 : Nat) -> Type
    constructor TB : (c : Nat) -> (x : Nat) -> (y : Nat) -> (hi' : Nat) -> (hi : Bit hi') -> (lo' : Nat) -> (lo : Bit lo') -> (pf : Id Nat (plus c (plus x y)) (plus lo' (double hi'))) -> TwoBits c x y
    adb : (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x5 : Bit c) -> (_x6 : Bit x) -> (_x7 : Bit y) -> TwoBits c x y 
      [adb] [Z] [Z] [Z] O O O = TB Z Z Z Z O Z O (Refl Nat Z)
      [adb] [1] [Z] [Z] I O O = TB 1 Z Z Z O 1 I (Refl Nat 1)
      [adb] [Z] [1] [Z] O I O = TB Z 1 Z Z O 1 I (Refl Nat 1)
      [adb] [Z] [Z] [1] O O I = TB Z Z 1 Z O 1 I (Refl Nat 1)
      [adb] [1] [1] [Z] I I O = TB 1 1 Z 1 I Z O (Refl Nat 2)
      [adb] [1] [Z] [1] I O I = TB 1 Z 1 1 I Z O (Refl Nat 2)
      [adb] [Z] [1] [1] O I I = TB Z 1 1 1 I Z O (Refl Nat 2)
      [adb] [1] [1] [1] I I I = TB 1 1 1 1 I 1 I (Refl Nat 3)
    add' : (w : Nat) -> (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x8 : Bit c) -> (_x9 : Bin w x) -> (_x10 : Bin w y) -> Bin (S w) (plus c (plus x y)) 
      c : Nat cb : Bit c
        [add'] [Z] c [Z] [Z] cb N N = C Z c cb Z N
      w : Nat c : Nat cb : Bit c xb' : Nat xb : Bit xb' xn' : Nat xn : Bin w xn' yb' : Nat yb : Bit yb' yn' : Nat yn : Bin w yn'
        [add'] ([S] w) c [plus xb' (double xn')] [plus yb' (double yn')] cb (C [w] xb' xb xn' xn) (C [w] yb' yb yn' yn) = 
          let f : (_x11 : TwoBits c xb' yb') -> Bin (S (S w)) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) 
            hi' : Nat hi : Bit hi' lo' : Nat lo : Bit lo' pf : Id Nat (plus c (plus xb' yb')) (plus lo' (double hi'))
              [f] ([TB] [c] [xb'] [yb'] hi' hi lo' lo pf) = 
                let postulate eq : Id Nat (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn'))))
                in subst Nat (Bin (S (S w))) (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) eq (C (S w) lo' lo (plus hi' (plus xn' yn')) (add' w hi' xn' yn' hi xn yn))
          in f (adb c xb' yb' cb xb yb)
    add : (w : Nat) -> (x : Nat) -> (y : Nat) -> (bx : Bin w x) -> (by : Bin w y) -> Bin (S w) (plus x y) = (\w : Nat. (\x : Nat. (\y : Nat. (\bx : Bin w x. (\by : Bin w y. add' w Z x y O bx by)))))
    foreign inputSize : Nat
    binVal : (_x12 : Bool) -> (_x13 : Nat) -> Nat 
      b : Bool
        [binVal] b Z = Z
      n : Nat
        [binVal] True (S n) = S (double (binVal False n))
      n : Nat
        [binVal] False (S n) = double (binVal True n)
    mkBin : (b : Bool) -> (w : Nat) -> Bin w (binVal b w) 
      b : Bool
        [mkBin] b Z = N
      n : Nat
        [mkBin] True (S n) = C n 1 I (binVal False n) (mkBin False n)
      n : Nat
        [mkBin] False (S n) = C n Z O (binVal True n) (mkBin True n)
    main : Bin (S inputSize) (plus (binVal True inputSize) (binVal False inputSize)) = 
      let
        x : Bin inputSize (binVal True inputSize) = mkBin True inputSize
        y : Bin inputSize (binVal False inputSize) = mkBin False inputSize
      in add inputSize (binVal True inputSize) (binVal False inputSize) x y
  in main

### Evarified ###

  let
    constructor Nat :1: Type
    constructor Z :2: Nat
    constructor S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        [plus] -9- Z -8- n = n
      m :10: Nat n :11: Nat
        [plus] -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    constructor Bool :18: Type
    constructor True :19: Bool
    constructor False :20: Bool
    not :21: (_x2 :22: Bool) -> Bool 
      [not] -23- True = False
      [not] -24- False = True
    constructor Unit :25: Type
    constructor MkUnit :26: Unit
    constructor Pair :27: (_x3 :28: Type) -> (_x4 :29: Type) -> Type
    constructor MkPair :30: (a :31: Type) -> (b :32: Type) -> (_x5 :33: a) -> (_x6 :34: b) -> Pair -36- a -35- b
    fst :37: (a :38: Type) -> (b :39: Type) -> (_x7 :40: Pair -42- a -41- b) -> a 
      a :43: Type b :44: Type x :45: a y :46: b
        [fst] -49- a -48- b -47- ([MkPair] -53- [a] -52- [b] -51- x -50- y) = x
    snd :54: (a :55: Type) -> (b :56: Type) -> (_x8 :57: Pair -59- a -58- b) -> b 
      a :60: Type b :61: Type x :62: a y :63: b
        [snd] -66- a -65- b -64- ([MkPair] -70- [a] -69- [b] -68- x -67- y) = y
    constructor Either :71: (_x9 :72: Type) -> (_x10 :73: Type) -> Type
    constructor Left :74: (a :75: Type) -> (b :76: Type) -> (_x11 :77: a) -> Either -79- a -78- b
    constructor Right :80: (a :81: Type) -> (b :82: Type) -> (_x12 :83: b) -> Either -85- a -84- b
    id :86: (a :87: Type) -> (x :88: a) -> a = (\a :89: Type. (\x :90: a. x))
    constructor Fin :91: (_x13 :92: Nat) -> Type
    constructor FZ :93: (n :94: Nat) -> Fin -95- (S -96- n)
    constructor FS :97: (n :98: Nat) -> (_x14 :99: Fin -100- n) -> Fin -101- (S -102- n)
    constructor Vect :103: (_x15 :104: Nat) -> (_x16 :105: Type) -> Type
    constructor VN :106: (a :107: Type) -> Vect -109- Z -108- a
    constructor VC :110: (n :111: Nat) -> (a :112: Type) -> (x :113: a) -> (xs :114: Vect -116- n -115- a) -> Vect -118- (S -119- n) -117- a
    constructor Id :120: (a :121: Type) -> (x :122: a) -> (y :123: a) -> Type
    constructor Refl :124: (a :125: Type) -> (x :126: a) -> Id -129- a -128- x -127- x
    subst :130: (a :131: Type) -> (P :132: (_x0 :133: a) -> Type) -> (x :134: a) -> (y :135: a) -> (eq :136: Id -139- a -138- x -137- y) -> (_x1 :140: P -141- x) -> P -142- y 
      a :143: Type P :144: (_x2 :145: a) -> Type x :146: a
        [subst] -151- a -150- P -149- x -148- [x] -147- [Refl -153- a -152- x] = (\z :154: P -155- x. z)
    constructor Bit :156: (_x0 :157: Nat) -> Type
    constructor I :158: Bit -159- 1
    constructor O :161: Bit -162- Z
    double :163: (_x1 :164: Nat) -> Nat 
      [double] -165- Z = Z
      n :166: Nat
        [double] -167- (S -168- n) = S -169- (S -170- (double -171- n))
    constructor Bin :172: (width :173: Nat) -> (value :174: Nat) -> Type
    constructor N :175: Bin -177- Z -176- Z
    constructor C :178: (width :179: Nat) -> (lsbVal :180: Nat) -> (lsb :181: Bit -182- lsbVal) -> (restVal :183: Nat) -> (rest :R: Bin -185- width -184- restVal) -> Bin -187- (S -188- width) -186- (plus -190- lsbVal -189- (double -191- restVal))
    constructor TwoBits :192: (_x2 :193: Nat) -> (_x3 :194: Nat) -> (_x4 :195: Nat) -> Type
    constructor TB :196: (c :197: Nat) -> (x :198: Nat) -> (y :199: Nat) -> (hi' :200: Nat) -> (hi :201: Bit -202- hi') -> (lo' :203: Nat) -> (lo :204: Bit -205- lo') -> (pf :206: Id -209- Nat -208- (plus -211- c -210- (plus -213- x -212- y)) -207- (plus -215- lo' -214- (double -216- hi'))) -> TwoBits -219- c -218- x -217- y
    adb :220: (c :221: Nat) -> (x :222: Nat) -> (y :223: Nat) -> (_x5 :224: Bit -225- c) -> (_x6 :226: Bit -227- x) -> (_x7 :228: Bit -229- y) -> TwoBits -232- c -231- x -230- y 
      [adb] -238- [Z] -237- [Z] -236- [Z] -235- O -234- O -233- O = TB -246- Z -245- Z -244- Z -243- Z -242- O -241- Z -240- O -239- (Refl -248- Nat -247- Z)
      [adb] -254- [1] -253- [Z] -252- [Z] -251- I -250- O -249- O = TB -263- 1 -262- Z -261- Z -260- Z -259- O -258- 1 -257- I -256- (Refl -267- Nat -266- 1)
      [adb] -274- [Z] -273- [1] -272- [Z] -271- O -270- I -269- O = TB -283- Z -282- 1 -281- Z -280- Z -279- O -278- 1 -277- I -276- (Refl -287- Nat -286- 1)
      [adb] -294- [Z] -293- [Z] -292- [1] -291- O -290- O -289- I = TB -303- Z -302- Z -301- 1 -300- Z -299- O -298- 1 -297- I -296- (Refl -307- Nat -306- 1)
      [adb] -314- [1] -313- [1] -312- [Z] -311- I -310- I -309- O = TB -324- 1 -323- 1 -322- Z -321- 1 -320- I -319- Z -318- O -317- (Refl -329- Nat -328- 2)
      [adb] -337- [1] -336- [Z] -335- [1] -334- I -333- O -332- I = TB -347- 1 -346- Z -345- 1 -344- 1 -343- I -342- Z -341- O -340- (Refl -352- Nat -351- 2)
      [adb] -360- [Z] -359- [1] -358- [1] -357- O -356- I -355- I = TB -370- Z -369- 1 -368- 1 -367- 1 -366- I -365- Z -364- O -363- (Refl -375- Nat -374- 2)
      [adb] -383- [1] -382- [1] -381- [1] -380- I -379- I -378- I = TB -394- 1 -393- 1 -392- 1 -391- 1 -390- I -389- 1 -388- I -387- (Refl -401- Nat -400- 3)
    add' :405: (w :406: Nat) -> (c :407: Nat) -> (x :408: Nat) -> (y :409: Nat) -> (_x8 :410: Bit -411- c) -> (_x9 :412: Bin -414- w -413- x) -> (_x10 :415: Bin -417- w -416- y) -> Bin -419- (S -420- w) -418- (plus -422- c -421- (plus -424- x -423- y)) 
      c :425: Nat cb :426: Bit -427- c
        [add'] -434- [Z] -433- c -432- [Z] -431- [Z] -430- cb -429- N -428- N = C -439- Z -438- c -437- cb -436- Z -435- N
      w :440: Nat c :441: Nat cb :442: Bit -443- c xb' :444: Nat xb :445: Bit -446- xb' xn' :447: Nat xn :448: Bin -450- w -449- xn' yb' :451: Nat yb :452: Bit -453- yb' yn' :454: Nat yn :455: Bin -457- w -456- yn'
        [add'] -464- ([S] -465- w) -463- c -462- [plus -467- xb' -466- (double -468- xn')] -461- [plus -470- yb' -469- (double -471- yn')] -460- cb -459- (C -476- [w] -475- xb' -474- xb -473- xn' -472- xn) -458- (C -481- [w] -480- yb' -479- yb -478- yn' -477- yn) = 
          let f :482: (_x11 :483: TwoBits -486- c -485- xb' -484- yb') -> Bin -488- (S -489- (S -490- w)) -487- (plus -492- c -491- (plus -494- (plus -496- xb' -495- (double -497- xn')) -493- (plus -499- yb' -498- (double -500- yn')))) 
            hi' :501: Nat hi :502: Bit -503- hi' lo' :504: Nat lo :505: Bit -506- lo' pf :507: Id -510- Nat -509- (plus -512- c -511- (plus -514- xb' -513- yb')) -508- (plus -516- lo' -515- (double -517- hi'))
              [f] -518- ([TB] -526- [c] -525- [xb'] -524- [yb'] -523- hi' -522- hi -521- lo' -520- lo -519- pf) = 
                let postulate eq :527: Id -530- Nat -529- (plus -532- lo' -531- (double -533- (plus -535- hi' -534- (plus -537- xn' -536- yn')))) -528- (plus -539- c -538- (plus -541- (plus -543- xb' -542- (double -544- xn')) -540- (plus -546- yb' -545- (double -547- yn'))))
                in subst -553- Nat -552- (Bin -554- (S -555- (S -556- w))) -551- (plus -558- lo' -557- (double -559- (plus -561- hi' -560- (plus -563- xn' -562- yn')))) -550- (plus -565- c -564- (plus -567- (plus -569- xb' -568- (double -570- xn')) -566- (plus -572- yb' -571- (double -573- yn')))) -549- eq -548- (C -578- (S -579- w) -577- lo' -576- lo -575- (plus -581- hi' -580- (plus -583- xn' -582- yn')) -574- (add' -590- w -589- hi' -588- xn' -587- yn' -586- hi -585- xn -584- yn))
          in f -591- (adb -597- c -596- xb' -595- yb' -594- cb -593- xb -592- yb)
    add :598: (w :599: Nat) -> (x :600: Nat) -> (y :601: Nat) -> (bx :602: Bin -604- w -603- x) -> (by :605: Bin -607- w -606- y) -> Bin -609- (S -610- w) -608- (plus -612- x -611- y) = (\w :613: Nat. (\x :614: Nat. (\y :615: Nat. (\bx :616: Bin -618- w -617- x. (\by :619: Bin -621- w -620- y. add' -628- w -627- Z -626- x -625- y -624- O -623- bx -622- by)))))
    foreign inputSize :629: Nat
    binVal :630: (_x12 :631: Bool) -> (_x13 :632: Nat) -> Nat 
      b :633: Bool
        [binVal] -635- b -634- Z = Z
      n :636: Nat
        [binVal] -638- True -637- (S -639- n) = S -640- (double -641- (binVal -643- False -642- n))
      n :644: Nat
        [binVal] -646- False -645- (S -647- n) = double -648- (binVal -650- True -649- n)
    mkBin :651: (b :652: Bool) -> (w :653: Nat) -> Bin -655- w -654- (binVal -657- b -656- w) 
      b :658: Bool
        [mkBin] -660- b -659- Z = N
      n :661: Nat
        [mkBin] -663- True -662- (S -664- n) = C -669- n -668- 1 -667- I -666- (binVal -672- False -671- n) -665- (mkBin -674- False -673- n)
      n :675: Nat
        [mkBin] -677- False -676- (S -678- n) = C -683- n -682- Z -681- O -680- (binVal -685- True -684- n) -679- (mkBin -687- True -686- n)
    main :688: Bin -690- (S -691- inputSize) -689- (plus -693- (binVal -695- True -694- inputSize) -692- (binVal -697- False -696- inputSize)) = 
      let
        x :698: Bin -700- inputSize -699- (binVal -702- True -701- inputSize) = mkBin -704- True -703- inputSize
        y :705: Bin -707- inputSize -706- (binVal -709- False -708- inputSize) = mkBin -711- False -710- inputSize
      in add -716- inputSize -715- (binVal -718- True -717- inputSize) -714- (binVal -720- False -719- inputSize) -713- x -712- y
  in main

### Constraints ###

[] -> [2,3,19,20,130,140,154,175,178,188,405,406,412,415,420,428,429,434,435,440,448,455,458,459,464,465,472,477,482,489,490,548,555,556,574,579,584,585,590,598,599,602,605,610,613,616,619,622,623,628,629,651,652,653,659,660,661,662,663,664,665,673,674,675,676,677,678,679,686,687,691,698,703,704,705,710,711,712,713,716,R]
[5,6,134,164] -> [447,501,561,563]
[5,6,135] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,163,164,165,166,167,168,169,170,171,444,451,567,568,569,572]
[5,6,135,164] -> [447,570]
[5,6,135,568] -> [6]
[5,6,135,569] -> [5]
[5,6,135,570] -> [164]
[5,6,183] -> [447,583]
[5,134] -> [504,558]
[5,135] -> [441,565]
[5,183] -> [501,581]
[5,461] -> [451,470]
[5,462] -> [444,467]
[6,134] -> [163,164,165,166,167,168,169,170,171,557]
[6,134,164] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,454,559,560,562]
[6,134,164,560] -> [6]
[6,134,164,561] -> [5]
[6,134,164,562] -> [6]
[6,134,164,563] -> [5]
[6,134,559] -> [164]
[6,135] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,163,164,165,166,167,168,169,170,171,564,566,571]
[6,135,164] -> [454,573]
[6,135,566] -> [6]
[6,135,567] -> [5]
[6,135,571] -> [6]
[6,135,572] -> [5]
[6,135,573] -> [164]
[6,164,461] -> [454,471]
[6,164,462] -> [447,468]
[6,183] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,454,580,582]
[6,183,582] -> [6]
[6,183,583] -> [5]
[6,461] -> [163,164,165,166,167,168,169,170,171,469]
[6,461,471] -> [164]
[6,462] -> [163,164,165,166,167,168,169,170,171,466]
[6,462,468] -> [164]
[15] -> [640]
[15,206,483] -> [268,288,308,330,331,353,376,402,403]
[125,147] -> [143,153]
[125,206,483] -> [1,248,267,287,307,329,352,375,401]
[126,147] -> [146,152]
[126,206,483] -> [247,266,268,286,288,306,308,328,330,331,351,353,354,374,376,377,400,402,403,404]
[127,147] -> [137]
[127,206,483] -> [207]
[128,147] -> [138]
[128,206,483] -> [208]
[129,147] -> [139]
[129,206,483] -> [209]
[131] -> [1,151,553]
[132] -> [150,172,552]
[132,133] -> [174]
[132,173] -> [554]
[132,174] -> [133]
[132,554] -> [173]
[133,150] -> [145]
[134] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,149,551]
[134,557] -> [6]
[134,558] -> [5]
[135] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,148,550]
[135,564] -> [6]
[135,565] -> [5]
[136] -> [147,527,549]
[136,137] -> [528]
[136,138] -> [529]
[136,139] -> [530]
[136,528] -> [137]
[136,529] -> [138]
[136,530] -> [139]
[136,531] -> [557]
[136,532] -> [558]
[136,533] -> [559]
[136,534] -> [560]
[136,535] -> [561]
[136,536] -> [562]
[136,537] -> [563]
[136,538] -> [564]
[136,539] -> [565]
[136,540] -> [566]
[136,541] -> [567]
[136,542] -> [568]
[136,543] -> [569]
[136,544] -> [570]
[136,545] -> [571]
[136,546] -> [572]
[136,547] -> [573]
[136,557] -> [531]
[136,558] -> [532]
[136,559] -> [533]
[136,560] -> [534]
[136,561] -> [535]
[136,562] -> [536]
[136,563] -> [537]
[136,564] -> [538]
[136,565] -> [539]
[136,566] -> [540]
[136,567] -> [541]
[136,568] -> [542]
[136,569] -> [543]
[136,570] -> [544]
[136,571] -> [545]
[136,572] -> [546]
[136,573] -> [547]
[137,147] -> [127]
[138,147] -> [128]
[139,147] -> [129]
[141] -> [155,186]
[142] -> [155,487]
[143] -> [151]
[144] -> [150]
[145,150] -> [133]
[146] -> [149]
[147] -> [124,136]
[147,152] -> [126]
[147,153] -> [125]
[148] -> [135,146]
[149] -> [134]
[150] -> [132]
[151] -> [131]
[155] -> [141,142]
[159,181] -> [182]
[159,201,483] -> [202]
[159,204,483] -> [205]
[159,483] -> [225,227,229]
[160,181] -> [670]
[160,201,483] -> [327,350,373,398]
[160,204,483] -> [265,285,305,399]
[160,483] -> [255,275,295,315,316,338,339,361,362,384,385,386]
[162,181] -> [182]
[162,201,483] -> [202]
[162,204,483] -> [205]
[162,410] -> [411]
[162,483] -> [225,227,229]
[169,206,483] -> [330,353,376,403]
[170,206,483] -> [331,354,377,404]
[176] -> [184,413,416,654]
[177] -> [185,414,417,655]
[179] -> [439,476,481,578,669,683]
[180] -> [425,438,475,480,504,577,668,670,682]
[181] -> [158,161,426,437,474,479,505,576,667,681]
[181,182] -> [159,162,427,506]
[181,427] -> [182]
[181,506] -> [182]
[181,670] -> [160]
[182,474] -> [446]
[182,479] -> [453]
[183] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,163,164,165,166,167,168,169,170,171,436,473,478,575,630,631,632,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,666,680]
[183,580] -> [6]
[183,581] -> [5]
[183,631] -> [672,685]
[183,632] -> [671,684]
[183,671] -> [632]
[183,672] -> [631]
[183,684] -> [632]
[183,685] -> [631]
[184] -> [176,418,449,456,654]
[185] -> [177,419,450,457,655]
[186] -> [141,413,416,418,654]
[187] -> [414,417,419,554,655]
[189] -> [421,466,469,557]
[190] -> [422,467,470,558]
[191] -> [468,471,559,641,648]
[197,483] -> [246,263,264,283,303,324,325,347,348,370,394,395]
[197,518] -> [526]
[198,483] -> [245,262,282,284,302,323,326,346,369,371,393,396]
[198,518] -> [525]
[199,483] -> [244,261,281,301,304,322,345,349,368,372,392,397]
[199,518] -> [524]
[200,483] -> [243,260,280,300,321,327,344,350,367,373,391,398]
[200,518] -> [523]
[201,202,483] -> [159,162]
[201,327,483] -> [160]
[201,350,483] -> [160]
[201,373,483] -> [160]
[201,398,483] -> [160]
[201,483] -> [242,259,279,299,320,343,366,390]
[201,518] -> [522]
[202,522] -> [503]
[203,483] -> [241,258,265,278,285,298,305,319,342,365,389,399]
[203,518] -> [521]
[204,205,483] -> [159,162]
[204,265,483] -> [160]
[204,285,483] -> [160]
[204,305,483] -> [160]
[204,399,483] -> [160]
[204,483] -> [240,257,277,297,318,341,364,388]
[204,518] -> [520]
[205,520] -> [506]
[206,207,483] -> [127]
[206,208,483] -> [128]
[206,209,483] -> [129]
[206,247,483] -> [126]
[206,248,483] -> [125]
[206,266,483] -> [126]
[206,267,483] -> [125]
[206,268,483] -> [15]
[206,286,483] -> [126]
[206,287,483] -> [125]
[206,288,483] -> [15]
[206,304,483] -> [308]
[206,306,483] -> [126]
[206,307,483] -> [125]
[206,308,483] -> [15,304]
[206,328,483] -> [126]
[206,329,483] -> [125]
[206,330,483] -> [15,169]
[206,331,483] -> [15,170]
[206,349,483] -> [354]
[206,351,483] -> [126]
[206,352,483] -> [125]
[206,353,483] -> [15,169]
[206,354,483] -> [170,349]
[206,372,483] -> [377]
[206,374,483] -> [126]
[206,375,483] -> [125]
[206,376,483] -> [15,169]
[206,377,483] -> [170,372]
[206,397,483] -> [404]
[206,400,483] -> [126]
[206,401,483] -> [125]
[206,402,483] -> [15]
[206,403,483] -> [15,169]
[206,404,483] -> [170,397]
[206,483] -> [124,239,256,276,296,317,340,363,387]
[206,518] -> [519]
[207,519] -> [508]
[208,519] -> [509]
[209,519] -> [510]
[210,519] -> [511]
[211,519] -> [512]
[212,519] -> [513]
[213,519] -> [514]
[214,519] -> [515]
[215,519] -> [516]
[216,519] -> [517]
[217,483] -> [230]
[217,518] -> [484]
[218,483] -> [231]
[218,518] -> [485]
[219,483] -> [232]
[219,518] -> [486]
[221,483] -> [238,254,274,294,314,337,360,383,441,597]
[222,483] -> [237,253,273,293,313,336,359,382,444,596]
[223,483] -> [236,252,272,292,312,335,358,381,451,595]
[224,225,483] -> [443]
[224,443,483] -> [225]
[224,483] -> [442,594]
[225,483] -> [159,162]
[226,227,483] -> [446]
[226,446,483] -> [227]
[226,483] -> [445,593]
[227,483] -> [159,162]
[228,229,483] -> [453]
[228,453,483] -> [229]
[228,483] -> [452,592]
[229,483] -> [159,162]
[230,483] -> [217,484]
[231,483] -> [218,485]
[232,483] -> [219,486]
[236,483] -> [223]
[237,483] -> [222]
[238,483] -> [221]
[239,483] -> [206]
[240,483] -> [204]
[241,483] -> [203]
[242,483] -> [201]
[243,483] -> [200]
[244,483] -> [199]
[245,483] -> [198]
[246,483] -> [197]
[252,483] -> [223]
[253,483] -> [222]
[254,483] -> [221,255]
[255,483] -> [160,264]
[256,483] -> [206]
[257,483] -> [204]
[258,483] -> [203]
[259,483] -> [201]
[260,483] -> [200]
[261,483] -> [199]
[262,483] -> [198]
[263,483] -> [197]
[264,483] -> [255]
[272,483] -> [223]
[273,483] -> [222,275]
[274,483] -> [221]
[275,483] -> [160,284]
[276,483] -> [206]
[277,483] -> [204]
[278,483] -> [203]
[279,483] -> [201]
[280,483] -> [200]
[281,483] -> [199]
[282,483] -> [198]
[283,483] -> [197]
[284,483] -> [275]
[292,483] -> [223,295]
[293,483] -> [222]
[294,483] -> [221]
[295,483] -> [160,304]
[296,483] -> [206]
[297,483] -> [204]
[298,483] -> [203]
[299,483] -> [201]
[300,483] -> [200]
[301,483] -> [199]
[302,483] -> [198]
[303,483] -> [197]
[304,483] -> [295]
[312,483] -> [223]
[313,483] -> [222,316]
[314,483] -> [221,315]
[315,483] -> [160,325]
[316,483] -> [160,326]
[317,483] -> [206]
[318,483] -> [204]
[319,483] -> [203]
[320,483] -> [201]
[321,483] -> [200]
[322,483] -> [199]
[323,483] -> [198]
[324,483] -> [197]
[325,483] -> [315]
[326,483] -> [316]
[335,483] -> [223,339]
[336,483] -> [222]
[337,483] -> [221,338]
[338,483] -> [160,348]
[339,483] -> [160,349]
[340,483] -> [206]
[341,483] -> [204]
[342,483] -> [203]
[343,483] -> [201]
[344,483] -> [200]
[345,483] -> [199]
[346,483] -> [198]
[347,483] -> [197]
[348,483] -> [338]
[349,483] -> [339]
[358,483] -> [223,362]
[359,483] -> [222,361]
[360,483] -> [221]
[361,483] -> [160,371]
[362,483] -> [160,372]
[363,483] -> [206]
[364,483] -> [204]
[365,483] -> [203]
[366,483] -> [201]
[367,483] -> [200]
[368,483] -> [199]
[369,483] -> [198]
[370,483] -> [197]
[371,483] -> [361]
[372,483] -> [362]
[381,483] -> [223,386]
[382,483] -> [222,385]
[383,483] -> [221,384]
[384,483] -> [160,395]
[385,483] -> [160,396]
[386,483] -> [160,397]
[387,483] -> [206]
[388,483] -> [204]
[389,483] -> [203]
[390,483] -> [201]
[391,483] -> [200]
[392,483] -> [199]
[393,483] -> [198]
[394,483] -> [197]
[395,483] -> [384]
[396,483] -> [385]
[397,483] -> [386]
[407] -> [433,463,501,589,627]
[408] -> [432,447,462,588,614,626]
[409] -> [431,454,461,587,615,625]
[410] -> [161,430,460,502,586,624]
[410,411] -> [162,503]
[410,503] -> [411]
[411,430] -> [427]
[411,460] -> [443]
[413] -> [176,186,449,617]
[414] -> [177,187,450,618]
[416] -> [176,186,456,620]
[417] -> [177,187,457,621]
[418] -> [184,186,487,608]
[419] -> [185,187,488,609]
[421] -> [189,491,580]
[422] -> [190,492,581]
[423] -> [493,582,611]
[424] -> [494,583,612]
[425] -> [433]
[426] -> [430]
[427,430] -> [411]
[430] -> [410]
[431] -> [409]
[432] -> [408]
[433] -> [407]
[436] -> [183]
[437] -> [181]
[438] -> [180]
[439] -> [179]
[441] -> [463]
[442] -> [460]
[443,460] -> [411]
[444] -> [475]
[445] -> [474]
[446,474] -> [182]
[447] -> [473]
[449] -> [184,413]
[450] -> [185,414]
[451] -> [480]
[452] -> [479]
[453,479] -> [182]
[454] -> [478]
[456] -> [184,416]
[457] -> [185,417]
[460] -> [410]
[461] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,409]
[461,469] -> [6]
[461,470] -> [5]
[462] -> [4,5,6,7,8,9,10,11,12,13,14,15,16,17,408]
[462,466] -> [6]
[462,467] -> [5]
[463] -> [407]
[466] -> [189,495]
[467] -> [190,496]
[468] -> [191,497]
[469] -> [189,498]
[470] -> [190,499]
[471] -> [191,500]
[473] -> [183]
[474] -> [181]
[475] -> [180]
[476] -> [179]
[478] -> [183]
[479] -> [181]
[480] -> [180]
[481] -> [179]
[483] -> [158,161,196,220,224,226,228,233,234,235,249,250,251,269,270,271,289,290,291,309,310,311,332,333,334,355,356,357,378,379,380,518,591]
[483,484] -> [230]
[483,485] -> [231]
[483,486] -> [232]
[483,592] -> [228]
[483,593] -> [226]
[483,594] -> [224]
[483,595] -> [223]
[483,596] -> [222]
[483,597] -> [221]
[484,518] -> [217]
[485,518] -> [218]
[486,518] -> [219]
[487] -> [142,418]
[488] -> [419,554]
[491] -> [421,564]
[492] -> [422,565]
[493] -> [423,566]
[494] -> [424,567]
[495] -> [466,568]
[496] -> [467,569]
[497] -> [468,570]
[498] -> [469,571]
[499] -> [470,572]
[500] -> [471,573]
[501] -> [523]
[502] -> [522]
[503,522] -> [202]
[504] -> [521]
[505] -> [520]
[506,520] -> [205]
[507] -> [519]
[508,519] -> [207]
[509,519] -> [208]
[510,519] -> [209]
[511,519] -> [210]
[512,519] -> [211]
[513,519] -> [212]
[514,519] -> [213]
[515,519] -> [214]
[516,519] -> [215]
[517,519] -> [216]
[518] -> [196,483]
[519] -> [206,518]
[520] -> [204,518]
[521] -> [203,518]
[522] -> [201,518]
[523] -> [200,518]
[524] -> [199,451,518]
[525] -> [198,444,518]
[526] -> [197,441,518]
[549] -> [136]
[550] -> [135]
[551] -> [134]
[552] -> [132]
[553] -> [131]
[554] -> [187,488]
[557] -> [189]
[558] -> [190]
[559] -> [191]
[560] -> [580]
[561] -> [581]
[562] -> [582]
[563] -> [583]
[564] -> [491]
[565] -> [492]
[566] -> [493]
[567] -> [494]
[568] -> [495]
[569] -> [496]
[570] -> [497]
[571] -> [498]
[572] -> [499]
[573] -> [500]
[575] -> [183]
[576] -> [181]
[577] -> [180]
[578] -> [179]
[580] -> [421,560]
[581] -> [422,561]
[582] -> [423,562]
[583] -> [424,563]
[586] -> [410]
[587] -> [409]
[588] -> [408]
[589] -> [407]
[591] -> [483]
[600] -> [163,164,165,166,167,168,169,170,171,614,630,631,632,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,715]
[600,631] -> [718]
[600,632] -> [717]
[600,717] -> [632]
[600,718] -> [631]
[601] -> [163,164,165,166,167,168,169,170,171,615,630,631,632,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,714]
[601,631] -> [720]
[601,632] -> [719]
[601,719] -> [632]
[601,720] -> [631]
[603] -> [617,699]
[604] -> [618,700]
[606] -> [620,706]
[607] -> [621,707]
[608] -> [418,689]
[609] -> [419,690]
[611] -> [423,692]
[612] -> [424,693]
[614] -> [600]
[615] -> [601]
[617] -> [413,603]
[618] -> [414,604]
[620] -> [416,606]
[621] -> [417,607]
[624] -> [410]
[625] -> [409]
[626] -> [408]
[627] -> [407]
[640] -> [15]
[641] -> [191]
[642] -> [671]
[643] -> [672]
[648] -> [191]
[649] -> [684]
[650] -> [685]
[654] -> [176,184,186,699,706]
[655] -> [177,185,187,700,707]
[656] -> [671,684,701,708]
[657] -> [672,685,702,709]
[666] -> [183]
[667] -> [181]
[668] -> [180]
[669] -> [179]
[671] -> [642,656]
[672] -> [643,657]
[680] -> [183]
[681] -> [181]
[682] -> [180]
[683] -> [179]
[684] -> [649,656]
[685] -> [650,657]
[689] -> [608]
[690] -> [609]
[692] -> [611]
[693] -> [612]
[694] -> [717]
[695] -> [718]
[696] -> [719]
[697] -> [720]
[699] -> [603,654]
[700] -> [604,655]
[701] -> [656,717]
[702] -> [657,718]
[706] -> [606,654]
[707] -> [607,655]
[708] -> [656,719]
[709] -> [657,720]
[714] -> [601]
[715] -> [600]
[717] -> [694,701]
[718] -> [695,702]
[719] -> [696,708]
[720] -> [697,709]
[R] -> [688]

### Solution ###

[2,3,19,20,130,140,154,175,178,188,405,406,412,415,420,428,429,434,435,440,448,455,458,459,464,465,472,477,482,489,490,548,555,556,574,579,584,585,590,598,599,602,605,610,613,616,619,622,623,628,629,651,652,653,659,660,661,662,663,664,665,673,674,675,676,677,678,679,686,687,688,691,698,703,704,705,710,711,712,713,716,R]

### Annotated ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x13 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x14 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x15 :E: Nat) -> (_x16 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        [subst] -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :E: Bit -E- 1
    constructor O :E: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      [double] -E- Z = Z
      n :E: Nat
        [double] -E- (S -E- n) = S -E- (S -E- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :E: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :E: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :E: Bit -E- hi') -> (lo' :E: Nat) -> (lo :E: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :E: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :E: Bit -E- c) -> (_x6 :E: Bit -E- x) -> (_x7 :E: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      [adb] -E- [Z] -E- [Z] -E- [Z] -E- O -E- O -E- O = TB -E- Z -E- Z -E- Z -E- Z -E- O -E- Z -E- O -E- (Refl -E- Nat -E- Z)
      [adb] -E- [1] -E- [Z] -E- [Z] -E- I -E- O -E- O = TB -E- 1 -E- Z -E- Z -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [1] -E- [Z] -E- O -E- I -E- O = TB -E- Z -E- 1 -E- Z -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [Z] -E- [1] -E- O -E- O -E- I = TB -E- Z -E- Z -E- 1 -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [1] -E- [1] -E- [Z] -E- I -E- I -E- O = TB -E- 1 -E- 1 -E- Z -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [Z] -E- [1] -E- I -E- O -E- I = TB -E- 1 -E- Z -E- 1 -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [Z] -E- [1] -E- [1] -E- O -E- I -E- I = TB -E- Z -E- 1 -E- 1 -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [1] -E- [1] -E- I -E- I -E- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -E- I -E- 1 -E- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :R: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :E: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :E: Bit -E- c
        [add'] -R- [Z] -E- c -E- [Z] -E- [Z] -E- cb -R- N -R- N = C -E- Z -E- c -E- cb -E- Z -R- N
      w :R: Nat c :E: Nat cb :E: Bit -E- c xb' :E: Nat xb :E: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :E: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        [add'] -R- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -E- cb -R- (C -E- [w] -E- xb' -E- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -E- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :E: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :E: Bit -E- hi' lo' :E: Nat lo :E: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              [f] -E- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -E- hi -E- lo' -E- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -E- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -R- w -E- hi' -E- xn' -E- yn' -E- hi -R- xn -R- yn))
          in f -E- (adb -E- c -E- xb' -E- yb' -E- cb -E- xb -E- yb)
    add :R: (w :R: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :R: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -R- w -E- Z -E- x -E- y -E- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        [binVal] -E- b -E- Z = Z
      n :E: Nat
        [binVal] -E- True -E- (S -E- n) = S -E- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        [binVal] -E- False -E- (S -E- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :E: Bool
        [mkBin] -R- b -R- Z = N
      n :R: Nat
        [mkBin] -R- True -R- (S -R- n) = C -E- n -E- 1 -E- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        [mkBin] -R- False -R- (S -R- n) = C -E- n -E- Z -E- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -R- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Specialised ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x13 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x14 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x15 :E: Nat) -> (_x16 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        [subst] -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :E: Bit -E- 1
    constructor O :E: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      [double] -E- Z = Z
      n :E: Nat
        [double] -E- (S -E- n) = S -E- (S -E- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :E: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :E: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :E: Bit -E- hi') -> (lo' :E: Nat) -> (lo :E: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :E: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :E: Bit -E- c) -> (_x6 :E: Bit -E- x) -> (_x7 :E: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      [adb] -E- [Z] -E- [Z] -E- [Z] -E- O -E- O -E- O = TB -E- Z -E- Z -E- Z -E- Z -E- O -E- Z -E- O -E- (Refl -E- Nat -E- Z)
      [adb] -E- [1] -E- [Z] -E- [Z] -E- I -E- O -E- O = TB -E- 1 -E- Z -E- Z -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [1] -E- [Z] -E- O -E- I -E- O = TB -E- Z -E- 1 -E- Z -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [Z] -E- [1] -E- O -E- O -E- I = TB -E- Z -E- Z -E- 1 -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [1] -E- [1] -E- [Z] -E- I -E- I -E- O = TB -E- 1 -E- 1 -E- Z -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [Z] -E- [1] -E- I -E- O -E- I = TB -E- 1 -E- Z -E- 1 -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [Z] -E- [1] -E- [1] -E- O -E- I -E- I = TB -E- Z -E- 1 -E- 1 -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [1] -E- [1] -E- I -E- I -E- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -E- I -E- 1 -E- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :R: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :E: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :E: Bit -E- c
        [add'] -R- [Z] -E- c -E- [Z] -E- [Z] -E- cb -R- N -R- N = C -E- Z -E- c -E- cb -E- Z -R- N
      w :R: Nat c :E: Nat cb :E: Bit -E- c xb' :E: Nat xb :E: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :E: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        [add'] -R- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -E- cb -R- (C -E- [w] -E- xb' -E- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -E- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :E: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :E: Bit -E- hi' lo' :E: Nat lo :E: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              [f] -E- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -E- hi -E- lo' -E- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -E- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -R- w -E- hi' -E- xn' -E- yn' -E- hi -R- xn -R- yn))
          in f -E- (adb -E- c -E- xb' -E- yb' -E- cb -E- xb -E- yb)
    add :R: (w :R: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :R: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -R- w -E- Z -E- x -E- y -E- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        [binVal] -E- b -E- Z = Z
      n :E: Nat
        [binVal] -E- True -E- (S -E- n) = S -E- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        [binVal] -E- False -E- (S -E- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :E: Bool
        [mkBin] -R- b -R- Z = N
      n :R: Nat
        [mkBin] -R- True -R- (S -R- n) = C -E- n -E- 1 -E- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        [mkBin] -R- False -R- (S -R- n) = C -E- n -E- Z -E- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -R- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Final annotation ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x13 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x14 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x15 :E: Nat) -> (_x16 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        [subst] -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :E: Bit -E- 1
    constructor O :E: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      [double] -E- Z = Z
      n :E: Nat
        [double] -E- (S -E- n) = S -E- (S -E- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :E: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :E: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :E: Bit -E- hi') -> (lo' :E: Nat) -> (lo :E: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :E: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :E: Bit -E- c) -> (_x6 :E: Bit -E- x) -> (_x7 :E: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      [adb] -E- [Z] -E- [Z] -E- [Z] -E- O -E- O -E- O = TB -E- Z -E- Z -E- Z -E- Z -E- O -E- Z -E- O -E- (Refl -E- Nat -E- Z)
      [adb] -E- [1] -E- [Z] -E- [Z] -E- I -E- O -E- O = TB -E- 1 -E- Z -E- Z -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [1] -E- [Z] -E- O -E- I -E- O = TB -E- Z -E- 1 -E- Z -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [Z] -E- [1] -E- O -E- O -E- I = TB -E- Z -E- Z -E- 1 -E- Z -E- O -E- 1 -E- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [1] -E- [1] -E- [Z] -E- I -E- I -E- O = TB -E- 1 -E- 1 -E- Z -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [Z] -E- [1] -E- I -E- O -E- I = TB -E- 1 -E- Z -E- 1 -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [Z] -E- [1] -E- [1] -E- O -E- I -E- I = TB -E- Z -E- 1 -E- 1 -E- 1 -E- I -E- Z -E- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [1] -E- [1] -E- I -E- I -E- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -E- I -E- 1 -E- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :R: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :E: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :E: Bit -E- c
        [add'] -R- [Z] -E- c -E- [Z] -E- [Z] -E- cb -R- N -R- N = C -E- Z -E- c -E- cb -E- Z -R- N
      w :R: Nat c :E: Nat cb :E: Bit -E- c xb' :E: Nat xb :E: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :E: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        [add'] -R- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -E- cb -R- (C -E- [w] -E- xb' -E- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -E- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :E: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :E: Bit -E- hi' lo' :E: Nat lo :E: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              [f] -E- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -E- hi -E- lo' -E- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -E- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -R- w -E- hi' -E- xn' -E- yn' -E- hi -R- xn -R- yn))
          in f -E- (adb -E- c -E- xb' -E- yb' -E- cb -E- xb -E- yb)
    add :R: (w :R: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :R: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -R- w -E- Z -E- x -E- y -E- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        [binVal] -E- b -E- Z = Z
      n :E: Nat
        [binVal] -E- True -E- (S -E- n) = S -E- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        [binVal] -E- False -E- (S -E- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :E: Bool
        [mkBin] -R- b -R- Z = N
      n :R: Nat
        [mkBin] -R- True -R- (S -R- n) = C -E- n -E- 1 -E- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        [mkBin] -R- False -R- (S -R- n) = C -E- n -E- Z -E- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -R- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    subst = (\z. z)
    constructor N : Bin
    constructor C : (rest) -> Bin
    add' 
      [_] [_] N N = C N
      [_] ([_] w) (C xn) (C yn) = 
        let f = subst (C (add' w xn yn))
        in f
    add = (\w. (\bx. (\by. add' w bx by)))
    foreign inputSize
    mkBin 
      [_] _ Z = N
      [_] True (S n) = C (mkBin False n)
      [_] False (S n) = C (mkBin True n)
    main = 
      let
        x = mkBin True inputSize
        y = mkBin False inputSize
      in add inputSize x y
  in main

### Normal forms ###

unerased:
  
  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    subst : (a : Type) -> (P : (_x0 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (_x1 : P x) -> P y 
      a : Type P : (_x2 : a) -> Type x : a
        [subst] a P x [x] [Refl a x] = (\z : P x. z)
    constructor Bit : (_x0 : Nat) -> Type
    constructor I : Bit 1
    constructor O : Bit Z
    double : (_x1 : Nat) -> Nat 
      [double] Z = Z
      n : Nat
        [double] (S n) = S (S (double n))
    constructor Bin : (width : Nat) -> (value : Nat) -> Type
    constructor N : Bin Z Z
    constructor C : (width : Nat) -> (lsbVal : Nat) -> (lsb : Bit lsbVal) -> (restVal : Nat) -> (rest :R: Bin width restVal) -> Bin (S width) (plus lsbVal (double restVal))
    constructor TwoBits : (_x2 : Nat) -> (_x3 : Nat) -> (_x4 : Nat) -> Type
    constructor TB : (c : Nat) -> (x : Nat) -> (y : Nat) -> (hi' : Nat) -> (hi : Bit hi') -> (lo' : Nat) -> (lo : Bit lo') -> (pf : Id Nat (plus c (plus x y)) (plus lo' (double hi'))) -> TwoBits c x y
    adb : (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x5 : Bit c) -> (_x6 : Bit x) -> (_x7 : Bit y) -> TwoBits c x y 
      [adb] [Z] [Z] [Z] O O O = TB Z Z Z Z O Z O (Refl Nat Z)
      [adb] [1] [Z] [Z] I O O = TB 1 Z Z Z O 1 I (Refl Nat 1)
      [adb] [Z] [1] [Z] O I O = TB Z 1 Z Z O 1 I (Refl Nat 1)
      [adb] [Z] [Z] [1] O O I = TB Z Z 1 Z O 1 I (Refl Nat 1)
      [adb] [1] [1] [Z] I I O = TB 1 1 Z 1 I Z O (Refl Nat 2)
      [adb] [1] [Z] [1] I O I = TB 1 Z 1 1 I Z O (Refl Nat 2)
      [adb] [Z] [1] [1] O I I = TB Z 1 1 1 I Z O (Refl Nat 2)
      [adb] [1] [1] [1] I I I = TB 1 1 1 1 I 1 I (Refl Nat 3)
    add' : (w : Nat) -> (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x8 : Bit c) -> (_x9 : Bin w x) -> (_x10 : Bin w y) -> Bin (S w) (plus c (plus x y)) 
      c : Nat cb : Bit c
        [add'] [Z] c [Z] [Z] cb N N = C Z c cb Z N
      w : Nat c : Nat cb : Bit c xb' : Nat xb : Bit xb' xn' : Nat xn : Bin w xn' yb' : Nat yb : Bit yb' yn' : Nat yn : Bin w yn'
        [add'] ([S] w) c [plus xb' (double xn')] [plus yb' (double yn')] cb (C [w] xb' xb xn' xn) (C [w] yb' yb yn' yn) = 
          let f : (_x11 : TwoBits c xb' yb') -> Bin (S (S w)) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) 
            hi' : Nat hi : Bit hi' lo' : Nat lo : Bit lo' pf : Id Nat (plus c (plus xb' yb')) (plus lo' (double hi'))
              [f] ([TB] [c] [xb'] [yb'] hi' hi lo' lo pf) = 
                let postulate eq : Id Nat (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn'))))
                in subst Nat (Bin (S (S w))) (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) eq (C (S w) lo' lo (plus hi' (plus xn' yn')) (add' w hi' xn' yn' hi xn yn))
          in f (adb c xb' yb' cb xb yb)
    foreign inputSize : Nat
    binVal : (_x12 : Bool) -> (_x13 : Nat) -> Nat 
      b : Bool
        [binVal] b Z = Z
      n : Nat
        [binVal] True (S n) = S (double (binVal False n))
      n : Nat
        [binVal] False (S n) = double (binVal True n)
    mkBin : (b : Bool) -> (w : Nat) -> Bin w (binVal b w) 
      b : Bool
        [mkBin] b Z = N
      n : Nat
        [mkBin] True (S n) = C n 1 I (binVal False n) (mkBin False n)
      n : Nat
        [mkBin] False (S n) = C n Z O (binVal True n) (mkBin True n)
  in add' inputSize Z (binVal True inputSize) (binVal False inputSize) O (mkBin True inputSize) (mkBin False inputSize)

erased:
  
  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    subst = (\z. z)
    constructor N : Bin
    constructor C : (rest) -> Bin
    add' 
      [_] [_] N N = C N
      [_] ([_] w) (C xn) (C yn) = 
        let f = subst (C (add' w xn yn))
        in f
    foreign inputSize
    mkBin 
      [_] _ Z = N
      [_] True (S n) = C (mkBin False n)
      [_] False (S n) = C (mkBin True n)
  in add' inputSize (mkBin True inputSize) (mkBin False inputSize)

