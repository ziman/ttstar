-- vim: ft=idris

### Desugared ###

  let
    postulate RealWorld : Type
    postulate IOResult : (_x0 : Type) -> Type
    postulate MkIOR : (a : Type) -> (x : a) -> (w : RealWorld) -> IOResult a
    postulate IO : (_x1 : Type) -> Type
    postulate MkIO : (a : Type) -> (f : (_x2 : RealWorld) -> IOResult a) -> IO a
    ioReturn : (a : Type) -> (x : a) -> IO a 
      a : Type x : a
        [ioReturn] a x = MkIO a (\w : RealWorld. MkIOR a x w)
    ioBind3 : (b : Type) -> (_x3 : RealWorld) -> (_x4 : IO b) -> IOResult b 
      b : Type w : RealWorld f : (_x5 : RealWorld) -> IOResult b
        [ioBind3] b w (MkIO [b] f) = f w
    ioBind2 : (a : Type) -> (b : Type) -> (g : (x : a) -> IO b) -> (r : IOResult a) -> IOResult b 
      a : Type b : Type g : (_x6 : a) -> IO b x : a w : RealWorld
        [ioBind2] a b g (MkIOR [a] x w) = ioBind3 b w (g x)
    ioBind : (a : Type) -> (b : Type) -> (x : IO a) -> (y : (_x7 : a) -> IO b) -> IO b 
      a : Type b : Type f : (_x8 : RealWorld) -> IOResult a g : (_x9 : a) -> IO b
        [ioBind] a b (MkIO [a] f) g = MkIO b (\w : RealWorld. ioBind2 a b g (f w))
    ioIgnore : (a : Type) -> (b : Type) -> (r : b) -> (x : IO a) -> IO b = (\a : Type. (\b : Type. (\r : b. (\x : IO a. ioBind a b x (\v : a. ioReturn b r)))))
    postulate Nat : Type
    postulate Z : Nat
    postulate S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    postulate Bool : Type
    postulate T : Bool
    postulate F : Bool
    not : (_x2 : Bool) -> Bool 
      [not] T = F
      [not] F = T
    postulate Unit : Type
    postulate tt : Unit
    postulate Int : Type
    foreign intS : (x :R: Int) -> Int
    foreign intZ : Int
    postulate Unspec : Type
    foreign printSchemeRepr : (a :E: Type) -> (x :R: a) -> IO Unspec
    natToInt : (_x0 : Nat) -> Int 
      [natToInt] Z = intZ
      n : Nat
        [natToInt] (S n) = intS (natToInt n)
    printNat : (x : Nat) -> IO Unspec = (\x : Nat. printSchemeRepr Int (natToInt x))
    main : IO Unspec = printNat 4
  in main

### Evarified ###

  let
    postulate RealWorld :1: Type
    postulate IOResult :2: (_x0 :3: Type) -> Type
    postulate MkIOR :4: (a :5: Type) -> (x :6: a) -> (w :7: RealWorld) -> IOResult -8- a
    postulate IO :9: (_x1 :10: Type) -> Type
    postulate MkIO :11: (a :12: Type) -> (f :13: (_x2 :14: RealWorld) -> IOResult -15- a) -> IO -16- a
    ioReturn :17: (a :18: Type) -> (x :19: a) -> IO -20- a 
      a :21: Type x :22: a
        [ioReturn] -24- a -23- x = MkIO -26- a -25- (\w :27: RealWorld. MkIOR -30- a -29- x -28- w)
    ioBind3 :31: (b :32: Type) -> (_x3 :33: RealWorld) -> (_x4 :34: IO -35- b) -> IOResult -36- b 
      b :37: Type w :38: RealWorld f :39: (_x5 :40: RealWorld) -> IOResult -41- b
        [ioBind3] -44- b -43- w -42- (MkIO -46- [b] -45- f) = f -47- w
    ioBind2 :48: (a :49: Type) -> (b :50: Type) -> (g :51: (x :52: a) -> IO -53- b) -> (r :54: IOResult -55- a) -> IOResult -56- b 
      a :57: Type b :58: Type g :59: (_x6 :60: a) -> IO -61- b x :62: a w :63: RealWorld
        [ioBind2] -67- a -66- b -65- g -64- (MkIOR -70- [a] -69- x -68- w) = ioBind3 -73- b -72- w -71- (g -74- x)
    ioBind :75: (a :76: Type) -> (b :77: Type) -> (x :78: IO -79- a) -> (y :80: (_x7 :81: a) -> IO -82- b) -> IO -83- b 
      a :84: Type b :85: Type f :86: (_x8 :87: RealWorld) -> IOResult -88- a g :89: (_x9 :90: a) -> IO -91- b
        [ioBind] -95- a -94- b -93- (MkIO -97- [a] -96- f) -92- g = MkIO -99- b -98- (\w :100: RealWorld. ioBind2 -104- a -103- b -102- g -101- (f -105- w))
    ioIgnore :106: (a :107: Type) -> (b :108: Type) -> (r :109: b) -> (x :110: IO -111- a) -> IO -112- b = (\a :113: Type. (\b :114: Type. (\r :115: b. (\x :116: IO -117- a. ioBind -121- a -120- b -119- x -118- (\v :122: a. ioReturn -124- b -123- r)))))
    postulate Nat :125: Type
    postulate Z :126: Nat
    postulate S :127: (x :R: Nat) -> Nat
    plus :128: (_x0 :129: Nat) -> (_x1 :130: Nat) -> Nat 
      n :131: Nat
        [plus] -133- Z -132- n = n
      m :134: Nat n :135: Nat
        [plus] -137- (S -138- m) -136- n = S -139- (plus -141- m -140- n)
    postulate Bool :142: Type
    postulate T :143: Bool
    postulate F :144: Bool
    not :145: (_x2 :146: Bool) -> Bool 
      [not] -147- T = F
      [not] -148- F = T
    postulate Unit :149: Type
    postulate tt :150: Unit
    postulate Int :151: Type
    foreign intS :152: (x :R: Int) -> Int
    foreign intZ :153: Int
    postulate Unspec :154: Type
    foreign printSchemeRepr :155: (a :E: Type) -> (x :R: a) -> IO -156- Unspec
    natToInt :157: (_x0 :158: Nat) -> Int 
      [natToInt] -159- Z = intZ
      n :160: Nat
        [natToInt] -161- (S -162- n) = intS -163- (natToInt -164- n)
    printNat :165: (x :166: Nat) -> IO -167- Unspec = (\x :168: Nat. printSchemeRepr -170- Int -169- (natToInt -171- x))
    main :172: IO -173- Unspec = printNat -174- 4
  in main

### Constraints ###

[] -> [126,127,152,153,155,157,158,159,160,161,162,163,164,165,166,168,169,171,174,175,176,177,178,R]
[156] -> [167]
[167] -> [156,173]
[170] -> [E]
[173] -> [167]
[E] -> [151,170]
[R] -> [172]

### Solution ###

[126,127,152,153,155,157,158,159,160,161,162,163,164,165,166,168,169,171,172,174,175,176,177,178,R]

### Annotated ###

  let
    postulate RealWorld :E: Type
    postulate IOResult :E: (_x0 :E: Type) -> Type
    postulate MkIOR :E: (a :E: Type) -> (x :E: a) -> (w :E: RealWorld) -> IOResult -E- a
    postulate IO :E: (_x1 :E: Type) -> Type
    postulate MkIO :E: (a :E: Type) -> (f :E: (_x2 :E: RealWorld) -> IOResult -E- a) -> IO -E- a
    ioReturn :E: (a :E: Type) -> (x :E: a) -> IO -E- a 
      a :E: Type x :E: a
        [ioReturn] -E- a -E- x = MkIO -E- a -E- (\w :E: RealWorld. MkIOR -E- a -E- x -E- w)
    ioBind3 :E: (b :E: Type) -> (_x3 :E: RealWorld) -> (_x4 :E: IO -E- b) -> IOResult -E- b 
      b :E: Type w :E: RealWorld f :E: (_x5 :E: RealWorld) -> IOResult -E- b
        [ioBind3] -E- b -E- w -E- (MkIO -E- [b] -E- f) = f -E- w
    ioBind2 :E: (a :E: Type) -> (b :E: Type) -> (g :E: (x :E: a) -> IO -E- b) -> (r :E: IOResult -E- a) -> IOResult -E- b 
      a :E: Type b :E: Type g :E: (_x6 :E: a) -> IO -E- b x :E: a w :E: RealWorld
        [ioBind2] -E- a -E- b -E- g -E- (MkIOR -E- [a] -E- x -E- w) = ioBind3 -E- b -E- w -E- (g -E- x)
    ioBind :E: (a :E: Type) -> (b :E: Type) -> (x :E: IO -E- a) -> (y :E: (_x7 :E: a) -> IO -E- b) -> IO -E- b 
      a :E: Type b :E: Type f :E: (_x8 :E: RealWorld) -> IOResult -E- a g :E: (_x9 :E: a) -> IO -E- b
        [ioBind] -E- a -E- b -E- (MkIO -E- [a] -E- f) -E- g = MkIO -E- b -E- (\w :E: RealWorld. ioBind2 -E- a -E- b -E- g -E- (f -E- w))
    ioIgnore :E: (a :E: Type) -> (b :E: Type) -> (r :E: b) -> (x :E: IO -E- a) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\r :E: b. (\x :E: IO -E- a. ioBind -E- a -E- b -E- x -E- (\v :E: a. ioReturn -E- b -E- r)))))
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate T :E: Bool
    postulate F :E: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- T = F
      [not] -E- F = T
    postulate Unit :E: Type
    postulate tt :E: Unit
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    foreign printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    main :R: IO -E- Unspec = printNat -R- 4
  in main

### Specialised ###

  let
    postulate RealWorld :E: Type
    postulate IOResult :E: (_x0 :E: Type) -> Type
    postulate MkIOR :E: (a :E: Type) -> (x :E: a) -> (w :E: RealWorld) -> IOResult -E- a
    postulate IO :E: (_x1 :E: Type) -> Type
    postulate MkIO :E: (a :E: Type) -> (f :E: (_x2 :E: RealWorld) -> IOResult -E- a) -> IO -E- a
    ioReturn :E: (a :E: Type) -> (x :E: a) -> IO -E- a 
      a :E: Type x :E: a
        [ioReturn] -E- a -E- x = MkIO -E- a -E- (\w :E: RealWorld. MkIOR -E- a -E- x -E- w)
    ioBind3 :E: (b :E: Type) -> (_x3 :E: RealWorld) -> (_x4 :E: IO -E- b) -> IOResult -E- b 
      b :E: Type w :E: RealWorld f :E: (_x5 :E: RealWorld) -> IOResult -E- b
        [ioBind3] -E- b -E- w -E- (MkIO -E- [b] -E- f) = f -E- w
    ioBind2 :E: (a :E: Type) -> (b :E: Type) -> (g :E: (x :E: a) -> IO -E- b) -> (r :E: IOResult -E- a) -> IOResult -E- b 
      a :E: Type b :E: Type g :E: (_x6 :E: a) -> IO -E- b x :E: a w :E: RealWorld
        [ioBind2] -E- a -E- b -E- g -E- (MkIOR -E- [a] -E- x -E- w) = ioBind3 -E- b -E- w -E- (g -E- x)
    ioBind :E: (a :E: Type) -> (b :E: Type) -> (x :E: IO -E- a) -> (y :E: (_x7 :E: a) -> IO -E- b) -> IO -E- b 
      a :E: Type b :E: Type f :E: (_x8 :E: RealWorld) -> IOResult -E- a g :E: (_x9 :E: a) -> IO -E- b
        [ioBind] -E- a -E- b -E- (MkIO -E- [a] -E- f) -E- g = MkIO -E- b -E- (\w :E: RealWorld. ioBind2 -E- a -E- b -E- g -E- (f -E- w))
    ioIgnore :E: (a :E: Type) -> (b :E: Type) -> (r :E: b) -> (x :E: IO -E- a) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\r :E: b. (\x :E: IO -E- a. ioBind -E- a -E- b -E- x -E- (\v :E: a. ioReturn -E- b -E- r)))))
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate T :E: Bool
    postulate F :E: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- T = F
      [not] -E- F = T
    postulate Unit :E: Type
    postulate tt :E: Unit
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    foreign printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    main :R: IO -E- Unspec = printNat -R- 4
  in main

### Final annotation ###

  let
    postulate RealWorld :E: Type
    postulate IOResult :E: (_x0 :E: Type) -> Type
    postulate MkIOR :E: (a :E: Type) -> (x :E: a) -> (w :E: RealWorld) -> IOResult -E- a
    postulate IO :E: (_x1 :E: Type) -> Type
    postulate MkIO :E: (a :E: Type) -> (f :E: (_x2 :E: RealWorld) -> IOResult -E- a) -> IO -E- a
    ioReturn :E: (a :E: Type) -> (x :E: a) -> IO -E- a 
      a :E: Type x :E: a
        [ioReturn] -E- a -E- x = MkIO -E- a -E- (\w :E: RealWorld. MkIOR -E- a -E- x -E- w)
    ioBind3 :E: (b :E: Type) -> (_x3 :E: RealWorld) -> (_x4 :E: IO -E- b) -> IOResult -E- b 
      b :E: Type w :E: RealWorld f :E: (_x5 :E: RealWorld) -> IOResult -E- b
        [ioBind3] -E- b -E- w -E- (MkIO -E- [b] -E- f) = f -E- w
    ioBind2 :E: (a :E: Type) -> (b :E: Type) -> (g :E: (x :E: a) -> IO -E- b) -> (r :E: IOResult -E- a) -> IOResult -E- b 
      a :E: Type b :E: Type g :E: (_x6 :E: a) -> IO -E- b x :E: a w :E: RealWorld
        [ioBind2] -E- a -E- b -E- g -E- (MkIOR -E- [a] -E- x -E- w) = ioBind3 -E- b -E- w -E- (g -E- x)
    ioBind :E: (a :E: Type) -> (b :E: Type) -> (x :E: IO -E- a) -> (y :E: (_x7 :E: a) -> IO -E- b) -> IO -E- b 
      a :E: Type b :E: Type f :E: (_x8 :E: RealWorld) -> IOResult -E- a g :E: (_x9 :E: a) -> IO -E- b
        [ioBind] -E- a -E- b -E- (MkIO -E- [a] -E- f) -E- g = MkIO -E- b -E- (\w :E: RealWorld. ioBind2 -E- a -E- b -E- g -E- (f -E- w))
    ioIgnore :E: (a :E: Type) -> (b :E: Type) -> (r :E: b) -> (x :E: IO -E- a) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\r :E: b. (\x :E: IO -E- a. ioBind -E- a -E- b -E- x -E- (\v :E: a. ioReturn -E- b -E- r)))))
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate T :E: Bool
    postulate F :E: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- T = F
      [not] -E- F = T
    postulate Unit :E: Type
    postulate tt :E: Unit
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    foreign printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    main :R: IO -E- Unspec = printNat -R- 4
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Z : Nat
    postulate S : (x) -> Nat
    foreign intS
    foreign intZ
    foreign printSchemeRepr
    natToInt 
      [_] Z = intZ
      [_] (S n) = intS (natToInt n)
    printNat = (\x. printSchemeRepr (natToInt x))
    main = printNat 4
  in main

### Normal forms ###

unerased:
  
  let
    postulate IO : (_x1 : Type) -> Type
    postulate Int : Type
    foreign intS : (x :R: Int) -> Int
    foreign intZ : Int
    postulate Unspec : Type
    foreign printSchemeRepr : (a :E: Type) -> (x :R: a) -> IO Unspec
  in printSchemeRepr Int (intS (intS (intS (intS intZ))))

erased:
  
  let
    foreign intS
    foreign intZ
    foreign printSchemeRepr
  in printSchemeRepr (intS (intS (intS (intS intZ))))

