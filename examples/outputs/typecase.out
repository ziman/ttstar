-- vim: ft=idris

### Desugared ###

  let
    postulate Nat : Type
    postulate Z : Nat
    postulate S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    postulate Bool : Type
    postulate True : Bool
    postulate False : Bool
    not : (_x2 : Bool) -> Bool 
      [not] True = False
      [not] False = True
    postulate Unit : Type
    postulate MkUnit : Unit
    postulate Pair : (_x3 : Type) -> (_x4 : Type) -> Type
    postulate MkPair : (a : Type) -> (b : Type) -> (_x5 : a) -> (_x6 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x7 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        [fst] a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x8 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        [snd] a b ([MkPair] [a] [b] x y) = y
    postulate Either : (_x9 : Type) -> (_x10 : Type) -> Type
    postulate Left : (a : Type) -> (b : Type) -> (_x11 : a) -> Either a b
    postulate Right : (a : Type) -> (b : Type) -> (_x12 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    isZero : (_x0 : Nat) -> Bool 
      [isZero] Z = True
      n : Nat
        [isZero] (S n) = False
    f : (a : Type) -> (x : a) -> Bool 
      [f] Bool = not
      [f] Nat = isZero
      a : Type
        [f] a = (\x : a. False)
    main : Bool = f Bool False
  in main

### Evarified ###

  let
    postulate Nat :1: Type
    postulate Z :2: Nat
    postulate S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        [plus] -9- Z -8- n = n
      m :10: Nat n :11: Nat
        [plus] -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    postulate Bool :18: Type
    postulate True :19: Bool
    postulate False :20: Bool
    not :21: (_x2 :22: Bool) -> Bool 
      [not] -23- True = False
      [not] -24- False = True
    postulate Unit :25: Type
    postulate MkUnit :26: Unit
    postulate Pair :27: (_x3 :28: Type) -> (_x4 :29: Type) -> Type
    postulate MkPair :30: (a :31: Type) -> (b :32: Type) -> (_x5 :33: a) -> (_x6 :34: b) -> Pair -36- a -35- b
    fst :37: (a :38: Type) -> (b :39: Type) -> (_x7 :40: Pair -42- a -41- b) -> a 
      a :43: Type b :44: Type x :45: a y :46: b
        [fst] -49- a -48- b -47- ([MkPair] -53- [a] -52- [b] -51- x -50- y) = x
    snd :54: (a :55: Type) -> (b :56: Type) -> (_x8 :57: Pair -59- a -58- b) -> b 
      a :60: Type b :61: Type x :62: a y :63: b
        [snd] -66- a -65- b -64- ([MkPair] -70- [a] -69- [b] -68- x -67- y) = y
    postulate Either :71: (_x9 :72: Type) -> (_x10 :73: Type) -> Type
    postulate Left :74: (a :75: Type) -> (b :76: Type) -> (_x11 :77: a) -> Either -79- a -78- b
    postulate Right :80: (a :81: Type) -> (b :82: Type) -> (_x12 :83: b) -> Either -85- a -84- b
    id :86: (a :87: Type) -> (x :88: a) -> a = (\a :89: Type. (\x :90: a. x))
    isZero :91: (_x0 :92: Nat) -> Bool 
      [isZero] -93- Z = True
      n :94: Nat
        [isZero] -95- (S -96- n) = False
    f :97: (a :98: Type) -> (x :99: a) -> Bool 
      [f] -100- Bool = not
      [f] -101- Nat = isZero
      a :102: Type
        [f] -103- a = (\x :104: a. False)
    main :105: Bool = f -107- Bool -106- False
  in main

### Constraints ###

[] -> [1,2,3,18,19,20,21,22,23,24,91,92,93,95,96,97,98,99,100,101,103,104,106,107,R]
[R] -> [105]

### Solution ###

[1,2,3,18,19,20,21,22,23,24,91,92,93,95,96,97,98,99,100,101,103,104,105,106,107,R]

### Annotated ###

  let
    postulate Nat :R: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :R: Type
    postulate True :R: Bool
    postulate False :R: Bool
    not :R: (_x2 :R: Bool) -> Bool 
      [not] -R- True = False
      [not] -R- False = True
    postulate Unit :E: Type
    postulate MkUnit :E: Unit
    postulate Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    postulate MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    postulate Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    postulate Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    postulate Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    isZero :R: (_x0 :R: Nat) -> Bool 
      [isZero] -R- Z = True
      n :E: Nat
        [isZero] -R- (S -R- n) = False
    f :R: (a :R: Type) -> (x :R: a) -> Bool 
      [f] -R- Bool = not
      [f] -R- Nat = isZero
      a :E: Type
        [f] -R- a = (\x :R: a. False)
    main :R: Bool = f -R- Bool -R- False
  in main

### Specialised ###

  let
    postulate Nat :R: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :R: Type
    postulate True :R: Bool
    postulate False :R: Bool
    not :R: (_x2 :R: Bool) -> Bool 
      [not] -R- True = False
      [not] -R- False = True
    postulate Unit :E: Type
    postulate MkUnit :E: Unit
    postulate Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    postulate MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    postulate Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    postulate Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    postulate Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    isZero :R: (_x0 :R: Nat) -> Bool 
      [isZero] -R- Z = True
      n :E: Nat
        [isZero] -R- (S -R- n) = False
    f :R: (a :R: Type) -> (x :R: a) -> Bool 
      [f] -R- Bool = not
      [f] -R- Nat = isZero
      a :E: Type
        [f] -R- a = (\x :R: a. False)
    main :R: Bool = f -R- Bool -R- False
  in main

### Final annotation ###

  let
    postulate Nat :R: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :R: Type
    postulate True :R: Bool
    postulate False :R: Bool
    not :R: (_x2 :R: Bool) -> Bool 
      [not] -R- True = False
      [not] -R- False = True
    postulate Unit :E: Type
    postulate MkUnit :E: Unit
    postulate Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    postulate MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    postulate Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    postulate Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    postulate Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    isZero :R: (_x0 :R: Nat) -> Bool 
      [isZero] -R- Z = True
      n :E: Nat
        [isZero] -R- (S -R- n) = False
    f :R: (a :R: Type) -> (x :R: a) -> Bool 
      [f] -R- Bool = not
      [f] -R- Nat = isZero
      a :E: Type
        [f] -R- a = (\x :R: a. False)
    main :R: Bool = f -R- Bool -R- False
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Nat : Type
    postulate Z : Nat
    postulate S : (x) -> Nat
    postulate Bool : Type
    postulate True : Bool
    postulate False : Bool
    not 
      [_] True = False
      [_] False = True
    isZero 
      [_] Z = True
      [_] (S _) = False
    f 
      [_] Bool = not
      [_] Nat = isZero
      [_] _ = (\x. False)
    main = f Bool False
  in main

### Normal forms ###

unerased:
  
  let
    postulate Bool : Type
    postulate True : Bool
  in True

erased:
  
  let
    postulate Bool : Type
    postulate True : Bool
  in True

