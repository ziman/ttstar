-- vim: ft=ttstar

### Desugared ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    times : (_x2 : Nat) -> (_x3 : Nat) -> Nat 
      n : Nat
        [times] Z n = Z
      m : Nat n : Nat
        [times] (S m) n = plus n (times m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x4 : Bool) -> Bool 
      [not] True = False
      [not] False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x5 : Type) -> (_x6 : Type) -> Type
    constructor MkPair : (a : Type) -> (b : Type) -> (_x7 : a) -> (_x8 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x9 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        [fst] a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x10 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        [snd] a b ([MkPair] [a] [b] x y) = y
    constructor Either : (_x11 : Type) -> (_x12 : Type) -> Type
    constructor Left : (a : Type) -> (b : Type) -> (_x13 : a) -> Either a b
    constructor Right : (a : Type) -> (b : Type) -> (_x14 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x15 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x16 : Fin n) -> Fin (S n)
    constructor Vect : (_x17 : Nat) -> (_x18 : Type) -> Type
    constructor VN : (a : Type) -> Vect Z a
    constructor VC : (n : Nat) -> (a : Type) -> (x : a) -> (xs : Vect n a) -> Vect (S n) a
    constructor List : Type
    constructor Nil : List
    constructor Cons : (_x0 : Bool) -> (_x1 : List) -> List
    repl : (n : Nat) -> (x : Bool) -> (_x2 : List) -> List 
      x : Bool xs : List
        [repl] Z x xs = xs
      n : Nat x : Bool xs : List
        [repl] (S n) x xs = Cons x (repl n x xs)
    constructor RLE : (_x3 : List) -> Type
    constructor RNil : RLE Nil
    constructor RCons : (n : Nat) -> (x : Bool) -> (xs : List) -> (_x4 : RLE xs) -> RLE (repl n x xs)
    compress : (xs : List) -> RLE xs 
      [compress] Nil = RNil
      x : Bool xs : List
        [compress] (Cons x xs) = 
          let aux : (y : Bool) -> (ys : List) -> (_x5 : RLE ys) -> RLE (Cons y ys) 
            y : Bool
              [aux] y [Nil] RNil = RCons 1 y Nil RNil
            n : Nat zs : List rzs : RLE zs
              [aux] True [repl n True zs] (RCons n True zs rzs) = RCons (S n) True zs rzs
            n : Nat zs : List rzs : RLE zs
              [aux] False [repl n False zs] (RCons n False zs rzs) = RCons (S n) False zs rzs
            n : Nat zs : List rzs : RLE zs
              [aux] True [repl n False zs] (RCons n False zs rzs) = RCons 1 True (repl n False zs) (RCons n False zs rzs)
            n : Nat zs : List rzs : RLE zs
              [aux] False [repl n True zs] (RCons n True zs rzs) = RCons 1 False (repl n True zs) (RCons n True zs rzs)
          in aux x xs (compress xs)
    decompress : (xs : List) -> (_x6 : RLE xs) -> List 
      [decompress] [Nil] RNil = Nil
      n : Nat x : Bool xs : List rxs : RLE xs
        [decompress] [repl n x xs] (RCons n x xs rxs) = repl n x (decompress xs rxs)
    foldl : (_x7 : (_x8 : Bool) -> (_x9 : Bool) -> Bool) -> (_x10 : Bool) -> (_x11 : List) -> Bool 
      f : (_x12 : Bool) -> (_x13 : Bool) -> Bool z : Bool
        [foldl] f z Nil = z
      f : (_x14 : Bool) -> (_x15 : Bool) -> Bool z : Bool x : Bool xs : List
        [foldl] f z (Cons x xs) = foldl f (f z x) xs
    xor : (_x16 : Bool) -> (_x17 : Bool) -> Bool 
      b : Bool
        [xor] False b = b
      [xor] True False = True
      [xor] True True = False
    xors : (_x18 : List) -> Bool = foldl xor False
    genInputList : (n : Nat) -> List = (\n : Nat. repl n True Nil)
    main : Bool = 
      let
        foreign inputSize : Nat
        inputList : List = genInputList inputSize
      in xors (decompress inputList (compress inputList))
  in main

### Evarified ###

  let
    constructor Nat :1: Type
    constructor Z :2: Nat
    constructor S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        [plus] -9- Z -8- n = n
      m :10: Nat n :11: Nat
        [plus] -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    times :18: (_x2 :19: Nat) -> (_x3 :20: Nat) -> Nat 
      n :21: Nat
        [times] -23- Z -22- n = Z
      m :24: Nat n :25: Nat
        [times] -27- (S -28- m) -26- n = plus -30- n -29- (times -32- m -31- n)
    constructor Bool :33: Type
    constructor True :34: Bool
    constructor False :35: Bool
    not :36: (_x4 :37: Bool) -> Bool 
      [not] -38- True = False
      [not] -39- False = True
    constructor Unit :40: Type
    constructor MkUnit :41: Unit
    constructor Pair :42: (_x5 :43: Type) -> (_x6 :44: Type) -> Type
    constructor MkPair :45: (a :46: Type) -> (b :47: Type) -> (_x7 :48: a) -> (_x8 :49: b) -> Pair -51- a -50- b
    fst :52: (a :53: Type) -> (b :54: Type) -> (_x9 :55: Pair -57- a -56- b) -> a 
      a :58: Type b :59: Type x :60: a y :61: b
        [fst] -64- a -63- b -62- ([MkPair] -68- [a] -67- [b] -66- x -65- y) = x
    snd :69: (a :70: Type) -> (b :71: Type) -> (_x10 :72: Pair -74- a -73- b) -> b 
      a :75: Type b :76: Type x :77: a y :78: b
        [snd] -81- a -80- b -79- ([MkPair] -85- [a] -84- [b] -83- x -82- y) = y
    constructor Either :86: (_x11 :87: Type) -> (_x12 :88: Type) -> Type
    constructor Left :89: (a :90: Type) -> (b :91: Type) -> (_x13 :92: a) -> Either -94- a -93- b
    constructor Right :95: (a :96: Type) -> (b :97: Type) -> (_x14 :98: b) -> Either -100- a -99- b
    id :101: (a :102: Type) -> (x :103: a) -> a = (\a :104: Type. (\x :105: a. x))
    constructor Fin :106: (_x15 :107: Nat) -> Type
    constructor FZ :108: (n :109: Nat) -> Fin -110- (S -111- n)
    constructor FS :112: (n :113: Nat) -> (_x16 :114: Fin -115- n) -> Fin -116- (S -117- n)
    constructor Vect :118: (_x17 :119: Nat) -> (_x18 :120: Type) -> Type
    constructor VN :121: (a :122: Type) -> Vect -124- Z -123- a
    constructor VC :125: (n :126: Nat) -> (a :127: Type) -> (x :128: a) -> (xs :129: Vect -131- n -130- a) -> Vect -133- (S -134- n) -132- a
    constructor List :135: Type
    constructor Nil :136: List
    constructor Cons :137: (_x0 :138: Bool) -> (_x1 :139: List) -> List
    repl :140: (n :141: Nat) -> (x :142: Bool) -> (_x2 :143: List) -> List 
      x :144: Bool xs :145: List
        [repl] -148- Z -147- x -146- xs = xs
      n :149: Nat x :150: Bool xs :151: List
        [repl] -154- (S -155- n) -153- x -152- xs = Cons -157- x -156- (repl -160- n -159- x -158- xs)
    constructor RLE :161: (_x3 :162: List) -> Type
    constructor RNil :163: RLE -164- Nil
    constructor RCons :165: (n :166: Nat) -> (x :167: Bool) -> (xs :168: List) -> (_x4 :169: RLE -170- xs) -> RLE -171- (repl -174- n -173- x -172- xs)
    compress :175: (xs :176: List) -> RLE -177- xs 
      [compress] -178- Nil = RNil
      x :179: Bool xs :180: List
        [compress] -181- (Cons -183- x -182- xs) = 
          let aux :184: (y :185: Bool) -> (ys :186: List) -> (_x5 :187: RLE -188- ys) -> RLE -189- (Cons -191- y -190- ys) 
            y :192: Bool
              [aux] -195- y -194- [Nil] -193- RNil = RCons -199- 1 -198- y -197- Nil -196- RNil
            n :201: Nat zs :202: List rzs :203: RLE -204- zs
              [aux] -207- True -206- [repl -210- n -209- True -208- zs] -205- (RCons -214- n -213- True -212- zs -211- rzs) = RCons -218- (S -219- n) -217- True -216- zs -215- rzs
            n :220: Nat zs :221: List rzs :222: RLE -223- zs
              [aux] -226- False -225- [repl -229- n -228- False -227- zs] -224- (RCons -233- n -232- False -231- zs -230- rzs) = RCons -237- (S -238- n) -236- False -235- zs -234- rzs
            n :239: Nat zs :240: List rzs :241: RLE -242- zs
              [aux] -245- True -244- [repl -248- n -247- False -246- zs] -243- (RCons -252- n -251- False -250- zs -249- rzs) = RCons -256- 1 -255- True -254- (repl -260- n -259- False -258- zs) -253- (RCons -264- n -263- False -262- zs -261- rzs)
            n :265: Nat zs :266: List rzs :267: RLE -268- zs
              [aux] -271- False -270- [repl -274- n -273- True -272- zs] -269- (RCons -278- n -277- True -276- zs -275- rzs) = RCons -282- 1 -281- False -280- (repl -286- n -285- True -284- zs) -279- (RCons -290- n -289- True -288- zs -287- rzs)
          in aux -293- x -292- xs -291- (compress -294- xs)
    decompress :295: (xs :296: List) -> (_x6 :297: RLE -298- xs) -> List 
      [decompress] -300- [Nil] -299- RNil = Nil
      n :301: Nat x :302: Bool xs :303: List rxs :304: RLE -305- xs
        [decompress] -307- [repl -310- n -309- x -308- xs] -306- (RCons -314- n -313- x -312- xs -311- rxs) = repl -317- n -316- x -315- (decompress -319- xs -318- rxs)
    foldl :320: (_x7 :321: (_x8 :322: Bool) -> (_x9 :323: Bool) -> Bool) -> (_x10 :324: Bool) -> (_x11 :325: List) -> Bool 
      f :326: (_x12 :327: Bool) -> (_x13 :328: Bool) -> Bool z :329: Bool
        [foldl] -332- f -331- z -330- Nil = z
      f :333: (_x14 :334: Bool) -> (_x15 :335: Bool) -> Bool z :336: Bool x :337: Bool xs :338: List
        [foldl] -341- f -340- z -339- (Cons -343- x -342- xs) = foldl -346- f -345- (f -348- z -347- x) -344- xs
    xor :349: (_x16 :350: Bool) -> (_x17 :351: Bool) -> Bool 
      b :352: Bool
        [xor] -354- False -353- b = b
      [xor] -356- True -355- False = True
      [xor] -358- True -357- True = False
    xors :359: (_x18 :360: List) -> Bool = foldl -362- xor -361- False
    genInputList :363: (n :364: Nat) -> List = (\n :365: Nat. repl -368- n -367- True -366- Nil)
    main :369: Bool = 
      let
        foreign inputSize :370: Nat
        inputList :371: List = genInputList -372- inputSize
      in xors -373- (decompress -375- inputList -374- (compress -376- inputList))
  in main

### Constraints ###

[] -> [2,3,34,35,136,137,138,139,140,141,142,143,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,163,165,166,167,169,175,176,178,179,180,181,182,183,184,185,187,192,193,195,196,198,199,200,201,203,205,207,211,213,214,215,217,218,219,220,222,224,226,230,232,233,234,236,237,238,239,241,243,245,249,251,252,253,255,256,257,261,263,264,265,267,269,271,275,277,278,279,281,282,283,287,289,290,291,293,294,295,297,299,301,302,304,306,311,313,314,315,316,317,318,320,321,322,323,324,325,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,370,371,372,373,374,376,R]
[144] -> [147]
[144,206] -> [147]
[144,225] -> [147]
[144,244] -> [147]
[144,254] -> [147]
[144,270] -> [147]
[144,280] -> [147]
[144,307] -> [147]
[144,375] -> [147]
[164] -> [170,177,188,298]
[168] -> [197,212,216,231,235,250,254,262,276,280,288,312]
[170] -> [164,171,204,223,242,268,305]
[171] -> [170,188,189,298]
[171,172] -> [208,227,246,258,272,284,308]
[171,173] -> [209,228,247,259,273,285,309]
[171,174] -> [210,229,248,260,274,286,310]
[171,208] -> [172]
[171,209] -> [173]
[171,210] -> [174]
[171,227] -> [172]
[171,228] -> [173]
[171,229] -> [174]
[171,246] -> [172]
[171,247] -> [173]
[171,248] -> [174]
[171,258] -> [172]
[171,259] -> [173]
[171,260] -> [174]
[171,272] -> [172]
[171,273] -> [173]
[171,274] -> [174]
[171,284] -> [172]
[171,285] -> [173]
[171,286] -> [174]
[171,308] -> [172]
[171,309] -> [173]
[171,310] -> [174]
[177] -> [164,188,189,190,191,298,366,367,368]
[177,190] -> [182]
[177,191] -> [183]
[186] -> [194,206,225,244,270,292]
[188] -> [164,171,177]
[189] -> [171,177,190,191]
[189,190] -> [156,208,209,210,227,228,229]
[189,190,208] -> [158]
[189,190,209] -> [159]
[189,190,210] -> [160]
[189,190,227] -> [158]
[189,190,228] -> [159]
[189,190,229] -> [160]
[189,190,246] -> [258]
[189,190,247] -> [259]
[189,190,248] -> [260]
[189,190,258] -> [246]
[189,190,259] -> [247]
[189,190,260] -> [248]
[189,190,272] -> [284]
[189,190,273] -> [285]
[189,190,274] -> [286]
[189,190,284] -> [272]
[189,190,285] -> [273]
[189,190,286] -> [274]
[189,191] -> [157]
[194] -> [136,186,R]
[197] -> [136,168]
[202] -> [212]
[204] -> [170]
[206] -> [2,3,137,138,139,140,141,142,143,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,186,208,209,210,R]
[206,208] -> [143,202]
[206,209] -> [34,142]
[206,210] -> [141,201]
[212] -> [168,205]
[216] -> [168,202]
[221] -> [231]
[223] -> [170]
[225] -> [2,3,137,138,139,140,141,142,143,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,186,227,228,229,R]
[225,227] -> [143,221]
[225,228] -> [35,142]
[225,229] -> [141,220]
[231] -> [168,224]
[235] -> [168,221]
[240] -> [250]
[242] -> [170]
[244] -> [2,3,137,138,139,140,141,142,143,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,186,246,247,248,R]
[244,246] -> [143,240]
[244,247] -> [35,142]
[244,248] -> [141,239]
[250] -> [168,243]
[254] -> [2,3,137,138,139,140,141,142,143,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,168,258,259,260,R]
[254,258] -> [143,240]
[254,259] -> [35,142]
[254,260] -> [141,239]
[262] -> [168,240]
[266] -> [276]
[268] -> [170]
[270] -> [2,3,137,138,139,140,141,142,143,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,186,272,273,274,R]
[270,272] -> [143,266]
[270,273] -> [34,142]
[270,274] -> [141,265]
[276] -> [168,269]
[280] -> [2,3,137,138,139,140,141,142,143,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,168,284,285,286,R]
[280,284] -> [143,266]
[280,285] -> [34,142]
[280,286] -> [141,265]
[288] -> [168,266]
[292] -> [180,186]
[296] -> [300,307,319,375]
[298] -> [164,171,177,305]
[300] -> [136,296,R]
[303] -> [312]
[305] -> [170,298]
[307] -> [2,3,137,138,139,140,141,142,143,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,296,308,309,310,R]
[307,308] -> [143,303]
[307,309] -> [142,302]
[307,310] -> [141,301]
[312] -> [168,306]
[319] -> [296,303]
[326] -> [332]
[375] -> [2,3,34,136,137,138,139,140,141,142,143,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,296,363,364,365,366,367,368,370,371,372,R]
[R] -> [369]

### Solution ###

[2,3,34,35,136,137,138,139,140,141,142,143,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,163,165,166,167,169,175,176,178,179,180,181,182,183,184,185,187,192,193,195,196,198,199,200,201,203,205,207,211,213,214,215,217,218,219,220,222,224,226,230,232,233,234,236,237,238,239,241,243,245,249,251,252,253,255,256,257,261,263,264,265,267,269,271,275,277,278,279,281,282,283,287,289,290,291,293,294,295,297,299,301,302,304,306,311,313,314,315,316,317,318,320,321,322,323,324,325,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,376,R]

### Annotated ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        [times] -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        [times] -E- (S -E- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor List :E: Type
    constructor Nil :R: List
    constructor Cons :R: (_x0 :R: Bool) -> (_x1 :R: List) -> List
    repl :R: (n :R: Nat) -> (x :R: Bool) -> (_x2 :R: List) -> List 
      x :E: Bool xs :R: List
        [repl] -R- Z -R- x -R- xs = xs
      n :R: Nat x :R: Bool xs :R: List
        [repl] -R- (S -R- n) -R- x -R- xs = Cons -R- x -R- (repl -R- n -R- x -R- xs)
    constructor RLE :E: (_x3 :E: List) -> Type
    constructor RNil :R: RLE -E- Nil
    constructor RCons :R: (n :R: Nat) -> (x :R: Bool) -> (xs :E: List) -> (_x4 :R: RLE -E- xs) -> RLE -E- (repl -E- n -E- x -E- xs)
    compress :R: (xs :R: List) -> RLE -E- xs 
      [compress] -R- Nil = RNil
      x :R: Bool xs :R: List
        [compress] -R- (Cons -R- x -R- xs) = 
          let aux :R: (y :R: Bool) -> (ys :E: List) -> (_x5 :R: RLE -E- ys) -> RLE -E- (Cons -E- y -E- ys) 
            y :R: Bool
              [aux] -R- y -E- [Nil] -R- RNil = RCons -R- 1 -R- y -E- Nil -R- RNil
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- True -E- [repl -E- n -E- True -E- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- (S -R- n) -R- True -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- False -E- [repl -E- n -E- False -E- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- (S -R- n) -R- False -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- True -E- [repl -E- n -E- False -E- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- 1 -R- True -E- (repl -E- n -E- False -E- zs) -R- (RCons -R- n -R- False -E- zs -R- rzs)
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- False -E- [repl -E- n -E- True -E- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- 1 -R- False -E- (repl -E- n -E- True -E- zs) -R- (RCons -R- n -R- True -E- zs -R- rzs)
          in aux -R- x -E- xs -R- (compress -R- xs)
    decompress :R: (xs :E: List) -> (_x6 :R: RLE -E- xs) -> List 
      [decompress] -E- [Nil] -R- RNil = Nil
      n :R: Nat x :R: Bool xs :E: List rxs :R: RLE -E- xs
        [decompress] -E- [repl -E- n -E- x -E- xs] -R- (RCons -R- n -R- x -E- xs -R- rxs) = repl -R- n -R- x -R- (decompress -E- xs -R- rxs)
    foldl :R: (_x7 :R: (_x8 :R: Bool) -> (_x9 :R: Bool) -> Bool) -> (_x10 :R: Bool) -> (_x11 :R: List) -> Bool 
      f :E: (_x12 :R: Bool) -> (_x13 :R: Bool) -> Bool z :R: Bool
        [foldl] -R- f -R- z -R- Nil = z
      f :R: (_x14 :R: Bool) -> (_x15 :R: Bool) -> Bool z :R: Bool x :R: Bool xs :R: List
        [foldl] -R- f -R- z -R- (Cons -R- x -R- xs) = foldl -R- f -R- (f -R- z -R- x) -R- xs
    xor :R: (_x16 :R: Bool) -> (_x17 :R: Bool) -> Bool 
      b :R: Bool
        [xor] -R- False -R- b = b
      [xor] -R- True -R- False = True
      [xor] -R- True -R- True = False
    xors :R: (_x18 :R: List) -> Bool = foldl -R- xor -R- False
    genInputList :R: (n :R: Nat) -> List = (\n :R: Nat. repl -R- n -R- True -R- Nil)
    main :R: Bool = 
      let
        foreign inputSize :R: Nat
        inputList :R: List = genInputList -R- inputSize
      in xors -R- (decompress -E- inputList -R- (compress -R- inputList))
  in main

### Specialised ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        [times] -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        [times] -E- (S -E- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor List :E: Type
    constructor Nil :R: List
    constructor Cons :R: (_x0 :R: Bool) -> (_x1 :R: List) -> List
    repl :R: (n :R: Nat) -> (x :R: Bool) -> (_x2 :R: List) -> List 
      x :E: Bool xs :R: List
        [repl] -R- Z -R- x -R- xs = xs
      n :R: Nat x :R: Bool xs :R: List
        [repl] -R- (S -R- n) -R- x -R- xs = Cons -R- x -R- (repl -R- n -R- x -R- xs)
    constructor RLE :E: (_x3 :E: List) -> Type
    constructor RNil :R: RLE -E- Nil
    constructor RCons :R: (n :R: Nat) -> (x :R: Bool) -> (xs :E: List) -> (_x4 :R: RLE -E- xs) -> RLE -E- (repl -E- n -E- x -E- xs)
    compress :R: (xs :R: List) -> RLE -E- xs 
      [compress] -R- Nil = RNil
      x :R: Bool xs :R: List
        [compress] -R- (Cons -R- x -R- xs) = 
          let aux :R: (y :R: Bool) -> (ys :E: List) -> (_x5 :R: RLE -E- ys) -> RLE -E- (Cons -E- y -E- ys) 
            y :R: Bool
              [aux] -R- y -E- [Nil] -R- RNil = RCons -R- 1 -R- y -E- Nil -R- RNil
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- True -E- [repl -E- n -E- True -E- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- (S -R- n) -R- True -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- False -E- [repl -E- n -E- False -E- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- (S -R- n) -R- False -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- True -E- [repl -E- n -E- False -E- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- 1 -R- True -E- (repl -E- n -E- False -E- zs) -R- (RCons -R- n -R- False -E- zs -R- rzs)
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- False -E- [repl -E- n -E- True -E- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- 1 -R- False -E- (repl -E- n -E- True -E- zs) -R- (RCons -R- n -R- True -E- zs -R- rzs)
          in aux -R- x -E- xs -R- (compress -R- xs)
    decompress :R: (xs :E: List) -> (_x6 :R: RLE -E- xs) -> List 
      [decompress] -E- [Nil] -R- RNil = Nil
      n :R: Nat x :R: Bool xs :E: List rxs :R: RLE -E- xs
        [decompress] -E- [repl -E- n -E- x -E- xs] -R- (RCons -R- n -R- x -E- xs -R- rxs) = repl -R- n -R- x -R- (decompress -E- xs -R- rxs)
    foldl :R: (_x7 :R: (_x8 :R: Bool) -> (_x9 :R: Bool) -> Bool) -> (_x10 :R: Bool) -> (_x11 :R: List) -> Bool 
      f :E: (_x12 :R: Bool) -> (_x13 :R: Bool) -> Bool z :R: Bool
        [foldl] -R- f -R- z -R- Nil = z
      f :R: (_x14 :R: Bool) -> (_x15 :R: Bool) -> Bool z :R: Bool x :R: Bool xs :R: List
        [foldl] -R- f -R- z -R- (Cons -R- x -R- xs) = foldl -R- f -R- (f -R- z -R- x) -R- xs
    xor :R: (_x16 :R: Bool) -> (_x17 :R: Bool) -> Bool 
      b :R: Bool
        [xor] -R- False -R- b = b
      [xor] -R- True -R- False = True
      [xor] -R- True -R- True = False
    xors :R: (_x18 :R: List) -> Bool = foldl -R- xor -R- False
    genInputList :R: (n :R: Nat) -> List = (\n :R: Nat. repl -R- n -R- True -R- Nil)
    main :R: Bool = 
      let
        foreign inputSize :R: Nat
        inputList :R: List = genInputList -R- inputSize
      in xors -R- (decompress -E- inputList -R- (compress -R- inputList))
  in main

### Final annotation ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        [times] -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        [times] -E- (S -E- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor List :E: Type
    constructor Nil :R: List
    constructor Cons :R: (_x0 :R: Bool) -> (_x1 :R: List) -> List
    repl :R: (n :R: Nat) -> (x :R: Bool) -> (_x2 :R: List) -> List 
      x :E: Bool xs :R: List
        [repl] -R- Z -R- x -R- xs = xs
      n :R: Nat x :R: Bool xs :R: List
        [repl] -R- (S -R- n) -R- x -R- xs = Cons -R- x -R- (repl -R- n -R- x -R- xs)
    constructor RLE :E: (_x3 :E: List) -> Type
    constructor RNil :R: RLE -E- Nil
    constructor RCons :R: (n :R: Nat) -> (x :R: Bool) -> (xs :E: List) -> (_x4 :R: RLE -E- xs) -> RLE -E- (repl -E- n -E- x -E- xs)
    compress :R: (xs :R: List) -> RLE -E- xs 
      [compress] -R- Nil = RNil
      x :R: Bool xs :R: List
        [compress] -R- (Cons -R- x -R- xs) = 
          let aux :R: (y :R: Bool) -> (ys :E: List) -> (_x5 :R: RLE -E- ys) -> RLE -E- (Cons -E- y -E- ys) 
            y :R: Bool
              [aux] -R- y -E- [Nil] -R- RNil = RCons -R- 1 -R- y -E- Nil -R- RNil
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- True -E- [repl -E- n -E- True -E- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- (S -R- n) -R- True -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- False -E- [repl -E- n -E- False -E- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- (S -R- n) -R- False -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- True -E- [repl -E- n -E- False -E- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- 1 -R- True -E- (repl -E- n -E- False -E- zs) -R- (RCons -R- n -R- False -E- zs -R- rzs)
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- False -E- [repl -E- n -E- True -E- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- 1 -R- False -E- (repl -E- n -E- True -E- zs) -R- (RCons -R- n -R- True -E- zs -R- rzs)
          in aux -R- x -E- xs -R- (compress -R- xs)
    decompress :R: (xs :E: List) -> (_x6 :R: RLE -E- xs) -> List 
      [decompress] -E- [Nil] -R- RNil = Nil
      n :R: Nat x :R: Bool xs :E: List rxs :R: RLE -E- xs
        [decompress] -E- [repl -E- n -E- x -E- xs] -R- (RCons -R- n -R- x -E- xs -R- rxs) = repl -R- n -R- x -R- (decompress -E- xs -R- rxs)
    foldl :R: (_x7 :R: (_x8 :R: Bool) -> (_x9 :R: Bool) -> Bool) -> (_x10 :R: Bool) -> (_x11 :R: List) -> Bool 
      f :E: (_x12 :R: Bool) -> (_x13 :R: Bool) -> Bool z :R: Bool
        [foldl] -R- f -R- z -R- Nil = z
      f :R: (_x14 :R: Bool) -> (_x15 :R: Bool) -> Bool z :R: Bool x :R: Bool xs :R: List
        [foldl] -R- f -R- z -R- (Cons -R- x -R- xs) = foldl -R- f -R- (f -R- z -R- x) -R- xs
    xor :R: (_x16 :R: Bool) -> (_x17 :R: Bool) -> Bool 
      b :R: Bool
        [xor] -R- False -R- b = b
      [xor] -R- True -R- False = True
      [xor] -R- True -R- True = False
    xors :R: (_x18 :R: List) -> Bool = foldl -R- xor -R- False
    genInputList :R: (n :R: Nat) -> List = (\n :R: Nat. repl -R- n -R- True -R- Nil)
    main :R: Bool = 
      let
        foreign inputSize :R: Nat
        inputList :R: List = genInputList -R- inputSize
      in xors -R- (decompress -E- inputList -R- (compress -R- inputList))
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    constructor Nil : List
    constructor Cons : (_x0) -> (_x1) -> List
    repl 
      [_] Z _ xs = xs
      [_] (S n) x xs = Cons x (repl n x xs)
    constructor RNil : RLE
    constructor RCons : (n) -> (x) -> (_x4) -> RLE
    compress 
      [_] Nil = RNil
      [_] (Cons x xs) = 
        let aux 
          [_] y RNil = RCons 1 y RNil
          [_] True (RCons n True rzs) = RCons (S n) True rzs
          [_] False (RCons n False rzs) = RCons (S n) False rzs
          [_] True (RCons n False rzs) = RCons 1 True (RCons n False rzs)
          [_] False (RCons n True rzs) = RCons 1 False (RCons n True rzs)
        in aux x (compress xs)
    decompress 
      [_] RNil = Nil
      [_] (RCons n x rxs) = repl n x (decompress rxs)
    foldl 
      [_] _ z Nil = z
      [_] f z (Cons x xs) = foldl f (f z x) xs
    xor 
      [_] False b = b
      [_] True False = True
      [_] True True = False
    xors = foldl xor False
    genInputList = (\n. repl n True Nil)
    main = 
      let
        foreign inputSize
        inputList = genInputList inputSize
      in xors (decompress (compress inputList))
  in main

### Intermediate representation ###

let Z = constructor 0
  in let S = constructor 1
    in let True = constructor 0
      in let False = constructor 0
        in let Nil = constructor 0
          in let Cons = constructor 2
            in let repl = \_pv0. \_pv1. \_pv2.
              case _pv0 of
                S _pv3 => ((Cons _pv1) (((repl _pv3) _pv1) _pv2))
                Z => _pv2
              in let RNil = constructor 0
                in let RCons = constructor 3
                  in let compress = \_pv0.
                    case _pv0 of
                      Cons _pv1 _pv2 => let aux = \_pv3. \_pv4.
                        case _pv4 of
                          RNil => (((RCons (S Z)) _pv3) RNil)
                          _ => case _pv3 of
                            False => case _pv4 of
                              RCons _pv5 _pv6 _pv7 => case _pv6 of
                                False => (((RCons (S _pv5)) False) _pv7)
                                True => (((RCons (S Z)) False) (((RCons _pv5) True) _pv7))
                            True => case _pv4 of
                              RCons _pv5 _pv6 _pv7 => case _pv6 of
                                False => (((RCons (S Z)) True) (((RCons _pv5) False) _pv7))
                                True => (((RCons (S _pv5)) True) _pv7)
                        in ((aux _pv1) (compress _pv2))
                      Nil => RNil
                    in let decompress = \_pv0.
                      case _pv0 of
                        RCons _pv1 _pv2 _pv3 => (((repl _pv1) _pv2) (decompress _pv3))
                        RNil => Nil
                      in let foldl = \_pv0. \_pv1. \_pv2.
                        case _pv2 of
                          Cons _pv3 _pv4 => (((foldl _pv0) ((_pv0 _pv1) _pv3)) _pv4)
                          Nil => _pv1
                        in let xor = \_pv0. \_pv1.
                          case _pv0 of
                            False => _pv1
                            True => case _pv1 of
                              False => True
                              True => False
                          in let xors = ((foldl xor) False)
                            in let genInputList = \n. (((repl n) True) Nil)
                              in let main = let inputSize = foreign "(rts-arg-peano 'Z 'S 0)"
                                in let inputList = (genInputList inputSize)
                                  in (xors (decompress (compress inputList)))
                                in main

### Normal forms ###

unerased:
  
  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    constructor List : Type
    constructor Nil : List
    constructor Cons : (_x0 : Bool) -> (_x1 : List) -> List
    repl : (n : Nat) -> (x : Bool) -> (_x2 : List) -> List 
      x : Bool xs : List
        [repl] Z x xs = xs
      n : Nat x : Bool xs : List
        [repl] (S n) x xs = Cons x (repl n x xs)
    constructor RLE : (_x3 : List) -> Type
    constructor RNil : RLE Nil
    constructor RCons : (n : Nat) -> (x : Bool) -> (xs : List) -> (_x4 : RLE xs) -> RLE (repl n x xs)
    compress : (xs : List) -> RLE xs 
      [compress] Nil = RNil
      x : Bool xs : List
        [compress] (Cons x xs) = 
          let aux : (y : Bool) -> (ys : List) -> (_x5 : RLE ys) -> RLE (Cons y ys) 
            y : Bool
              [aux] y [Nil] RNil = RCons 1 y Nil RNil
            n : Nat zs : List rzs : RLE zs
              [aux] True [repl n True zs] (RCons n True zs rzs) = RCons (S n) True zs rzs
            n : Nat zs : List rzs : RLE zs
              [aux] False [repl n False zs] (RCons n False zs rzs) = RCons (S n) False zs rzs
            n : Nat zs : List rzs : RLE zs
              [aux] True [repl n False zs] (RCons n False zs rzs) = RCons 1 True (repl n False zs) (RCons n False zs rzs)
            n : Nat zs : List rzs : RLE zs
              [aux] False [repl n True zs] (RCons n True zs rzs) = RCons 1 False (repl n True zs) (RCons n True zs rzs)
          in aux x xs (compress xs)
    decompress : (xs : List) -> (_x6 : RLE xs) -> List 
      [decompress] [Nil] RNil = Nil
      n : Nat x : Bool xs : List rxs : RLE xs
        [decompress] [repl n x xs] (RCons n x xs rxs) = repl n x (decompress xs rxs)
    foldl : (_x7 : (_x8 : Bool) -> (_x9 : Bool) -> Bool) -> (_x10 : Bool) -> (_x11 : List) -> Bool 
      f : (_x12 : Bool) -> (_x13 : Bool) -> Bool z : Bool
        [foldl] f z Nil = z
      f : (_x14 : Bool) -> (_x15 : Bool) -> Bool z : Bool x : Bool xs : List
        [foldl] f z (Cons x xs) = foldl f (f z x) xs
    xor : (_x16 : Bool) -> (_x17 : Bool) -> Bool 
      b : Bool
        [xor] False b = b
      [xor] True False = True
      [xor] True True = False
  in 
    let foreign inputSize : Nat
    in foldl xor False (decompress (repl inputSize True Nil) (compress (repl inputSize True Nil)))

erased:
  
  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    constructor Nil : List
    constructor Cons : (_x0) -> (_x1) -> List
    repl 
      [_] Z _ xs = xs
      [_] (S n) x xs = Cons x (repl n x xs)
    constructor RNil : RLE
    constructor RCons : (n) -> (x) -> (_x4) -> RLE
    compress 
      [_] Nil = RNil
      [_] (Cons x xs) = 
        let aux 
          [_] y RNil = RCons 1 y RNil
          [_] True (RCons n True rzs) = RCons (S n) True rzs
          [_] False (RCons n False rzs) = RCons (S n) False rzs
          [_] True (RCons n False rzs) = RCons 1 True (RCons n False rzs)
          [_] False (RCons n True rzs) = RCons 1 False (RCons n True rzs)
        in aux x (compress xs)
    decompress 
      [_] RNil = Nil
      [_] (RCons n x rxs) = repl n x (decompress rxs)
    foldl 
      [_] _ z Nil = z
      [_] f z (Cons x xs) = foldl f (f z x) xs
    xor 
      [_] False b = b
      [_] True False = True
      [_] True True = False
  in 
    let foreign inputSize
    in foldl xor False (decompress (compress (repl inputSize True Nil)))

