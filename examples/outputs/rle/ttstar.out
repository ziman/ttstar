-- vim: ft=ttstar

### Desugared ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        plus Z n = n
      m : Nat n : Nat
        plus (S m) n = S (plus m n)
    times : (_x2 : Nat) -> (_x3 : Nat) -> Nat 
      n : Nat
        times Z n = Z
      m : Nat n : Nat
        times (S m) n = plus n (times m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x4 : Bool) -> Bool 
      not True = False
      not False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x5 : Type) -> (_x6 : Type) -> Type
    constructor MkPair : (a : Type) -> (b : Type) -> (_x7 : a) -> (_x8 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x9 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        fst a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x10 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        snd a b ([MkPair] [a] [b] x y) = y
    constructor Either : (_x11 : Type) -> (_x12 : Type) -> Type
    constructor Left : (a : Type) -> (b : Type) -> (_x13 : a) -> Either a b
    constructor Right : (a : Type) -> (b : Type) -> (_x14 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x15 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x16 : Fin n) -> Fin (S n)
    constructor Vect : (_x17 : Nat) -> (_x18 : Type) -> Type
    constructor VN : (a : Type) -> Vect Z a
    constructor VC : (n : Nat) -> (a : Type) -> (x : a) -> (xs : Vect n a) -> Vect (S n) a
    constructor List : (_x19 : Type) -> Type
    constructor Nil : (a : Type) -> List a
    constructor Cons : (a : Type) -> (x : a) -> (xs : List a) -> List a
    constructor List : Type
    constructor Nil : List
    constructor Cons : (_x0 : Bool) -> (_x1 : List) -> List
    repl : (n : Nat) -> (x : Bool) -> (_x2 : List) -> List 
      x : Bool xs : List
        repl Z x xs = xs
      n : Nat x : Bool xs : List
        repl (S n) x xs = Cons x (repl n x xs)
    constructor RLE : (_x3 : List) -> Type
    constructor RNil : RLE Nil
    constructor RCons : (n : Nat) -> (x : Bool) -> (xs : List) -> (_x4 : RLE xs) -> RLE (repl n x xs)
    compress : (xs : List) -> RLE xs 
      compress Nil = RNil
      x : Bool xs : List
        compress (Cons x xs) = 
          let aux : (y : Bool) -> (ys : List) -> (_x5 : RLE ys) -> RLE (Cons y ys) 
            y : Bool
              aux y [Nil] RNil = RCons 1 y Nil RNil
            n : Nat zs : List rzs : RLE zs
              aux True [repl n True zs] (RCons n True zs rzs) = RCons (S n) True zs rzs
            n : Nat zs : List rzs : RLE zs
              aux False [repl n False zs] (RCons n False zs rzs) = RCons (S n) False zs rzs
            n : Nat zs : List rzs : RLE zs
              aux True [repl n False zs] (RCons n False zs rzs) = RCons 1 True (repl n False zs) (RCons n False zs rzs)
            n : Nat zs : List rzs : RLE zs
              aux False [repl n True zs] (RCons n True zs rzs) = RCons 1 False (repl n True zs) (RCons n True zs rzs)
          in aux x xs (compress xs)
    decompress : (xs : List) -> (_x6 : RLE xs) -> List 
      decompress [Nil] RNil = Nil
      n : Nat x : Bool xs : List rxs : RLE xs
        decompress [repl n x xs] (RCons n x xs rxs) = repl n x (decompress xs rxs)
    foldl : (_x7 : (_x8 : Bool) -> (_x9 : Bool) -> Bool) -> (_x10 : Bool) -> (_x11 : List) -> Bool 
      f : (_x12 : Bool) -> (_x13 : Bool) -> Bool z : Bool
        foldl f z Nil = z
      f : (_x14 : Bool) -> (_x15 : Bool) -> Bool z : Bool x : Bool xs : List
        foldl f z (Cons x xs) = foldl f (f z x) xs
    xor : (_x16 : Bool) -> (_x17 : Bool) -> Bool 
      b : Bool
        xor False b = b
      xor True False = True
      xor True True = False
    xors : (_x18 : List) -> Bool = foldl xor False
    genInputList : (n : Nat) -> List = (\n : Nat. repl n True Nil)
    main : Bool = 
      let
        foreign inputSize : Nat
        inputList : List = genInputList inputSize
      in xors (decompress inputList (compress inputList))
  in main

### Elaborated ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        plus Z n = n
      m : Nat n : Nat
        plus (S m) n = S (plus m n)
    times : (_x2 : Nat) -> (_x3 : Nat) -> Nat 
      n : Nat
        times Z n = Z
      m : Nat n : Nat
        times (S m) n = plus n (times m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x4 : Bool) -> Bool 
      not True = False
      not False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x5 : Type) -> (_x6 : Type) -> Type
    constructor MkPair : (a : Type) -> (b : Type) -> (_x7 : a) -> (_x8 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x9 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        fst a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x10 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        snd a b ([MkPair] [a] [b] x y) = y
    constructor Either : (_x11 : Type) -> (_x12 : Type) -> Type
    constructor Left : (a : Type) -> (b : Type) -> (_x13 : a) -> Either a b
    constructor Right : (a : Type) -> (b : Type) -> (_x14 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x15 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x16 : Fin n) -> Fin (S n)
    constructor Vect : (_x17 : Nat) -> (_x18 : Type) -> Type
    constructor VN : (a : Type) -> Vect Z a
    constructor VC : (n : Nat) -> (a : Type) -> (x : a) -> (xs : Vect n a) -> Vect (S n) a
    constructor List : (_x19 : Type) -> Type
    constructor Nil : (a : Type) -> List a
    constructor Cons : (a : Type) -> (x : a) -> (xs : List a) -> List a
    constructor List : Type
    constructor Nil : List
    constructor Cons : (_x0 : Bool) -> (_x1 : List) -> List
    repl : (n : Nat) -> (x : Bool) -> (_x2 : List) -> List 
      x : Bool xs : List
        repl Z x xs = xs
      n : Nat x : Bool xs : List
        repl (S n) x xs = Cons x (repl n x xs)
    constructor RLE : (_x3 : List) -> Type
    constructor RNil : RLE Nil
    constructor RCons : (n : Nat) -> (x : Bool) -> (xs : List) -> (_x4 : RLE xs) -> RLE (repl n x xs)
    compress : (xs : List) -> RLE xs 
      compress Nil = RNil
      x : Bool xs : List
        compress (Cons x xs) = 
          let aux : (y : Bool) -> (ys : List) -> (_x5 : RLE ys) -> RLE (Cons y ys) 
            y : Bool
              aux y [Nil] RNil = RCons 1 y Nil RNil
            n : Nat zs : List rzs : RLE zs
              aux True [repl n True zs] (RCons n True zs rzs) = RCons (S n) True zs rzs
            n : Nat zs : List rzs : RLE zs
              aux False [repl n False zs] (RCons n False zs rzs) = RCons (S n) False zs rzs
            n : Nat zs : List rzs : RLE zs
              aux True [repl n False zs] (RCons n False zs rzs) = RCons 1 True (repl n False zs) (RCons n False zs rzs)
            n : Nat zs : List rzs : RLE zs
              aux False [repl n True zs] (RCons n True zs rzs) = RCons 1 False (repl n True zs) (RCons n True zs rzs)
          in aux x xs (compress xs)
    decompress : (xs : List) -> (_x6 : RLE xs) -> List 
      decompress [Nil] RNil = Nil
      n : Nat x : Bool xs : List rxs : RLE xs
        decompress [repl n x xs] (RCons n x xs rxs) = repl n x (decompress xs rxs)
    foldl : (_x7 : (_x8 : Bool) -> (_x9 : Bool) -> Bool) -> (_x10 : Bool) -> (_x11 : List) -> Bool 
      f : (_x12 : Bool) -> (_x13 : Bool) -> Bool z : Bool
        foldl f z Nil = z
      f : (_x14 : Bool) -> (_x15 : Bool) -> Bool z : Bool x : Bool xs : List
        foldl f z (Cons x xs) = foldl f (f z x) xs
    xor : (_x16 : Bool) -> (_x17 : Bool) -> Bool 
      b : Bool
        xor False b = b
      xor True False = True
      xor True True = False
    xors : (_x18 : List) -> Bool = foldl xor False
    genInputList : (n : Nat) -> List = (\n : Nat. repl n True Nil)
    main : Bool = 
      let
        foreign inputSize : Nat
        inputList : List = genInputList inputSize
      in xors (decompress inputList (compress inputList))
  in main

### Evarified ###

  let
    constructor Nat :1: Type
    constructor Z :2: Nat
    constructor S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        plus -9- Z -8- n = n
      m :10: Nat n :11: Nat
        plus -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    times :18: (_x2 :19: Nat) -> (_x3 :20: Nat) -> Nat 
      n :21: Nat
        times -23- Z -22- n = Z
      m :24: Nat n :25: Nat
        times -27- (S -28- m) -26- n = plus -30- n -29- (times -32- m -31- n)
    constructor Bool :33: Type
    constructor True :34: Bool
    constructor False :35: Bool
    not :36: (_x4 :37: Bool) -> Bool 
      not -38- True = False
      not -39- False = True
    constructor Unit :40: Type
    constructor MkUnit :41: Unit
    constructor Pair :42: (_x5 :43: Type) -> (_x6 :44: Type) -> Type
    constructor MkPair :45: (a :46: Type) -> (b :47: Type) -> (_x7 :48: a) -> (_x8 :49: b) -> Pair -51- a -50- b
    fst :52: (a :53: Type) -> (b :54: Type) -> (_x9 :55: Pair -57- a -56- b) -> a 
      a :58: Type b :59: Type x :60: a y :61: b
        fst -64- a -63- b -62- ([MkPair] -68- [a] -67- [b] -66- x -65- y) = x
    snd :69: (a :70: Type) -> (b :71: Type) -> (_x10 :72: Pair -74- a -73- b) -> b 
      a :75: Type b :76: Type x :77: a y :78: b
        snd -81- a -80- b -79- ([MkPair] -85- [a] -84- [b] -83- x -82- y) = y
    constructor Either :86: (_x11 :87: Type) -> (_x12 :88: Type) -> Type
    constructor Left :89: (a :90: Type) -> (b :91: Type) -> (_x13 :92: a) -> Either -94- a -93- b
    constructor Right :95: (a :96: Type) -> (b :97: Type) -> (_x14 :98: b) -> Either -100- a -99- b
    id :101: (a :102: Type) -> (x :103: a) -> a = (\a :104: Type. (\x :105: a. x))
    constructor Fin :106: (_x15 :107: Nat) -> Type
    constructor FZ :108: (n :109: Nat) -> Fin -110- (S -111- n)
    constructor FS :112: (n :113: Nat) -> (_x16 :114: Fin -115- n) -> Fin -116- (S -117- n)
    constructor Vect :118: (_x17 :119: Nat) -> (_x18 :120: Type) -> Type
    constructor VN :121: (a :122: Type) -> Vect -124- Z -123- a
    constructor VC :125: (n :126: Nat) -> (a :127: Type) -> (x :128: a) -> (xs :129: Vect -131- n -130- a) -> Vect -133- (S -134- n) -132- a
    constructor List :135: (_x19 :136: Type) -> Type
    constructor Nil :137: (a :138: Type) -> List -139- a
    constructor Cons :140: (a :141: Type) -> (x :142: a) -> (xs :143: List -144- a) -> List -145- a
    constructor List :146: Type
    constructor Nil :147: List
    constructor Cons :148: (_x0 :149: Bool) -> (_x1 :150: List) -> List
    repl :151: (n :152: Nat) -> (x :153: Bool) -> (_x2 :154: List) -> List 
      x :155: Bool xs :156: List
        repl -159- Z -158- x -157- xs = xs
      n :160: Nat x :161: Bool xs :162: List
        repl -165- (S -166- n) -164- x -163- xs = Cons -168- x -167- (repl -171- n -170- x -169- xs)
    constructor RLE :172: (_x3 :173: List) -> Type
    constructor RNil :174: RLE -175- Nil
    constructor RCons :176: (n :177: Nat) -> (x :178: Bool) -> (xs :179: List) -> (_x4 :180: RLE -181- xs) -> RLE -182- (repl -185- n -184- x -183- xs)
    compress :186: (xs :187: List) -> RLE -188- xs 
      compress -189- Nil = RNil
      x :190: Bool xs :191: List
        compress -192- (Cons -194- x -193- xs) = 
          let aux :195: (y :196: Bool) -> (ys :197: List) -> (_x5 :198: RLE -199- ys) -> RLE -200- (Cons -202- y -201- ys) 
            y :203: Bool
              aux -206- y -205- [Nil] -204- RNil = RCons -210- 1 -209- y -208- Nil -207- RNil
            n :212: Nat zs :213: List rzs :214: RLE -215- zs
              aux -218- True -217- [repl -221- n -220- True -219- zs] -216- (RCons -225- n -224- True -223- zs -222- rzs) = RCons -229- (S -230- n) -228- True -227- zs -226- rzs
            n :231: Nat zs :232: List rzs :233: RLE -234- zs
              aux -237- False -236- [repl -240- n -239- False -238- zs] -235- (RCons -244- n -243- False -242- zs -241- rzs) = RCons -248- (S -249- n) -247- False -246- zs -245- rzs
            n :250: Nat zs :251: List rzs :252: RLE -253- zs
              aux -256- True -255- [repl -259- n -258- False -257- zs] -254- (RCons -263- n -262- False -261- zs -260- rzs) = RCons -267- 1 -266- True -265- (repl -271- n -270- False -269- zs) -264- (RCons -275- n -274- False -273- zs -272- rzs)
            n :276: Nat zs :277: List rzs :278: RLE -279- zs
              aux -282- False -281- [repl -285- n -284- True -283- zs] -280- (RCons -289- n -288- True -287- zs -286- rzs) = RCons -293- 1 -292- False -291- (repl -297- n -296- True -295- zs) -290- (RCons -301- n -300- True -299- zs -298- rzs)
          in aux -304- x -303- xs -302- (compress -305- xs)
    decompress :306: (xs :307: List) -> (_x6 :308: RLE -309- xs) -> List 
      decompress -311- [Nil] -310- RNil = Nil
      n :312: Nat x :313: Bool xs :314: List rxs :315: RLE -316- xs
        decompress -318- [repl -321- n -320- x -319- xs] -317- (RCons -325- n -324- x -323- xs -322- rxs) = repl -328- n -327- x -326- (decompress -330- xs -329- rxs)
    foldl :331: (_x7 :332: (_x8 :333: Bool) -> (_x9 :334: Bool) -> Bool) -> (_x10 :335: Bool) -> (_x11 :336: List) -> Bool 
      f :337: (_x12 :338: Bool) -> (_x13 :339: Bool) -> Bool z :340: Bool
        foldl -343- f -342- z -341- Nil = z
      f :344: (_x14 :345: Bool) -> (_x15 :346: Bool) -> Bool z :347: Bool x :348: Bool xs :349: List
        foldl -352- f -351- z -350- (Cons -354- x -353- xs) = foldl -357- f -356- (f -359- z -358- x) -355- xs
    xor :360: (_x16 :361: Bool) -> (_x17 :362: Bool) -> Bool 
      b :363: Bool
        xor -365- False -364- b = b
      xor -367- True -366- False = True
      xor -369- True -368- True = False
    xors :370: (_x18 :371: List) -> Bool = foldl -373- xor -372- False
    genInputList :374: (n :375: Nat) -> List = (\n :376: Nat. repl -379- n -378- True -377- Nil)
    main :380: Bool = 
      let
        foreign inputSize :381: Nat
        inputList :382: List = genInputList -383- inputSize
      in xors -384- (decompress -386- inputList -385- (compress -387- inputList))
  in main

### Constraints ###

[] -> [14,15,28,111,117,134,166,211,230,249,268,294,380]
[4] -> [2,3,7,9,13]
[4,8] -> [7]
[4,12] -> [11]
[4,13,14] -> [10]
[4,15,16] -> [11]
[4,15,17] -> [10]
[5] -> [9,13,17,30]
[6] -> [8,12,16,29]
[7] -> [4,8]
[8] -> [6]
[9] -> [5]
[10] -> [4,13,14]
[11] -> [4,12]
[12] -> [6]
[13] -> [5]
[16] -> [6]
[17] -> [5]
[18] -> [2,3,4,23,27]
[18,22] -> [21]
[18,26] -> [25]
[18,27,28] -> [24]
[18,29,31] -> [25]
[18,29,32] -> [24]
[18,30] -> [25]
[19] -> [23,27,32]
[20] -> [22,26,31]
[21] -> [18,22]
[22] -> [20]
[23] -> [19]
[24] -> [18,27,28]
[25] -> [18,26]
[26] -> [20]
[27] -> [19]
[29] -> [6]
[30] -> [5]
[31] -> [20]
[32] -> [19]
[36] -> [34,35,38,39]
[37] -> [38,39]
[38] -> [37]
[39] -> [37]
[43] -> [51,57,74]
[44] -> [50,56,73]
[46] -> [68,85]
[47] -> [67,84]
[48] -> [66,83]
[49] -> [65,82]
[50] -> [44,56,73]
[51] -> [43]
[52] -> [60]
[52,62] -> [45]
[52,62,65] -> [61]
[52,62,66] -> [60]
[52,62,67] -> [59]
[52,62,68] -> [58]
[52,63] -> [59]
[52,64] -> [58]
[53] -> [64]
[54] -> [63]
[55] -> [62]
[56] -> [44,50]
[57] -> [43]
[58] -> [52,64]
[59] -> [52,63]
[60] -> [52,62,66]
[61] -> [52,62,65]
[62] -> [55]
[63] -> [54]
[64] -> [53]
[65] -> [49]
[66] -> [48]
[67] -> [47]
[68] -> [46]
[69] -> [78]
[69,79] -> [45]
[69,79,82] -> [78]
[69,79,83] -> [77]
[69,79,84] -> [76]
[69,79,85] -> [75]
[69,80] -> [76]
[69,81] -> [75]
[70] -> [81]
[71] -> [80]
[72] -> [79]
[73] -> [44,50]
[74] -> [43]
[75] -> [69,81]
[76] -> [69,80]
[77] -> [69,79,83]
[78] -> [69,79,82]
[79] -> [72]
[80] -> [71]
[81] -> [70]
[82] -> [49]
[83] -> [48]
[84] -> [47]
[85] -> [46]
[87] -> [94,100]
[88] -> [93,99]
[93] -> [88]
[94] -> [87]
[99] -> [88]
[100] -> [87]
[101] -> [105]
[102] -> [104]
[103] -> [105]
[104] -> [102]
[105] -> [103]
[107] -> [110,115,116]
[110] -> [107]
[115] -> [107]
[116] -> [107]
[119] -> [124,131,133]
[120] -> [123,130,132]
[123] -> [120]
[124] -> [119]
[130] -> [120]
[131] -> [119]
[132] -> [120]
[133] -> [119]
[136] -> [139,144,145]
[139] -> [136]
[144] -> [136]
[145] -> [136]
[149] -> [168,194,202,354]
[150] -> [167,193,201,353]
[151] -> [2,3,148,156,159,165]
[151,157] -> [156]
[151,158] -> [155]
[151,163] -> [162]
[151,164] -> [161]
[151,165,166] -> [160]
[151,167,169] -> [162]
[151,167,170] -> [161]
[151,167,171] -> [160]
[151,168] -> [161]
[152] -> [159,165,171,185,221,240,259,271,285,297,321,328,379]
[153] -> [158,164,170,184,220,239,258,270,284,296,320,327,378]
[154] -> [157,163,169,183,219,238,257,269,283,295,319,326,377]
[155] -> [151,158]
[156] -> [151,157]
[157] -> [154]
[158] -> [153]
[159] -> [152]
[160] -> [151,165,166]
[161] -> [151,164]
[162] -> [151,163]
[163] -> [154]
[164] -> [153]
[165] -> [152]
[167] -> [150]
[168] -> [149]
[169] -> [154]
[170] -> [153]
[171] -> [152]
[173] -> [175,181,182,188,199,200,215,234,253,279,309,316]
[175] -> [173,181,188,199,309]
[177] -> [210,225,229,244,248,263,267,275,289,293,301,325]
[178] -> [209,224,228,243,247,262,266,274,288,292,300,324]
[179] -> [208,223,227,242,246,261,265,273,287,291,299,323]
[180] -> [207,222,226,241,245,260,264,272,286,290,298,322]
[181] -> [173,175,182,215,234,253,279,316]
[182] -> [173,181,199,200,309]
[183] -> [154]
[184] -> [153]
[185] -> [152]
[186] -> [147,148,174,189,192,195]
[186,192,193] -> [191]
[186,192,194] -> [190]
[186,302,305] -> [191]
[186,303] -> [191]
[186,304] -> [190]
[187] -> [189,192,305,387]
[188] -> [173,175,199,200,309]
[189] -> [187]
[190] -> [186,192,194]
[191] -> [186,192,193]
[192] -> [187]
[193] -> [150]
[194] -> [149]
[195] -> [34,35,174,176,204,216,218,224,235,237,243,254,256,262,280,282,288]
[195,205] -> [147]
[195,206] -> [203]
[195,207] -> [174]
[195,208] -> [147]
[195,209] -> [203]
[195,210] -> [3]
[195,210,211] -> [2]
[195,216,222] -> [214]
[195,216,223] -> [213]
[195,216,225] -> [212]
[195,217] -> [151]
[195,217,219] -> [213]
[195,217,220] -> [34]
[195,217,221] -> [212]
[195,226] -> [214]
[195,227] -> [213]
[195,228] -> [34]
[195,229] -> [3]
[195,229,230] -> [212]
[195,235,241] -> [233]
[195,235,242] -> [232]
[195,235,244] -> [231]
[195,236] -> [151]
[195,236,238] -> [232]
[195,236,239] -> [35]
[195,236,240] -> [231]
[195,245] -> [233]
[195,246] -> [232]
[195,247] -> [35]
[195,248] -> [3]
[195,248,249] -> [231]
[195,254,260] -> [252]
[195,254,261] -> [251]
[195,254,263] -> [250]
[195,255] -> [151]
[195,255,257] -> [251]
[195,255,258] -> [35]
[195,255,259] -> [250]
[195,264] -> [176]
[195,264,272] -> [252]
[195,264,273] -> [251]
[195,264,274] -> [35]
[195,264,275] -> [250]
[195,265] -> [151]
[195,265,269] -> [251]
[195,265,270] -> [35]
[195,265,271] -> [250]
[195,266] -> [34]
[195,267] -> [3]
[195,267,268] -> [2]
[195,280,286] -> [278]
[195,280,287] -> [277]
[195,280,289] -> [276]
[195,281] -> [151]
[195,281,283] -> [277]
[195,281,284] -> [34]
[195,281,285] -> [276]
[195,290] -> [176]
[195,290,298] -> [278]
[195,290,299] -> [277]
[195,290,300] -> [34]
[195,290,301] -> [276]
[195,291] -> [151]
[195,291,295] -> [277]
[195,291,296] -> [34]
[195,291,297] -> [276]
[195,292] -> [35]
[195,293] -> [3]
[195,293,294] -> [2]
[196] -> [206,218,237,256,282,304]
[197] -> [205,217,236,255,281,303]
[198] -> [204,216,235,254,280,302]
[199] -> [173,175,182,188]
[200] -> [173,182,188]
[201] -> [150]
[202] -> [149]
[203] -> [195,206]
[204] -> [198]
[205] -> [197]
[206] -> [196]
[207] -> [180]
[208] -> [179]
[209] -> [178]
[210] -> [177]
[212] -> [195,216,225]
[213] -> [195,216,223]
[214] -> [195,216,222]
[215] -> [173,181]
[216] -> [198]
[217] -> [197]
[218] -> [196]
[219] -> [154]
[220] -> [153]
[221] -> [152]
[222] -> [180]
[223] -> [179]
[224] -> [178]
[225] -> [177]
[226] -> [180]
[227] -> [179]
[228] -> [178]
[229] -> [177]
[231] -> [195,235,244]
[232] -> [195,235,242]
[233] -> [195,235,241]
[234] -> [173,181]
[235] -> [198]
[236] -> [197]
[237] -> [196]
[238] -> [154]
[239] -> [153]
[240] -> [152]
[241] -> [180]
[242] -> [179]
[243] -> [178]
[244] -> [177]
[245] -> [180]
[246] -> [179]
[247] -> [178]
[248] -> [177]
[250] -> [195,254,263]
[251] -> [195,254,261]
[252] -> [195,254,260]
[253] -> [173,181]
[254] -> [198]
[255] -> [197]
[256] -> [196]
[257] -> [154]
[258] -> [153]
[259] -> [152]
[260] -> [180]
[261] -> [179]
[262] -> [178]
[263] -> [177]
[264] -> [180]
[265] -> [179]
[266] -> [178]
[267] -> [177]
[269] -> [154]
[270] -> [153]
[271] -> [152]
[272] -> [180]
[273] -> [179]
[274] -> [178]
[275] -> [177]
[276] -> [195,280,289]
[277] -> [195,280,287]
[278] -> [195,280,286]
[279] -> [173,181]
[280] -> [198]
[281] -> [197]
[282] -> [196]
[283] -> [154]
[284] -> [153]
[285] -> [152]
[286] -> [180]
[287] -> [179]
[288] -> [178]
[289] -> [177]
[290] -> [180]
[291] -> [179]
[292] -> [178]
[293] -> [177]
[295] -> [154]
[296] -> [153]
[297] -> [152]
[298] -> [180]
[299] -> [179]
[300] -> [178]
[301] -> [177]
[302] -> [198]
[303] -> [197]
[304] -> [196]
[305] -> [187]
[306] -> [147,151,174,176,310,317]
[306,311] -> [147]
[306,317,322] -> [315]
[306,317,323] -> [314]
[306,317,324] -> [313]
[306,317,325] -> [312]
[306,318] -> [151]
[306,318,319] -> [314]
[306,318,320] -> [313]
[306,318,321] -> [312]
[306,326,329] -> [315]
[306,326,330] -> [314]
[306,327] -> [313]
[306,328] -> [312]
[307] -> [311,318,330,386]
[308] -> [310,317,329,385]
[309] -> [173,175,182,188,316]
[310] -> [308]
[311] -> [307]
[312] -> [306,317,325]
[313] -> [306,317,324]
[314] -> [306,317,323]
[315] -> [306,317,322]
[316] -> [173,181,309]
[317] -> [308]
[318] -> [307]
[319] -> [154]
[320] -> [153]
[321] -> [152]
[322] -> [180]
[323] -> [179]
[324] -> [178]
[325] -> [177]
[326] -> [154]
[327] -> [153]
[328] -> [152]
[329] -> [308]
[330] -> [307]
[331] -> [147,148,340,341,350]
[331,342] -> [340]
[331,343] -> [337]
[331,350,353] -> [349]
[331,350,354] -> [348]
[331,351] -> [347]
[331,352] -> [344]
[331,355] -> [349]
[331,356] -> [344]
[331,356,358] -> [348]
[331,356,359] -> [347]
[331,357] -> [344]
[332] -> [343,352,357,373]
[333] -> [338,345,361]
[334] -> [339,346,362]
[335] -> [342,351,356,372]
[336] -> [341,350,355,371]
[337] -> [331,343]
[338] -> [333]
[339] -> [334]
[340] -> [331,342]
[341] -> [336]
[342] -> [335]
[343] -> [332]
[344] -> [331,352]
[345] -> [333,359]
[346] -> [334,358]
[347] -> [331,351]
[348] -> [331,350,354]
[349] -> [331,350,353]
[350] -> [336]
[351] -> [335]
[352] -> [332]
[353] -> [150]
[354] -> [149]
[355] -> [336]
[356] -> [335]
[357] -> [332]
[358] -> [346]
[359] -> [345]
[360] -> [34,35,363,365,366,367,368,369]
[360,364] -> [363]
[361] -> [333,365,367,369]
[362] -> [334,364,366,368]
[363] -> [360,364]
[364] -> [362]
[365] -> [361]
[366] -> [362]
[367] -> [361]
[368] -> [362]
[369] -> [361]
[370] -> [331]
[370,372] -> [35]
[370,373] -> [360]
[371] -> [336,384]
[372] -> [335]
[373] -> [332]
[374] -> [151]
[374,377] -> [147]
[374,378] -> [34]
[374,379] -> [376]
[375] -> [376,383]
[376] -> [375]
[377] -> [154]
[378] -> [153]
[379] -> [152]
[380] -> [370]
[380,384] -> [306]
[380,384,385] -> [186]
[380,384,385,387] -> [382]
[380,384,386] -> [382]
[382] -> [374]
[382,383] -> [381]
[383] -> [375]
[384] -> [371]
[385] -> [308]
[386] -> [307]
[387] -> [187]

### Solution ###

[2,3,14,15,28,34,35,111,117,134,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,174,176,177,178,180,183,184,185,186,187,189,190,191,192,193,194,195,196,198,201,202,203,204,206,207,209,210,211,212,214,216,218,219,220,221,222,224,225,226,228,229,230,231,233,235,237,238,239,240,241,243,244,245,247,248,249,250,252,254,256,257,258,259,260,262,263,264,266,267,268,269,270,271,272,274,275,276,278,280,282,283,284,285,286,288,289,290,292,293,294,295,296,297,298,300,301,302,304,305,306,308,310,312,313,315,317,319,320,321,322,324,325,326,327,328,329,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,387,R]

### Annotated ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        snd -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: (_x19 :E: Type) -> Type
    constructor Nil :E: (a :E: Type) -> List -E- a
    constructor Cons :E: (a :E: Type) -> (x :E: a) -> (xs :E: List -E- a) -> List -E- a
    constructor List :E: Type
    constructor Nil :R: List
    constructor Cons :R: (_x0 :R: Bool) -> (_x1 :R: List) -> List
    repl :R: (n :R: Nat) -> (x :R: Bool) -> (_x2 :R: List) -> List 
      x :R: Bool xs :R: List
        repl -R- Z -R- x -R- xs = xs
      n :R: Nat x :R: Bool xs :R: List
        repl -R- (S -R- n) -R- x -R- xs = Cons -R- x -R- (repl -R- n -R- x -R- xs)
    constructor RLE :E: (_x3 :E: List) -> Type
    constructor RNil :R: RLE -E- Nil
    constructor RCons :R: (n :R: Nat) -> (x :R: Bool) -> (xs :E: List) -> (_x4 :R: RLE -E- xs) -> RLE -E- (repl -R- n -R- x -R- xs)
    compress :R: (xs :R: List) -> RLE -E- xs 
      compress -R- Nil = RNil
      x :R: Bool xs :R: List
        compress -R- (Cons -R- x -R- xs) = 
          let aux :R: (y :R: Bool) -> (ys :E: List) -> (_x5 :R: RLE -E- ys) -> RLE -E- (Cons -R- y -R- ys) 
            y :R: Bool
              aux -R- y -E- [Nil] -R- RNil = RCons -R- 1 -R- y -E- Nil -R- RNil
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- True -E- [repl -R- n -R- True -R- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- (S -R- n) -R- True -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- False -E- [repl -R- n -R- False -R- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- (S -R- n) -R- False -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- True -E- [repl -R- n -R- False -R- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- 1 -R- True -E- (repl -R- n -R- False -R- zs) -R- (RCons -R- n -R- False -E- zs -R- rzs)
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- False -E- [repl -R- n -R- True -R- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- 1 -R- False -E- (repl -R- n -R- True -R- zs) -R- (RCons -R- n -R- True -E- zs -R- rzs)
          in aux -R- x -E- xs -R- (compress -R- xs)
    decompress :R: (xs :E: List) -> (_x6 :R: RLE -E- xs) -> List 
      decompress -E- [Nil] -R- RNil = Nil
      n :R: Nat x :R: Bool xs :E: List rxs :R: RLE -E- xs
        decompress -E- [repl -R- n -R- x -R- xs] -R- (RCons -R- n -R- x -E- xs -R- rxs) = repl -R- n -R- x -R- (decompress -E- xs -R- rxs)
    foldl :R: (_x7 :R: (_x8 :R: Bool) -> (_x9 :R: Bool) -> Bool) -> (_x10 :R: Bool) -> (_x11 :R: List) -> Bool 
      f :R: (_x12 :R: Bool) -> (_x13 :R: Bool) -> Bool z :R: Bool
        foldl -R- f -R- z -R- Nil = z
      f :R: (_x14 :R: Bool) -> (_x15 :R: Bool) -> Bool z :R: Bool x :R: Bool xs :R: List
        foldl -R- f -R- z -R- (Cons -R- x -R- xs) = foldl -R- f -R- (f -R- z -R- x) -R- xs
    xor :R: (_x16 :R: Bool) -> (_x17 :R: Bool) -> Bool 
      b :R: Bool
        xor -R- False -R- b = b
      xor -R- True -R- False = True
      xor -R- True -R- True = False
    xors :R: (_x18 :R: List) -> Bool = foldl -R- xor -R- False
    genInputList :R: (n :R: Nat) -> List = (\n :R: Nat. repl -R- n -R- True -R- Nil)
    main :R: Bool = 
      let
        foreign inputSize :R: Nat
        inputList :R: List = genInputList -R- inputSize
      in xors -R- (decompress -E- inputList -R- (compress -R- inputList))
  in main

### Specialised ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        snd -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: (_x19 :E: Type) -> Type
    constructor Nil :E: (a :E: Type) -> List -E- a
    constructor Cons :E: (a :E: Type) -> (x :E: a) -> (xs :E: List -E- a) -> List -E- a
    constructor List :E: Type
    constructor Nil :R: List
    constructor Cons :R: (_x0 :R: Bool) -> (_x1 :R: List) -> List
    repl :R: (n :R: Nat) -> (x :R: Bool) -> (_x2 :R: List) -> List 
      x :R: Bool xs :R: List
        repl -R- Z -R- x -R- xs = xs
      n :R: Nat x :R: Bool xs :R: List
        repl -R- (S -R- n) -R- x -R- xs = Cons -R- x -R- (repl -R- n -R- x -R- xs)
    constructor RLE :E: (_x3 :E: List) -> Type
    constructor RNil :R: RLE -E- Nil
    constructor RCons :R: (n :R: Nat) -> (x :R: Bool) -> (xs :E: List) -> (_x4 :R: RLE -E- xs) -> RLE -E- (repl -R- n -R- x -R- xs)
    compress :R: (xs :R: List) -> RLE -E- xs 
      compress -R- Nil = RNil
      x :R: Bool xs :R: List
        compress -R- (Cons -R- x -R- xs) = 
          let aux :R: (y :R: Bool) -> (ys :E: List) -> (_x5 :R: RLE -E- ys) -> RLE -E- (Cons -R- y -R- ys) 
            y :R: Bool
              aux -R- y -E- [Nil] -R- RNil = RCons -R- 1 -R- y -E- Nil -R- RNil
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- True -E- [repl -R- n -R- True -R- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- (S -R- n) -R- True -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- False -E- [repl -R- n -R- False -R- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- (S -R- n) -R- False -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- True -E- [repl -R- n -R- False -R- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- 1 -R- True -E- (repl -R- n -R- False -R- zs) -R- (RCons -R- n -R- False -E- zs -R- rzs)
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- False -E- [repl -R- n -R- True -R- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- 1 -R- False -E- (repl -R- n -R- True -R- zs) -R- (RCons -R- n -R- True -E- zs -R- rzs)
          in aux -R- x -E- xs -R- (compress -R- xs)
    decompress :R: (xs :E: List) -> (_x6 :R: RLE -E- xs) -> List 
      decompress -E- [Nil] -R- RNil = Nil
      n :R: Nat x :R: Bool xs :E: List rxs :R: RLE -E- xs
        decompress -E- [repl -R- n -R- x -R- xs] -R- (RCons -R- n -R- x -E- xs -R- rxs) = repl -R- n -R- x -R- (decompress -E- xs -R- rxs)
    foldl :R: (_x7 :R: (_x8 :R: Bool) -> (_x9 :R: Bool) -> Bool) -> (_x10 :R: Bool) -> (_x11 :R: List) -> Bool 
      f :R: (_x12 :R: Bool) -> (_x13 :R: Bool) -> Bool z :R: Bool
        foldl -R- f -R- z -R- Nil = z
      f :R: (_x14 :R: Bool) -> (_x15 :R: Bool) -> Bool z :R: Bool x :R: Bool xs :R: List
        foldl -R- f -R- z -R- (Cons -R- x -R- xs) = foldl -R- f -R- (f -R- z -R- x) -R- xs
    xor :R: (_x16 :R: Bool) -> (_x17 :R: Bool) -> Bool 
      b :R: Bool
        xor -R- False -R- b = b
      xor -R- True -R- False = True
      xor -R- True -R- True = False
    xors :R: (_x18 :R: List) -> Bool = foldl -R- xor -R- False
    genInputList :R: (n :R: Nat) -> List = (\n :R: Nat. repl -R- n -R- True -R- Nil)
    main :R: Bool = 
      let
        foreign inputSize :R: Nat
        inputList :R: List = genInputList -R- inputSize
      in xors -R- (decompress -E- inputList -R- (compress -R- inputList))
  in main

### Final annotation ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        snd -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: (_x19 :E: Type) -> Type
    constructor Nil :E: (a :E: Type) -> List -E- a
    constructor Cons :E: (a :E: Type) -> (x :E: a) -> (xs :E: List -E- a) -> List -E- a
    constructor List :E: Type
    constructor Nil :R: List
    constructor Cons :R: (_x0 :R: Bool) -> (_x1 :R: List) -> List
    repl :R: (n :R: Nat) -> (x :R: Bool) -> (_x2 :R: List) -> List 
      x :R: Bool xs :R: List
        repl -R- Z -R- x -R- xs = xs
      n :R: Nat x :R: Bool xs :R: List
        repl -R- (S -R- n) -R- x -R- xs = Cons -R- x -R- (repl -R- n -R- x -R- xs)
    constructor RLE :E: (_x3 :E: List) -> Type
    constructor RNil :R: RLE -E- Nil
    constructor RCons :R: (n :R: Nat) -> (x :R: Bool) -> (xs :E: List) -> (_x4 :R: RLE -E- xs) -> RLE -E- (repl -R- n -R- x -R- xs)
    compress :R: (xs :R: List) -> RLE -E- xs 
      compress -R- Nil = RNil
      x :R: Bool xs :R: List
        compress -R- (Cons -R- x -R- xs) = 
          let aux :R: (y :R: Bool) -> (ys :E: List) -> (_x5 :R: RLE -E- ys) -> RLE -E- (Cons -R- y -R- ys) 
            y :R: Bool
              aux -R- y -E- [Nil] -R- RNil = RCons -R- 1 -R- y -E- Nil -R- RNil
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- True -E- [repl -R- n -R- True -R- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- (S -R- n) -R- True -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- False -E- [repl -R- n -R- False -R- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- (S -R- n) -R- False -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- True -E- [repl -R- n -R- False -R- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- 1 -R- True -E- (repl -R- n -R- False -R- zs) -R- (RCons -R- n -R- False -E- zs -R- rzs)
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- False -E- [repl -R- n -R- True -R- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- 1 -R- False -E- (repl -R- n -R- True -R- zs) -R- (RCons -R- n -R- True -E- zs -R- rzs)
          in aux -R- x -E- xs -R- (compress -R- xs)
    decompress :R: (xs :E: List) -> (_x6 :R: RLE -E- xs) -> List 
      decompress -E- [Nil] -R- RNil = Nil
      n :R: Nat x :R: Bool xs :E: List rxs :R: RLE -E- xs
        decompress -E- [repl -R- n -R- x -R- xs] -R- (RCons -R- n -R- x -E- xs -R- rxs) = repl -R- n -R- x -R- (decompress -E- xs -R- rxs)
    foldl :R: (_x7 :R: (_x8 :R: Bool) -> (_x9 :R: Bool) -> Bool) -> (_x10 :R: Bool) -> (_x11 :R: List) -> Bool 
      f :R: (_x12 :R: Bool) -> (_x13 :R: Bool) -> Bool z :R: Bool
        foldl -R- f -R- z -R- Nil = z
      f :R: (_x14 :R: Bool) -> (_x15 :R: Bool) -> Bool z :R: Bool x :R: Bool xs :R: List
        foldl -R- f -R- z -R- (Cons -R- x -R- xs) = foldl -R- f -R- (f -R- z -R- x) -R- xs
    xor :R: (_x16 :R: Bool) -> (_x17 :R: Bool) -> Bool 
      b :R: Bool
        xor -R- False -R- b = b
      xor -R- True -R- False = True
      xor -R- True -R- True = False
    xors :R: (_x18 :R: List) -> Bool = foldl -R- xor -R- False
    genInputList :R: (n :R: Nat) -> List = (\n :R: Nat. repl -R- n -R- True -R- Nil)
    main :R: Bool = 
      let
        foreign inputSize :R: Nat
        inputList :R: List = genInputList -R- inputSize
      in xors -R- (decompress -E- inputList -R- (compress -R- inputList))
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    constructor Nil : List
    constructor Cons : (_x0) -> (_x1) -> List
    repl 
      repl Z x xs = xs
      repl (S n) x xs = Cons x (repl n x xs)
    constructor RNil : RLE
    constructor RCons : (n) -> (x) -> (_x4) -> RLE
    compress 
      compress Nil = RNil
      compress (Cons x xs) = 
        let aux 
          aux y RNil = RCons 1 y RNil
          aux True (RCons n True rzs) = RCons (S n) True rzs
          aux False (RCons n False rzs) = RCons (S n) False rzs
          aux True (RCons n False rzs) = RCons 1 True (RCons n False rzs)
          aux False (RCons n True rzs) = RCons 1 False (RCons n True rzs)
        in aux x (compress xs)
    decompress 
      decompress RNil = Nil
      decompress (RCons n x rxs) = repl n x (decompress rxs)
    foldl 
      foldl f z Nil = z
      foldl f z (Cons x xs) = foldl f (f z x) xs
    xor 
      xor False b = b
      xor True False = True
      xor True True = False
    xors = foldl xor False
    genInputList = (\n. repl n True Nil)
    main = 
      let
        foreign inputSize
        inputList = genInputList inputSize
      in xors (decompress (compress inputList))
  in main

### Intermediate representation ###

let Z = constructor 0
  in let S = constructor 1
    in let True = constructor 0
      in let False = constructor 0
        in let Nil = constructor 0
          in let Cons = constructor 2
            in let repl = \_pv0. \_pv1. \_pv2.
              case _pv0 of
                S _pv3 => ((Cons _pv1) (((repl _pv3) _pv1) _pv2))
                Z => _pv2
              in let RNil = constructor 0
                in let RCons = constructor 3
                  in let compress = \_pv0.
                    case _pv0 of
                      Cons _pv1 _pv2 => let aux = \_pv3. \_pv4.
                        case _pv4 of
                          RNil => (((RCons (S Z)) _pv3) RNil)
                          _ => case _pv3 of
                            False => case _pv4 of
                              RCons _pv5 _pv6 _pv7 => case _pv6 of
                                False => (((RCons (S _pv5)) False) _pv7)
                                True => (((RCons (S Z)) False) (((RCons _pv5) True) _pv7))
                            True => case _pv4 of
                              RCons _pv5 _pv6 _pv7 => case _pv6 of
                                False => (((RCons (S Z)) True) (((RCons _pv5) False) _pv7))
                                True => (((RCons (S _pv5)) True) _pv7)
                        in ((aux _pv1) (compress _pv2))
                      Nil => RNil
                    in let decompress = \_pv0.
                      case _pv0 of
                        RCons _pv1 _pv2 _pv3 => (((repl _pv1) _pv2) (decompress _pv3))
                        RNil => Nil
                      in let foldl = \_pv0. \_pv1. \_pv2.
                        case _pv2 of
                          Cons _pv3 _pv4 => (((foldl _pv0) ((_pv0 _pv1) _pv3)) _pv4)
                          Nil => _pv1
                        in let xor = \_pv0. \_pv1.
                          case _pv0 of
                            False => _pv1
                            True => case _pv1 of
                              False => True
                              True => False
                          in let xors = ((foldl xor) False)
                            in let genInputList = \n. (((repl n) True) Nil)
                              in let main = let inputSize = foreign "(rts-arg-peano 'Z 'S 0)"
                                in let inputList = (genInputList inputSize)
                                  in (xors (decompress (compress inputList)))
                                in main

### Normal forms ###

unerased:
  
  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    constructor List : (_x19 : Type) -> Type
    constructor Nil : (a : Type) -> List a
    constructor Cons : (a : Type) -> (x : a) -> (xs : List a) -> List a
    constructor List : Type
    constructor Nil : List
    constructor Cons : (_x0 : Bool) -> (_x1 : List) -> List
    repl : (n : Nat) -> (x : Bool) -> (_x2 : List) -> List 
      x : Bool xs : List
        repl Z x xs = xs
      n : Nat x : Bool xs : List
        repl (S n) x xs = Cons x (repl n x xs)
    constructor RLE : (_x3 : List) -> Type
    constructor RNil : RLE Nil
    constructor RCons : (n : Nat) -> (x : Bool) -> (xs : List) -> (_x4 : RLE xs) -> RLE (repl n x xs)
    compress : (xs : List) -> RLE xs 
      compress Nil = RNil
      x : Bool xs : List
        compress (Cons x xs) = 
          let aux : (y : Bool) -> (ys : List) -> (_x5 : RLE ys) -> RLE (Cons y ys) 
            y : Bool
              aux y [Nil] RNil = RCons 1 y Nil RNil
            n : Nat zs : List rzs : RLE zs
              aux True [repl n True zs] (RCons n True zs rzs) = RCons (S n) True zs rzs
            n : Nat zs : List rzs : RLE zs
              aux False [repl n False zs] (RCons n False zs rzs) = RCons (S n) False zs rzs
            n : Nat zs : List rzs : RLE zs
              aux True [repl n False zs] (RCons n False zs rzs) = RCons 1 True (repl n False zs) (RCons n False zs rzs)
            n : Nat zs : List rzs : RLE zs
              aux False [repl n True zs] (RCons n True zs rzs) = RCons 1 False (repl n True zs) (RCons n True zs rzs)
          in aux x xs (compress xs)
    decompress : (xs : List) -> (_x6 : RLE xs) -> List 
      decompress [Nil] RNil = Nil
      n : Nat x : Bool xs : List rxs : RLE xs
        decompress [repl n x xs] (RCons n x xs rxs) = repl n x (decompress xs rxs)
    foldl : (_x7 : (_x8 : Bool) -> (_x9 : Bool) -> Bool) -> (_x10 : Bool) -> (_x11 : List) -> Bool 
      f : (_x12 : Bool) -> (_x13 : Bool) -> Bool z : Bool
        foldl f z Nil = z
      f : (_x14 : Bool) -> (_x15 : Bool) -> Bool z : Bool x : Bool xs : List
        foldl f z (Cons x xs) = foldl f (f z x) xs
    xor : (_x16 : Bool) -> (_x17 : Bool) -> Bool 
      b : Bool
        xor False b = b
      xor True False = True
      xor True True = False
  in 
    let foreign inputSize : Nat
    in foldl xor False (decompress (repl inputSize True Nil) (compress (repl inputSize True Nil)))

erased:
  
  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    constructor Nil : List
    constructor Cons : (_x0) -> (_x1) -> List
    repl 
      repl Z x xs = xs
      repl (S n) x xs = Cons x (repl n x xs)
    constructor RNil : RLE
    constructor RCons : (n) -> (x) -> (_x4) -> RLE
    compress 
      compress Nil = RNil
      compress (Cons x xs) = 
        let aux 
          aux y RNil = RCons 1 y RNil
          aux True (RCons n True rzs) = RCons (S n) True rzs
          aux False (RCons n False rzs) = RCons (S n) False rzs
          aux True (RCons n False rzs) = RCons 1 True (RCons n False rzs)
          aux False (RCons n True rzs) = RCons 1 False (RCons n True rzs)
        in aux x (compress xs)
    decompress 
      decompress RNil = Nil
      decompress (RCons n x rxs) = repl n x (decompress rxs)
    foldl 
      foldl f z Nil = z
      foldl f z (Cons x xs) = foldl f (f z x) xs
    xor 
      xor False b = b
      xor True False = True
      xor True True = False
  in 
    let foreign inputSize
    in foldl xor False (decompress (compress (repl inputSize True Nil)))

