-- vim: ft=ttstar

### Desugared ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        plus Z n = n
      m : Nat n : Nat
        plus (S m) n = S (plus m n)
    times : (_x2 : Nat) -> (_x3 : Nat) -> Nat 
      n : Nat
        times Z n = Z
      m : Nat n : Nat
        times (S m) n = plus n (times m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x4 : Bool) -> Bool 
      not True = False
      not False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x5 : Type) -> (_x6 : Type) -> Type
    constructor MkPair : (a : Type) -> (b : Type) -> (_x7 : a) -> (_x8 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x9 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        fst a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x10 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        snd a b ([MkPair] [a] [b] x y) = y
    constructor Either : (_x11 : Type) -> (_x12 : Type) -> Type
    constructor Left : (a : Type) -> (b : Type) -> (_x13 : a) -> Either a b
    constructor Right : (a : Type) -> (b : Type) -> (_x14 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x15 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x16 : Fin n) -> Fin (S n)
    constructor Vect : (_x17 : Nat) -> (_x18 : Type) -> Type
    constructor VN : (a : Type) -> Vect Z a
    constructor VC : (n : Nat) -> (a : Type) -> (x : a) -> (xs : Vect n a) -> Vect (S n) a
    constructor List : Type
    constructor Nil : List
    constructor Cons : (_x0 : Bool) -> (_x1 : List) -> List
    repl : (n : Nat) -> (x : Bool) -> (_x2 : List) -> List 
      x : Bool xs : List
        repl Z x xs = xs
      n : Nat x : Bool xs : List
        repl (S n) x xs = Cons x (repl n x xs)
    constructor RLE : (_x3 : List) -> Type
    constructor RNil : RLE Nil
    constructor RCons : (n : Nat) -> (x : Bool) -> (xs : List) -> (_x4 : RLE xs) -> RLE (repl n x xs)
    compress : (xs : List) -> RLE xs 
      compress Nil = RNil
      x : Bool xs : List
        compress (Cons x xs) = 
          let aux : (y : Bool) -> (ys : List) -> (_x5 : RLE ys) -> RLE (Cons y ys) 
            y : Bool
              aux y [Nil] RNil = RCons 1 y Nil RNil
            n : Nat zs : List rzs : RLE zs
              aux True [repl n True zs] (RCons n True zs rzs) = RCons (S n) True zs rzs
            n : Nat zs : List rzs : RLE zs
              aux False [repl n False zs] (RCons n False zs rzs) = RCons (S n) False zs rzs
            n : Nat zs : List rzs : RLE zs
              aux True [repl n False zs] (RCons n False zs rzs) = RCons 1 True (repl n False zs) (RCons n False zs rzs)
            n : Nat zs : List rzs : RLE zs
              aux False [repl n True zs] (RCons n True zs rzs) = RCons 1 False (repl n True zs) (RCons n True zs rzs)
          in aux x xs (compress xs)
    decompress : (xs : List) -> (_x6 : RLE xs) -> List 
      decompress [Nil] RNil = Nil
      n : Nat x : Bool xs : List rxs : RLE xs
        decompress [repl n x xs] (RCons n x xs rxs) = repl n x (decompress xs rxs)
    foldl : (_x7 : (_x8 : Bool) -> (_x9 : Bool) -> Bool) -> (_x10 : Bool) -> (_x11 : List) -> Bool 
      f : (_x12 : Bool) -> (_x13 : Bool) -> Bool z : Bool
        foldl f z Nil = z
      f : (_x14 : Bool) -> (_x15 : Bool) -> Bool z : Bool x : Bool xs : List
        foldl f z (Cons x xs) = foldl f (f z x) xs
    xor : (_x16 : Bool) -> (_x17 : Bool) -> Bool 
      b : Bool
        xor False b = b
      xor True False = True
      xor True True = False
    xors : (_x18 : List) -> Bool = foldl xor False
    genInputList : (n : Nat) -> List = (\n : Nat. repl n True Nil)
    main : Bool = 
      let
        foreign inputSize : Nat
        inputList : List = genInputList inputSize
      in xors (decompress inputList (compress inputList))
  in main

### Evarified ###

  let
    constructor Nat :1: Type
    constructor Z :2: Nat
    constructor S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        plus -9- Z -8- n = n
      m :10: Nat n :11: Nat
        plus -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    times :18: (_x2 :19: Nat) -> (_x3 :20: Nat) -> Nat 
      n :21: Nat
        times -23- Z -22- n = Z
      m :24: Nat n :25: Nat
        times -27- (S -28- m) -26- n = plus -30- n -29- (times -32- m -31- n)
    constructor Bool :33: Type
    constructor True :34: Bool
    constructor False :35: Bool
    not :36: (_x4 :37: Bool) -> Bool 
      not -38- True = False
      not -39- False = True
    constructor Unit :40: Type
    constructor MkUnit :41: Unit
    constructor Pair :42: (_x5 :43: Type) -> (_x6 :44: Type) -> Type
    constructor MkPair :45: (a :46: Type) -> (b :47: Type) -> (_x7 :48: a) -> (_x8 :49: b) -> Pair -51- a -50- b
    fst :52: (a :53: Type) -> (b :54: Type) -> (_x9 :55: Pair -57- a -56- b) -> a 
      a :58: Type b :59: Type x :60: a y :61: b
        fst -64- a -63- b -62- ([MkPair] -68- [a] -67- [b] -66- x -65- y) = x
    snd :69: (a :70: Type) -> (b :71: Type) -> (_x10 :72: Pair -74- a -73- b) -> b 
      a :75: Type b :76: Type x :77: a y :78: b
        snd -81- a -80- b -79- ([MkPair] -85- [a] -84- [b] -83- x -82- y) = y
    constructor Either :86: (_x11 :87: Type) -> (_x12 :88: Type) -> Type
    constructor Left :89: (a :90: Type) -> (b :91: Type) -> (_x13 :92: a) -> Either -94- a -93- b
    constructor Right :95: (a :96: Type) -> (b :97: Type) -> (_x14 :98: b) -> Either -100- a -99- b
    id :101: (a :102: Type) -> (x :103: a) -> a = (\a :104: Type. (\x :105: a. x))
    constructor Fin :106: (_x15 :107: Nat) -> Type
    constructor FZ :108: (n :109: Nat) -> Fin -110- (S -111- n)
    constructor FS :112: (n :113: Nat) -> (_x16 :114: Fin -115- n) -> Fin -116- (S -117- n)
    constructor Vect :118: (_x17 :119: Nat) -> (_x18 :120: Type) -> Type
    constructor VN :121: (a :122: Type) -> Vect -124- Z -123- a
    constructor VC :125: (n :126: Nat) -> (a :127: Type) -> (x :128: a) -> (xs :129: Vect -131- n -130- a) -> Vect -133- (S -134- n) -132- a
    constructor List :135: Type
    constructor Nil :136: List
    constructor Cons :137: (_x0 :138: Bool) -> (_x1 :139: List) -> List
    repl :140: (n :141: Nat) -> (x :142: Bool) -> (_x2 :143: List) -> List 
      x :144: Bool xs :145: List
        repl -148- Z -147- x -146- xs = xs
      n :149: Nat x :150: Bool xs :151: List
        repl -154- (S -155- n) -153- x -152- xs = Cons -157- x -156- (repl -160- n -159- x -158- xs)
    constructor RLE :161: (_x3 :162: List) -> Type
    constructor RNil :163: RLE -164- Nil
    constructor RCons :165: (n :166: Nat) -> (x :167: Bool) -> (xs :168: List) -> (_x4 :169: RLE -170- xs) -> RLE -171- (repl -174- n -173- x -172- xs)
    compress :175: (xs :176: List) -> RLE -177- xs 
      compress -178- Nil = RNil
      x :179: Bool xs :180: List
        compress -181- (Cons -183- x -182- xs) = 
          let aux :184: (y :185: Bool) -> (ys :186: List) -> (_x5 :187: RLE -188- ys) -> RLE -189- (Cons -191- y -190- ys) 
            y :192: Bool
              aux -195- y -194- [Nil] -193- RNil = RCons -199- 1 -198- y -197- Nil -196- RNil
            n :201: Nat zs :202: List rzs :203: RLE -204- zs
              aux -207- True -206- [repl -210- n -209- True -208- zs] -205- (RCons -214- n -213- True -212- zs -211- rzs) = RCons -218- (S -219- n) -217- True -216- zs -215- rzs
            n :220: Nat zs :221: List rzs :222: RLE -223- zs
              aux -226- False -225- [repl -229- n -228- False -227- zs] -224- (RCons -233- n -232- False -231- zs -230- rzs) = RCons -237- (S -238- n) -236- False -235- zs -234- rzs
            n :239: Nat zs :240: List rzs :241: RLE -242- zs
              aux -245- True -244- [repl -248- n -247- False -246- zs] -243- (RCons -252- n -251- False -250- zs -249- rzs) = RCons -256- 1 -255- True -254- (repl -260- n -259- False -258- zs) -253- (RCons -264- n -263- False -262- zs -261- rzs)
            n :265: Nat zs :266: List rzs :267: RLE -268- zs
              aux -271- False -270- [repl -274- n -273- True -272- zs] -269- (RCons -278- n -277- True -276- zs -275- rzs) = RCons -282- 1 -281- False -280- (repl -286- n -285- True -284- zs) -279- (RCons -290- n -289- True -288- zs -287- rzs)
          in aux -293- x -292- xs -291- (compress -294- xs)
    decompress :295: (xs :296: List) -> (_x6 :297: RLE -298- xs) -> List 
      decompress -300- [Nil] -299- RNil = Nil
      n :301: Nat x :302: Bool xs :303: List rxs :304: RLE -305- xs
        decompress -307- [repl -310- n -309- x -308- xs] -306- (RCons -314- n -313- x -312- xs -311- rxs) = repl -317- n -316- x -315- (decompress -319- xs -318- rxs)
    foldl :320: (_x7 :321: (_x8 :322: Bool) -> (_x9 :323: Bool) -> Bool) -> (_x10 :324: Bool) -> (_x11 :325: List) -> Bool 
      f :326: (_x12 :327: Bool) -> (_x13 :328: Bool) -> Bool z :329: Bool
        foldl -332- f -331- z -330- Nil = z
      f :333: (_x14 :334: Bool) -> (_x15 :335: Bool) -> Bool z :336: Bool x :337: Bool xs :338: List
        foldl -341- f -340- z -339- (Cons -343- x -342- xs) = foldl -346- f -345- (f -348- z -347- x) -344- xs
    xor :349: (_x16 :350: Bool) -> (_x17 :351: Bool) -> Bool 
      b :352: Bool
        xor -354- False -353- b = b
      xor -356- True -355- False = True
      xor -358- True -357- True = False
    xors :359: (_x18 :360: List) -> Bool = foldl -362- xor -361- False
    genInputList :363: (n :364: Nat) -> List = (\n :365: Nat. repl -368- n -367- True -366- Nil)
    main :369: Bool = 
      let
        foreign inputSize :370: Nat
        inputList :371: List = genInputList -372- inputSize
      in xors -373- (decompress -375- inputList -374- (compress -376- inputList))
  in main

### Constraints ###

[] -> [14,15,28,111,117,134,155,200,219,238,257,283,369]
[4] -> [2,3,7,9,13]
[4,8] -> [7]
[4,12] -> [11]
[4,13,14] -> [10]
[4,15,16] -> [11]
[4,15,17] -> [10]
[5] -> [9,13,17,30]
[6] -> [8,12,16,29]
[7] -> [4,8]
[8] -> [6]
[9] -> [5]
[10] -> [4,13,14]
[11] -> [4,12]
[12] -> [6]
[13] -> [5]
[16] -> [6]
[17] -> [5]
[18] -> [2,3,4,23,27]
[18,22] -> [21]
[18,26] -> [25]
[18,27,28] -> [24]
[18,29,31] -> [25]
[18,29,32] -> [24]
[18,30] -> [25]
[19] -> [23,27,32]
[20] -> [22,26,31]
[21] -> [18,22]
[22] -> [20]
[23] -> [19]
[24] -> [18,27,28]
[25] -> [18,26]
[26] -> [20]
[27] -> [19]
[29] -> [6]
[30] -> [5]
[31] -> [20]
[32] -> [19]
[36] -> [34,35,38,39]
[37] -> [38,39]
[38] -> [37]
[39] -> [37]
[43] -> [51,57,74]
[44] -> [50,56,73]
[46] -> [68,85]
[47] -> [67,84]
[48] -> [66,83]
[49] -> [65,82]
[50] -> [44,56,73]
[51] -> [43]
[52] -> [60]
[52,62] -> [45]
[52,62,65] -> [61]
[52,62,66] -> [60]
[52,62,67] -> [59]
[52,62,68] -> [58]
[52,63] -> [59]
[52,64] -> [58]
[53] -> [64]
[54] -> [63]
[55] -> [62]
[56] -> [44,50]
[57] -> [43]
[58] -> [52,64]
[59] -> [52,63]
[60] -> [52,62,66]
[61] -> [52,62,65]
[62] -> [55]
[63] -> [54]
[64] -> [53]
[65] -> [49]
[66] -> [48]
[67] -> [47]
[68] -> [46]
[69] -> [78]
[69,79] -> [45]
[69,79,82] -> [78]
[69,79,83] -> [77]
[69,79,84] -> [76]
[69,79,85] -> [75]
[69,80] -> [76]
[69,81] -> [75]
[70] -> [81]
[71] -> [80]
[72] -> [79]
[73] -> [44,50]
[74] -> [43]
[75] -> [69,81]
[76] -> [69,80]
[77] -> [69,79,83]
[78] -> [69,79,82]
[79] -> [72]
[80] -> [71]
[81] -> [70]
[82] -> [49]
[83] -> [48]
[84] -> [47]
[85] -> [46]
[87] -> [94,100]
[88] -> [93,99]
[93] -> [88]
[94] -> [87]
[99] -> [88]
[100] -> [87]
[101] -> [105]
[102] -> [104]
[103] -> [105]
[104] -> [102]
[105] -> [103]
[107] -> [110,115,116]
[110] -> [107]
[115] -> [107]
[116] -> [107]
[119] -> [124,131,133]
[120] -> [123,130,132]
[123] -> [120]
[124] -> [119]
[130] -> [120]
[131] -> [119]
[132] -> [120]
[133] -> [119]
[138] -> [157,183,191,343]
[139] -> [156,182,190,342]
[140] -> [2,3,137,145,148,154]
[140,146] -> [145]
[140,147] -> [144]
[140,152] -> [151]
[140,153] -> [150]
[140,154,155] -> [149]
[140,156,158] -> [151]
[140,156,159] -> [150]
[140,156,160] -> [149]
[140,157] -> [150]
[141] -> [148,154,160,174,210,229,248,260,274,286,310,317,368]
[142] -> [147,153,159,173,209,228,247,259,273,285,309,316,367]
[143] -> [146,152,158,172,208,227,246,258,272,284,308,315,366]
[144] -> [140,147]
[145] -> [140,146]
[146] -> [143]
[147] -> [142]
[148] -> [141]
[149] -> [140,154,155]
[150] -> [140,153]
[151] -> [140,152]
[152] -> [143]
[153] -> [142]
[154] -> [141]
[156] -> [139]
[157] -> [138]
[158] -> [143]
[159] -> [142]
[160] -> [141]
[162] -> [164,170,171,177,188,189,204,223,242,268,298,305]
[164] -> [162,170,177,188,298]
[166] -> [199,214,218,233,237,252,256,264,278,282,290,314]
[167] -> [198,213,217,232,236,251,255,263,277,281,289,313]
[168] -> [197,212,216,231,235,250,254,262,276,280,288,312]
[169] -> [196,211,215,230,234,249,253,261,275,279,287,311]
[170] -> [162,164,171,204,223,242,268,305]
[171] -> [162,170,188,189,298]
[172] -> [143]
[173] -> [142]
[174] -> [141]
[175] -> [136,137,163,178,181,184]
[175,181,182] -> [180]
[175,181,183] -> [179]
[175,291,294] -> [180]
[175,292] -> [180]
[175,293] -> [179]
[176] -> [178,181,294,376]
[177] -> [162,164,188,189,298]
[178] -> [176]
[179] -> [175,181,183]
[180] -> [175,181,182]
[181] -> [176]
[182] -> [139]
[183] -> [138]
[184] -> [34,35,163,165,193,205,207,213,224,226,232,243,245,251,269,271,277]
[184,194] -> [136]
[184,195] -> [192]
[184,196] -> [163]
[184,197] -> [136]
[184,198] -> [192]
[184,199] -> [3]
[184,199,200] -> [2]
[184,205,211] -> [203]
[184,205,212] -> [202]
[184,205,214] -> [201]
[184,206] -> [140]
[184,206,208] -> [202]
[184,206,209] -> [34]
[184,206,210] -> [201]
[184,215] -> [203]
[184,216] -> [202]
[184,217] -> [34]
[184,218] -> [3]
[184,218,219] -> [201]
[184,224,230] -> [222]
[184,224,231] -> [221]
[184,224,233] -> [220]
[184,225] -> [140]
[184,225,227] -> [221]
[184,225,228] -> [35]
[184,225,229] -> [220]
[184,234] -> [222]
[184,235] -> [221]
[184,236] -> [35]
[184,237] -> [3]
[184,237,238] -> [220]
[184,243,249] -> [241]
[184,243,250] -> [240]
[184,243,252] -> [239]
[184,244] -> [140]
[184,244,246] -> [240]
[184,244,247] -> [35]
[184,244,248] -> [239]
[184,253] -> [165]
[184,253,261] -> [241]
[184,253,262] -> [240]
[184,253,263] -> [35]
[184,253,264] -> [239]
[184,254] -> [140]
[184,254,258] -> [240]
[184,254,259] -> [35]
[184,254,260] -> [239]
[184,255] -> [34]
[184,256] -> [3]
[184,256,257] -> [2]
[184,269,275] -> [267]
[184,269,276] -> [266]
[184,269,278] -> [265]
[184,270] -> [140]
[184,270,272] -> [266]
[184,270,273] -> [34]
[184,270,274] -> [265]
[184,279] -> [165]
[184,279,287] -> [267]
[184,279,288] -> [266]
[184,279,289] -> [34]
[184,279,290] -> [265]
[184,280] -> [140]
[184,280,284] -> [266]
[184,280,285] -> [34]
[184,280,286] -> [265]
[184,281] -> [35]
[184,282] -> [3]
[184,282,283] -> [2]
[185] -> [195,207,226,245,271,293]
[186] -> [194,206,225,244,270,292]
[187] -> [193,205,224,243,269,291]
[188] -> [162,164,171,177]
[189] -> [162,171,177]
[190] -> [139]
[191] -> [138]
[192] -> [184,195]
[193] -> [187]
[194] -> [186]
[195] -> [185]
[196] -> [169]
[197] -> [168]
[198] -> [167]
[199] -> [166]
[201] -> [184,205,214]
[202] -> [184,205,212]
[203] -> [184,205,211]
[204] -> [162,170]
[205] -> [187]
[206] -> [186]
[207] -> [185]
[208] -> [143]
[209] -> [142]
[210] -> [141]
[211] -> [169]
[212] -> [168]
[213] -> [167]
[214] -> [166]
[215] -> [169]
[216] -> [168]
[217] -> [167]
[218] -> [166]
[220] -> [184,224,233]
[221] -> [184,224,231]
[222] -> [184,224,230]
[223] -> [162,170]
[224] -> [187]
[225] -> [186]
[226] -> [185]
[227] -> [143]
[228] -> [142]
[229] -> [141]
[230] -> [169]
[231] -> [168]
[232] -> [167]
[233] -> [166]
[234] -> [169]
[235] -> [168]
[236] -> [167]
[237] -> [166]
[239] -> [184,243,252]
[240] -> [184,243,250]
[241] -> [184,243,249]
[242] -> [162,170]
[243] -> [187]
[244] -> [186]
[245] -> [185]
[246] -> [143]
[247] -> [142]
[248] -> [141]
[249] -> [169]
[250] -> [168]
[251] -> [167]
[252] -> [166]
[253] -> [169]
[254] -> [168]
[255] -> [167]
[256] -> [166]
[258] -> [143]
[259] -> [142]
[260] -> [141]
[261] -> [169]
[262] -> [168]
[263] -> [167]
[264] -> [166]
[265] -> [184,269,278]
[266] -> [184,269,276]
[267] -> [184,269,275]
[268] -> [162,170]
[269] -> [187]
[270] -> [186]
[271] -> [185]
[272] -> [143]
[273] -> [142]
[274] -> [141]
[275] -> [169]
[276] -> [168]
[277] -> [167]
[278] -> [166]
[279] -> [169]
[280] -> [168]
[281] -> [167]
[282] -> [166]
[284] -> [143]
[285] -> [142]
[286] -> [141]
[287] -> [169]
[288] -> [168]
[289] -> [167]
[290] -> [166]
[291] -> [187]
[292] -> [186]
[293] -> [185]
[294] -> [176]
[295] -> [136,140,163,165,299,306]
[295,300] -> [136]
[295,306,311] -> [304]
[295,306,312] -> [303]
[295,306,313] -> [302]
[295,306,314] -> [301]
[295,307] -> [140]
[295,307,308] -> [303]
[295,307,309] -> [302]
[295,307,310] -> [301]
[295,315,318] -> [304]
[295,315,319] -> [303]
[295,316] -> [302]
[295,317] -> [301]
[296] -> [300,307,319,375]
[297] -> [299,306,318,374]
[298] -> [162,164,171,177,305]
[299] -> [297]
[300] -> [296]
[301] -> [295,306,314]
[302] -> [295,306,313]
[303] -> [295,306,312]
[304] -> [295,306,311]
[305] -> [162,170,298]
[306] -> [297]
[307] -> [296]
[308] -> [143]
[309] -> [142]
[310] -> [141]
[311] -> [169]
[312] -> [168]
[313] -> [167]
[314] -> [166]
[315] -> [143]
[316] -> [142]
[317] -> [141]
[318] -> [297]
[319] -> [296]
[320] -> [136,137,329,330,339]
[320,331] -> [329]
[320,332] -> [326]
[320,339,342] -> [338]
[320,339,343] -> [337]
[320,340] -> [336]
[320,341] -> [333]
[320,344] -> [338]
[320,345] -> [333]
[320,345,347] -> [337]
[320,345,348] -> [336]
[320,346] -> [333]
[321] -> [332,341,346,362]
[322] -> [327,334,350]
[323] -> [328,335,351]
[324] -> [331,340,345,361]
[325] -> [330,339,344,360]
[326] -> [320,332]
[327] -> [322]
[328] -> [323]
[329] -> [320,331]
[330] -> [325]
[331] -> [324]
[332] -> [321]
[333] -> [320,341]
[334] -> [322,348]
[335] -> [323,347]
[336] -> [320,340]
[337] -> [320,339,343]
[338] -> [320,339,342]
[339] -> [325]
[340] -> [324]
[341] -> [321]
[342] -> [139]
[343] -> [138]
[344] -> [325]
[345] -> [324]
[346] -> [321]
[347] -> [335]
[348] -> [334]
[349] -> [34,35,352,354,355,356,357,358]
[349,353] -> [352]
[350] -> [322,354,356,358]
[351] -> [323,353,355,357]
[352] -> [349,353]
[353] -> [351]
[354] -> [350]
[355] -> [351]
[356] -> [350]
[357] -> [351]
[358] -> [350]
[359] -> [320]
[359,361] -> [35]
[359,362] -> [349]
[360] -> [325,373]
[361] -> [324]
[362] -> [321]
[363] -> [140]
[363,366] -> [136]
[363,367] -> [34]
[363,368] -> [365]
[364] -> [365,372]
[365] -> [364]
[366] -> [143]
[367] -> [142]
[368] -> [141]
[369] -> [359]
[369,373] -> [295]
[369,373,374] -> [175]
[369,373,374,376] -> [371]
[369,373,375] -> [371]
[371] -> [363]
[371,372] -> [370]
[372] -> [364]
[373] -> [360]
[374] -> [297]
[375] -> [296]
[376] -> [176]

### Solution ###

[2,3,14,15,28,34,35,111,117,134,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,163,165,166,167,169,172,173,174,175,176,178,179,180,181,182,183,184,185,187,190,191,192,193,195,196,198,199,200,201,203,205,207,208,209,210,211,213,214,215,217,218,219,220,222,224,226,227,228,229,230,232,233,234,236,237,238,239,241,243,245,246,247,248,249,251,252,253,255,256,257,258,259,260,261,263,264,265,267,269,271,272,273,274,275,277,278,279,281,282,283,284,285,286,287,289,290,291,293,294,295,297,299,301,302,304,306,308,309,310,311,313,314,315,316,317,318,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,376,R]

### Annotated ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        snd -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: Type
    constructor Nil :R: List
    constructor Cons :R: (_x0 :R: Bool) -> (_x1 :R: List) -> List
    repl :R: (n :R: Nat) -> (x :R: Bool) -> (_x2 :R: List) -> List 
      x :R: Bool xs :R: List
        repl -R- Z -R- x -R- xs = xs
      n :R: Nat x :R: Bool xs :R: List
        repl -R- (S -R- n) -R- x -R- xs = Cons -R- x -R- (repl -R- n -R- x -R- xs)
    constructor RLE :E: (_x3 :E: List) -> Type
    constructor RNil :R: RLE -E- Nil
    constructor RCons :R: (n :R: Nat) -> (x :R: Bool) -> (xs :E: List) -> (_x4 :R: RLE -E- xs) -> RLE -E- (repl -R- n -R- x -R- xs)
    compress :R: (xs :R: List) -> RLE -E- xs 
      compress -R- Nil = RNil
      x :R: Bool xs :R: List
        compress -R- (Cons -R- x -R- xs) = 
          let aux :R: (y :R: Bool) -> (ys :E: List) -> (_x5 :R: RLE -E- ys) -> RLE -E- (Cons -R- y -R- ys) 
            y :R: Bool
              aux -R- y -E- [Nil] -R- RNil = RCons -R- 1 -R- y -E- Nil -R- RNil
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- True -E- [repl -R- n -R- True -R- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- (S -R- n) -R- True -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- False -E- [repl -R- n -R- False -R- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- (S -R- n) -R- False -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- True -E- [repl -R- n -R- False -R- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- 1 -R- True -E- (repl -R- n -R- False -R- zs) -R- (RCons -R- n -R- False -E- zs -R- rzs)
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- False -E- [repl -R- n -R- True -R- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- 1 -R- False -E- (repl -R- n -R- True -R- zs) -R- (RCons -R- n -R- True -E- zs -R- rzs)
          in aux -R- x -E- xs -R- (compress -R- xs)
    decompress :R: (xs :E: List) -> (_x6 :R: RLE -E- xs) -> List 
      decompress -E- [Nil] -R- RNil = Nil
      n :R: Nat x :R: Bool xs :E: List rxs :R: RLE -E- xs
        decompress -E- [repl -R- n -R- x -R- xs] -R- (RCons -R- n -R- x -E- xs -R- rxs) = repl -R- n -R- x -R- (decompress -E- xs -R- rxs)
    foldl :R: (_x7 :R: (_x8 :R: Bool) -> (_x9 :R: Bool) -> Bool) -> (_x10 :R: Bool) -> (_x11 :R: List) -> Bool 
      f :R: (_x12 :R: Bool) -> (_x13 :R: Bool) -> Bool z :R: Bool
        foldl -R- f -R- z -R- Nil = z
      f :R: (_x14 :R: Bool) -> (_x15 :R: Bool) -> Bool z :R: Bool x :R: Bool xs :R: List
        foldl -R- f -R- z -R- (Cons -R- x -R- xs) = foldl -R- f -R- (f -R- z -R- x) -R- xs
    xor :R: (_x16 :R: Bool) -> (_x17 :R: Bool) -> Bool 
      b :R: Bool
        xor -R- False -R- b = b
      xor -R- True -R- False = True
      xor -R- True -R- True = False
    xors :R: (_x18 :R: List) -> Bool = foldl -R- xor -R- False
    genInputList :R: (n :R: Nat) -> List = (\n :R: Nat. repl -R- n -R- True -R- Nil)
    main :R: Bool = 
      let
        foreign inputSize :R: Nat
        inputList :R: List = genInputList -R- inputSize
      in xors -R- (decompress -E- inputList -R- (compress -R- inputList))
  in main

### Specialised ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        snd -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: Type
    constructor Nil :R: List
    constructor Cons :R: (_x0 :R: Bool) -> (_x1 :R: List) -> List
    repl :R: (n :R: Nat) -> (x :R: Bool) -> (_x2 :R: List) -> List 
      x :R: Bool xs :R: List
        repl -R- Z -R- x -R- xs = xs
      n :R: Nat x :R: Bool xs :R: List
        repl -R- (S -R- n) -R- x -R- xs = Cons -R- x -R- (repl -R- n -R- x -R- xs)
    constructor RLE :E: (_x3 :E: List) -> Type
    constructor RNil :R: RLE -E- Nil
    constructor RCons :R: (n :R: Nat) -> (x :R: Bool) -> (xs :E: List) -> (_x4 :R: RLE -E- xs) -> RLE -E- (repl -R- n -R- x -R- xs)
    compress :R: (xs :R: List) -> RLE -E- xs 
      compress -R- Nil = RNil
      x :R: Bool xs :R: List
        compress -R- (Cons -R- x -R- xs) = 
          let aux :R: (y :R: Bool) -> (ys :E: List) -> (_x5 :R: RLE -E- ys) -> RLE -E- (Cons -R- y -R- ys) 
            y :R: Bool
              aux -R- y -E- [Nil] -R- RNil = RCons -R- 1 -R- y -E- Nil -R- RNil
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- True -E- [repl -R- n -R- True -R- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- (S -R- n) -R- True -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- False -E- [repl -R- n -R- False -R- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- (S -R- n) -R- False -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- True -E- [repl -R- n -R- False -R- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- 1 -R- True -E- (repl -R- n -R- False -R- zs) -R- (RCons -R- n -R- False -E- zs -R- rzs)
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- False -E- [repl -R- n -R- True -R- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- 1 -R- False -E- (repl -R- n -R- True -R- zs) -R- (RCons -R- n -R- True -E- zs -R- rzs)
          in aux -R- x -E- xs -R- (compress -R- xs)
    decompress :R: (xs :E: List) -> (_x6 :R: RLE -E- xs) -> List 
      decompress -E- [Nil] -R- RNil = Nil
      n :R: Nat x :R: Bool xs :E: List rxs :R: RLE -E- xs
        decompress -E- [repl -R- n -R- x -R- xs] -R- (RCons -R- n -R- x -E- xs -R- rxs) = repl -R- n -R- x -R- (decompress -E- xs -R- rxs)
    foldl :R: (_x7 :R: (_x8 :R: Bool) -> (_x9 :R: Bool) -> Bool) -> (_x10 :R: Bool) -> (_x11 :R: List) -> Bool 
      f :R: (_x12 :R: Bool) -> (_x13 :R: Bool) -> Bool z :R: Bool
        foldl -R- f -R- z -R- Nil = z
      f :R: (_x14 :R: Bool) -> (_x15 :R: Bool) -> Bool z :R: Bool x :R: Bool xs :R: List
        foldl -R- f -R- z -R- (Cons -R- x -R- xs) = foldl -R- f -R- (f -R- z -R- x) -R- xs
    xor :R: (_x16 :R: Bool) -> (_x17 :R: Bool) -> Bool 
      b :R: Bool
        xor -R- False -R- b = b
      xor -R- True -R- False = True
      xor -R- True -R- True = False
    xors :R: (_x18 :R: List) -> Bool = foldl -R- xor -R- False
    genInputList :R: (n :R: Nat) -> List = (\n :R: Nat. repl -R- n -R- True -R- Nil)
    main :R: Bool = 
      let
        foreign inputSize :R: Nat
        inputList :R: List = genInputList -R- inputSize
      in xors -R- (decompress -E- inputList -R- (compress -R- inputList))
  in main

### Final annotation ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        snd -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: Type
    constructor Nil :R: List
    constructor Cons :R: (_x0 :R: Bool) -> (_x1 :R: List) -> List
    repl :R: (n :R: Nat) -> (x :R: Bool) -> (_x2 :R: List) -> List 
      x :R: Bool xs :R: List
        repl -R- Z -R- x -R- xs = xs
      n :R: Nat x :R: Bool xs :R: List
        repl -R- (S -R- n) -R- x -R- xs = Cons -R- x -R- (repl -R- n -R- x -R- xs)
    constructor RLE :E: (_x3 :E: List) -> Type
    constructor RNil :R: RLE -E- Nil
    constructor RCons :R: (n :R: Nat) -> (x :R: Bool) -> (xs :E: List) -> (_x4 :R: RLE -E- xs) -> RLE -E- (repl -R- n -R- x -R- xs)
    compress :R: (xs :R: List) -> RLE -E- xs 
      compress -R- Nil = RNil
      x :R: Bool xs :R: List
        compress -R- (Cons -R- x -R- xs) = 
          let aux :R: (y :R: Bool) -> (ys :E: List) -> (_x5 :R: RLE -E- ys) -> RLE -E- (Cons -R- y -R- ys) 
            y :R: Bool
              aux -R- y -E- [Nil] -R- RNil = RCons -R- 1 -R- y -E- Nil -R- RNil
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- True -E- [repl -R- n -R- True -R- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- (S -R- n) -R- True -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- False -E- [repl -R- n -R- False -R- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- (S -R- n) -R- False -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- True -E- [repl -R- n -R- False -R- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- 1 -R- True -E- (repl -R- n -R- False -R- zs) -R- (RCons -R- n -R- False -E- zs -R- rzs)
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              aux -R- False -E- [repl -R- n -R- True -R- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- 1 -R- False -E- (repl -R- n -R- True -R- zs) -R- (RCons -R- n -R- True -E- zs -R- rzs)
          in aux -R- x -E- xs -R- (compress -R- xs)
    decompress :R: (xs :E: List) -> (_x6 :R: RLE -E- xs) -> List 
      decompress -E- [Nil] -R- RNil = Nil
      n :R: Nat x :R: Bool xs :E: List rxs :R: RLE -E- xs
        decompress -E- [repl -R- n -R- x -R- xs] -R- (RCons -R- n -R- x -E- xs -R- rxs) = repl -R- n -R- x -R- (decompress -E- xs -R- rxs)
    foldl :R: (_x7 :R: (_x8 :R: Bool) -> (_x9 :R: Bool) -> Bool) -> (_x10 :R: Bool) -> (_x11 :R: List) -> Bool 
      f :R: (_x12 :R: Bool) -> (_x13 :R: Bool) -> Bool z :R: Bool
        foldl -R- f -R- z -R- Nil = z
      f :R: (_x14 :R: Bool) -> (_x15 :R: Bool) -> Bool z :R: Bool x :R: Bool xs :R: List
        foldl -R- f -R- z -R- (Cons -R- x -R- xs) = foldl -R- f -R- (f -R- z -R- x) -R- xs
    xor :R: (_x16 :R: Bool) -> (_x17 :R: Bool) -> Bool 
      b :R: Bool
        xor -R- False -R- b = b
      xor -R- True -R- False = True
      xor -R- True -R- True = False
    xors :R: (_x18 :R: List) -> Bool = foldl -R- xor -R- False
    genInputList :R: (n :R: Nat) -> List = (\n :R: Nat. repl -R- n -R- True -R- Nil)
    main :R: Bool = 
      let
        foreign inputSize :R: Nat
        inputList :R: List = genInputList -R- inputSize
      in xors -R- (decompress -E- inputList -R- (compress -R- inputList))
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    constructor Nil : List
    constructor Cons : (_x0) -> (_x1) -> List
    repl 
      repl Z x xs = xs
      repl (S n) x xs = Cons x (repl n x xs)
    constructor RNil : RLE
    constructor RCons : (n) -> (x) -> (_x4) -> RLE
    compress 
      compress Nil = RNil
      compress (Cons x xs) = 
        let aux 
          aux y RNil = RCons 1 y RNil
          aux True (RCons n True rzs) = RCons (S n) True rzs
          aux False (RCons n False rzs) = RCons (S n) False rzs
          aux True (RCons n False rzs) = RCons 1 True (RCons n False rzs)
          aux False (RCons n True rzs) = RCons 1 False (RCons n True rzs)
        in aux x (compress xs)
    decompress 
      decompress RNil = Nil
      decompress (RCons n x rxs) = repl n x (decompress rxs)
    foldl 
      foldl f z Nil = z
      foldl f z (Cons x xs) = foldl f (f z x) xs
    xor 
      xor False b = b
      xor True False = True
      xor True True = False
    xors = foldl xor False
    genInputList = (\n. repl n True Nil)
    main = 
      let
        foreign inputSize
        inputList = genInputList inputSize
      in xors (decompress (compress inputList))
  in main

### Intermediate representation ###

let Z = constructor 0
  in let S = constructor 1
    in let True = constructor 0
      in let False = constructor 0
        in let Nil = constructor 0
          in let Cons = constructor 2
            in let repl = \_pv0. \_pv1. \_pv2.
              case _pv0 of
                S _pv3 => ((Cons _pv1) (((repl _pv3) _pv1) _pv2))
                Z => _pv2
              in let RNil = constructor 0
                in let RCons = constructor 3
                  in let compress = \_pv0.
                    case _pv0 of
                      Cons _pv1 _pv2 => let aux = \_pv3. \_pv4.
                        case _pv4 of
                          RNil => (((RCons (S Z)) _pv3) RNil)
                          _ => case _pv3 of
                            False => case _pv4 of
                              RCons _pv5 _pv6 _pv7 => case _pv6 of
                                False => (((RCons (S _pv5)) False) _pv7)
                                True => (((RCons (S Z)) False) (((RCons _pv5) True) _pv7))
                            True => case _pv4 of
                              RCons _pv5 _pv6 _pv7 => case _pv6 of
                                False => (((RCons (S Z)) True) (((RCons _pv5) False) _pv7))
                                True => (((RCons (S _pv5)) True) _pv7)
                        in ((aux _pv1) (compress _pv2))
                      Nil => RNil
                    in let decompress = \_pv0.
                      case _pv0 of
                        RCons _pv1 _pv2 _pv3 => (((repl _pv1) _pv2) (decompress _pv3))
                        RNil => Nil
                      in let foldl = \_pv0. \_pv1. \_pv2.
                        case _pv2 of
                          Cons _pv3 _pv4 => (((foldl _pv0) ((_pv0 _pv1) _pv3)) _pv4)
                          Nil => _pv1
                        in let xor = \_pv0. \_pv1.
                          case _pv0 of
                            False => _pv1
                            True => case _pv1 of
                              False => True
                              True => False
                          in let xors = ((foldl xor) False)
                            in let genInputList = \n. (((repl n) True) Nil)
                              in let main = let inputSize = foreign "(rts-arg-peano 'Z 'S 0)"
                                in let inputList = (genInputList inputSize)
                                  in (xors (decompress (compress inputList)))
                                in main

### Normal forms ###

unerased:
  
  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    constructor List : Type
    constructor Nil : List
    constructor Cons : (_x0 : Bool) -> (_x1 : List) -> List
    repl : (n : Nat) -> (x : Bool) -> (_x2 : List) -> List 
      x : Bool xs : List
        repl Z x xs = xs
      n : Nat x : Bool xs : List
        repl (S n) x xs = Cons x (repl n x xs)
    constructor RLE : (_x3 : List) -> Type
    constructor RNil : RLE Nil
    constructor RCons : (n : Nat) -> (x : Bool) -> (xs : List) -> (_x4 : RLE xs) -> RLE (repl n x xs)
    compress : (xs : List) -> RLE xs 
      compress Nil = RNil
      x : Bool xs : List
        compress (Cons x xs) = 
          let aux : (y : Bool) -> (ys : List) -> (_x5 : RLE ys) -> RLE (Cons y ys) 
            y : Bool
              aux y [Nil] RNil = RCons 1 y Nil RNil
            n : Nat zs : List rzs : RLE zs
              aux True [repl n True zs] (RCons n True zs rzs) = RCons (S n) True zs rzs
            n : Nat zs : List rzs : RLE zs
              aux False [repl n False zs] (RCons n False zs rzs) = RCons (S n) False zs rzs
            n : Nat zs : List rzs : RLE zs
              aux True [repl n False zs] (RCons n False zs rzs) = RCons 1 True (repl n False zs) (RCons n False zs rzs)
            n : Nat zs : List rzs : RLE zs
              aux False [repl n True zs] (RCons n True zs rzs) = RCons 1 False (repl n True zs) (RCons n True zs rzs)
          in aux x xs (compress xs)
    decompress : (xs : List) -> (_x6 : RLE xs) -> List 
      decompress [Nil] RNil = Nil
      n : Nat x : Bool xs : List rxs : RLE xs
        decompress [repl n x xs] (RCons n x xs rxs) = repl n x (decompress xs rxs)
    foldl : (_x7 : (_x8 : Bool) -> (_x9 : Bool) -> Bool) -> (_x10 : Bool) -> (_x11 : List) -> Bool 
      f : (_x12 : Bool) -> (_x13 : Bool) -> Bool z : Bool
        foldl f z Nil = z
      f : (_x14 : Bool) -> (_x15 : Bool) -> Bool z : Bool x : Bool xs : List
        foldl f z (Cons x xs) = foldl f (f z x) xs
    xor : (_x16 : Bool) -> (_x17 : Bool) -> Bool 
      b : Bool
        xor False b = b
      xor True False = True
      xor True True = False
  in 
    let foreign inputSize : Nat
    in foldl xor False (decompress (repl inputSize True Nil) (compress (repl inputSize True Nil)))

erased:
  
  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    constructor Nil : List
    constructor Cons : (_x0) -> (_x1) -> List
    repl 
      repl Z x xs = xs
      repl (S n) x xs = Cons x (repl n x xs)
    constructor RNil : RLE
    constructor RCons : (n) -> (x) -> (_x4) -> RLE
    compress 
      compress Nil = RNil
      compress (Cons x xs) = 
        let aux 
          aux y RNil = RCons 1 y RNil
          aux True (RCons n True rzs) = RCons (S n) True rzs
          aux False (RCons n False rzs) = RCons (S n) False rzs
          aux True (RCons n False rzs) = RCons 1 True (RCons n False rzs)
          aux False (RCons n True rzs) = RCons 1 False (RCons n True rzs)
        in aux x (compress xs)
    decompress 
      decompress RNil = Nil
      decompress (RCons n x rxs) = repl n x (decompress rxs)
    foldl 
      foldl f z Nil = z
      foldl f z (Cons x xs) = foldl f (f z x) xs
    xor 
      xor False b = b
      xor True False = True
      xor True True = False
  in 
    let foreign inputSize
    in foldl xor False (decompress (compress (repl inputSize True Nil)))

