-- vim: ft=ttstar

### Desugared ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x2 : Bool) -> Bool 
      [not] True = False
      [not] False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x3 : Type) -> (_x4 : Type) -> Type
    constructor MkPair : (a : Type) -> (b : Type) -> (_x5 : a) -> (_x6 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x7 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        [fst] a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x8 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        [snd] a b ([MkPair] [a] [b] x y) = y
    constructor Either : (_x9 : Type) -> (_x10 : Type) -> Type
    constructor Left : (a : Type) -> (b : Type) -> (_x11 : a) -> Either a b
    constructor Right : (a : Type) -> (b : Type) -> (_x12 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x13 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x14 : Fin n) -> Fin (S n)
    constructor Vect : (_x15 : Nat) -> (_x16 : Type) -> Type
    constructor VN : (a : Type) -> Vect Z a
    constructor VC : (n : Nat) -> (a : Type) -> (x : a) -> (xs : Vect n a) -> Vect (S n) a
    constructor List : Type
    constructor Nil : List
    constructor Cons : (_x0 : Bool) -> (_x1 : List) -> List
    repl : (n : Nat) -> (x : Bool) -> (_x2 : List) -> List 
      x : Bool xs : List
        [repl] Z x xs = xs
      n : Nat x : Bool xs : List
        [repl] (S n) x xs = Cons x (repl n x xs)
    constructor RLE : (_x3 : List) -> Type
    constructor RNil : RLE Nil
    constructor RCons : (n : Nat) -> (x : Bool) -> (xs : List) -> (_x4 : RLE xs) -> RLE (repl n x xs)
    compress : (xs : List) -> RLE xs 
      [compress] Nil = RNil
      x : Bool xs : List
        [compress] (Cons x xs) = 
          let aux : (y : Bool) -> (ys : List) -> (_x5 : RLE ys) -> RLE (Cons y ys) 
            y : Bool
              [aux] y [Nil] RNil = RCons 1 y Nil RNil
            n : Nat zs : List rzs : RLE zs
              [aux] True [repl n True zs] (RCons n True zs rzs) = RCons (S n) True zs rzs
            n : Nat zs : List rzs : RLE zs
              [aux] False [repl n False zs] (RCons n False zs rzs) = RCons (S n) False zs rzs
            n : Nat zs : List rzs : RLE zs
              [aux] True [repl n False zs] (RCons n False zs rzs) = RCons 1 True (repl n False zs) (RCons n False zs rzs)
            n : Nat zs : List rzs : RLE zs
              [aux] False [repl n True zs] (RCons n True zs rzs) = RCons 1 False (repl n True zs) (RCons n True zs rzs)
          in aux x xs (compress xs)
    decompress : (xs : List) -> (_x6 : RLE xs) -> List 
      [decompress] [Nil] RNil = Nil
      n : Nat x : Bool xs : List rxs : RLE xs
        [decompress] [repl n x xs] (RCons n x xs rxs) = repl n x (decompress xs rxs)
    foldl : (_x7 : (_x8 : Bool) -> (_x9 : Bool) -> Bool) -> (_x10 : Bool) -> (_x11 : List) -> Bool 
      f : (_x12 : Bool) -> (_x13 : Bool) -> Bool z : Bool
        [foldl] f z Nil = z
      f : (_x14 : Bool) -> (_x15 : Bool) -> Bool z : Bool x : Bool xs : List
        [foldl] f z (Cons x xs) = foldl f (f z x) xs
    xor : (_x16 : Bool) -> (_x17 : Bool) -> Bool 
      b : Bool
        [xor] False b = b
      [xor] True False = True
      [xor] True True = False
    xors : (_x18 : List) -> Bool = foldl xor False
    genInputList : (n : Nat) -> List = (\n : Nat. repl n True Nil)
    main : Bool = 
      let
        foreign inputSize : Nat
        inputList : List = genInputList inputSize
      in xors (decompress inputList (compress inputList))
  in main

### Evarified ###

  let
    constructor Nat :1: Type
    constructor Z :2: Nat
    constructor S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        [plus] -9- Z -8- n = n
      m :10: Nat n :11: Nat
        [plus] -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    constructor Bool :18: Type
    constructor True :19: Bool
    constructor False :20: Bool
    not :21: (_x2 :22: Bool) -> Bool 
      [not] -23- True = False
      [not] -24- False = True
    constructor Unit :25: Type
    constructor MkUnit :26: Unit
    constructor Pair :27: (_x3 :28: Type) -> (_x4 :29: Type) -> Type
    constructor MkPair :30: (a :31: Type) -> (b :32: Type) -> (_x5 :33: a) -> (_x6 :34: b) -> Pair -36- a -35- b
    fst :37: (a :38: Type) -> (b :39: Type) -> (_x7 :40: Pair -42- a -41- b) -> a 
      a :43: Type b :44: Type x :45: a y :46: b
        [fst] -49- a -48- b -47- ([MkPair] -53- [a] -52- [b] -51- x -50- y) = x
    snd :54: (a :55: Type) -> (b :56: Type) -> (_x8 :57: Pair -59- a -58- b) -> b 
      a :60: Type b :61: Type x :62: a y :63: b
        [snd] -66- a -65- b -64- ([MkPair] -70- [a] -69- [b] -68- x -67- y) = y
    constructor Either :71: (_x9 :72: Type) -> (_x10 :73: Type) -> Type
    constructor Left :74: (a :75: Type) -> (b :76: Type) -> (_x11 :77: a) -> Either -79- a -78- b
    constructor Right :80: (a :81: Type) -> (b :82: Type) -> (_x12 :83: b) -> Either -85- a -84- b
    id :86: (a :87: Type) -> (x :88: a) -> a = (\a :89: Type. (\x :90: a. x))
    constructor Fin :91: (_x13 :92: Nat) -> Type
    constructor FZ :93: (n :94: Nat) -> Fin -95- (S -96- n)
    constructor FS :97: (n :98: Nat) -> (_x14 :99: Fin -100- n) -> Fin -101- (S -102- n)
    constructor Vect :103: (_x15 :104: Nat) -> (_x16 :105: Type) -> Type
    constructor VN :106: (a :107: Type) -> Vect -109- Z -108- a
    constructor VC :110: (n :111: Nat) -> (a :112: Type) -> (x :113: a) -> (xs :114: Vect -116- n -115- a) -> Vect -118- (S -119- n) -117- a
    constructor List :120: Type
    constructor Nil :121: List
    constructor Cons :122: (_x0 :123: Bool) -> (_x1 :124: List) -> List
    repl :125: (n :126: Nat) -> (x :127: Bool) -> (_x2 :128: List) -> List 
      x :129: Bool xs :130: List
        [repl] -133- Z -132- x -131- xs = xs
      n :134: Nat x :135: Bool xs :136: List
        [repl] -139- (S -140- n) -138- x -137- xs = Cons -142- x -141- (repl -145- n -144- x -143- xs)
    constructor RLE :146: (_x3 :147: List) -> Type
    constructor RNil :148: RLE -149- Nil
    constructor RCons :150: (n :151: Nat) -> (x :152: Bool) -> (xs :153: List) -> (_x4 :154: RLE -155- xs) -> RLE -156- (repl -159- n -158- x -157- xs)
    compress :160: (xs :161: List) -> RLE -162- xs 
      [compress] -163- Nil = RNil
      x :164: Bool xs :165: List
        [compress] -166- (Cons -168- x -167- xs) = 
          let aux :169: (y :170: Bool) -> (ys :171: List) -> (_x5 :172: RLE -173- ys) -> RLE -174- (Cons -176- y -175- ys) 
            y :177: Bool
              [aux] -180- y -179- [Nil] -178- RNil = RCons -184- 1 -183- y -182- Nil -181- RNil
            n :186: Nat zs :187: List rzs :188: RLE -189- zs
              [aux] -192- True -191- [repl -195- n -194- True -193- zs] -190- (RCons -199- n -198- True -197- zs -196- rzs) = RCons -203- (S -204- n) -202- True -201- zs -200- rzs
            n :205: Nat zs :206: List rzs :207: RLE -208- zs
              [aux] -211- False -210- [repl -214- n -213- False -212- zs] -209- (RCons -218- n -217- False -216- zs -215- rzs) = RCons -222- (S -223- n) -221- False -220- zs -219- rzs
            n :224: Nat zs :225: List rzs :226: RLE -227- zs
              [aux] -230- True -229- [repl -233- n -232- False -231- zs] -228- (RCons -237- n -236- False -235- zs -234- rzs) = RCons -241- 1 -240- True -239- (repl -245- n -244- False -243- zs) -238- (RCons -249- n -248- False -247- zs -246- rzs)
            n :250: Nat zs :251: List rzs :252: RLE -253- zs
              [aux] -256- False -255- [repl -259- n -258- True -257- zs] -254- (RCons -263- n -262- True -261- zs -260- rzs) = RCons -267- 1 -266- False -265- (repl -271- n -270- True -269- zs) -264- (RCons -275- n -274- True -273- zs -272- rzs)
          in aux -278- x -277- xs -276- (compress -279- xs)
    decompress :280: (xs :281: List) -> (_x6 :282: RLE -283- xs) -> List 
      [decompress] -285- [Nil] -284- RNil = Nil
      n :286: Nat x :287: Bool xs :288: List rxs :289: RLE -290- xs
        [decompress] -292- [repl -295- n -294- x -293- xs] -291- (RCons -299- n -298- x -297- xs -296- rxs) = repl -302- n -301- x -300- (decompress -304- xs -303- rxs)
    foldl :305: (_x7 :306: (_x8 :307: Bool) -> (_x9 :308: Bool) -> Bool) -> (_x10 :309: Bool) -> (_x11 :310: List) -> Bool 
      f :311: (_x12 :312: Bool) -> (_x13 :313: Bool) -> Bool z :314: Bool
        [foldl] -317- f -316- z -315- Nil = z
      f :318: (_x14 :319: Bool) -> (_x15 :320: Bool) -> Bool z :321: Bool x :322: Bool xs :323: List
        [foldl] -326- f -325- z -324- (Cons -328- x -327- xs) = foldl -331- f -330- (f -333- z -332- x) -329- xs
    xor :334: (_x16 :335: Bool) -> (_x17 :336: Bool) -> Bool 
      b :337: Bool
        [xor] -339- False -338- b = b
      [xor] -341- True -340- False = True
      [xor] -343- True -342- True = False
    xors :344: (_x18 :345: List) -> Bool = foldl -347- xor -346- False
    genInputList :348: (n :349: Nat) -> List = (\n :350: Nat. repl -353- n -352- True -351- Nil)
    main :354: Bool = 
      let
        foreign inputSize :355: Nat
        inputList :356: List = genInputList -357- inputSize
      in xors -358- (decompress -360- inputList -359- (compress -361- inputList))
  in main

### Constraints ###

[] -> [2,3,19,20,121,122,123,124,125,126,127,128,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,148,150,151,152,154,160,161,163,164,165,166,167,168,169,170,172,177,178,180,181,183,184,185,186,188,190,192,196,198,199,200,202,203,204,205,207,209,211,215,217,218,219,221,222,223,224,226,228,230,234,236,237,238,240,241,242,246,248,249,250,252,254,256,260,262,263,264,266,267,268,272,274,275,276,278,279,280,282,284,286,287,289,291,296,298,299,300,301,302,303,305,306,307,308,309,310,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,355,356,357,358,359,361,R]
[129] -> [132]
[129,191] -> [132]
[129,210] -> [132]
[129,229] -> [132]
[129,239] -> [132]
[129,255] -> [132]
[129,265] -> [132]
[129,292] -> [132]
[129,360] -> [132]
[149] -> [155,162,173,283]
[153] -> [182,197,201,216,220,235,239,247,261,265,273,297]
[155] -> [149,156,189,208,227,253,290]
[156] -> [155,173,174,283]
[156,157] -> [193,212,231,243,257,269,293]
[156,158] -> [194,213,232,244,258,270,294]
[156,159] -> [195,214,233,245,259,271,295]
[156,193] -> [157]
[156,194] -> [158]
[156,195] -> [159]
[156,212] -> [157]
[156,213] -> [158]
[156,214] -> [159]
[156,231] -> [157]
[156,232] -> [158]
[156,233] -> [159]
[156,243] -> [157]
[156,244] -> [158]
[156,245] -> [159]
[156,257] -> [157]
[156,258] -> [158]
[156,259] -> [159]
[156,269] -> [157]
[156,270] -> [158]
[156,271] -> [159]
[156,293] -> [157]
[156,294] -> [158]
[156,295] -> [159]
[162] -> [149,173,174,175,176,283,351,352,353]
[162,175] -> [167]
[162,176] -> [168]
[171] -> [179,191,210,229,255,277]
[173] -> [149,156,162]
[174] -> [156,162,175,176]
[174,175] -> [141,193,194,195,212,213,214]
[174,175,193] -> [143]
[174,175,194] -> [144]
[174,175,195] -> [145]
[174,175,212] -> [143]
[174,175,213] -> [144]
[174,175,214] -> [145]
[174,175,231] -> [243]
[174,175,232] -> [244]
[174,175,233] -> [245]
[174,175,243] -> [231]
[174,175,244] -> [232]
[174,175,245] -> [233]
[174,175,257] -> [269]
[174,175,258] -> [270]
[174,175,259] -> [271]
[174,175,269] -> [257]
[174,175,270] -> [258]
[174,175,271] -> [259]
[174,176] -> [142]
[179] -> [121,171,R]
[182] -> [121,153]
[187] -> [197]
[189] -> [155]
[191] -> [2,3,122,123,124,125,126,127,128,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,171,193,194,195,R]
[191,193] -> [128,187]
[191,194] -> [19,127]
[191,195] -> [126,186]
[197] -> [153,190]
[201] -> [153,187]
[206] -> [216]
[208] -> [155]
[210] -> [2,3,122,123,124,125,126,127,128,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,171,212,213,214,R]
[210,212] -> [128,206]
[210,213] -> [20,127]
[210,214] -> [126,205]
[216] -> [153,209]
[220] -> [153,206]
[225] -> [235]
[227] -> [155]
[229] -> [2,3,122,123,124,125,126,127,128,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,171,231,232,233,R]
[229,231] -> [128,225]
[229,232] -> [20,127]
[229,233] -> [126,224]
[235] -> [153,228]
[239] -> [2,3,122,123,124,125,126,127,128,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,153,243,244,245,R]
[239,243] -> [128,225]
[239,244] -> [20,127]
[239,245] -> [126,224]
[247] -> [153,225]
[251] -> [261]
[253] -> [155]
[255] -> [2,3,122,123,124,125,126,127,128,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,171,257,258,259,R]
[255,257] -> [128,251]
[255,258] -> [19,127]
[255,259] -> [126,250]
[261] -> [153,254]
[265] -> [2,3,122,123,124,125,126,127,128,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,153,269,270,271,R]
[265,269] -> [128,251]
[265,270] -> [19,127]
[265,271] -> [126,250]
[273] -> [153,251]
[277] -> [165,171]
[281] -> [285,292,304,360]
[283] -> [149,156,162,290]
[285] -> [121,281,R]
[288] -> [297]
[290] -> [155,283]
[292] -> [2,3,122,123,124,125,126,127,128,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,281,293,294,295,R]
[292,293] -> [128,288]
[292,294] -> [127,287]
[292,295] -> [126,286]
[297] -> [153,291]
[304] -> [281,288]
[311] -> [317]
[360] -> [2,3,19,121,122,123,124,125,126,127,128,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,281,348,349,350,351,352,353,355,356,357,R]
[R] -> [354]

### Solution ###

[2,3,19,20,121,122,123,124,125,126,127,128,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,148,150,151,152,154,160,161,163,164,165,166,167,168,169,170,172,177,178,180,181,183,184,185,186,188,190,192,196,198,199,200,202,203,204,205,207,209,211,215,217,218,219,221,222,223,224,226,228,230,234,236,237,238,240,241,242,246,248,249,250,252,254,256,260,262,263,264,266,267,268,272,274,275,276,278,279,280,282,284,286,287,289,291,296,298,299,300,301,302,303,305,306,307,308,309,310,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,361,R]

### Annotated ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x13 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x14 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x15 :E: Nat) -> (_x16 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor List :E: Type
    constructor Nil :R: List
    constructor Cons :R: (_x0 :R: Bool) -> (_x1 :R: List) -> List
    repl :R: (n :R: Nat) -> (x :R: Bool) -> (_x2 :R: List) -> List 
      x :E: Bool xs :R: List
        [repl] -R- Z -R- x -R- xs = xs
      n :R: Nat x :R: Bool xs :R: List
        [repl] -R- (S -R- n) -R- x -R- xs = Cons -R- x -R- (repl -R- n -R- x -R- xs)
    constructor RLE :E: (_x3 :E: List) -> Type
    constructor RNil :R: RLE -E- Nil
    constructor RCons :R: (n :R: Nat) -> (x :R: Bool) -> (xs :E: List) -> (_x4 :R: RLE -E- xs) -> RLE -E- (repl -E- n -E- x -E- xs)
    compress :R: (xs :R: List) -> RLE -E- xs 
      [compress] -R- Nil = RNil
      x :R: Bool xs :R: List
        [compress] -R- (Cons -R- x -R- xs) = 
          let aux :R: (y :R: Bool) -> (ys :E: List) -> (_x5 :R: RLE -E- ys) -> RLE -E- (Cons -E- y -E- ys) 
            y :R: Bool
              [aux] -R- y -E- [Nil] -R- RNil = RCons -R- 1 -R- y -E- Nil -R- RNil
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- True -E- [repl -E- n -E- True -E- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- (S -R- n) -R- True -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- False -E- [repl -E- n -E- False -E- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- (S -R- n) -R- False -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- True -E- [repl -E- n -E- False -E- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- 1 -R- True -E- (repl -E- n -E- False -E- zs) -R- (RCons -R- n -R- False -E- zs -R- rzs)
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- False -E- [repl -E- n -E- True -E- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- 1 -R- False -E- (repl -E- n -E- True -E- zs) -R- (RCons -R- n -R- True -E- zs -R- rzs)
          in aux -R- x -E- xs -R- (compress -R- xs)
    decompress :R: (xs :E: List) -> (_x6 :R: RLE -E- xs) -> List 
      [decompress] -E- [Nil] -R- RNil = Nil
      n :R: Nat x :R: Bool xs :E: List rxs :R: RLE -E- xs
        [decompress] -E- [repl -E- n -E- x -E- xs] -R- (RCons -R- n -R- x -E- xs -R- rxs) = repl -R- n -R- x -R- (decompress -E- xs -R- rxs)
    foldl :R: (_x7 :R: (_x8 :R: Bool) -> (_x9 :R: Bool) -> Bool) -> (_x10 :R: Bool) -> (_x11 :R: List) -> Bool 
      f :E: (_x12 :R: Bool) -> (_x13 :R: Bool) -> Bool z :R: Bool
        [foldl] -R- f -R- z -R- Nil = z
      f :R: (_x14 :R: Bool) -> (_x15 :R: Bool) -> Bool z :R: Bool x :R: Bool xs :R: List
        [foldl] -R- f -R- z -R- (Cons -R- x -R- xs) = foldl -R- f -R- (f -R- z -R- x) -R- xs
    xor :R: (_x16 :R: Bool) -> (_x17 :R: Bool) -> Bool 
      b :R: Bool
        [xor] -R- False -R- b = b
      [xor] -R- True -R- False = True
      [xor] -R- True -R- True = False
    xors :R: (_x18 :R: List) -> Bool = foldl -R- xor -R- False
    genInputList :R: (n :R: Nat) -> List = (\n :R: Nat. repl -R- n -R- True -R- Nil)
    main :R: Bool = 
      let
        foreign inputSize :R: Nat
        inputList :R: List = genInputList -R- inputSize
      in xors -R- (decompress -E- inputList -R- (compress -R- inputList))
  in main

### Specialised ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x13 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x14 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x15 :E: Nat) -> (_x16 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor List :E: Type
    constructor Nil :R: List
    constructor Cons :R: (_x0 :R: Bool) -> (_x1 :R: List) -> List
    repl :R: (n :R: Nat) -> (x :R: Bool) -> (_x2 :R: List) -> List 
      x :E: Bool xs :R: List
        [repl] -R- Z -R- x -R- xs = xs
      n :R: Nat x :R: Bool xs :R: List
        [repl] -R- (S -R- n) -R- x -R- xs = Cons -R- x -R- (repl -R- n -R- x -R- xs)
    constructor RLE :E: (_x3 :E: List) -> Type
    constructor RNil :R: RLE -E- Nil
    constructor RCons :R: (n :R: Nat) -> (x :R: Bool) -> (xs :E: List) -> (_x4 :R: RLE -E- xs) -> RLE -E- (repl -E- n -E- x -E- xs)
    compress :R: (xs :R: List) -> RLE -E- xs 
      [compress] -R- Nil = RNil
      x :R: Bool xs :R: List
        [compress] -R- (Cons -R- x -R- xs) = 
          let aux :R: (y :R: Bool) -> (ys :E: List) -> (_x5 :R: RLE -E- ys) -> RLE -E- (Cons -E- y -E- ys) 
            y :R: Bool
              [aux] -R- y -E- [Nil] -R- RNil = RCons -R- 1 -R- y -E- Nil -R- RNil
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- True -E- [repl -E- n -E- True -E- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- (S -R- n) -R- True -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- False -E- [repl -E- n -E- False -E- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- (S -R- n) -R- False -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- True -E- [repl -E- n -E- False -E- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- 1 -R- True -E- (repl -E- n -E- False -E- zs) -R- (RCons -R- n -R- False -E- zs -R- rzs)
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- False -E- [repl -E- n -E- True -E- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- 1 -R- False -E- (repl -E- n -E- True -E- zs) -R- (RCons -R- n -R- True -E- zs -R- rzs)
          in aux -R- x -E- xs -R- (compress -R- xs)
    decompress :R: (xs :E: List) -> (_x6 :R: RLE -E- xs) -> List 
      [decompress] -E- [Nil] -R- RNil = Nil
      n :R: Nat x :R: Bool xs :E: List rxs :R: RLE -E- xs
        [decompress] -E- [repl -E- n -E- x -E- xs] -R- (RCons -R- n -R- x -E- xs -R- rxs) = repl -R- n -R- x -R- (decompress -E- xs -R- rxs)
    foldl :R: (_x7 :R: (_x8 :R: Bool) -> (_x9 :R: Bool) -> Bool) -> (_x10 :R: Bool) -> (_x11 :R: List) -> Bool 
      f :E: (_x12 :R: Bool) -> (_x13 :R: Bool) -> Bool z :R: Bool
        [foldl] -R- f -R- z -R- Nil = z
      f :R: (_x14 :R: Bool) -> (_x15 :R: Bool) -> Bool z :R: Bool x :R: Bool xs :R: List
        [foldl] -R- f -R- z -R- (Cons -R- x -R- xs) = foldl -R- f -R- (f -R- z -R- x) -R- xs
    xor :R: (_x16 :R: Bool) -> (_x17 :R: Bool) -> Bool 
      b :R: Bool
        [xor] -R- False -R- b = b
      [xor] -R- True -R- False = True
      [xor] -R- True -R- True = False
    xors :R: (_x18 :R: List) -> Bool = foldl -R- xor -R- False
    genInputList :R: (n :R: Nat) -> List = (\n :R: Nat. repl -R- n -R- True -R- Nil)
    main :R: Bool = 
      let
        foreign inputSize :R: Nat
        inputList :R: List = genInputList -R- inputSize
      in xors -R- (decompress -E- inputList -R- (compress -R- inputList))
  in main

### Final annotation ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x13 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x14 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x15 :E: Nat) -> (_x16 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor List :E: Type
    constructor Nil :R: List
    constructor Cons :R: (_x0 :R: Bool) -> (_x1 :R: List) -> List
    repl :R: (n :R: Nat) -> (x :R: Bool) -> (_x2 :R: List) -> List 
      x :E: Bool xs :R: List
        [repl] -R- Z -R- x -R- xs = xs
      n :R: Nat x :R: Bool xs :R: List
        [repl] -R- (S -R- n) -R- x -R- xs = Cons -R- x -R- (repl -R- n -R- x -R- xs)
    constructor RLE :E: (_x3 :E: List) -> Type
    constructor RNil :R: RLE -E- Nil
    constructor RCons :R: (n :R: Nat) -> (x :R: Bool) -> (xs :E: List) -> (_x4 :R: RLE -E- xs) -> RLE -E- (repl -E- n -E- x -E- xs)
    compress :R: (xs :R: List) -> RLE -E- xs 
      [compress] -R- Nil = RNil
      x :R: Bool xs :R: List
        [compress] -R- (Cons -R- x -R- xs) = 
          let aux :R: (y :R: Bool) -> (ys :E: List) -> (_x5 :R: RLE -E- ys) -> RLE -E- (Cons -E- y -E- ys) 
            y :R: Bool
              [aux] -R- y -E- [Nil] -R- RNil = RCons -R- 1 -R- y -E- Nil -R- RNil
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- True -E- [repl -E- n -E- True -E- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- (S -R- n) -R- True -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- False -E- [repl -E- n -E- False -E- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- (S -R- n) -R- False -E- zs -R- rzs
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- True -E- [repl -E- n -E- False -E- zs] -R- (RCons -R- n -R- False -E- zs -R- rzs) = RCons -R- 1 -R- True -E- (repl -E- n -E- False -E- zs) -R- (RCons -R- n -R- False -E- zs -R- rzs)
            n :R: Nat zs :E: List rzs :R: RLE -E- zs
              [aux] -R- False -E- [repl -E- n -E- True -E- zs] -R- (RCons -R- n -R- True -E- zs -R- rzs) = RCons -R- 1 -R- False -E- (repl -E- n -E- True -E- zs) -R- (RCons -R- n -R- True -E- zs -R- rzs)
          in aux -R- x -E- xs -R- (compress -R- xs)
    decompress :R: (xs :E: List) -> (_x6 :R: RLE -E- xs) -> List 
      [decompress] -E- [Nil] -R- RNil = Nil
      n :R: Nat x :R: Bool xs :E: List rxs :R: RLE -E- xs
        [decompress] -E- [repl -E- n -E- x -E- xs] -R- (RCons -R- n -R- x -E- xs -R- rxs) = repl -R- n -R- x -R- (decompress -E- xs -R- rxs)
    foldl :R: (_x7 :R: (_x8 :R: Bool) -> (_x9 :R: Bool) -> Bool) -> (_x10 :R: Bool) -> (_x11 :R: List) -> Bool 
      f :E: (_x12 :R: Bool) -> (_x13 :R: Bool) -> Bool z :R: Bool
        [foldl] -R- f -R- z -R- Nil = z
      f :R: (_x14 :R: Bool) -> (_x15 :R: Bool) -> Bool z :R: Bool x :R: Bool xs :R: List
        [foldl] -R- f -R- z -R- (Cons -R- x -R- xs) = foldl -R- f -R- (f -R- z -R- x) -R- xs
    xor :R: (_x16 :R: Bool) -> (_x17 :R: Bool) -> Bool 
      b :R: Bool
        [xor] -R- False -R- b = b
      [xor] -R- True -R- False = True
      [xor] -R- True -R- True = False
    xors :R: (_x18 :R: List) -> Bool = foldl -R- xor -R- False
    genInputList :R: (n :R: Nat) -> List = (\n :R: Nat. repl -R- n -R- True -R- Nil)
    main :R: Bool = 
      let
        foreign inputSize :R: Nat
        inputList :R: List = genInputList -R- inputSize
      in xors -R- (decompress -E- inputList -R- (compress -R- inputList))
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    constructor Nil : List
    constructor Cons : (_x0) -> (_x1) -> List
    repl 
      [_] Z _ xs = xs
      [_] (S n) x xs = Cons x (repl n x xs)
    constructor RNil : RLE
    constructor RCons : (n) -> (x) -> (_x4) -> RLE
    compress 
      [_] Nil = RNil
      [_] (Cons x xs) = 
        let aux 
          [_] y RNil = RCons 1 y RNil
          [_] True (RCons n True rzs) = RCons (S n) True rzs
          [_] False (RCons n False rzs) = RCons (S n) False rzs
          [_] True (RCons n False rzs) = RCons 1 True (RCons n False rzs)
          [_] False (RCons n True rzs) = RCons 1 False (RCons n True rzs)
        in aux x (compress xs)
    decompress 
      [_] RNil = Nil
      [_] (RCons n x rxs) = repl n x (decompress rxs)
    foldl 
      [_] _ z Nil = z
      [_] f z (Cons x xs) = foldl f (f z x) xs
    xor 
      [_] False b = b
      [_] True False = True
      [_] True True = False
    xors = foldl xor False
    genInputList = (\n. repl n True Nil)
    main = 
      let
        foreign inputSize
        inputList = genInputList inputSize
      in xors (decompress (compress inputList))
  in main

### Intermediate representation ###

let Z = constructor 0
  in let S = constructor 1
    in let True = constructor 0
      in let False = constructor 0
        in let Nil = constructor 0
          in let Cons = constructor 2
            in let repl = \_pv0. \_pv1. \_pv2.
              case _pv0 of
                S _pv3 => ((Cons _pv1) (((repl _pv3) _pv1) _pv2))
                Z => _pv2
              in let RNil = constructor 0
                in let RCons = constructor 3
                  in let compress = \_pv0.
                    case _pv0 of
                      Cons _pv1 _pv2 => let aux = \_pv3. \_pv4.
                        case _pv4 of
                          RNil => (((RCons (S Z)) _pv3) RNil)
                          _ => case _pv3 of
                            False => case _pv4 of
                              RCons _pv5 _pv6 _pv7 => case _pv6 of
                                False => (((RCons (S _pv5)) False) _pv7)
                                True => (((RCons (S Z)) False) (((RCons _pv5) True) _pv7))
                            True => case _pv4 of
                              RCons _pv5 _pv6 _pv7 => case _pv6 of
                                False => (((RCons (S Z)) True) (((RCons _pv5) False) _pv7))
                                True => (((RCons (S _pv5)) True) _pv7)
                        in ((aux _pv1) (compress _pv2))
                      Nil => RNil
                    in let decompress = \_pv0.
                      case _pv0 of
                        RCons _pv1 _pv2 _pv3 => (((repl _pv1) _pv2) (decompress _pv3))
                        RNil => Nil
                      in let foldl = \_pv0. \_pv1. \_pv2.
                        case _pv2 of
                          Cons _pv3 _pv4 => (((foldl _pv0) ((_pv0 _pv1) _pv3)) _pv4)
                          Nil => _pv1
                        in let xor = \_pv0. \_pv1.
                          case _pv0 of
                            False => _pv1
                            True => case _pv1 of
                              False => True
                              True => False
                          in let xors = ((foldl xor) False)
                            in let genInputList = \n. (((repl n) True) Nil)
                              in let main = let inputSize = foreign "(rts-arg-peano 'Z 'S 0)"
                                in let inputList = (genInputList inputSize)
                                  in (xors (decompress (compress inputList)))
                                in main

### Normal forms ###

unerased:
  
  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    constructor List : Type
    constructor Nil : List
    constructor Cons : (_x0 : Bool) -> (_x1 : List) -> List
    repl : (n : Nat) -> (x : Bool) -> (_x2 : List) -> List 
      x : Bool xs : List
        [repl] Z x xs = xs
      n : Nat x : Bool xs : List
        [repl] (S n) x xs = Cons x (repl n x xs)
    constructor RLE : (_x3 : List) -> Type
    constructor RNil : RLE Nil
    constructor RCons : (n : Nat) -> (x : Bool) -> (xs : List) -> (_x4 : RLE xs) -> RLE (repl n x xs)
    compress : (xs : List) -> RLE xs 
      [compress] Nil = RNil
      x : Bool xs : List
        [compress] (Cons x xs) = 
          let aux : (y : Bool) -> (ys : List) -> (_x5 : RLE ys) -> RLE (Cons y ys) 
            y : Bool
              [aux] y [Nil] RNil = RCons 1 y Nil RNil
            n : Nat zs : List rzs : RLE zs
              [aux] True [repl n True zs] (RCons n True zs rzs) = RCons (S n) True zs rzs
            n : Nat zs : List rzs : RLE zs
              [aux] False [repl n False zs] (RCons n False zs rzs) = RCons (S n) False zs rzs
            n : Nat zs : List rzs : RLE zs
              [aux] True [repl n False zs] (RCons n False zs rzs) = RCons 1 True (repl n False zs) (RCons n False zs rzs)
            n : Nat zs : List rzs : RLE zs
              [aux] False [repl n True zs] (RCons n True zs rzs) = RCons 1 False (repl n True zs) (RCons n True zs rzs)
          in aux x xs (compress xs)
    decompress : (xs : List) -> (_x6 : RLE xs) -> List 
      [decompress] [Nil] RNil = Nil
      n : Nat x : Bool xs : List rxs : RLE xs
        [decompress] [repl n x xs] (RCons n x xs rxs) = repl n x (decompress xs rxs)
    foldl : (_x7 : (_x8 : Bool) -> (_x9 : Bool) -> Bool) -> (_x10 : Bool) -> (_x11 : List) -> Bool 
      f : (_x12 : Bool) -> (_x13 : Bool) -> Bool z : Bool
        [foldl] f z Nil = z
      f : (_x14 : Bool) -> (_x15 : Bool) -> Bool z : Bool x : Bool xs : List
        [foldl] f z (Cons x xs) = foldl f (f z x) xs
    xor : (_x16 : Bool) -> (_x17 : Bool) -> Bool 
      b : Bool
        [xor] False b = b
      [xor] True False = True
      [xor] True True = False
  in 
    let foreign inputSize : Nat
    in foldl xor False (decompress (repl inputSize True Nil) (compress (repl inputSize True Nil)))

erased:
  
  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    constructor Nil : List
    constructor Cons : (_x0) -> (_x1) -> List
    repl 
      [_] Z _ xs = xs
      [_] (S n) x xs = Cons x (repl n x xs)
    constructor RNil : RLE
    constructor RCons : (n) -> (x) -> (_x4) -> RLE
    compress 
      [_] Nil = RNil
      [_] (Cons x xs) = 
        let aux 
          [_] y RNil = RCons 1 y RNil
          [_] True (RCons n True rzs) = RCons (S n) True rzs
          [_] False (RCons n False rzs) = RCons (S n) False rzs
          [_] True (RCons n False rzs) = RCons 1 True (RCons n False rzs)
          [_] False (RCons n True rzs) = RCons 1 False (RCons n True rzs)
        in aux x (compress xs)
    decompress 
      [_] RNil = Nil
      [_] (RCons n x rxs) = repl n x (decompress rxs)
    foldl 
      [_] _ z Nil = z
      [_] f z (Cons x xs) = foldl f (f z x) xs
    xor 
      [_] False b = b
      [_] True False = True
      [_] True True = False
  in 
    let foreign inputSize
    in foldl xor False (decompress (compress (repl inputSize True Nil)))

