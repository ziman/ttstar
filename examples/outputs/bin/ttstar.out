-- vim: ft=ttstar

### Desugared ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    times : (_x2 : Nat) -> (_x3 : Nat) -> Nat 
      n : Nat
        [times] Z n = Z
      m : Nat n : Nat
        [times] (S m) n = plus n (times m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x4 : Bool) -> Bool 
      [not] True = False
      [not] False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x5 : Type) -> (_x6 : Type) -> Type
    constructor MkPair : (a : Type) -> (b : Type) -> (_x7 : a) -> (_x8 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x9 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        [fst] a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x10 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        [snd] a b ([MkPair] [a] [b] x y) = y
    constructor Either : (_x11 : Type) -> (_x12 : Type) -> Type
    constructor Left : (a : Type) -> (b : Type) -> (_x13 : a) -> Either a b
    constructor Right : (a : Type) -> (b : Type) -> (_x14 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x15 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x16 : Fin n) -> Fin (S n)
    constructor Vect : (_x17 : Nat) -> (_x18 : Type) -> Type
    constructor VN : (a : Type) -> Vect Z a
    constructor VC : (n : Nat) -> (a : Type) -> (x : a) -> (xs : Vect n a) -> Vect (S n) a
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    subst : (a : Type) -> (P : (_x0 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (_x1 : P x) -> P y 
      a : Type P : (_x2 : a) -> Type x : a
        [subst] a P x [x] [Refl a x] = (\z : P x. z)
    constructor Bit : (_x0 : Nat) -> Type
    constructor I : Bit 1
    constructor O : Bit Z
    double : (_x1 : Nat) -> Nat 
      [double] Z = Z
      n : Nat
        [double] (S n) = S (S (double n))
    constructor Bin : (width : Nat) -> (value : Nat) -> Type
    constructor N : Bin Z Z
    constructor C : (width : Nat) -> (lsbVal : Nat) -> (lsb :R: Bit lsbVal) -> (restVal : Nat) -> (rest :R: Bin width restVal) -> Bin (S width) (plus lsbVal (double restVal))
    constructor TwoBits : (_x2 : Nat) -> (_x3 : Nat) -> (_x4 : Nat) -> Type
    constructor TB : (c : Nat) -> (x : Nat) -> (y : Nat) -> (hi' : Nat) -> (hi : Bit hi') -> (lo' : Nat) -> (lo : Bit lo') -> (pf : Id Nat (plus c (plus x y)) (plus lo' (double hi'))) -> TwoBits c x y
    adb : (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x5 : Bit c) -> (_x6 : Bit x) -> (_x7 : Bit y) -> TwoBits c x y 
      [adb] [Z] [Z] [Z] O O O = TB Z Z Z Z O Z O (Refl Nat Z)
      [adb] [1] [Z] [Z] I O O = TB 1 Z Z Z O 1 I (Refl Nat 1)
      [adb] [Z] [1] [Z] O I O = TB Z 1 Z Z O 1 I (Refl Nat 1)
      [adb] [Z] [Z] [1] O O I = TB Z Z 1 Z O 1 I (Refl Nat 1)
      [adb] [1] [1] [Z] I I O = TB 1 1 Z 1 I Z O (Refl Nat 2)
      [adb] [1] [Z] [1] I O I = TB 1 Z 1 1 I Z O (Refl Nat 2)
      [adb] [Z] [1] [1] O I I = TB Z 1 1 1 I Z O (Refl Nat 2)
      [adb] [1] [1] [1] I I I = TB 1 1 1 1 I 1 I (Refl Nat 3)
    add' : (w : Nat) -> (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x8 : Bit c) -> (_x9 : Bin w x) -> (_x10 : Bin w y) -> Bin (S w) (plus c (plus x y)) 
      c : Nat cb : Bit c
        [add'] [Z] c [Z] [Z] cb N N = C Z c cb Z N
      w : Nat c : Nat cb : Bit c xb' : Nat xb : Bit xb' xn' : Nat xn : Bin w xn' yb' : Nat yb : Bit yb' yn' : Nat yn : Bin w yn'
        [add'] ([S] w) c [plus xb' (double xn')] [plus yb' (double yn')] cb (C [w] xb' xb xn' xn) (C [w] yb' yb yn' yn) = 
          let f : (_x11 : TwoBits c xb' yb') -> Bin (S (S w)) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) 
            hi' : Nat hi : Bit hi' lo' : Nat lo : Bit lo' pf : Id Nat (plus c (plus xb' yb')) (plus lo' (double hi'))
              [f] ([TB] [c] [xb'] [yb'] hi' hi lo' lo pf) = 
                let postulate eq : Id Nat (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn'))))
                in subst Nat (Bin (S (S w))) (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) eq (C (S w) lo' lo (plus hi' (plus xn' yn')) (add' w hi' xn' yn' hi xn yn))
          in f (adb c xb' yb' cb xb yb)
    add : (w : Nat) -> (x : Nat) -> (y : Nat) -> (bx : Bin w x) -> (by : Bin w y) -> Bin (S w) (plus x y) = (\w : Nat. (\x : Nat. (\y : Nat. (\bx : Bin w x. (\by : Bin w y. add' w Z x y O bx by)))))
    foreign inputSize : Nat
    binVal : (_x12 : Bool) -> (_x13 : Nat) -> Nat 
      b : Bool
        [binVal] b Z = Z
      n : Nat
        [binVal] True (S n) = S (double (binVal False n))
      n : Nat
        [binVal] False (S n) = double (binVal True n)
    mkBin : (b : Bool) -> (w : Nat) -> Bin w (binVal b w) 
      b : Bool
        [mkBin] b Z = N
      n : Nat
        [mkBin] True (S n) = C n 1 I (binVal False n) (mkBin False n)
      n : Nat
        [mkBin] False (S n) = C n Z O (binVal True n) (mkBin True n)
    main : Bin (S inputSize) (plus (binVal True inputSize) (binVal False inputSize)) = 
      let
        x : Bin inputSize (binVal True inputSize) = mkBin True inputSize
        y : Bin inputSize (binVal False inputSize) = mkBin False inputSize
      in add inputSize (binVal True inputSize) (binVal False inputSize) x y
  in main

### Evarified ###

  let
    constructor Nat :1: Type
    constructor Z :2: Nat
    constructor S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        [plus] -9- Z -8- n = n
      m :10: Nat n :11: Nat
        [plus] -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    times :18: (_x2 :19: Nat) -> (_x3 :20: Nat) -> Nat 
      n :21: Nat
        [times] -23- Z -22- n = Z
      m :24: Nat n :25: Nat
        [times] -27- (S -28- m) -26- n = plus -30- n -29- (times -32- m -31- n)
    constructor Bool :33: Type
    constructor True :34: Bool
    constructor False :35: Bool
    not :36: (_x4 :37: Bool) -> Bool 
      [not] -38- True = False
      [not] -39- False = True
    constructor Unit :40: Type
    constructor MkUnit :41: Unit
    constructor Pair :42: (_x5 :43: Type) -> (_x6 :44: Type) -> Type
    constructor MkPair :45: (a :46: Type) -> (b :47: Type) -> (_x7 :48: a) -> (_x8 :49: b) -> Pair -51- a -50- b
    fst :52: (a :53: Type) -> (b :54: Type) -> (_x9 :55: Pair -57- a -56- b) -> a 
      a :58: Type b :59: Type x :60: a y :61: b
        [fst] -64- a -63- b -62- ([MkPair] -68- [a] -67- [b] -66- x -65- y) = x
    snd :69: (a :70: Type) -> (b :71: Type) -> (_x10 :72: Pair -74- a -73- b) -> b 
      a :75: Type b :76: Type x :77: a y :78: b
        [snd] -81- a -80- b -79- ([MkPair] -85- [a] -84- [b] -83- x -82- y) = y
    constructor Either :86: (_x11 :87: Type) -> (_x12 :88: Type) -> Type
    constructor Left :89: (a :90: Type) -> (b :91: Type) -> (_x13 :92: a) -> Either -94- a -93- b
    constructor Right :95: (a :96: Type) -> (b :97: Type) -> (_x14 :98: b) -> Either -100- a -99- b
    id :101: (a :102: Type) -> (x :103: a) -> a = (\a :104: Type. (\x :105: a. x))
    constructor Fin :106: (_x15 :107: Nat) -> Type
    constructor FZ :108: (n :109: Nat) -> Fin -110- (S -111- n)
    constructor FS :112: (n :113: Nat) -> (_x16 :114: Fin -115- n) -> Fin -116- (S -117- n)
    constructor Vect :118: (_x17 :119: Nat) -> (_x18 :120: Type) -> Type
    constructor VN :121: (a :122: Type) -> Vect -124- Z -123- a
    constructor VC :125: (n :126: Nat) -> (a :127: Type) -> (x :128: a) -> (xs :129: Vect -131- n -130- a) -> Vect -133- (S -134- n) -132- a
    constructor Id :135: (a :136: Type) -> (x :137: a) -> (y :138: a) -> Type
    constructor Refl :139: (a :140: Type) -> (x :141: a) -> Id -144- a -143- x -142- x
    subst :145: (a :146: Type) -> (P :147: (_x0 :148: a) -> Type) -> (x :149: a) -> (y :150: a) -> (eq :151: Id -154- a -153- x -152- y) -> (_x1 :155: P -156- x) -> P -157- y 
      a :158: Type P :159: (_x2 :160: a) -> Type x :161: a
        [subst] -166- a -165- P -164- x -163- [x] -162- [Refl -168- a -167- x] = (\z :169: P -170- x. z)
    constructor Bit :171: (_x0 :172: Nat) -> Type
    constructor I :173: Bit -174- 1
    constructor O :176: Bit -177- Z
    double :178: (_x1 :179: Nat) -> Nat 
      [double] -180- Z = Z
      n :181: Nat
        [double] -182- (S -183- n) = S -184- (S -185- (double -186- n))
    constructor Bin :187: (width :188: Nat) -> (value :189: Nat) -> Type
    constructor N :190: Bin -192- Z -191- Z
    constructor C :193: (width :194: Nat) -> (lsbVal :195: Nat) -> (lsb :R: Bit -196- lsbVal) -> (restVal :197: Nat) -> (rest :R: Bin -199- width -198- restVal) -> Bin -201- (S -202- width) -200- (plus -204- lsbVal -203- (double -205- restVal))
    constructor TwoBits :206: (_x2 :207: Nat) -> (_x3 :208: Nat) -> (_x4 :209: Nat) -> Type
    constructor TB :210: (c :211: Nat) -> (x :212: Nat) -> (y :213: Nat) -> (hi' :214: Nat) -> (hi :215: Bit -216- hi') -> (lo' :217: Nat) -> (lo :218: Bit -219- lo') -> (pf :220: Id -223- Nat -222- (plus -225- c -224- (plus -227- x -226- y)) -221- (plus -229- lo' -228- (double -230- hi'))) -> TwoBits -233- c -232- x -231- y
    adb :234: (c :235: Nat) -> (x :236: Nat) -> (y :237: Nat) -> (_x5 :238: Bit -239- c) -> (_x6 :240: Bit -241- x) -> (_x7 :242: Bit -243- y) -> TwoBits -246- c -245- x -244- y 
      [adb] -252- [Z] -251- [Z] -250- [Z] -249- O -248- O -247- O = TB -260- Z -259- Z -258- Z -257- Z -256- O -255- Z -254- O -253- (Refl -262- Nat -261- Z)
      [adb] -268- [1] -267- [Z] -266- [Z] -265- I -264- O -263- O = TB -277- 1 -276- Z -275- Z -274- Z -273- O -272- 1 -271- I -270- (Refl -281- Nat -280- 1)
      [adb] -288- [Z] -287- [1] -286- [Z] -285- O -284- I -283- O = TB -297- Z -296- 1 -295- Z -294- Z -293- O -292- 1 -291- I -290- (Refl -301- Nat -300- 1)
      [adb] -308- [Z] -307- [Z] -306- [1] -305- O -304- O -303- I = TB -317- Z -316- Z -315- 1 -314- Z -313- O -312- 1 -311- I -310- (Refl -321- Nat -320- 1)
      [adb] -328- [1] -327- [1] -326- [Z] -325- I -324- I -323- O = TB -338- 1 -337- 1 -336- Z -335- 1 -334- I -333- Z -332- O -331- (Refl -343- Nat -342- 2)
      [adb] -351- [1] -350- [Z] -349- [1] -348- I -347- O -346- I = TB -361- 1 -360- Z -359- 1 -358- 1 -357- I -356- Z -355- O -354- (Refl -366- Nat -365- 2)
      [adb] -374- [Z] -373- [1] -372- [1] -371- O -370- I -369- I = TB -384- Z -383- 1 -382- 1 -381- 1 -380- I -379- Z -378- O -377- (Refl -389- Nat -388- 2)
      [adb] -397- [1] -396- [1] -395- [1] -394- I -393- I -392- I = TB -408- 1 -407- 1 -406- 1 -405- 1 -404- I -403- 1 -402- I -401- (Refl -415- Nat -414- 3)
    add' :419: (w :420: Nat) -> (c :421: Nat) -> (x :422: Nat) -> (y :423: Nat) -> (_x8 :424: Bit -425- c) -> (_x9 :426: Bin -428- w -427- x) -> (_x10 :429: Bin -431- w -430- y) -> Bin -433- (S -434- w) -432- (plus -436- c -435- (plus -438- x -437- y)) 
      c :439: Nat cb :440: Bit -441- c
        [add'] -448- [Z] -447- c -446- [Z] -445- [Z] -444- cb -443- N -442- N = C -453- Z -452- c -451- cb -450- Z -449- N
      w :454: Nat c :455: Nat cb :456: Bit -457- c xb' :458: Nat xb :459: Bit -460- xb' xn' :461: Nat xn :462: Bin -464- w -463- xn' yb' :465: Nat yb :466: Bit -467- yb' yn' :468: Nat yn :469: Bin -471- w -470- yn'
        [add'] -478- ([S] -479- w) -477- c -476- [plus -481- xb' -480- (double -482- xn')] -475- [plus -484- yb' -483- (double -485- yn')] -474- cb -473- (C -490- [w] -489- xb' -488- xb -487- xn' -486- xn) -472- (C -495- [w] -494- yb' -493- yb -492- yn' -491- yn) = 
          let f :496: (_x11 :497: TwoBits -500- c -499- xb' -498- yb') -> Bin -502- (S -503- (S -504- w)) -501- (plus -506- c -505- (plus -508- (plus -510- xb' -509- (double -511- xn')) -507- (plus -513- yb' -512- (double -514- yn')))) 
            hi' :515: Nat hi :516: Bit -517- hi' lo' :518: Nat lo :519: Bit -520- lo' pf :521: Id -524- Nat -523- (plus -526- c -525- (plus -528- xb' -527- yb')) -522- (plus -530- lo' -529- (double -531- hi'))
              [f] -532- ([TB] -540- [c] -539- [xb'] -538- [yb'] -537- hi' -536- hi -535- lo' -534- lo -533- pf) = 
                let postulate eq :541: Id -544- Nat -543- (plus -546- lo' -545- (double -547- (plus -549- hi' -548- (plus -551- xn' -550- yn')))) -542- (plus -553- c -552- (plus -555- (plus -557- xb' -556- (double -558- xn')) -554- (plus -560- yb' -559- (double -561- yn'))))
                in subst -567- Nat -566- (Bin -568- (S -569- (S -570- w))) -565- (plus -572- lo' -571- (double -573- (plus -575- hi' -574- (plus -577- xn' -576- yn')))) -564- (plus -579- c -578- (plus -581- (plus -583- xb' -582- (double -584- xn')) -580- (plus -586- yb' -585- (double -587- yn')))) -563- eq -562- (C -592- (S -593- w) -591- lo' -590- lo -589- (plus -595- hi' -594- (plus -597- xn' -596- yn')) -588- (add' -604- w -603- hi' -602- xn' -601- yn' -600- hi -599- xn -598- yn))
          in f -605- (adb -611- c -610- xb' -609- yb' -608- cb -607- xb -606- yb)
    add :612: (w :613: Nat) -> (x :614: Nat) -> (y :615: Nat) -> (bx :616: Bin -618- w -617- x) -> (by :619: Bin -621- w -620- y) -> Bin -623- (S -624- w) -622- (plus -626- x -625- y) = (\w :627: Nat. (\x :628: Nat. (\y :629: Nat. (\bx :630: Bin -632- w -631- x. (\by :633: Bin -635- w -634- y. add' -642- w -641- Z -640- x -639- y -638- O -637- bx -636- by)))))
    foreign inputSize :643: Nat
    binVal :644: (_x12 :645: Bool) -> (_x13 :646: Nat) -> Nat 
      b :647: Bool
        [binVal] -649- b -648- Z = Z
      n :650: Nat
        [binVal] -652- True -651- (S -653- n) = S -654- (double -655- (binVal -657- False -656- n))
      n :658: Nat
        [binVal] -660- False -659- (S -661- n) = double -662- (binVal -664- True -663- n)
    mkBin :665: (b :666: Bool) -> (w :667: Nat) -> Bin -669- w -668- (binVal -671- b -670- w) 
      b :672: Bool
        [mkBin] -674- b -673- Z = N
      n :675: Nat
        [mkBin] -677- True -676- (S -678- n) = C -683- n -682- 1 -681- I -680- (binVal -686- False -685- n) -679- (mkBin -688- False -687- n)
      n :689: Nat
        [mkBin] -691- False -690- (S -692- n) = C -697- n -696- Z -695- O -694- (binVal -699- True -698- n) -693- (mkBin -701- True -700- n)
    main :702: Bin -704- (S -705- inputSize) -703- (plus -707- (binVal -709- True -708- inputSize) -706- (binVal -711- False -710- inputSize)) = 
      let
        x :712: Bin -714- inputSize -713- (binVal -716- True -715- inputSize) = mkBin -718- True -717- inputSize
        y :719: Bin -721- inputSize -720- (binVal -723- False -722- inputSize) = mkBin -725- False -724- inputSize
      in add -730- inputSize -729- (binVal -732- True -731- inputSize) -728- (binVal -734- False -733- inputSize) -727- x -726- y
  in main

### Constraints ###

[] -> [2,3,34,35,145,155,169,173,176,190,193,210,215,218,234,238,240,242,247,248,249,254,256,263,264,265,271,273,283,284,285,291,293,303,304,305,311,313,323,324,325,332,334,346,347,348,355,357,369,370,371,378,380,392,393,394,402,404,419,424,426,429,440,442,443,444,449,451,456,459,462,466,469,472,473,474,486,488,491,493,496,497,516,519,532,534,536,562,588,590,598,599,600,605,606,607,608,612,616,619,630,633,636,637,638,643,665,666,667,673,674,675,676,677,678,679,681,687,688,689,690,691,692,693,695,700,701,712,717,718,719,724,725,726,727,R]
[5,475] -> [484]
[5,476] -> [481]
[5,564] -> [579]
[5,564,578] -> [581]
[5,564,578,580] -> [586]
[5,564,578,581] -> [583]
[5,565] -> [572]
[5,565,571,573] -> [575]
[5,565,571,573,574] -> [577]
[5,589] -> [595]
[5,589,594] -> [597]
[6,475] -> [483]
[6,476] -> [480]
[6,564] -> [578]
[6,564,578] -> [580]
[6,564,578,580] -> [585]
[6,564,578,581] -> [582]
[6,565] -> [571]
[6,565,571,573] -> [574]
[6,565,571,573,574] -> [576]
[6,589] -> [594]
[6,589,594] -> [596]
[15,142,270] -> [282]
[15,142,290] -> [302]
[15,142,310] -> [322]
[15,142,401] -> [416]
[15,143,270] -> [282]
[15,143,290] -> [302]
[15,143,331] -> [344]
[15,143,331,344] -> [345]
[15,143,354] -> [367]
[15,143,377] -> [390]
[15,143,401] -> [416]
[15,143,401,416] -> [417]
[15,668] -> [654]
[140,162] -> [168]
[140,253] -> [262]
[140,270] -> [281]
[140,290] -> [301]
[140,310] -> [321]
[140,331] -> [343]
[140,354] -> [366]
[140,377] -> [389]
[140,401] -> [415]
[141,162] -> [167]
[141,253] -> [261]
[141,270] -> [280]
[141,290] -> [300]
[141,310] -> [320]
[141,331] -> [342]
[141,354] -> [365]
[141,377] -> [388]
[141,401] -> [414]
[142,162] -> [152]
[142,184,331] -> [344]
[142,184,354] -> [367]
[142,184,377] -> [390]
[142,184,401,416] -> [417]
[142,185,331,344] -> [345]
[142,185,354,367] -> [368]
[142,185,377,390] -> [391]
[142,185,401,416,417] -> [418]
[142,253] -> [221]
[142,270] -> [221]
[142,270,282] -> [15]
[142,290] -> [221]
[142,290,302] -> [15]
[142,310] -> [221]
[142,310,322] -> [15]
[142,331] -> [221]
[142,331,344] -> [184]
[142,331,344,345] -> [185]
[142,354] -> [221]
[142,354,367] -> [184]
[142,354,367,368] -> [185]
[142,377] -> [221]
[142,377,390] -> [184]
[142,377,390,391] -> [185]
[142,401] -> [221]
[142,401,416] -> [15]
[142,401,416,417] -> [184]
[142,401,416,417,418] -> [185]
[143,162] -> [153]
[143,253] -> [222]
[143,270] -> [222]
[143,270,282] -> [15]
[143,290] -> [222]
[143,290,302] -> [15]
[143,310] -> [222]
[143,310,318] -> [322]
[143,310,322] -> [318]
[143,331] -> [222]
[143,331,344] -> [15]
[143,331,344,345] -> [15]
[143,354] -> [222]
[143,354,363,367] -> [368]
[143,354,367] -> [15]
[143,354,367,368] -> [363]
[143,377] -> [222]
[143,377,386,390] -> [391]
[143,377,390] -> [15]
[143,377,390,391] -> [386]
[143,401] -> [222]
[143,401,411,416,417] -> [418]
[143,401,416] -> [15]
[143,401,416,417] -> [15]
[143,401,416,417,418] -> [411]
[144,162] -> [154]
[144,253] -> [223]
[144,270] -> [223]
[144,290] -> [223]
[144,310] -> [223]
[144,331] -> [223]
[144,354] -> [223]
[144,377] -> [223]
[144,401] -> [223]
[146] -> [166,567]
[147] -> [165,566]
[148,165] -> [160]
[148,566] -> [189]
[149] -> [164,565]
[150] -> [163,564]
[151] -> [162,563]
[152,162] -> [142]
[152,563] -> [542]
[153,162] -> [143]
[153,563] -> [543]
[154,162] -> [144]
[154,563] -> [544]
[156] -> [170,200]
[157] -> [170,501]
[158] -> [166]
[159] -> [165]
[160,165] -> [148]
[161] -> [164]
[162] -> [139,151,R]
[162,167] -> [141,161]
[162,168] -> [140,158]
[163] -> [150,161,R]
[164] -> [149,R]
[165] -> [147,R]
[166] -> [146,R]
[170] -> [156,157]
[174] -> [196,216,219,239,241,243]
[174,175] -> [269,279,289,299,309,319,329,330,341,352,353,364,375,376,387,398,399,400,412,413,684]
[174,269] -> [175]
[174,279] -> [175]
[174,289] -> [175]
[174,299] -> [175]
[174,309] -> [175]
[174,319] -> [175]
[174,329] -> [175]
[174,330] -> [175]
[174,341] -> [175]
[174,352] -> [175]
[174,353] -> [175]
[174,364] -> [175]
[174,375] -> [175]
[174,376] -> [175]
[174,387] -> [175]
[174,398] -> [175]
[174,399] -> [175]
[174,400] -> [175]
[174,412] -> [175]
[174,413] -> [175]
[174,684] -> [175]
[177] -> [196,216,219,239,241,243,425]
[179,475,483] -> [485]
[179,476,480] -> [482]
[179,564,578,580,585] -> [587]
[179,564,578,581,582] -> [584]
[179,565,571] -> [573]
[188,566] -> [568]
[189,566] -> [148]
[191] -> [198,427,430,668]
[192] -> [199,428,431,669]
[194] -> [453,490,495,592,683,697]
[195] -> [452,489,494,591,682,696]
[196] -> [174,177,441,460,467,520]
[197] -> [450,487,492,589,680,694]
[198] -> [191,432,463,470,668]
[199] -> [192,433,464,471,669]
[200] -> [156,427,430,432,668]
[200,203] -> [480,483,571]
[200,203,205] -> [482,485,573]
[200,203,205,574] -> [594]
[200,203,205,575] -> [595]
[200,203,205,576,594] -> [596]
[200,203,205,577,594] -> [597]
[200,203,205,594] -> [574]
[200,203,205,594,596] -> [576]
[200,203,205,594,597] -> [577]
[200,203,205,595] -> [575]
[200,203,482] -> [205]
[200,203,485] -> [205]
[200,203,573] -> [205]
[200,204] -> [481,484,572]
[200,480] -> [203]
[200,481] -> [204]
[200,483] -> [203]
[200,484] -> [204]
[200,571] -> [203]
[200,572] -> [204]
[201] -> [428,431,433,568,669]
[201,202] -> [479,569]
[201,202,570] -> [593]
[201,202,593] -> [570]
[201,479] -> [202]
[201,569] -> [202]
[202,433] -> [434]
[202,669] -> [678,692]
[203,432] -> [435]
[204,432] -> [436]
[205,654,668] -> [655]
[205,668] -> [662]
[211] -> [260,277,297,317,338,361,384,408,540]
[212] -> [259,276,296,316,337,360,383,407,539]
[213] -> [258,275,295,315,336,359,382,406,538]
[214] -> [257,274,294,314,335,358,381,405,537]
[216] -> [174,177,517]
[217] -> [255,272,292,312,333,356,379,403,535]
[219] -> [174,177,520]
[220] -> [253,270,290,310,331,354,377,401,533]
[221,253] -> [142]
[221,270] -> [142]
[221,290] -> [142]
[221,310] -> [142]
[221,331] -> [142]
[221,354] -> [142]
[221,377] -> [142]
[221,401] -> [142]
[221,533] -> [522]
[222,253] -> [143]
[222,270] -> [143]
[222,290] -> [143]
[222,310] -> [143]
[222,331] -> [143]
[222,354] -> [143]
[222,377] -> [143]
[222,401] -> [143]
[222,533] -> [523]
[223,253] -> [144]
[223,270] -> [144]
[223,290] -> [144]
[223,310] -> [144]
[223,331] -> [144]
[223,354] -> [144]
[223,377] -> [144]
[223,401] -> [144]
[223,533] -> [524]
[224,523,533] -> [525]
[225,523,533] -> [526]
[226,523,525,533] -> [527]
[227,523,525,533] -> [528]
[228,522,533] -> [529]
[229,522,533] -> [530]
[230,522,529,533] -> [531]
[231] -> [244,498]
[232] -> [245,499]
[233] -> [246,500]
[235] -> [252,268,288,308,328,351,374,397,611]
[236] -> [251,267,287,307,327,350,373,396,610]
[237] -> [250,266,286,306,326,349,372,395,609]
[239] -> [174,177,457]
[241] -> [174,177,460]
[243] -> [174,177,467]
[244] -> [231,498]
[244,309] -> [318]
[244,318] -> [309]
[244,353] -> [363]
[244,363] -> [353]
[244,376] -> [386]
[244,386] -> [376]
[244,400] -> [411]
[244,411] -> [400]
[245] -> [232,499]
[245,289] -> [298]
[245,298] -> [289]
[245,330] -> [340]
[245,340] -> [330]
[245,375] -> [385]
[245,385] -> [375]
[245,399] -> [410]
[245,410] -> [399]
[246] -> [233,500]
[246,269] -> [278]
[246,278] -> [269]
[246,329] -> [339]
[246,339] -> [329]
[246,352] -> [362]
[246,362] -> [352]
[246,398] -> [409]
[246,409] -> [398]
[250] -> [2,237,R]
[251] -> [2,236,R]
[252] -> [2,235,R]
[253] -> [139,220]
[253,261] -> [2,141]
[253,262] -> [1,140]
[255] -> [2,217]
[257] -> [2,214]
[258] -> [2,213]
[259] -> [2,212]
[260] -> [2,211]
[266] -> [2,237,R]
[267] -> [2,236,R]
[268] -> [3,235,269,R]
[268,269] -> [2,R]
[270] -> [139,220]
[270,280] -> [3,141,282]
[270,280,282] -> [2,R]
[270,281] -> [1,140]
[272] -> [3,217,279]
[272,279] -> [2,R]
[274] -> [2,214]
[275] -> [2,213]
[276] -> [2,212]
[277] -> [3,211,278]
[277,278] -> [2,R]
[286] -> [2,237,R]
[287] -> [3,236,289,R]
[287,289] -> [2,R]
[288] -> [2,235,R]
[290] -> [139,220]
[290,300] -> [3,141,302]
[290,300,302] -> [2,R]
[290,301] -> [1,140]
[292] -> [3,217,299]
[292,299] -> [2,R]
[294] -> [2,214]
[295] -> [2,213]
[296] -> [3,212,298]
[296,298] -> [2,R]
[297] -> [2,211]
[306] -> [3,237,309,R]
[306,309] -> [2,R]
[307] -> [2,236,R]
[308] -> [2,235,R]
[310] -> [139,220]
[310,320] -> [3,141,322]
[310,320,322] -> [2,R]
[310,321] -> [1,140]
[312] -> [3,217,319]
[312,319] -> [2,R]
[314] -> [2,214]
[315] -> [3,213,318]
[315,318] -> [2,R]
[316] -> [2,212]
[317] -> [2,211]
[326] -> [2,237,R]
[327] -> [3,236,330,R]
[327,330] -> [2,R]
[328] -> [3,235,329,R]
[328,329] -> [2,R]
[331] -> [139,220]
[331,342] -> [3,141,344]
[331,342,344] -> [3,345,R]
[331,342,344,345] -> [2,R]
[331,343] -> [1,140]
[333] -> [2,217]
[335] -> [3,214,341]
[335,341] -> [2,R]
[336] -> [2,213]
[337] -> [3,212,340]
[337,340] -> [2,R]
[338] -> [3,211,339]
[338,339] -> [2,R]
[349] -> [3,237,353,R]
[349,353] -> [2,R]
[350] -> [2,236,R]
[351] -> [3,235,352,R]
[351,352] -> [2,R]
[354] -> [139,220]
[354,365] -> [3,141,367]
[354,365,367] -> [3,368,R]
[354,365,367,368] -> [2,R]
[354,366] -> [1,140]
[356] -> [2,217]
[358] -> [3,214,364]
[358,364] -> [2,R]
[359] -> [3,213,363]
[359,363] -> [2,R]
[360] -> [2,212]
[361] -> [3,211,362]
[361,362] -> [2,R]
[372] -> [3,237,376,R]
[372,376] -> [2,R]
[373] -> [3,236,375,R]
[373,375] -> [2,R]
[374] -> [2,235,R]
[377] -> [139,220]
[377,388] -> [3,141,390]
[377,388,390] -> [3,391,R]
[377,388,390,391] -> [2,R]
[377,389] -> [1,140]
[379] -> [2,217]
[381] -> [3,214,387]
[381,387] -> [2,R]
[382] -> [3,213,386]
[382,386] -> [2,R]
[383] -> [3,212,385]
[383,385] -> [2,R]
[384] -> [2,211]
[395] -> [3,237,400,R]
[395,400] -> [2,R]
[396] -> [3,236,399,R]
[396,399] -> [2,R]
[397] -> [3,235,398,R]
[397,398] -> [2,R]
[401] -> [139,220]
[401,414] -> [3,141,416]
[401,414,416] -> [3,417,R]
[401,414,416,417] -> [3,418,R]
[401,414,416,417,418] -> [2,R]
[401,415] -> [1,140]
[403] -> [3,217,413]
[403,413] -> [2,R]
[405] -> [3,214,412]
[405,412] -> [2,R]
[406] -> [3,213,411]
[406,411] -> [2,R]
[407] -> [3,212,410]
[407,410] -> [2,R]
[408] -> [3,211,409]
[408,409] -> [2,R]
[420] -> [448,478,604,642]
[421] -> [447,477,603,641]
[422] -> [446,476,602,640]
[423] -> [445,475,601,639]
[425] -> [177,441,457,517]
[427] -> [191,200,463,631]
[428] -> [192,201,464,632]
[430] -> [191,200,470,634]
[431] -> [192,201,471,635]
[432] -> [198,200,501,622]
[432,435] -> [203,505,594]
[432,435,437] -> [507,596]
[432,435,437,483] -> [512]
[432,435,437,483,485] -> [514]
[432,435,437,483,514] -> [485]
[432,435,437,484] -> [513]
[432,435,437,512] -> [483]
[432,435,437,513] -> [484]
[432,435,438] -> [508,597]
[432,435,438,480] -> [509]
[432,435,438,480,482] -> [511]
[432,435,438,480,511] -> [482]
[432,435,438,481] -> [510]
[432,435,438,509] -> [480]
[432,435,438,510] -> [481]
[432,435,507] -> [437]
[432,435,508] -> [438]
[432,435,596] -> [437]
[432,435,597] -> [438]
[432,436] -> [204,506,595]
[432,505] -> [435]
[432,506] -> [436]
[432,594] -> [435]
[432,595] -> [436]
[433] -> [199,201,502,623]
[433,434] -> [202,503,593]
[433,434,479] -> [504]
[433,434,504] -> [479]
[433,503] -> [434]
[433,593] -> [434]
[434,623] -> [624]
[437,622] -> [625]
[438,622] -> [626]
[439] -> [447]
[441] -> [196,425]
[445] -> [2,423,R]
[446] -> [2,422,R]
[447] -> [421,R]
[448] -> [2,420,R]
[450] -> [2,197]
[452] -> [195,439]
[453] -> [2,194]
[454] -> [479]
[455] -> [477]
[457] -> [239,425]
[458] -> [489]
[460] -> [196,241]
[461] -> [487]
[463] -> [198,427]
[464] -> [199,428]
[465] -> [494]
[467] -> [196,243]
[468] -> [492]
[470] -> [198,430]
[471] -> [199,431]
[475] -> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,423,R]
[475,483] -> [2,3,6,178,179,180,181,182,183,184,185,186,R]
[475,483,485] -> [179,468]
[475,484] -> [5,465]
[476] -> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,422,R]
[476,480] -> [2,3,6,178,179,180,181,182,183,184,185,186,R]
[476,480,482] -> [179,461]
[476,481] -> [5,458]
[477] -> [421,R]
[478] -> [3,420,479,R]
[478,479] -> [R]
[479] -> [478]
[487] -> [197,473]
[489] -> [195,473]
[490] -> [194,454,473]
[492] -> [197,472]
[494] -> [195,472]
[495] -> [194,454,472]
[498] -> [231,244]
[499] -> [232,245]
[500] -> [233,246]
[501] -> [157,432]
[501,505] -> [578]
[501,505,507] -> [580]
[501,505,507,512] -> [585]
[501,505,507,512,514] -> [587]
[501,505,507,512,587] -> [514]
[501,505,507,513] -> [586]
[501,505,507,585] -> [512]
[501,505,507,586] -> [513]
[501,505,508] -> [581]
[501,505,508,509] -> [582]
[501,505,508,509,511] -> [584]
[501,505,508,509,584] -> [511]
[501,505,508,510] -> [583]
[501,505,508,582] -> [509]
[501,505,508,583] -> [510]
[501,505,580] -> [507]
[501,505,581] -> [508]
[501,506] -> [579]
[501,578] -> [505]
[501,579] -> [506]
[502] -> [433,568]
[502,503] -> [569]
[502,503,504] -> [570]
[502,503,570] -> [504]
[502,569] -> [503]
[515] -> [537]
[517] -> [216,425]
[518] -> [535]
[520] -> [196,219]
[521] -> [533]
[522,529,531,533] -> [230]
[522,529,533] -> [228]
[522,530,533] -> [229]
[522,533] -> [221]
[523,525,527,533] -> [226]
[523,525,528,533] -> [227]
[523,525,533] -> [224]
[523,526,533] -> [225]
[523,533] -> [222]
[524,533] -> [223]
[533] -> [220,532]
[535] -> [217,532]
[537] -> [214,532]
[538] -> [213,465,532]
[539] -> [212,458,532]
[540] -> [211,455,532]
[542,552,554,559,561,563] -> [587]
[542,552,554,559,563] -> [585]
[542,552,554,559,563,587] -> [561]
[542,552,554,560,563] -> [586]
[542,552,554,563] -> [580]
[542,552,554,563,585] -> [559]
[542,552,554,563,586] -> [560]
[542,552,555,556,558,563] -> [584]
[542,552,555,556,563] -> [582]
[542,552,555,556,563,584] -> [558]
[542,552,555,557,563] -> [583]
[542,552,555,563] -> [581]
[542,552,555,563,582] -> [556]
[542,552,555,563,583] -> [557]
[542,552,563] -> [578]
[542,552,563,580] -> [554]
[542,552,563,581] -> [555]
[542,553,563] -> [579]
[542,563] -> [152]
[542,563,578] -> [552]
[542,563,579] -> [553]
[543,545,547,548,550,563] -> [576]
[543,545,547,548,551,563] -> [577]
[543,545,547,548,563] -> [574]
[543,545,547,548,563,576] -> [550]
[543,545,547,548,563,577] -> [551]
[543,545,547,549,563] -> [575]
[543,545,547,563] -> [573]
[543,545,547,563,574] -> [548]
[543,545,547,563,575] -> [549]
[543,545,563] -> [571]
[543,545,563,573] -> [547]
[543,546,563] -> [572]
[543,563] -> [153]
[543,563,571] -> [545]
[543,563,572] -> [546]
[544,563] -> [154]
[563] -> [151,541]
[564] -> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,150,R]
[564,578] -> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,R]
[564,578,580] -> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,R]
[564,578,580,585] -> [2,3,6,178,179,180,181,182,183,184,185,186,R]
[564,578,580,585,587] -> [179,468]
[564,578,580,586] -> [5,465]
[564,578,581] -> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,R]
[564,578,581,582] -> [2,3,6,178,179,180,181,182,183,184,185,186,R]
[564,578,581,582,584] -> [179,461]
[564,578,581,583] -> [5,458]
[564,579] -> [5,455]
[565] -> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,149,R]
[565,571] -> [2,3,6,178,179,180,181,182,183,184,185,186,R]
[565,571,573] -> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,179,R]
[565,571,573,574] -> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,R]
[565,571,573,574,576] -> [6,468]
[565,571,573,574,577] -> [5,461]
[565,571,573,575] -> [5,515]
[565,572] -> [5,518]
[566] -> [147,187]
[566,568] -> [3,188,569]
[566,568,569] -> [3,570,R]
[566,568,569,570] -> [454,R]
[567] -> [1,146]
[568] -> [201,502]
[589] -> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,197,R]
[589,594] -> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,R]
[589,594,596] -> [6,468]
[589,594,597] -> [5,461]
[589,595] -> [5,515]
[591] -> [195,518]
[592] -> [3,194,593]
[592,593] -> [454,R]
[601] -> [423,468]
[602] -> [422,461]
[603] -> [421,515]
[604] -> [420,454]
[609] -> [237,465]
[610] -> [236,458]
[611] -> [235,455]
[613] -> [627,730]
[614] -> [628,729]
[615] -> [629,728]
[617] -> [631,713]
[618] -> [632,714]
[620] -> [634,720]
[621] -> [635,721]
[622] -> [432,703]
[622,625] -> [437]
[622,626] -> [438]
[623] -> [433,704]
[623,624] -> [434]
[624,704] -> [705]
[625,703] -> [706]
[626,703] -> [707]
[627] -> [613]
[628] -> [614]
[629] -> [615]
[631] -> [427,617]
[632] -> [428,618]
[634] -> [430,620]
[635] -> [431,621]
[639] -> [423,629]
[640] -> [422,628]
[641] -> [2,421]
[642] -> [420,627]
[645,680] -> [686]
[645,694] -> [699]
[645,728] -> [734]
[645,729] -> [732]
[646,680] -> [685]
[646,694] -> [698]
[646,728] -> [733]
[646,729] -> [731]
[647,680] -> [649]
[647,694] -> [649]
[647,728] -> [649]
[647,729] -> [649]
[654,655,656,668] -> [685]
[654,655,657,668] -> [686]
[654,655,668] -> [205]
[654,655,668,685] -> [656]
[654,655,668,686] -> [657]
[654,668] -> [15]
[662,663,668] -> [698]
[662,664,668] -> [699]
[662,668] -> [205]
[662,668,698] -> [663]
[662,668,699] -> [664]
[668] -> [191,198,200,713,720]
[668,670] -> [685,698]
[668,671] -> [686,699]
[668,685] -> [670]
[668,686] -> [671]
[668,698] -> [670]
[668,699] -> [671]
[669] -> [192,199,201,202,714,721]
[670,713] -> [715]
[670,720] -> [722]
[671,713] -> [716]
[671,720] -> [723]
[672] -> [674]
[680] -> [2,3,34,35,178,179,180,181,182,183,184,185,186,197,644,645,646,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,R]
[680,685] -> [646,675]
[680,686] -> [35,645]
[682] -> [3,195,684]
[682,684] -> [2,R]
[683] -> [194,675]
[694] -> [2,3,34,35,178,179,180,181,182,183,184,185,186,197,644,645,646,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,R]
[694,698] -> [646,689]
[694,699] -> [34,645]
[696] -> [2,195]
[697] -> [194,689]
[703] -> [622]
[703,706] -> [625]
[703,706,710] -> [733]
[703,706,711] -> [734]
[703,706,733] -> [710]
[703,706,734] -> [711]
[703,707] -> [626]
[703,707,708] -> [731]
[703,707,709] -> [732]
[703,707,731] -> [708]
[703,707,732] -> [709]
[704] -> [623]
[704,705] -> [624]
[713] -> [617,668]
[713,715] -> [670,731]
[713,716] -> [671,732]
[713,731] -> [715]
[713,732] -> [716]
[714] -> [618,669]
[720] -> [620,668]
[720,722] -> [670,733]
[720,723] -> [671,734]
[720,733] -> [722]
[720,734] -> [723]
[721] -> [621,669]
[728] -> [2,3,34,35,178,179,180,181,182,183,184,185,186,615,644,645,646,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,R]
[728,733] -> [643,646]
[728,734] -> [35,645]
[729] -> [2,3,34,35,178,179,180,181,182,183,184,185,186,614,644,645,646,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,R]
[729,731] -> [643,646]
[729,732] -> [34,645]
[730] -> [613,643]
[R] -> [702]

### Solution ###

[2,3,34,35,145,155,169,173,176,190,193,210,215,218,234,238,240,242,247,248,249,254,256,263,264,265,271,273,283,284,285,291,293,303,304,305,311,313,323,324,325,332,334,346,347,348,355,357,369,370,371,378,380,392,393,394,402,404,419,424,426,429,440,442,443,444,449,451,456,459,462,466,469,472,473,474,486,488,491,493,496,497,516,519,532,534,536,562,588,590,598,599,600,605,606,607,608,612,616,619,630,633,636,637,638,643,665,666,667,673,674,675,676,677,678,679,681,687,688,689,690,691,692,693,695,700,701,702,712,717,718,719,724,725,726,727,R]

### Annotated ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        [times] -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        [times] -E- (S -E- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        [subst] -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :R: Bit -E- 1
    constructor O :R: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      [double] -E- Z = Z
      n :E: Nat
        [double] -E- (S -E- n) = S -E- (S -E- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :R: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -E- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :R: Bit -E- hi') -> (lo' :E: Nat) -> (lo :R: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :R: Bit -E- c) -> (_x6 :R: Bit -E- x) -> (_x7 :R: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      [adb] -E- [Z] -E- [Z] -E- [Z] -R- O -R- O -R- O = TB -E- Z -E- Z -E- Z -E- Z -R- O -E- Z -R- O -E- (Refl -E- Nat -E- Z)
      [adb] -E- [1] -E- [Z] -E- [Z] -R- I -R- O -R- O = TB -E- 1 -E- Z -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [1] -E- [Z] -R- O -R- I -R- O = TB -E- Z -E- 1 -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [Z] -E- [1] -R- O -R- O -R- I = TB -E- Z -E- Z -E- 1 -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [1] -E- [1] -E- [Z] -R- I -R- I -R- O = TB -E- 1 -E- 1 -E- Z -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [Z] -E- [1] -R- I -R- O -R- I = TB -E- 1 -E- Z -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [Z] -E- [1] -E- [1] -R- O -R- I -R- I = TB -E- Z -E- 1 -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [1] -E- [1] -R- I -R- I -R- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -R- I -E- 1 -R- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :E: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :R: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -E- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :R: Bit -E- c
        [add'] -E- [Z] -E- c -E- [Z] -E- [Z] -R- cb -R- N -R- N = C -E- Z -E- c -R- cb -E- Z -R- N
      w :E: Nat c :E: Nat cb :R: Bit -E- c xb' :E: Nat xb :R: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :R: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        [add'] -E- ([S] -E- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -R- cb -R- (C -E- [w] -E- xb' -R- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -R- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :R: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -E- (S -E- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :R: Bit -E- hi' lo' :E: Nat lo :R: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              [f] -R- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -R- hi -E- lo' -R- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -E- (S -E- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -E- w) -E- lo' -R- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -E- w -E- hi' -E- xn' -E- yn' -R- hi -R- xn -R- yn))
          in f -R- (adb -E- c -E- xb' -E- yb' -R- cb -R- xb -R- yb)
    add :R: (w :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -E- w) -E- (plus -E- x -E- y) = (\w :E: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -E- w -E- Z -E- x -E- y -R- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        [binVal] -E- b -E- Z = Z
      n :E: Nat
        [binVal] -E- True -E- (S -E- n) = S -E- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        [binVal] -E- False -E- (S -E- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :E: Bool
        [mkBin] -R- b -R- Z = N
      n :R: Nat
        [mkBin] -R- True -R- (S -R- n) = C -E- n -E- 1 -R- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        [mkBin] -R- False -R- (S -R- n) = C -E- n -E- Z -R- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -E- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -E- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Specialised ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        [times] -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        [times] -E- (S -E- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        [subst] -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :R: Bit -E- 1
    constructor O :R: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      [double] -E- Z = Z
      n :E: Nat
        [double] -E- (S -E- n) = S -E- (S -E- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :R: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -E- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :R: Bit -E- hi') -> (lo' :E: Nat) -> (lo :R: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :R: Bit -E- c) -> (_x6 :R: Bit -E- x) -> (_x7 :R: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      [adb] -E- [Z] -E- [Z] -E- [Z] -R- O -R- O -R- O = TB -E- Z -E- Z -E- Z -E- Z -R- O -E- Z -R- O -E- (Refl -E- Nat -E- Z)
      [adb] -E- [1] -E- [Z] -E- [Z] -R- I -R- O -R- O = TB -E- 1 -E- Z -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [1] -E- [Z] -R- O -R- I -R- O = TB -E- Z -E- 1 -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [Z] -E- [1] -R- O -R- O -R- I = TB -E- Z -E- Z -E- 1 -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [1] -E- [1] -E- [Z] -R- I -R- I -R- O = TB -E- 1 -E- 1 -E- Z -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [Z] -E- [1] -R- I -R- O -R- I = TB -E- 1 -E- Z -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [Z] -E- [1] -E- [1] -R- O -R- I -R- I = TB -E- Z -E- 1 -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [1] -E- [1] -R- I -R- I -R- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -R- I -E- 1 -R- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :E: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :R: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -E- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :R: Bit -E- c
        [add'] -E- [Z] -E- c -E- [Z] -E- [Z] -R- cb -R- N -R- N = C -E- Z -E- c -R- cb -E- Z -R- N
      w :E: Nat c :E: Nat cb :R: Bit -E- c xb' :E: Nat xb :R: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :R: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        [add'] -E- ([S] -E- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -R- cb -R- (C -E- [w] -E- xb' -R- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -R- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :R: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -E- (S -E- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :R: Bit -E- hi' lo' :E: Nat lo :R: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              [f] -R- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -R- hi -E- lo' -R- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -E- (S -E- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -E- w) -E- lo' -R- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -E- w -E- hi' -E- xn' -E- yn' -R- hi -R- xn -R- yn))
          in f -R- (adb -E- c -E- xb' -E- yb' -R- cb -R- xb -R- yb)
    add :R: (w :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -E- w) -E- (plus -E- x -E- y) = (\w :E: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -E- w -E- Z -E- x -E- y -R- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        [binVal] -E- b -E- Z = Z
      n :E: Nat
        [binVal] -E- True -E- (S -E- n) = S -E- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        [binVal] -E- False -E- (S -E- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :E: Bool
        [mkBin] -R- b -R- Z = N
      n :R: Nat
        [mkBin] -R- True -R- (S -R- n) = C -E- n -E- 1 -R- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        [mkBin] -R- False -R- (S -R- n) = C -E- n -E- Z -R- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -E- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -E- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Final annotation ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        [times] -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        [times] -E- (S -E- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        [subst] -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :R: Bit -E- 1
    constructor O :R: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      [double] -E- Z = Z
      n :E: Nat
        [double] -E- (S -E- n) = S -E- (S -E- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :R: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -E- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :R: Bit -E- hi') -> (lo' :E: Nat) -> (lo :R: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :R: Bit -E- c) -> (_x6 :R: Bit -E- x) -> (_x7 :R: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      [adb] -E- [Z] -E- [Z] -E- [Z] -R- O -R- O -R- O = TB -E- Z -E- Z -E- Z -E- Z -R- O -E- Z -R- O -E- (Refl -E- Nat -E- Z)
      [adb] -E- [1] -E- [Z] -E- [Z] -R- I -R- O -R- O = TB -E- 1 -E- Z -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [1] -E- [Z] -R- O -R- I -R- O = TB -E- Z -E- 1 -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [Z] -E- [Z] -E- [1] -R- O -R- O -R- I = TB -E- Z -E- Z -E- 1 -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      [adb] -E- [1] -E- [1] -E- [Z] -R- I -R- I -R- O = TB -E- 1 -E- 1 -E- Z -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [Z] -E- [1] -R- I -R- O -R- I = TB -E- 1 -E- Z -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [Z] -E- [1] -E- [1] -R- O -R- I -R- I = TB -E- Z -E- 1 -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      [adb] -E- [1] -E- [1] -E- [1] -R- I -R- I -R- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -R- I -E- 1 -R- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :E: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :R: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -E- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :R: Bit -E- c
        [add'] -E- [Z] -E- c -E- [Z] -E- [Z] -R- cb -R- N -R- N = C -E- Z -E- c -R- cb -E- Z -R- N
      w :E: Nat c :E: Nat cb :R: Bit -E- c xb' :E: Nat xb :R: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :R: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        [add'] -E- ([S] -E- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -R- cb -R- (C -E- [w] -E- xb' -R- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -R- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :R: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -E- (S -E- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :R: Bit -E- hi' lo' :E: Nat lo :R: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              [f] -R- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -R- hi -E- lo' -R- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -E- (S -E- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -E- w) -E- lo' -R- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -E- w -E- hi' -E- xn' -E- yn' -R- hi -R- xn -R- yn))
          in f -R- (adb -E- c -E- xb' -E- yb' -R- cb -R- xb -R- yb)
    add :R: (w :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -E- w) -E- (plus -E- x -E- y) = (\w :E: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -E- w -E- Z -E- x -E- y -R- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        [binVal] -E- b -E- Z = Z
      n :E: Nat
        [binVal] -E- True -E- (S -E- n) = S -E- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        [binVal] -E- False -E- (S -E- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :E: Bool
        [mkBin] -R- b -R- Z = N
      n :R: Nat
        [mkBin] -R- True -R- (S -R- n) = C -E- n -E- 1 -R- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        [mkBin] -R- False -R- (S -R- n) = C -E- n -E- Z -R- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -E- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -E- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    subst = (\z. z)
    constructor I : Bit
    constructor O : Bit
    constructor N : Bin
    constructor C : (lsb) -> (rest) -> Bin
    constructor TB : (hi) -> (lo) -> TwoBits
    adb 
      [_] O O O = TB O O
      [_] I O O = TB O I
      [_] O I O = TB O I
      [_] O O I = TB O I
      [_] I I O = TB I O
      [_] I O I = TB I O
      [_] O I I = TB I O
      [_] I I I = TB I I
    add' 
      [_] cb N N = C cb N
      [_] cb (C xb xn) (C yb yn) = 
        let f 
          [_] ([_] hi lo) = subst (C lo (add' hi xn yn))
        in f (adb cb xb yb)
    add = (\bx. (\by. add' O bx by))
    foreign inputSize
    mkBin 
      [_] _ Z = N
      [_] True (S n) = C I (mkBin False n)
      [_] False (S n) = C O (mkBin True n)
    main = 
      let
        x = mkBin True inputSize
        y = mkBin False inputSize
      in add x y
  in main

### Intermediate representation ###

let Z = constructor 0
  in let S = constructor 1
    in let True = constructor 0
      in let False = constructor 0
        in let subst = \z. z
          in let I = constructor 0
            in let O = constructor 0
              in let N = constructor 0
                in let C = constructor 2
                  in let TB = constructor 2
                    in let adb = \_pv0. \_pv1. \_pv2.
                      case _pv0 of
                        I => case _pv1 of
                          I => case _pv2 of
                            I => ((TB I) I)
                            O => ((TB I) O)
                          O => case _pv2 of
                            I => ((TB I) O)
                            O => ((TB O) I)
                        O => case _pv1 of
                          I => case _pv2 of
                            I => ((TB I) O)
                            O => ((TB O) I)
                          O => case _pv2 of
                            I => ((TB O) I)
                            O => ((TB O) O)
                      in let add' = \_pv0. \_pv1. \_pv2.
                        case _pv1 of
                          C _pv3 _pv4 => case _pv2 of
                            C _pv5 _pv6 => let f = \_pv7.
                              case _pv7 of
                                _ _pv8 _pv9 => (subst ((C _pv9) (((add' _pv8) _pv4) _pv6)))
                              in (f (((adb _pv0) _pv3) _pv5))
                          N => ((C _pv0) N)
                        in let add = \bx. \by. (((add' O) bx) by)
                          in let inputSize = foreign "(rts-arg-peano 'Z 'S 0)"
                            in let mkBin = \_pv0. \_pv1.
                              case _pv1 of
                                Z => N
                                _ => case _pv0 of
                                  False => case _pv1 of
                                    S _pv2 => ((C O) ((mkBin True) _pv2))
                                  True => case _pv1 of
                                    S _pv2 => ((C I) ((mkBin False) _pv2))
                              in let main = let x = ((mkBin True) inputSize)
                                in let y = ((mkBin False) inputSize)
                                  in ((add x) y)
                                in main

### Normal forms ###

unerased:
  
  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    subst : (a : Type) -> (P : (_x0 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (_x1 : P x) -> P y 
      a : Type P : (_x2 : a) -> Type x : a
        [subst] a P x [x] [Refl a x] = (\z : P x. z)
    constructor Bit : (_x0 : Nat) -> Type
    constructor I : Bit 1
    constructor O : Bit Z
    double : (_x1 : Nat) -> Nat 
      [double] Z = Z
      n : Nat
        [double] (S n) = S (S (double n))
    constructor Bin : (width : Nat) -> (value : Nat) -> Type
    constructor N : Bin Z Z
    constructor C : (width : Nat) -> (lsbVal : Nat) -> (lsb :R: Bit lsbVal) -> (restVal : Nat) -> (rest :R: Bin width restVal) -> Bin (S width) (plus lsbVal (double restVal))
    constructor TwoBits : (_x2 : Nat) -> (_x3 : Nat) -> (_x4 : Nat) -> Type
    constructor TB : (c : Nat) -> (x : Nat) -> (y : Nat) -> (hi' : Nat) -> (hi : Bit hi') -> (lo' : Nat) -> (lo : Bit lo') -> (pf : Id Nat (plus c (plus x y)) (plus lo' (double hi'))) -> TwoBits c x y
    adb : (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x5 : Bit c) -> (_x6 : Bit x) -> (_x7 : Bit y) -> TwoBits c x y 
      [adb] [Z] [Z] [Z] O O O = TB Z Z Z Z O Z O (Refl Nat Z)
      [adb] [1] [Z] [Z] I O O = TB 1 Z Z Z O 1 I (Refl Nat 1)
      [adb] [Z] [1] [Z] O I O = TB Z 1 Z Z O 1 I (Refl Nat 1)
      [adb] [Z] [Z] [1] O O I = TB Z Z 1 Z O 1 I (Refl Nat 1)
      [adb] [1] [1] [Z] I I O = TB 1 1 Z 1 I Z O (Refl Nat 2)
      [adb] [1] [Z] [1] I O I = TB 1 Z 1 1 I Z O (Refl Nat 2)
      [adb] [Z] [1] [1] O I I = TB Z 1 1 1 I Z O (Refl Nat 2)
      [adb] [1] [1] [1] I I I = TB 1 1 1 1 I 1 I (Refl Nat 3)
    add' : (w : Nat) -> (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x8 : Bit c) -> (_x9 : Bin w x) -> (_x10 : Bin w y) -> Bin (S w) (plus c (plus x y)) 
      c : Nat cb : Bit c
        [add'] [Z] c [Z] [Z] cb N N = C Z c cb Z N
      w : Nat c : Nat cb : Bit c xb' : Nat xb : Bit xb' xn' : Nat xn : Bin w xn' yb' : Nat yb : Bit yb' yn' : Nat yn : Bin w yn'
        [add'] ([S] w) c [plus xb' (double xn')] [plus yb' (double yn')] cb (C [w] xb' xb xn' xn) (C [w] yb' yb yn' yn) = 
          let f : (_x11 : TwoBits c xb' yb') -> Bin (S (S w)) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) 
            hi' : Nat hi : Bit hi' lo' : Nat lo : Bit lo' pf : Id Nat (plus c (plus xb' yb')) (plus lo' (double hi'))
              [f] ([TB] [c] [xb'] [yb'] hi' hi lo' lo pf) = 
                let postulate eq : Id Nat (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn'))))
                in subst Nat (Bin (S (S w))) (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) eq (C (S w) lo' lo (plus hi' (plus xn' yn')) (add' w hi' xn' yn' hi xn yn))
          in f (adb c xb' yb' cb xb yb)
    foreign inputSize : Nat
    binVal : (_x12 : Bool) -> (_x13 : Nat) -> Nat 
      b : Bool
        [binVal] b Z = Z
      n : Nat
        [binVal] True (S n) = S (double (binVal False n))
      n : Nat
        [binVal] False (S n) = double (binVal True n)
    mkBin : (b : Bool) -> (w : Nat) -> Bin w (binVal b w) 
      b : Bool
        [mkBin] b Z = N
      n : Nat
        [mkBin] True (S n) = C n 1 I (binVal False n) (mkBin False n)
      n : Nat
        [mkBin] False (S n) = C n Z O (binVal True n) (mkBin True n)
  in add' inputSize Z (binVal True inputSize) (binVal False inputSize) O (mkBin True inputSize) (mkBin False inputSize)

erased:
  
  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    subst = (\z. z)
    constructor I : Bit
    constructor O : Bit
    constructor N : Bin
    constructor C : (lsb) -> (rest) -> Bin
    constructor TB : (hi) -> (lo) -> TwoBits
    adb 
      [_] O O O = TB O O
      [_] I O O = TB O I
      [_] O I O = TB O I
      [_] O O I = TB O I
      [_] I I O = TB I O
      [_] I O I = TB I O
      [_] O I I = TB I O
      [_] I I I = TB I I
    add' 
      [_] cb N N = C cb N
      [_] cb (C xb xn) (C yb yn) = 
        let f 
          [_] ([_] hi lo) = subst (C lo (add' hi xn yn))
        in f (adb cb xb yb)
    foreign inputSize
    mkBin 
      [_] _ Z = N
      [_] True (S n) = C I (mkBin False n)
      [_] False (S n) = C O (mkBin True n)
  in add' O (mkBin True inputSize) (mkBin False inputSize)

