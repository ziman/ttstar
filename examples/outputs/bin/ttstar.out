-- vim: ft=ttstar

### Desugared ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        plus Z n = n
      m : Nat n : Nat
        plus (S m) n = S (plus m n)
    times : (_x2 : Nat) -> (_x3 : Nat) -> Nat 
      n : Nat
        times Z n = Z
      m : Nat n : Nat
        times (S m) n = plus n (times m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x4 : Bool) -> Bool 
      not True = False
      not False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x5 : Type) -> (_x6 : Type) -> Type
    constructor MkPair : (a : Type) -> (b : Type) -> (_x7 : a) -> (_x8 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x9 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        fst a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x10 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        snd a b ([MkPair] [a] [b] x y) = y
    constructor Either : (_x11 : Type) -> (_x12 : Type) -> Type
    constructor Left : (a : Type) -> (b : Type) -> (_x13 : a) -> Either a b
    constructor Right : (a : Type) -> (b : Type) -> (_x14 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x15 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x16 : Fin n) -> Fin (S n)
    constructor Vect : (_x17 : Nat) -> (_x18 : Type) -> Type
    constructor VN : (a : Type) -> Vect Z a
    constructor VC : (n : Nat) -> (a : Type) -> (x : a) -> (xs : Vect n a) -> Vect (S n) a
    constructor List : (_x19 : Type) -> Type
    constructor Nil : (a : Type) -> List a
    constructor Cons : (a : Type) -> (x : a) -> (xs : List a) -> List a
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    subst : (a : Type) -> (P : (_x0 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (_x1 : P x) -> P y 
      a : Type P : (_x2 : a) -> Type x : a
        subst a P x [x] [Refl a x] = (\z : P x. z)
    constructor Bit : (_x0 : Nat) -> Type
    constructor I : Bit 1
    constructor O : Bit Z
    double : (_x1 : Nat) -> Nat 
      double Z = Z
      n : Nat
        double (S n) = S (S (double n))
    constructor Bin : (width : Nat) -> (value : Nat) -> Type
    constructor N : Bin Z Z
    constructor C : (width : Nat) -> (lsbVal : Nat) -> (lsb :R: Bit lsbVal) -> (restVal : Nat) -> (rest :R: Bin width restVal) -> Bin (S width) (plus lsbVal (double restVal))
    constructor TwoBits : (_x2 : Nat) -> (_x3 : Nat) -> (_x4 : Nat) -> Type
    constructor TB : (c : Nat) -> (x : Nat) -> (y : Nat) -> (hi' : Nat) -> (hi : Bit hi') -> (lo' : Nat) -> (lo : Bit lo') -> (pf : Id Nat (plus c (plus x y)) (plus lo' (double hi'))) -> TwoBits c x y
    adb : (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x5 : Bit c) -> (_x6 : Bit x) -> (_x7 : Bit y) -> TwoBits c x y 
      adb [Z] [Z] [Z] O O O = TB Z Z Z Z O Z O (Refl Nat Z)
      adb [1] [Z] [Z] I O O = TB 1 Z Z Z O 1 I (Refl Nat 1)
      adb [Z] [1] [Z] O I O = TB Z 1 Z Z O 1 I (Refl Nat 1)
      adb [Z] [Z] [1] O O I = TB Z Z 1 Z O 1 I (Refl Nat 1)
      adb [1] [1] [Z] I I O = TB 1 1 Z 1 I Z O (Refl Nat 2)
      adb [1] [Z] [1] I O I = TB 1 Z 1 1 I Z O (Refl Nat 2)
      adb [Z] [1] [1] O I I = TB Z 1 1 1 I Z O (Refl Nat 2)
      adb [1] [1] [1] I I I = TB 1 1 1 1 I 1 I (Refl Nat 3)
    add' : (w : Nat) -> (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x8 : Bit c) -> (_x9 : Bin w x) -> (_x10 : Bin w y) -> Bin (S w) (plus c (plus x y)) 
      c : Nat cb : Bit c
        add' [Z] c [Z] [Z] cb N N = C Z c cb Z N
      w : Nat c : Nat cb : Bit c xb' : Nat xb : Bit xb' xn' : Nat xn : Bin w xn' yb' : Nat yb : Bit yb' yn' : Nat yn : Bin w yn'
        add' ([S] w) c [plus xb' (double xn')] [plus yb' (double yn')] cb (C [w] xb' xb xn' xn) (C [w] yb' yb yn' yn) = 
          let f : (_x11 : TwoBits c xb' yb') -> Bin (S (S w)) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) 
            hi' : Nat hi : Bit hi' lo' : Nat lo : Bit lo' pf : Id Nat (plus c (plus xb' yb')) (plus lo' (double hi'))
              f ([TB] [c] [xb'] [yb'] hi' hi lo' lo pf) = 
                let postulate eq : Id Nat (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn'))))
                in subst Nat (Bin (S (S w))) (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) eq (C (S w) lo' lo (plus hi' (plus xn' yn')) (add' w hi' xn' yn' hi xn yn))
          in f (adb c xb' yb' cb xb yb)
    add : (w : Nat) -> (x : Nat) -> (y : Nat) -> (bx : Bin w x) -> (by : Bin w y) -> Bin (S w) (plus x y) = (\w : Nat. (\x : Nat. (\y : Nat. (\bx : Bin w x. (\by : Bin w y. add' w Z x y O bx by)))))
    foreign inputSize : Nat
    binVal : (_x12 : Bool) -> (_x13 : Nat) -> Nat 
      b : Bool
        binVal b Z = Z
      n : Nat
        binVal True (S n) = S (double (binVal False n))
      n : Nat
        binVal False (S n) = double (binVal True n)
    mkBin : (b : Bool) -> (w : Nat) -> Bin w (binVal b w) 
      b : Bool
        mkBin b Z = N
      n : Nat
        mkBin True (S n) = C n 1 I (binVal False n) (mkBin False n)
      n : Nat
        mkBin False (S n) = C n Z O (binVal True n) (mkBin True n)
    main : Bin (S inputSize) (plus (binVal True inputSize) (binVal False inputSize)) = 
      let
        x : Bin inputSize (binVal True inputSize) = mkBin True inputSize
        y : Bin inputSize (binVal False inputSize) = mkBin False inputSize
      in add inputSize (binVal True inputSize) (binVal False inputSize) x y
  in main

### Elaborated ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        plus Z n = n
      m : Nat n : Nat
        plus (S m) n = S (plus m n)
    times : (_x2 : Nat) -> (_x3 : Nat) -> Nat 
      n : Nat
        times Z n = Z
      m : Nat n : Nat
        times (S m) n = plus n (times m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x4 : Bool) -> Bool 
      not True = False
      not False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x5 : Type) -> (_x6 : Type) -> Type
    constructor MkPair : (a : Type) -> (b : Type) -> (_x7 : a) -> (_x8 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x9 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        fst a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x10 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        snd a b ([MkPair] [a] [b] x y) = y
    constructor Either : (_x11 : Type) -> (_x12 : Type) -> Type
    constructor Left : (a : Type) -> (b : Type) -> (_x13 : a) -> Either a b
    constructor Right : (a : Type) -> (b : Type) -> (_x14 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x15 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x16 : Fin n) -> Fin (S n)
    constructor Vect : (_x17 : Nat) -> (_x18 : Type) -> Type
    constructor VN : (a : Type) -> Vect Z a
    constructor VC : (n : Nat) -> (a : Type) -> (x : a) -> (xs : Vect n a) -> Vect (S n) a
    constructor List : (_x19 : Type) -> Type
    constructor Nil : (a : Type) -> List a
    constructor Cons : (a : Type) -> (x : a) -> (xs : List a) -> List a
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    subst : (a : Type) -> (P : (_x0 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (_x1 : P x) -> P y 
      a : Type P : (_x2 : a) -> Type x : a
        subst a P x [x] [Refl a x] = (\z : P x. z)
    constructor Bit : (_x0 : Nat) -> Type
    constructor I : Bit 1
    constructor O : Bit Z
    double : (_x1 : Nat) -> Nat 
      double Z = Z
      n : Nat
        double (S n) = S (S (double n))
    constructor Bin : (width : Nat) -> (value : Nat) -> Type
    constructor N : Bin Z Z
    constructor C : (width : Nat) -> (lsbVal : Nat) -> (lsb :R: Bit lsbVal) -> (restVal : Nat) -> (rest :R: Bin width restVal) -> Bin (S width) (plus lsbVal (double restVal))
    constructor TwoBits : (_x2 : Nat) -> (_x3 : Nat) -> (_x4 : Nat) -> Type
    constructor TB : (c : Nat) -> (x : Nat) -> (y : Nat) -> (hi' : Nat) -> (hi : Bit hi') -> (lo' : Nat) -> (lo : Bit lo') -> (pf : Id Nat (plus c (plus x y)) (plus lo' (double hi'))) -> TwoBits c x y
    adb : (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x5 : Bit c) -> (_x6 : Bit x) -> (_x7 : Bit y) -> TwoBits c x y 
      adb [Z] [Z] [Z] O O O = TB Z Z Z Z O Z O (Refl Nat Z)
      adb [1] [Z] [Z] I O O = TB 1 Z Z Z O 1 I (Refl Nat 1)
      adb [Z] [1] [Z] O I O = TB Z 1 Z Z O 1 I (Refl Nat 1)
      adb [Z] [Z] [1] O O I = TB Z Z 1 Z O 1 I (Refl Nat 1)
      adb [1] [1] [Z] I I O = TB 1 1 Z 1 I Z O (Refl Nat 2)
      adb [1] [Z] [1] I O I = TB 1 Z 1 1 I Z O (Refl Nat 2)
      adb [Z] [1] [1] O I I = TB Z 1 1 1 I Z O (Refl Nat 2)
      adb [1] [1] [1] I I I = TB 1 1 1 1 I 1 I (Refl Nat 3)
    add' : (w : Nat) -> (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x8 : Bit c) -> (_x9 : Bin w x) -> (_x10 : Bin w y) -> Bin (S w) (plus c (plus x y)) 
      c : Nat cb : Bit c
        add' [Z] c [Z] [Z] cb N N = C Z c cb Z N
      w : Nat c : Nat cb : Bit c xb' : Nat xb : Bit xb' xn' : Nat xn : Bin w xn' yb' : Nat yb : Bit yb' yn' : Nat yn : Bin w yn'
        add' ([S] w) c [plus xb' (double xn')] [plus yb' (double yn')] cb (C [w] xb' xb xn' xn) (C [w] yb' yb yn' yn) = 
          let f : (_x11 : TwoBits c xb' yb') -> Bin (S (S w)) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) 
            hi' : Nat hi : Bit hi' lo' : Nat lo : Bit lo' pf : Id Nat (plus c (plus xb' yb')) (plus lo' (double hi'))
              f ([TB] [c] [xb'] [yb'] hi' hi lo' lo pf) = 
                let postulate eq : Id Nat (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn'))))
                in subst Nat (Bin (S (S w))) (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) eq (C (S w) lo' lo (plus hi' (plus xn' yn')) (add' w hi' xn' yn' hi xn yn))
          in f (adb c xb' yb' cb xb yb)
    add : (w : Nat) -> (x : Nat) -> (y : Nat) -> (bx : Bin w x) -> (by : Bin w y) -> Bin (S w) (plus x y) = (\w : Nat. (\x : Nat. (\y : Nat. (\bx : Bin w x. (\by : Bin w y. add' w Z x y O bx by)))))
    foreign inputSize : Nat
    binVal : (_x12 : Bool) -> (_x13 : Nat) -> Nat 
      b : Bool
        binVal b Z = Z
      n : Nat
        binVal True (S n) = S (double (binVal False n))
      n : Nat
        binVal False (S n) = double (binVal True n)
    mkBin : (b : Bool) -> (w : Nat) -> Bin w (binVal b w) 
      b : Bool
        mkBin b Z = N
      n : Nat
        mkBin True (S n) = C n 1 I (binVal False n) (mkBin False n)
      n : Nat
        mkBin False (S n) = C n Z O (binVal True n) (mkBin True n)
    main : Bin (S inputSize) (plus (binVal True inputSize) (binVal False inputSize)) = 
      let
        x : Bin inputSize (binVal True inputSize) = mkBin True inputSize
        y : Bin inputSize (binVal False inputSize) = mkBin False inputSize
      in add inputSize (binVal True inputSize) (binVal False inputSize) x y
  in main

### Evarified ###

  let
    constructor Nat :1: Type
    constructor Z :2: Nat
    constructor S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        plus -9- Z -8- n = n
      m :10: Nat n :11: Nat
        plus -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    times :18: (_x2 :19: Nat) -> (_x3 :20: Nat) -> Nat 
      n :21: Nat
        times -23- Z -22- n = Z
      m :24: Nat n :25: Nat
        times -27- (S -28- m) -26- n = plus -30- n -29- (times -32- m -31- n)
    constructor Bool :33: Type
    constructor True :34: Bool
    constructor False :35: Bool
    not :36: (_x4 :37: Bool) -> Bool 
      not -38- True = False
      not -39- False = True
    constructor Unit :40: Type
    constructor MkUnit :41: Unit
    constructor Pair :42: (_x5 :43: Type) -> (_x6 :44: Type) -> Type
    constructor MkPair :45: (a :46: Type) -> (b :47: Type) -> (_x7 :48: a) -> (_x8 :49: b) -> Pair -51- a -50- b
    fst :52: (a :53: Type) -> (b :54: Type) -> (_x9 :55: Pair -57- a -56- b) -> a 
      a :58: Type b :59: Type x :60: a y :61: b
        fst -64- a -63- b -62- ([MkPair] -68- [a] -67- [b] -66- x -65- y) = x
    snd :69: (a :70: Type) -> (b :71: Type) -> (_x10 :72: Pair -74- a -73- b) -> b 
      a :75: Type b :76: Type x :77: a y :78: b
        snd -81- a -80- b -79- ([MkPair] -85- [a] -84- [b] -83- x -82- y) = y
    constructor Either :86: (_x11 :87: Type) -> (_x12 :88: Type) -> Type
    constructor Left :89: (a :90: Type) -> (b :91: Type) -> (_x13 :92: a) -> Either -94- a -93- b
    constructor Right :95: (a :96: Type) -> (b :97: Type) -> (_x14 :98: b) -> Either -100- a -99- b
    id :101: (a :102: Type) -> (x :103: a) -> a = (\a :104: Type. (\x :105: a. x))
    constructor Fin :106: (_x15 :107: Nat) -> Type
    constructor FZ :108: (n :109: Nat) -> Fin -110- (S -111- n)
    constructor FS :112: (n :113: Nat) -> (_x16 :114: Fin -115- n) -> Fin -116- (S -117- n)
    constructor Vect :118: (_x17 :119: Nat) -> (_x18 :120: Type) -> Type
    constructor VN :121: (a :122: Type) -> Vect -124- Z -123- a
    constructor VC :125: (n :126: Nat) -> (a :127: Type) -> (x :128: a) -> (xs :129: Vect -131- n -130- a) -> Vect -133- (S -134- n) -132- a
    constructor List :135: (_x19 :136: Type) -> Type
    constructor Nil :137: (a :138: Type) -> List -139- a
    constructor Cons :140: (a :141: Type) -> (x :142: a) -> (xs :143: List -144- a) -> List -145- a
    constructor Id :146: (a :147: Type) -> (x :148: a) -> (y :149: a) -> Type
    constructor Refl :150: (a :151: Type) -> (x :152: a) -> Id -155- a -154- x -153- x
    subst :156: (a :157: Type) -> (P :158: (_x0 :159: a) -> Type) -> (x :160: a) -> (y :161: a) -> (eq :162: Id -165- a -164- x -163- y) -> (_x1 :166: P -167- x) -> P -168- y 
      a :169: Type P :170: (_x2 :171: a) -> Type x :172: a
        subst -177- a -176- P -175- x -174- [x] -173- [Refl -179- a -178- x] = (\z :180: P -181- x. z)
    constructor Bit :182: (_x0 :183: Nat) -> Type
    constructor I :184: Bit -185- 1
    constructor O :187: Bit -188- Z
    double :189: (_x1 :190: Nat) -> Nat 
      double -191- Z = Z
      n :192: Nat
        double -193- (S -194- n) = S -195- (S -196- (double -197- n))
    constructor Bin :198: (width :199: Nat) -> (value :200: Nat) -> Type
    constructor N :201: Bin -203- Z -202- Z
    constructor C :204: (width :205: Nat) -> (lsbVal :206: Nat) -> (lsb :R: Bit -207- lsbVal) -> (restVal :208: Nat) -> (rest :R: Bin -210- width -209- restVal) -> Bin -212- (S -213- width) -211- (plus -215- lsbVal -214- (double -216- restVal))
    constructor TwoBits :217: (_x2 :218: Nat) -> (_x3 :219: Nat) -> (_x4 :220: Nat) -> Type
    constructor TB :221: (c :222: Nat) -> (x :223: Nat) -> (y :224: Nat) -> (hi' :225: Nat) -> (hi :226: Bit -227- hi') -> (lo' :228: Nat) -> (lo :229: Bit -230- lo') -> (pf :231: Id -234- Nat -233- (plus -236- c -235- (plus -238- x -237- y)) -232- (plus -240- lo' -239- (double -241- hi'))) -> TwoBits -244- c -243- x -242- y
    adb :245: (c :246: Nat) -> (x :247: Nat) -> (y :248: Nat) -> (_x5 :249: Bit -250- c) -> (_x6 :251: Bit -252- x) -> (_x7 :253: Bit -254- y) -> TwoBits -257- c -256- x -255- y 
      adb -263- [Z] -262- [Z] -261- [Z] -260- O -259- O -258- O = TB -271- Z -270- Z -269- Z -268- Z -267- O -266- Z -265- O -264- (Refl -273- Nat -272- Z)
      adb -279- [1] -278- [Z] -277- [Z] -276- I -275- O -274- O = TB -288- 1 -287- Z -286- Z -285- Z -284- O -283- 1 -282- I -281- (Refl -292- Nat -291- 1)
      adb -299- [Z] -298- [1] -297- [Z] -296- O -295- I -294- O = TB -308- Z -307- 1 -306- Z -305- Z -304- O -303- 1 -302- I -301- (Refl -312- Nat -311- 1)
      adb -319- [Z] -318- [Z] -317- [1] -316- O -315- O -314- I = TB -328- Z -327- Z -326- 1 -325- Z -324- O -323- 1 -322- I -321- (Refl -332- Nat -331- 1)
      adb -339- [1] -338- [1] -337- [Z] -336- I -335- I -334- O = TB -349- 1 -348- 1 -347- Z -346- 1 -345- I -344- Z -343- O -342- (Refl -354- Nat -353- 2)
      adb -362- [1] -361- [Z] -360- [1] -359- I -358- O -357- I = TB -372- 1 -371- Z -370- 1 -369- 1 -368- I -367- Z -366- O -365- (Refl -377- Nat -376- 2)
      adb -385- [Z] -384- [1] -383- [1] -382- O -381- I -380- I = TB -395- Z -394- 1 -393- 1 -392- 1 -391- I -390- Z -389- O -388- (Refl -400- Nat -399- 2)
      adb -408- [1] -407- [1] -406- [1] -405- I -404- I -403- I = TB -419- 1 -418- 1 -417- 1 -416- 1 -415- I -414- 1 -413- I -412- (Refl -426- Nat -425- 3)
    add' :430: (w :431: Nat) -> (c :432: Nat) -> (x :433: Nat) -> (y :434: Nat) -> (_x8 :435: Bit -436- c) -> (_x9 :437: Bin -439- w -438- x) -> (_x10 :440: Bin -442- w -441- y) -> Bin -444- (S -445- w) -443- (plus -447- c -446- (plus -449- x -448- y)) 
      c :450: Nat cb :451: Bit -452- c
        add' -459- [Z] -458- c -457- [Z] -456- [Z] -455- cb -454- N -453- N = C -464- Z -463- c -462- cb -461- Z -460- N
      w :465: Nat c :466: Nat cb :467: Bit -468- c xb' :469: Nat xb :470: Bit -471- xb' xn' :472: Nat xn :473: Bin -475- w -474- xn' yb' :476: Nat yb :477: Bit -478- yb' yn' :479: Nat yn :480: Bin -482- w -481- yn'
        add' -489- ([S] -490- w) -488- c -487- [plus -492- xb' -491- (double -493- xn')] -486- [plus -495- yb' -494- (double -496- yn')] -485- cb -484- (C -501- [w] -500- xb' -499- xb -498- xn' -497- xn) -483- (C -506- [w] -505- yb' -504- yb -503- yn' -502- yn) = 
          let f :507: (_x11 :508: TwoBits -511- c -510- xb' -509- yb') -> Bin -513- (S -514- (S -515- w)) -512- (plus -517- c -516- (plus -519- (plus -521- xb' -520- (double -522- xn')) -518- (plus -524- yb' -523- (double -525- yn')))) 
            hi' :526: Nat hi :527: Bit -528- hi' lo' :529: Nat lo :530: Bit -531- lo' pf :532: Id -535- Nat -534- (plus -537- c -536- (plus -539- xb' -538- yb')) -533- (plus -541- lo' -540- (double -542- hi'))
              f -543- ([TB] -551- [c] -550- [xb'] -549- [yb'] -548- hi' -547- hi -546- lo' -545- lo -544- pf) = 
                let postulate eq :552: Id -555- Nat -554- (plus -557- lo' -556- (double -558- (plus -560- hi' -559- (plus -562- xn' -561- yn')))) -553- (plus -564- c -563- (plus -566- (plus -568- xb' -567- (double -569- xn')) -565- (plus -571- yb' -570- (double -572- yn'))))
                in subst -578- Nat -577- (Bin -579- (S -580- (S -581- w))) -576- (plus -583- lo' -582- (double -584- (plus -586- hi' -585- (plus -588- xn' -587- yn')))) -575- (plus -590- c -589- (plus -592- (plus -594- xb' -593- (double -595- xn')) -591- (plus -597- yb' -596- (double -598- yn')))) -574- eq -573- (C -603- (S -604- w) -602- lo' -601- lo -600- (plus -606- hi' -605- (plus -608- xn' -607- yn')) -599- (add' -615- w -614- hi' -613- xn' -612- yn' -611- hi -610- xn -609- yn))
          in f -616- (adb -622- c -621- xb' -620- yb' -619- cb -618- xb -617- yb)
    add :623: (w :624: Nat) -> (x :625: Nat) -> (y :626: Nat) -> (bx :627: Bin -629- w -628- x) -> (by :630: Bin -632- w -631- y) -> Bin -634- (S -635- w) -633- (plus -637- x -636- y) = (\w :638: Nat. (\x :639: Nat. (\y :640: Nat. (\bx :641: Bin -643- w -642- x. (\by :644: Bin -646- w -645- y. add' -653- w -652- Z -651- x -650- y -649- O -648- bx -647- by)))))
    foreign inputSize :654: Nat
    binVal :655: (_x12 :656: Bool) -> (_x13 :657: Nat) -> Nat 
      b :658: Bool
        binVal -660- b -659- Z = Z
      n :661: Nat
        binVal -663- True -662- (S -664- n) = S -665- (double -666- (binVal -668- False -667- n))
      n :669: Nat
        binVal -671- False -670- (S -672- n) = double -673- (binVal -675- True -674- n)
    mkBin :676: (b :677: Bool) -> (w :678: Nat) -> Bin -680- w -679- (binVal -682- b -681- w) 
      b :683: Bool
        mkBin -685- b -684- Z = N
      n :686: Nat
        mkBin -688- True -687- (S -689- n) = C -694- n -693- 1 -692- I -691- (binVal -697- False -696- n) -690- (mkBin -699- False -698- n)
      n :700: Nat
        mkBin -702- False -701- (S -703- n) = C -708- n -707- Z -706- O -705- (binVal -710- True -709- n) -704- (mkBin -712- True -711- n)
    main :713: Bin -715- (S -716- inputSize) -714- (plus -718- (binVal -720- True -719- inputSize) -717- (binVal -722- False -721- inputSize)) = 
      let
        x :723: Bin -725- inputSize -724- (binVal -727- True -726- inputSize) = mkBin -729- True -728- inputSize
        y :730: Bin -732- inputSize -731- (binVal -734- False -733- inputSize) = mkBin -736- False -735- inputSize
      in add -741- inputSize -740- (binVal -743- True -742- inputSize) -739- (binVal -745- False -744- inputSize) -738- x -737- y
  in main

### Constraints ###

[] -> [14,15,28,111,117,134,186,194,195,196,213,280,289,290,293,300,309,310,313,320,329,330,333,340,341,350,351,352,355,356,363,364,373,374,375,378,379,386,387,396,397,398,401,402,409,410,411,420,421,422,423,424,427,428,429,445,460,462,490,497,499,502,504,514,515,580,581,599,601,604,635,664,665,672,689,690,692,695,703,704,706,713,716]
[4] -> [2,3,7,9,13]
[4,8] -> [7]
[4,12] -> [11]
[4,13,14] -> [10]
[4,15,16] -> [11]
[4,15,17] -> [10]
[5] -> [9,13,17,30,215,236,238,240,447,449,492,495,517,519,521,524,537,539,541,557,560,562,564,566,568,571,583,586,588,590,592,594,597,606,608,637,718]
[6] -> [8,12,16,29,214,235,237,239,446,448,491,494,516,518,520,523,536,538,540,556,559,561,563,565,567,570,582,585,587,589,591,593,596,605,607,636,717]
[7] -> [4,8]
[8] -> [6]
[9] -> [5]
[10] -> [4,13,14]
[11] -> [4,12]
[12] -> [6]
[13] -> [5]
[16] -> [6]
[17] -> [5]
[18] -> [2,3,4,23,27]
[18,22] -> [21]
[18,26] -> [25]
[18,27,28] -> [24]
[18,29,31] -> [25]
[18,29,32] -> [24]
[18,30] -> [25]
[19] -> [23,27,32]
[20] -> [22,26,31]
[21] -> [18,22]
[22] -> [20]
[23] -> [19]
[24] -> [18,27,28]
[25] -> [18,26]
[26] -> [20]
[27] -> [19]
[29] -> [6]
[30] -> [5]
[31] -> [20]
[32] -> [19]
[36] -> [34,35,38,39]
[37] -> [38,39]
[38] -> [37]
[39] -> [37]
[43] -> [51,57,74]
[44] -> [50,56,73]
[46] -> [68,85]
[47] -> [67,84]
[48] -> [66,83]
[49] -> [65,82]
[50] -> [44,56,73]
[51] -> [43]
[52] -> [60]
[52,62] -> [45]
[52,62,65] -> [61]
[52,62,66] -> [60]
[52,62,67] -> [59]
[52,62,68] -> [58]
[52,63] -> [59]
[52,64] -> [58]
[53] -> [64]
[54] -> [63]
[55] -> [62]
[56] -> [44,50]
[57] -> [43]
[58] -> [52,64]
[59] -> [52,63]
[60] -> [52,62,66]
[61] -> [52,62,65]
[62] -> [55]
[63] -> [54]
[64] -> [53]
[65] -> [49]
[66] -> [48]
[67] -> [47]
[68] -> [46]
[69] -> [78]
[69,79] -> [45]
[69,79,82] -> [78]
[69,79,83] -> [77]
[69,79,84] -> [76]
[69,79,85] -> [75]
[69,80] -> [76]
[69,81] -> [75]
[70] -> [81]
[71] -> [80]
[72] -> [79]
[73] -> [44,50]
[74] -> [43]
[75] -> [69,81]
[76] -> [69,80]
[77] -> [69,79,83]
[78] -> [69,79,82]
[79] -> [72]
[80] -> [71]
[81] -> [70]
[82] -> [49]
[83] -> [48]
[84] -> [47]
[85] -> [46]
[87] -> [94,100]
[88] -> [93,99]
[93] -> [88]
[94] -> [87]
[99] -> [88]
[100] -> [87]
[101] -> [105]
[102] -> [104]
[103] -> [105]
[104] -> [102]
[105] -> [103]
[107] -> [110,115,116]
[110] -> [107]
[115] -> [107]
[116] -> [107]
[119] -> [124,131,133]
[120] -> [123,130,132]
[123] -> [120]
[124] -> [119]
[130] -> [120]
[131] -> [119]
[132] -> [120]
[133] -> [119]
[136] -> [139,144,145]
[139] -> [136]
[144] -> [136]
[145] -> [136]
[147] -> [155,165,234,535,555]
[148] -> [154,164,233,534,554]
[149] -> [153,163,232,533,553]
[151] -> [179,273,292,312,332,354,377,400,426]
[152] -> [178,272,291,311,331,353,376,399,425]
[153] -> [149,163,232]
[154] -> [148]
[155] -> [147]
[156] -> [180]
[156,173] -> [150]
[156,173,178] -> [172]
[156,173,179] -> [169]
[156,174] -> [172]
[156,175] -> [172]
[156,176] -> [170]
[156,177] -> [169]
[157] -> [177,578]
[158] -> [176,577]
[159] -> [167,168,171,200]
[160] -> [175,576]
[161] -> [174,575]
[162] -> [173,574]
[163] -> [149,153,553]
[164] -> [148]
[165] -> [147]
[166] -> [180,573]
[167] -> [159,181,211]
[168] -> [159,181,512]
[169] -> [156,177]
[170] -> [156,176]
[171] -> [159,181]
[172] -> [156,175]
[173] -> [162]
[174] -> [161]
[175] -> [160]
[176] -> [158]
[177] -> [157]
[178] -> [152]
[179] -> [151]
[180] -> [166]
[181] -> [167,168,171]
[183] -> [185,188,207,227,230,250,252,254,436,452,468,471,478,528,531]
[185] -> [183,207,227,230,250,252,254]
[188] -> [183,207,227,230,250,252,254,436]
[189] -> [2,3,191,193]
[189,193,194] -> [192]
[189,195] -> [3]
[189,195,196,197] -> [192]
[190] -> [191,193,197,216,241,493,496,522,525,542,558,569,572,584,595,598,666,673]
[191] -> [190]
[192] -> [189,193,194]
[193] -> [190]
[197] -> [190]
[199] -> [203,210,212,439,442,444,475,482,513,579,629,632,634,643,646,680,715,725,732]
[200] -> [159,202,209,211,438,441,443,474,481,512,628,631,633,642,645,679,714,724,731]
[202] -> [200,209,438,441,679]
[203] -> [199]
[205] -> [464,501,506,603,694,708]
[206] -> [463,500,505,602,693,707]
[207] -> [183,185,188,452,471,478,531]
[208] -> [461,498,503,600,691,705]
[209] -> [200,202,443,474,481,679]
[210] -> [199]
[211] -> [167,200,438,441,443,679]
[212] -> [199]
[214] -> [6]
[215] -> [5]
[216] -> [190]
[218] -> [244,257,511]
[219] -> [243,256,510]
[220] -> [242,255,509]
[222] -> [271,288,308,328,349,372,395,419,551]
[223] -> [270,287,307,327,348,371,394,418,550]
[224] -> [269,286,306,326,347,370,393,417,549]
[225] -> [268,285,305,325,346,369,392,416,548]
[226] -> [267,284,304,324,345,368,391,415,547]
[227] -> [183,185,188,528]
[228] -> [266,283,303,323,344,367,390,414,546]
[229] -> [265,282,302,322,343,366,389,413,545]
[230] -> [183,185,188,531]
[231] -> [264,281,301,321,342,365,388,412,544]
[232] -> [149,153,533]
[233] -> [148]
[234] -> [147]
[235] -> [6]
[236] -> [5]
[237] -> [6]
[238] -> [5]
[239] -> [6]
[240] -> [5]
[241] -> [190]
[242] -> [220,255,509]
[243] -> [219]
[244] -> [218]
[245] -> [184,187,221,258,259,260,274,275,276,294,295,296,314,315,316,334,335,336,357,358,359,380,381,382,403,404,405]
[245,261] -> [2]
[245,262] -> [2]
[245,263] -> [2]
[245,264] -> [150]
[245,264,272] -> [2]
[245,264,273] -> [1]
[245,265] -> [187]
[245,266] -> [2]
[245,267] -> [187]
[245,268] -> [2]
[245,269] -> [2]
[245,270] -> [2]
[245,271] -> [2]
[245,277] -> [2]
[245,278] -> [2]
[245,279] -> [3]
[245,279,280] -> [2]
[245,281] -> [150]
[245,281,291] -> [3]
[245,281,291,293] -> [2]
[245,281,292] -> [1]
[245,282] -> [184]
[245,283] -> [3]
[245,283,290] -> [2]
[245,284] -> [187]
[245,285] -> [2]
[245,286] -> [2]
[245,287] -> [2]
[245,288] -> [3]
[245,288,289] -> [2]
[245,297] -> [2]
[245,298] -> [3]
[245,298,300] -> [2]
[245,299] -> [2]
[245,301] -> [150]
[245,301,311] -> [3]
[245,301,311,313] -> [2]
[245,301,312] -> [1]
[245,302] -> [184]
[245,303] -> [3]
[245,303,310] -> [2]
[245,304] -> [187]
[245,305] -> [2]
[245,306] -> [2]
[245,307] -> [3]
[245,307,309] -> [2]
[245,308] -> [2]
[245,317] -> [3]
[245,317,320] -> [2]
[245,318] -> [2]
[245,319] -> [2]
[245,321] -> [150]
[245,321,331] -> [3]
[245,321,331,333] -> [2]
[245,321,332] -> [1]
[245,322] -> [184]
[245,323] -> [3]
[245,323,330] -> [2]
[245,324] -> [187]
[245,325] -> [2]
[245,326] -> [3]
[245,326,329] -> [2]
[245,327] -> [2]
[245,328] -> [2]
[245,337] -> [2]
[245,338] -> [3]
[245,338,341] -> [2]
[245,339] -> [3]
[245,339,340] -> [2]
[245,342] -> [150]
[245,342,353] -> [3]
[245,342,353,355] -> [3]
[245,342,353,355,356] -> [2]
[245,342,354] -> [1]
[245,343] -> [187]
[245,344] -> [2]
[245,345] -> [184]
[245,346] -> [3]
[245,346,352] -> [2]
[245,347] -> [2]
[245,348] -> [3]
[245,348,351] -> [2]
[245,349] -> [3]
[245,349,350] -> [2]
[245,360] -> [3]
[245,360,364] -> [2]
[245,361] -> [2]
[245,362] -> [3]
[245,362,363] -> [2]
[245,365] -> [150]
[245,365,376] -> [3]
[245,365,376,378] -> [3]
[245,365,376,378,379] -> [2]
[245,365,377] -> [1]
[245,366] -> [187]
[245,367] -> [2]
[245,368] -> [184]
[245,369] -> [3]
[245,369,375] -> [2]
[245,370] -> [3]
[245,370,374] -> [2]
[245,371] -> [2]
[245,372] -> [3]
[245,372,373] -> [2]
[245,383] -> [3]
[245,383,387] -> [2]
[245,384] -> [3]
[245,384,386] -> [2]
[245,385] -> [2]
[245,388] -> [150]
[245,388,399] -> [3]
[245,388,399,401] -> [3]
[245,388,399,401,402] -> [2]
[245,388,400] -> [1]
[245,389] -> [187]
[245,390] -> [2]
[245,391] -> [184]
[245,392] -> [3]
[245,392,398] -> [2]
[245,393] -> [3]
[245,393,397] -> [2]
[245,394] -> [3]
[245,394,396] -> [2]
[245,395] -> [2]
[245,406] -> [3]
[245,406,411] -> [2]
[245,407] -> [3]
[245,407,410] -> [2]
[245,408] -> [3]
[245,408,409] -> [2]
[245,412] -> [150]
[245,412,425] -> [3]
[245,412,425,427] -> [3]
[245,412,425,427,428] -> [3]
[245,412,425,427,428,429] -> [2]
[245,412,426] -> [1]
[245,413] -> [184]
[245,414] -> [3]
[245,414,424] -> [2]
[245,415] -> [184]
[245,416] -> [3]
[245,416,423] -> [2]
[245,417] -> [3]
[245,417,422] -> [2]
[245,418] -> [3]
[245,418,421] -> [2]
[245,419] -> [3]
[245,419,420] -> [2]
[246] -> [263,279,299,319,339,362,385,408,622]
[247] -> [262,278,298,318,338,361,384,407,621]
[248] -> [261,277,297,317,337,360,383,406,620]
[249] -> [260,276,296,316,336,359,382,405,619]
[250] -> [183,185,188,468]
[251] -> [259,275,295,315,335,358,381,404,618]
[252] -> [183,185,188,471]
[253] -> [258,274,294,314,334,357,380,403,617]
[254] -> [183,185,188,478]
[255] -> [220,242,509]
[256] -> [219]
[257] -> [218]
[258] -> [253]
[259] -> [251]
[260] -> [249]
[261] -> [248]
[262] -> [247]
[263] -> [246]
[264] -> [231]
[265] -> [229]
[266] -> [228]
[267] -> [226]
[268] -> [225]
[269] -> [224]
[270] -> [223]
[271] -> [222]
[272] -> [152]
[273] -> [151]
[274] -> [253]
[275] -> [251]
[276] -> [249]
[277] -> [248]
[278] -> [247]
[279] -> [246]
[281] -> [231]
[282] -> [229]
[283] -> [228]
[284] -> [226]
[285] -> [225]
[286] -> [224]
[287] -> [223]
[288] -> [222]
[291] -> [152]
[292] -> [151]
[294] -> [253]
[295] -> [251]
[296] -> [249]
[297] -> [248]
[298] -> [247]
[299] -> [246]
[301] -> [231]
[302] -> [229]
[303] -> [228]
[304] -> [226]
[305] -> [225]
[306] -> [224]
[307] -> [223]
[308] -> [222]
[311] -> [152]
[312] -> [151]
[314] -> [253]
[315] -> [251]
[316] -> [249]
[317] -> [248]
[318] -> [247]
[319] -> [246]
[321] -> [231]
[322] -> [229]
[323] -> [228]
[324] -> [226]
[325] -> [225]
[326] -> [224]
[327] -> [223]
[328] -> [222]
[331] -> [152]
[332] -> [151]
[334] -> [253]
[335] -> [251]
[336] -> [249]
[337] -> [248]
[338] -> [247]
[339] -> [246]
[342] -> [231]
[343] -> [229]
[344] -> [228]
[345] -> [226]
[346] -> [225]
[347] -> [224]
[348] -> [223]
[349] -> [222]
[353] -> [152]
[354] -> [151]
[357] -> [253]
[358] -> [251]
[359] -> [249]
[360] -> [248]
[361] -> [247]
[362] -> [246]
[365] -> [231]
[366] -> [229]
[367] -> [228]
[368] -> [226]
[369] -> [225]
[370] -> [224]
[371] -> [223]
[372] -> [222]
[376] -> [152]
[377] -> [151]
[380] -> [253]
[381] -> [251]
[382] -> [249]
[383] -> [248]
[384] -> [247]
[385] -> [246]
[388] -> [231]
[389] -> [229]
[390] -> [228]
[391] -> [226]
[392] -> [225]
[393] -> [224]
[394] -> [223]
[395] -> [222]
[399] -> [152]
[400] -> [151]
[403] -> [253]
[404] -> [251]
[405] -> [249]
[406] -> [248]
[407] -> [247]
[408] -> [246]
[412] -> [231]
[413] -> [229]
[414] -> [228]
[415] -> [226]
[416] -> [225]
[417] -> [224]
[418] -> [223]
[419] -> [222]
[425] -> [152]
[426] -> [151]
[430] -> [201,204,453,454,483,484,507]
[430,455] -> [451]
[430,456] -> [2]
[430,457] -> [2]
[430,458] -> [450]
[430,459] -> [2]
[430,460] -> [201]
[430,461] -> [2]
[430,462] -> [451]
[430,463] -> [450]
[430,464] -> [2]
[430,483,502] -> [480]
[430,483,503] -> [479]
[430,483,504] -> [477]
[430,483,505] -> [476]
[430,483,506] -> [465]
[430,484,497] -> [473]
[430,484,498] -> [472]
[430,484,499] -> [470]
[430,484,500] -> [469]
[430,484,501] -> [465]
[430,485] -> [467]
[430,486] -> [4]
[430,486,494] -> [189]
[430,486,494,496] -> [479]
[430,486,495] -> [476]
[430,487] -> [4]
[430,487,491] -> [189]
[430,487,491,493] -> [472]
[430,487,492] -> [469]
[430,488] -> [466]
[430,489] -> [3]
[430,489,490] -> [465]
[430,616] -> [245]
[430,616,617] -> [477]
[430,616,618] -> [470]
[430,616,619] -> [467]
[430,616,620] -> [476]
[430,616,621] -> [469]
[430,616,622] -> [466]
[431] -> [459,489,615,653]
[432] -> [458,488,614,652]
[433] -> [457,487,613,651]
[434] -> [456,486,612,650]
[435] -> [455,485,611,649]
[436] -> [183,188,452,468,528]
[437] -> [454,484,610,648]
[438] -> [200,202,211,474,642]
[439] -> [199]
[440] -> [453,483,609,647]
[441] -> [200,202,211,481,645]
[442] -> [199]
[443] -> [200,209,211,512,633]
[444] -> [199]
[446] -> [6]
[447] -> [5]
[448] -> [6]
[449] -> [5]
[450] -> [430,458]
[451] -> [430,455]
[452] -> [183,207,436]
[453] -> [440]
[454] -> [437]
[455] -> [435]
[456] -> [434]
[457] -> [433]
[458] -> [432]
[459] -> [431]
[461] -> [208]
[463] -> [206]
[464] -> [205]
[465] -> [430,489,490]
[466] -> [430,488]
[467] -> [430,485]
[468] -> [183,250,436]
[469] -> [430,484,500]
[470] -> [430,484,499]
[471] -> [183,207,252]
[472] -> [430,484,498]
[473] -> [430,484,497]
[474] -> [200,209,438]
[475] -> [199]
[476] -> [430,483,505]
[477] -> [430,483,504]
[478] -> [183,207,254]
[479] -> [430,483,503]
[480] -> [430,483,502]
[481] -> [200,209,441]
[482] -> [199]
[483] -> [440]
[484] -> [437]
[485] -> [435]
[486] -> [434]
[487] -> [433]
[488] -> [432]
[489] -> [431]
[491] -> [6]
[492] -> [5]
[493] -> [190]
[494] -> [6]
[495] -> [5]
[496] -> [190]
[498] -> [208]
[500] -> [206]
[501] -> [205]
[503] -> [208]
[505] -> [206]
[506] -> [205]
[507] -> [156]
[507,543] -> [221]
[507,543,544] -> [532]
[507,543,545] -> [530]
[507,543,546] -> [529]
[507,543,547] -> [527]
[507,543,548] -> [526]
[507,543,549] -> [476]
[507,543,550] -> [469]
[507,543,551] -> [466]
[507,573] -> [204]
[507,573,599] -> [430]
[507,573,599,609] -> [480]
[507,573,599,610] -> [473]
[507,573,599,611] -> [527]
[507,573,599,612] -> [479]
[507,573,599,613] -> [472]
[507,573,599,614] -> [526]
[507,573,599,615] -> [465]
[507,573,600] -> [4]
[507,573,600,605] -> [4]
[507,573,600,605,607] -> [479]
[507,573,600,605,608] -> [472]
[507,573,600,606] -> [526]
[507,573,601] -> [530]
[507,573,602] -> [529]
[507,573,603] -> [3]
[507,573,603,604] -> [465]
[507,574] -> [552]
[507,575] -> [4]
[507,575,589] -> [4]
[507,575,589,591] -> [4]
[507,575,589,591,596] -> [189]
[507,575,589,591,596,598] -> [479]
[507,575,589,591,597] -> [476]
[507,575,589,592] -> [4]
[507,575,589,592,593] -> [189]
[507,575,589,592,593,595] -> [472]
[507,575,589,592,594] -> [469]
[507,575,590] -> [466]
[507,576] -> [4]
[507,576,582] -> [189]
[507,576,582,584] -> [4]
[507,576,582,584,585] -> [4]
[507,576,582,584,585,587] -> [479]
[507,576,582,584,585,588] -> [472]
[507,576,582,584,586] -> [526]
[507,576,583] -> [529]
[507,577] -> [198]
[507,577,579] -> [3]
[507,577,579,580] -> [3]
[507,577,579,580,581] -> [465]
[507,578] -> [1]
[508] -> [543,616]
[509] -> [220,242,255]
[510] -> [219]
[511] -> [218]
[512] -> [168,200,443]
[513] -> [199]
[516] -> [6]
[517] -> [5]
[518] -> [6]
[519] -> [5]
[520] -> [6]
[521] -> [5]
[522] -> [190]
[523] -> [6]
[524] -> [5]
[525] -> [190]
[526] -> [507,543,548]
[527] -> [507,543,547]
[528] -> [183,227,436]
[529] -> [507,543,546]
[530] -> [507,543,545]
[531] -> [183,207,230]
[532] -> [507,543,544]
[533] -> [149,232]
[534] -> [148]
[535] -> [147]
[536] -> [6]
[537] -> [5]
[538] -> [6]
[539] -> [5]
[540] -> [6]
[541] -> [5]
[542] -> [190]
[543] -> [508]
[544] -> [231]
[545] -> [229]
[546] -> [228]
[547] -> [226]
[548] -> [225]
[549] -> [224]
[550] -> [223]
[551] -> [222]
[553] -> [149,163]
[554] -> [148]
[555] -> [147]
[556] -> [6]
[557] -> [5]
[558] -> [190]
[559] -> [6]
[560] -> [5]
[561] -> [6]
[562] -> [5]
[563] -> [6]
[564] -> [5]
[565] -> [6]
[566] -> [5]
[567] -> [6]
[568] -> [5]
[569] -> [190]
[570] -> [6]
[571] -> [5]
[572] -> [190]
[573] -> [166]
[574] -> [162]
[575] -> [161]
[576] -> [160]
[577] -> [158]
[578] -> [157]
[579] -> [199]
[582] -> [6]
[583] -> [5]
[584] -> [190]
[585] -> [6]
[586] -> [5]
[587] -> [6]
[588] -> [5]
[589] -> [6]
[590] -> [5]
[591] -> [6]
[592] -> [5]
[593] -> [6]
[594] -> [5]
[595] -> [190]
[596] -> [6]
[597] -> [5]
[598] -> [190]
[600] -> [208]
[602] -> [206]
[603] -> [205]
[605] -> [6]
[606] -> [5]
[607] -> [6]
[608] -> [5]
[609] -> [440]
[610] -> [437]
[611] -> [435]
[612] -> [434]
[613] -> [433]
[614] -> [432]
[615] -> [431]
[616] -> [508]
[617] -> [253]
[618] -> [251]
[619] -> [249]
[620] -> [248]
[621] -> [247]
[622] -> [246]
[623] -> [430]
[623,647] -> [644]
[623,648] -> [641]
[623,649] -> [187]
[623,650] -> [640]
[623,651] -> [639]
[623,652] -> [2]
[623,653] -> [638]
[624] -> [638,741]
[625] -> [639,740]
[626] -> [640,739]
[627] -> [641,738]
[628] -> [200,642,724]
[629] -> [199]
[630] -> [644,737]
[631] -> [200,645,731]
[632] -> [199]
[633] -> [200,443,714]
[634] -> [199]
[636] -> [6]
[637] -> [5]
[638] -> [624]
[639] -> [625]
[640] -> [626]
[641] -> [627]
[642] -> [200,438,628]
[643] -> [199]
[644] -> [630]
[645] -> [200,441,631]
[646] -> [199]
[647] -> [440]
[648] -> [437]
[649] -> [435]
[650] -> [434]
[651] -> [433]
[652] -> [432]
[653] -> [431]
[655] -> [2,3,34,35,189,659,662,663,670,671]
[655,660] -> [658]
[655,662,664] -> [661]
[655,665] -> [189]
[655,665,666,667] -> [661]
[655,665,666,668] -> [35]
[655,670,672] -> [669]
[655,673,674] -> [669]
[655,673,675] -> [34]
[656] -> [660,663,668,671,675,682,697,710,720,722,727,734,743,745]
[657] -> [659,662,667,670,674,681,696,709,719,721,726,733,742,744]
[658] -> [655,660]
[659] -> [657]
[660] -> [656]
[661] -> [655,662,664]
[662] -> [657]
[663] -> [656]
[666] -> [190]
[667] -> [657]
[668] -> [656]
[669] -> [655,670,672]
[670] -> [657]
[671] -> [656]
[673] -> [190]
[674] -> [657]
[675] -> [656]
[676] -> [2,3,34,35,201,204,684,687,688,701,702]
[676,685] -> [683]
[676,687,689] -> [686]
[676,690,698] -> [686]
[676,690,699] -> [35]
[676,691] -> [655]
[676,691,696] -> [686]
[676,691,697] -> [35]
[676,692] -> [184]
[676,693] -> [3]
[676,693,695] -> [2]
[676,694] -> [686]
[676,701,703] -> [700]
[676,704,711] -> [700]
[676,704,712] -> [34]
[676,705] -> [655]
[676,705,709] -> [700]
[676,705,710] -> [34]
[676,706] -> [187]
[676,707] -> [2]
[676,708] -> [700]
[677] -> [685,688,699,702,712,729,736]
[678] -> [684,687,698,701,711,728,735]
[679] -> [200,202,209,211,724,731]
[680] -> [199]
[681] -> [657]
[682] -> [656]
[683] -> [676,685]
[684] -> [678]
[685] -> [677]
[686] -> [676,687,689]
[687] -> [678]
[688] -> [677]
[691] -> [208]
[693] -> [206]
[694] -> [205]
[696] -> [657]
[697] -> [656]
[698] -> [678]
[699] -> [677]
[700] -> [676,701,703]
[701] -> [678]
[702] -> [677]
[705] -> [208]
[707] -> [206]
[708] -> [205]
[709] -> [657]
[710] -> [656]
[711] -> [678]
[712] -> [677]
[713] -> [623]
[713,737] -> [730]
[713,738] -> [723]
[713,739] -> [655]
[713,739,744] -> [654]
[713,739,745] -> [35]
[713,740] -> [655]
[713,740,742] -> [654]
[713,740,743] -> [34]
[713,741] -> [654]
[714] -> [200,633]
[715] -> [199]
[717] -> [6]
[718] -> [5]
[719] -> [657]
[720] -> [656]
[721] -> [657]
[722] -> [656]
[723] -> [676]
[723,728] -> [654]
[723,729] -> [34]
[724] -> [200,628,679]
[725] -> [199]
[726] -> [657]
[727] -> [656]
[728] -> [678]
[729] -> [677]
[730] -> [676]
[730,735] -> [654]
[730,736] -> [35]
[731] -> [200,631,679]
[732] -> [199]
[733] -> [657]
[734] -> [656]
[735] -> [678]
[736] -> [677]
[737] -> [630]
[738] -> [627]
[739] -> [626]
[740] -> [625]
[741] -> [624]
[742] -> [657]
[743] -> [656]
[744] -> [657]
[745] -> [656]

### Solution ###

[2,3,14,15,28,34,35,111,117,134,156,166,180,184,186,187,194,195,196,201,204,213,221,226,229,245,249,251,253,258,259,260,265,267,274,275,276,280,282,284,289,290,293,294,295,296,300,302,304,309,310,313,314,315,316,320,322,324,329,330,333,334,335,336,340,341,343,345,350,351,352,355,356,357,358,359,363,364,366,368,373,374,375,378,379,380,381,382,386,387,389,391,396,397,398,401,402,403,404,405,409,410,411,413,415,420,421,422,423,424,427,428,429,430,435,437,440,445,451,453,454,455,460,462,467,470,473,477,480,483,484,485,490,497,499,502,504,507,508,514,515,527,530,543,545,547,573,580,581,599,601,604,609,610,611,616,617,618,619,623,627,630,635,641,644,647,648,649,654,664,665,672,676,677,678,683,684,685,686,687,688,689,690,692,695,698,699,700,701,702,703,704,706,711,712,713,716,723,728,729,730,735,736,737,738,R]

### Annotated ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        snd -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: (_x19 :E: Type) -> Type
    constructor Nil :E: (a :E: Type) -> List -E- a
    constructor Cons :E: (a :E: Type) -> (x :E: a) -> (xs :E: List -E- a) -> List -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        subst -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :R: Bit -E- 1
    constructor O :R: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      double -E- Z = Z
      n :E: Nat
        double -E- (S -R- n) = S -R- (S -R- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :R: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :R: Bit -E- hi') -> (lo' :E: Nat) -> (lo :R: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :R: Bit -E- c) -> (_x6 :R: Bit -E- x) -> (_x7 :R: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      adb -E- [Z] -E- [Z] -E- [Z] -R- O -R- O -R- O = TB -E- Z -E- Z -E- Z -E- Z -R- O -E- Z -R- O -E- (Refl -E- Nat -E- Z)
      adb -E- [1] -E- [Z] -E- [Z] -R- I -R- O -R- O = TB -E- 1 -E- Z -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [1] -E- [Z] -R- O -R- I -R- O = TB -E- Z -E- 1 -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [Z] -E- [1] -R- O -R- O -R- I = TB -E- Z -E- Z -E- 1 -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [1] -E- [1] -E- [Z] -R- I -R- I -R- O = TB -E- 1 -E- 1 -E- Z -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [Z] -E- [1] -R- I -R- O -R- I = TB -E- 1 -E- Z -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [Z] -E- [1] -E- [1] -R- O -R- I -R- I = TB -E- Z -E- 1 -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [1] -E- [1] -R- I -R- I -R- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -R- I -E- 1 -R- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :E: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :R: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :R: Bit -E- c
        add' -E- [Z] -E- c -E- [Z] -E- [Z] -R- cb -R- N -R- N = C -E- Z -E- c -R- cb -E- Z -R- N
      w :E: Nat c :E: Nat cb :R: Bit -E- c xb' :E: Nat xb :R: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :R: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        add' -E- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -R- cb -R- (C -E- [w] -E- xb' -R- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -R- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :R: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :R: Bit -E- hi' lo' :E: Nat lo :R: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              f -R- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -R- hi -E- lo' -R- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -R- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -E- w -E- hi' -E- xn' -E- yn' -R- hi -R- xn -R- yn))
          in f -R- (adb -E- c -E- xb' -E- yb' -R- cb -R- xb -R- yb)
    add :R: (w :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :E: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -E- w -E- Z -E- x -E- y -R- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        binVal -E- b -E- Z = Z
      n :E: Nat
        binVal -E- True -E- (S -R- n) = S -R- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        binVal -E- False -E- (S -R- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :R: Bool
        mkBin -R- b -R- Z = N
      n :R: Nat
        mkBin -R- True -R- (S -R- n) = C -E- n -E- 1 -R- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        mkBin -R- False -R- (S -R- n) = C -E- n -E- Z -R- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -E- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Specialised ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        snd -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: (_x19 :E: Type) -> Type
    constructor Nil :E: (a :E: Type) -> List -E- a
    constructor Cons :E: (a :E: Type) -> (x :E: a) -> (xs :E: List -E- a) -> List -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        subst -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :R: Bit -E- 1
    constructor O :R: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      double -E- Z = Z
      n :E: Nat
        double -E- (S -R- n) = S -R- (S -R- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :R: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :R: Bit -E- hi') -> (lo' :E: Nat) -> (lo :R: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :R: Bit -E- c) -> (_x6 :R: Bit -E- x) -> (_x7 :R: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      adb -E- [Z] -E- [Z] -E- [Z] -R- O -R- O -R- O = TB -E- Z -E- Z -E- Z -E- Z -R- O -E- Z -R- O -E- (Refl -E- Nat -E- Z)
      adb -E- [1] -E- [Z] -E- [Z] -R- I -R- O -R- O = TB -E- 1 -E- Z -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [1] -E- [Z] -R- O -R- I -R- O = TB -E- Z -E- 1 -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [Z] -E- [1] -R- O -R- O -R- I = TB -E- Z -E- Z -E- 1 -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [1] -E- [1] -E- [Z] -R- I -R- I -R- O = TB -E- 1 -E- 1 -E- Z -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [Z] -E- [1] -R- I -R- O -R- I = TB -E- 1 -E- Z -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [Z] -E- [1] -E- [1] -R- O -R- I -R- I = TB -E- Z -E- 1 -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [1] -E- [1] -R- I -R- I -R- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -R- I -E- 1 -R- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :E: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :R: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :R: Bit -E- c
        add' -E- [Z] -E- c -E- [Z] -E- [Z] -R- cb -R- N -R- N = C -E- Z -E- c -R- cb -E- Z -R- N
      w :E: Nat c :E: Nat cb :R: Bit -E- c xb' :E: Nat xb :R: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :R: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        add' -E- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -R- cb -R- (C -E- [w] -E- xb' -R- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -R- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :R: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :R: Bit -E- hi' lo' :E: Nat lo :R: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              f -R- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -R- hi -E- lo' -R- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -R- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -E- w -E- hi' -E- xn' -E- yn' -R- hi -R- xn -R- yn))
          in f -R- (adb -E- c -E- xb' -E- yb' -R- cb -R- xb -R- yb)
    add :R: (w :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :E: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -E- w -E- Z -E- x -E- y -R- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        binVal -E- b -E- Z = Z
      n :E: Nat
        binVal -E- True -E- (S -R- n) = S -R- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        binVal -E- False -E- (S -R- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :R: Bool
        mkBin -R- b -R- Z = N
      n :R: Nat
        mkBin -R- True -R- (S -R- n) = C -E- n -E- 1 -R- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        mkBin -R- False -R- (S -R- n) = C -E- n -E- Z -R- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -E- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Final annotation ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        snd -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: (_x19 :E: Type) -> Type
    constructor Nil :E: (a :E: Type) -> List -E- a
    constructor Cons :E: (a :E: Type) -> (x :E: a) -> (xs :E: List -E- a) -> List -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        subst -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :R: Bit -E- 1
    constructor O :R: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      double -E- Z = Z
      n :E: Nat
        double -E- (S -R- n) = S -R- (S -R- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :R: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :R: Bit -E- hi') -> (lo' :E: Nat) -> (lo :R: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :R: Bit -E- c) -> (_x6 :R: Bit -E- x) -> (_x7 :R: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      adb -E- [Z] -E- [Z] -E- [Z] -R- O -R- O -R- O = TB -E- Z -E- Z -E- Z -E- Z -R- O -E- Z -R- O -E- (Refl -E- Nat -E- Z)
      adb -E- [1] -E- [Z] -E- [Z] -R- I -R- O -R- O = TB -E- 1 -E- Z -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [1] -E- [Z] -R- O -R- I -R- O = TB -E- Z -E- 1 -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [Z] -E- [1] -R- O -R- O -R- I = TB -E- Z -E- Z -E- 1 -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [1] -E- [1] -E- [Z] -R- I -R- I -R- O = TB -E- 1 -E- 1 -E- Z -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [Z] -E- [1] -R- I -R- O -R- I = TB -E- 1 -E- Z -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [Z] -E- [1] -E- [1] -R- O -R- I -R- I = TB -E- Z -E- 1 -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [1] -E- [1] -R- I -R- I -R- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -R- I -E- 1 -R- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :E: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :R: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :R: Bit -E- c
        add' -E- [Z] -E- c -E- [Z] -E- [Z] -R- cb -R- N -R- N = C -E- Z -E- c -R- cb -E- Z -R- N
      w :E: Nat c :E: Nat cb :R: Bit -E- c xb' :E: Nat xb :R: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :R: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        add' -E- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -R- cb -R- (C -E- [w] -E- xb' -R- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -R- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :R: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :R: Bit -E- hi' lo' :E: Nat lo :R: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              f -R- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -R- hi -E- lo' -R- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -R- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -E- w -E- hi' -E- xn' -E- yn' -R- hi -R- xn -R- yn))
          in f -R- (adb -E- c -E- xb' -E- yb' -R- cb -R- xb -R- yb)
    add :R: (w :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :E: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -E- w -E- Z -E- x -E- y -R- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        binVal -E- b -E- Z = Z
      n :E: Nat
        binVal -E- True -E- (S -R- n) = S -R- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        binVal -E- False -E- (S -R- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :R: Bool
        mkBin -R- b -R- Z = N
      n :R: Nat
        mkBin -R- True -R- (S -R- n) = C -E- n -E- 1 -R- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        mkBin -R- False -R- (S -R- n) = C -E- n -E- Z -R- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -E- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    subst 
      subst = (\z. z)
    constructor I : Bit
    constructor O : Bit
    constructor N : Bin
    constructor C : (lsb) -> (rest) -> Bin
    constructor TB : (hi) -> (lo) -> TwoBits
    adb 
      adb O O O = TB O O
      adb I O O = TB O I
      adb O I O = TB O I
      adb O O I = TB O I
      adb I I O = TB I O
      adb I O I = TB I O
      adb O I I = TB I O
      adb I I I = TB I I
    add' 
      add' cb N N = C cb N
      add' cb (C xb xn) (C yb yn) = 
        let f 
          f ([_] hi lo) = subst (C lo (add' hi xn yn))
        in f (adb cb xb yb)
    add = (\bx. (\by. add' O bx by))
    foreign inputSize
    mkBin 
      mkBin b Z = N
      mkBin True (S n) = C I (mkBin False n)
      mkBin False (S n) = C O (mkBin True n)
    main = 
      let
        x = mkBin True inputSize
        y = mkBin False inputSize
      in add x y
  in main

### Intermediate representation ###

let Z = constructor 0
  in let S = constructor 1
    in let True = constructor 0
      in let False = constructor 0
        in let subst = \z. z
          in let I = constructor 0
            in let O = constructor 0
              in let N = constructor 0
                in let C = constructor 2
                  in let TB = constructor 2
                    in let adb = \_pv0. \_pv1. \_pv2.
                      case _pv0 of
                        I => case _pv1 of
                          I => case _pv2 of
                            I => ((TB I) I)
                            O => ((TB I) O)
                          O => case _pv2 of
                            I => ((TB I) O)
                            O => ((TB O) I)
                        O => case _pv1 of
                          I => case _pv2 of
                            I => ((TB I) O)
                            O => ((TB O) I)
                          O => case _pv2 of
                            I => ((TB O) I)
                            O => ((TB O) O)
                      in let add' = \_pv0. \_pv1. \_pv2.
                        case _pv1 of
                          C _pv3 _pv4 => case _pv2 of
                            C _pv5 _pv6 => let f = \_pv7.
                              case _pv7 of
                                _ _pv8 _pv9 => (subst ((C _pv9) (((add' _pv8) _pv4) _pv6)))
                              in (f (((adb _pv0) _pv3) _pv5))
                          N => ((C _pv0) N)
                        in let add = \bx. \by. (((add' O) bx) by)
                          in let inputSize = foreign "(rts-arg-peano 'Z 'S 0)"
                            in let mkBin = \_pv0. \_pv1.
                              case _pv1 of
                                Z => N
                                _ => case _pv0 of
                                  False => case _pv1 of
                                    S _pv2 => ((C O) ((mkBin True) _pv2))
                                  True => case _pv1 of
                                    S _pv2 => ((C I) ((mkBin False) _pv2))
                              in let main = let x = ((mkBin True) inputSize)
                                in let y = ((mkBin False) inputSize)
                                  in ((add x) y)
                                in main

### Normal forms ###

unerased:
  
  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        plus Z n = n
      m : Nat n : Nat
        plus (S m) n = S (plus m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    subst : (a : Type) -> (P : (_x0 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (_x1 : P x) -> P y 
      a : Type P : (_x2 : a) -> Type x : a
        subst a P x [x] [Refl a x] = (\z : P x. z)
    constructor Bit : (_x0 : Nat) -> Type
    constructor I : Bit 1
    constructor O : Bit Z
    double : (_x1 : Nat) -> Nat 
      double Z = Z
      n : Nat
        double (S n) = S (S (double n))
    constructor Bin : (width : Nat) -> (value : Nat) -> Type
    constructor N : Bin Z Z
    constructor C : (width : Nat) -> (lsbVal : Nat) -> (lsb :R: Bit lsbVal) -> (restVal : Nat) -> (rest :R: Bin width restVal) -> Bin (S width) (plus lsbVal (double restVal))
    constructor TwoBits : (_x2 : Nat) -> (_x3 : Nat) -> (_x4 : Nat) -> Type
    constructor TB : (c : Nat) -> (x : Nat) -> (y : Nat) -> (hi' : Nat) -> (hi : Bit hi') -> (lo' : Nat) -> (lo : Bit lo') -> (pf : Id Nat (plus c (plus x y)) (plus lo' (double hi'))) -> TwoBits c x y
    adb : (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x5 : Bit c) -> (_x6 : Bit x) -> (_x7 : Bit y) -> TwoBits c x y 
      adb [Z] [Z] [Z] O O O = TB Z Z Z Z O Z O (Refl Nat Z)
      adb [1] [Z] [Z] I O O = TB 1 Z Z Z O 1 I (Refl Nat 1)
      adb [Z] [1] [Z] O I O = TB Z 1 Z Z O 1 I (Refl Nat 1)
      adb [Z] [Z] [1] O O I = TB Z Z 1 Z O 1 I (Refl Nat 1)
      adb [1] [1] [Z] I I O = TB 1 1 Z 1 I Z O (Refl Nat 2)
      adb [1] [Z] [1] I O I = TB 1 Z 1 1 I Z O (Refl Nat 2)
      adb [Z] [1] [1] O I I = TB Z 1 1 1 I Z O (Refl Nat 2)
      adb [1] [1] [1] I I I = TB 1 1 1 1 I 1 I (Refl Nat 3)
    add' : (w : Nat) -> (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x8 : Bit c) -> (_x9 : Bin w x) -> (_x10 : Bin w y) -> Bin (S w) (plus c (plus x y)) 
      c : Nat cb : Bit c
        add' [Z] c [Z] [Z] cb N N = C Z c cb Z N
      w : Nat c : Nat cb : Bit c xb' : Nat xb : Bit xb' xn' : Nat xn : Bin w xn' yb' : Nat yb : Bit yb' yn' : Nat yn : Bin w yn'
        add' ([S] w) c [plus xb' (double xn')] [plus yb' (double yn')] cb (C [w] xb' xb xn' xn) (C [w] yb' yb yn' yn) = 
          let f : (_x11 : TwoBits c xb' yb') -> Bin (S (S w)) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) 
            hi' : Nat hi : Bit hi' lo' : Nat lo : Bit lo' pf : Id Nat (plus c (plus xb' yb')) (plus lo' (double hi'))
              f ([TB] [c] [xb'] [yb'] hi' hi lo' lo pf) = 
                let postulate eq : Id Nat (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn'))))
                in subst Nat (Bin (S (S w))) (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) eq (C (S w) lo' lo (plus hi' (plus xn' yn')) (add' w hi' xn' yn' hi xn yn))
          in f (adb c xb' yb' cb xb yb)
    foreign inputSize : Nat
    binVal : (_x12 : Bool) -> (_x13 : Nat) -> Nat 
      b : Bool
        binVal b Z = Z
      n : Nat
        binVal True (S n) = S (double (binVal False n))
      n : Nat
        binVal False (S n) = double (binVal True n)
    mkBin : (b : Bool) -> (w : Nat) -> Bin w (binVal b w) 
      b : Bool
        mkBin b Z = N
      n : Nat
        mkBin True (S n) = C n 1 I (binVal False n) (mkBin False n)
      n : Nat
        mkBin False (S n) = C n Z O (binVal True n) (mkBin True n)
  in add' inputSize Z (binVal True inputSize) (binVal False inputSize) O (mkBin True inputSize) (mkBin False inputSize)

erased:
  
  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    subst 
      subst = (\z. z)
    constructor I : Bit
    constructor O : Bit
    constructor N : Bin
    constructor C : (lsb) -> (rest) -> Bin
    constructor TB : (hi) -> (lo) -> TwoBits
    adb 
      adb O O O = TB O O
      adb I O O = TB O I
      adb O I O = TB O I
      adb O O I = TB O I
      adb I I O = TB I O
      adb I O I = TB I O
      adb O I I = TB I O
      adb I I I = TB I I
    add' 
      add' cb N N = C cb N
      add' cb (C xb xn) (C yb yn) = 
        let f 
          f ([_] hi lo) = subst (C lo (add' hi xn yn))
        in f (adb cb xb yb)
    foreign inputSize
    mkBin 
      mkBin b Z = N
      mkBin True (S n) = C I (mkBin False n)
      mkBin False (S n) = C O (mkBin True n)
  in add' O (mkBin True inputSize) (mkBin False inputSize)

