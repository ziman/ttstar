-- vim: ft=ttstar

### Desugared ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        plus Z n = n
      m : Nat n : Nat
        plus (S m) n = S (plus m n)
    times : (_x2 : Nat) -> (_x3 : Nat) -> Nat 
      n : Nat
        times Z n = Z
      m : Nat n : Nat
        times (S m) n = plus n (times m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x4 : Bool) -> Bool 
      not True = False
      not False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x5 : Type) -> (_x6 : Type) -> Type
    constructor MkPair : (a : Type) -> (b : Type) -> (_x7 : a) -> (_x8 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x9 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        fst a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x10 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        snd a b ([MkPair] [a] [b] x y) = y
    constructor Either : (_x11 : Type) -> (_x12 : Type) -> Type
    constructor Left : (a : Type) -> (b : Type) -> (_x13 : a) -> Either a b
    constructor Right : (a : Type) -> (b : Type) -> (_x14 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x15 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x16 : Fin n) -> Fin (S n)
    constructor Vect : (_x17 : Nat) -> (_x18 : Type) -> Type
    constructor VN : (a : Type) -> Vect Z a
    constructor VC : (n : Nat) -> (a : Type) -> (x : a) -> (xs : Vect n a) -> Vect (S n) a
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    subst : (a : Type) -> (P : (_x0 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (_x1 : P x) -> P y 
      a : Type P : (_x2 : a) -> Type x : a
        subst a P x [x] [Refl a x] = (\z : P x. z)
    constructor Bit : (_x0 : Nat) -> Type
    constructor I : Bit 1
    constructor O : Bit Z
    double : (_x1 : Nat) -> Nat 
      double Z = Z
      n : Nat
        double (S n) = S (S (double n))
    constructor Bin : (width : Nat) -> (value : Nat) -> Type
    constructor N : Bin Z Z
    constructor C : (width : Nat) -> (lsbVal : Nat) -> (lsb :R: Bit lsbVal) -> (restVal : Nat) -> (rest :R: Bin width restVal) -> Bin (S width) (plus lsbVal (double restVal))
    constructor TwoBits : (_x2 : Nat) -> (_x3 : Nat) -> (_x4 : Nat) -> Type
    constructor TB : (c : Nat) -> (x : Nat) -> (y : Nat) -> (hi' : Nat) -> (hi : Bit hi') -> (lo' : Nat) -> (lo : Bit lo') -> (pf : Id Nat (plus c (plus x y)) (plus lo' (double hi'))) -> TwoBits c x y
    adb : (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x5 : Bit c) -> (_x6 : Bit x) -> (_x7 : Bit y) -> TwoBits c x y 
      adb [Z] [Z] [Z] O O O = TB Z Z Z Z O Z O (Refl Nat Z)
      adb [1] [Z] [Z] I O O = TB 1 Z Z Z O 1 I (Refl Nat 1)
      adb [Z] [1] [Z] O I O = TB Z 1 Z Z O 1 I (Refl Nat 1)
      adb [Z] [Z] [1] O O I = TB Z Z 1 Z O 1 I (Refl Nat 1)
      adb [1] [1] [Z] I I O = TB 1 1 Z 1 I Z O (Refl Nat 2)
      adb [1] [Z] [1] I O I = TB 1 Z 1 1 I Z O (Refl Nat 2)
      adb [Z] [1] [1] O I I = TB Z 1 1 1 I Z O (Refl Nat 2)
      adb [1] [1] [1] I I I = TB 1 1 1 1 I 1 I (Refl Nat 3)
    add' : (w : Nat) -> (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x8 : Bit c) -> (_x9 : Bin w x) -> (_x10 : Bin w y) -> Bin (S w) (plus c (plus x y)) 
      c : Nat cb : Bit c
        add' [Z] c [Z] [Z] cb N N = C Z c cb Z N
      w : Nat c : Nat cb : Bit c xb' : Nat xb : Bit xb' xn' : Nat xn : Bin w xn' yb' : Nat yb : Bit yb' yn' : Nat yn : Bin w yn'
        add' ([S] w) c [plus xb' (double xn')] [plus yb' (double yn')] cb (C [w] xb' xb xn' xn) (C [w] yb' yb yn' yn) = 
          let f : (_x11 : TwoBits c xb' yb') -> Bin (S (S w)) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) 
            hi' : Nat hi : Bit hi' lo' : Nat lo : Bit lo' pf : Id Nat (plus c (plus xb' yb')) (plus lo' (double hi'))
              f ([TB] [c] [xb'] [yb'] hi' hi lo' lo pf) = 
                let postulate eq : Id Nat (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn'))))
                in subst Nat (Bin (S (S w))) (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) eq (C (S w) lo' lo (plus hi' (plus xn' yn')) (add' w hi' xn' yn' hi xn yn))
          in f (adb c xb' yb' cb xb yb)
    add : (w : Nat) -> (x : Nat) -> (y : Nat) -> (bx : Bin w x) -> (by : Bin w y) -> Bin (S w) (plus x y) = (\w : Nat. (\x : Nat. (\y : Nat. (\bx : Bin w x. (\by : Bin w y. add' w Z x y O bx by)))))
    foreign inputSize : Nat
    binVal : (_x12 : Bool) -> (_x13 : Nat) -> Nat 
      b : Bool
        binVal b Z = Z
      n : Nat
        binVal True (S n) = S (double (binVal False n))
      n : Nat
        binVal False (S n) = double (binVal True n)
    mkBin : (b : Bool) -> (w : Nat) -> Bin w (binVal b w) 
      b : Bool
        mkBin b Z = N
      n : Nat
        mkBin True (S n) = C n 1 I (binVal False n) (mkBin False n)
      n : Nat
        mkBin False (S n) = C n Z O (binVal True n) (mkBin True n)
    main : Bin (S inputSize) (plus (binVal True inputSize) (binVal False inputSize)) = 
      let
        x : Bin inputSize (binVal True inputSize) = mkBin True inputSize
        y : Bin inputSize (binVal False inputSize) = mkBin False inputSize
      in add inputSize (binVal True inputSize) (binVal False inputSize) x y
  in main

### Evarified ###

  let
    constructor Nat :1: Type
    constructor Z :2: Nat
    constructor S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        plus -9- Z -8- n = n
      m :10: Nat n :11: Nat
        plus -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    times :18: (_x2 :19: Nat) -> (_x3 :20: Nat) -> Nat 
      n :21: Nat
        times -23- Z -22- n = Z
      m :24: Nat n :25: Nat
        times -27- (S -28- m) -26- n = plus -30- n -29- (times -32- m -31- n)
    constructor Bool :33: Type
    constructor True :34: Bool
    constructor False :35: Bool
    not :36: (_x4 :37: Bool) -> Bool 
      not -38- True = False
      not -39- False = True
    constructor Unit :40: Type
    constructor MkUnit :41: Unit
    constructor Pair :42: (_x5 :43: Type) -> (_x6 :44: Type) -> Type
    constructor MkPair :45: (a :46: Type) -> (b :47: Type) -> (_x7 :48: a) -> (_x8 :49: b) -> Pair -51- a -50- b
    fst :52: (a :53: Type) -> (b :54: Type) -> (_x9 :55: Pair -57- a -56- b) -> a 
      a :58: Type b :59: Type x :60: a y :61: b
        fst -64- a -63- b -62- ([MkPair] -68- [a] -67- [b] -66- x -65- y) = x
    snd :69: (a :70: Type) -> (b :71: Type) -> (_x10 :72: Pair -74- a -73- b) -> b 
      a :75: Type b :76: Type x :77: a y :78: b
        snd -81- a -80- b -79- ([MkPair] -85- [a] -84- [b] -83- x -82- y) = y
    constructor Either :86: (_x11 :87: Type) -> (_x12 :88: Type) -> Type
    constructor Left :89: (a :90: Type) -> (b :91: Type) -> (_x13 :92: a) -> Either -94- a -93- b
    constructor Right :95: (a :96: Type) -> (b :97: Type) -> (_x14 :98: b) -> Either -100- a -99- b
    id :101: (a :102: Type) -> (x :103: a) -> a = (\a :104: Type. (\x :105: a. x))
    constructor Fin :106: (_x15 :107: Nat) -> Type
    constructor FZ :108: (n :109: Nat) -> Fin -110- (S -111- n)
    constructor FS :112: (n :113: Nat) -> (_x16 :114: Fin -115- n) -> Fin -116- (S -117- n)
    constructor Vect :118: (_x17 :119: Nat) -> (_x18 :120: Type) -> Type
    constructor VN :121: (a :122: Type) -> Vect -124- Z -123- a
    constructor VC :125: (n :126: Nat) -> (a :127: Type) -> (x :128: a) -> (xs :129: Vect -131- n -130- a) -> Vect -133- (S -134- n) -132- a
    constructor Id :135: (a :136: Type) -> (x :137: a) -> (y :138: a) -> Type
    constructor Refl :139: (a :140: Type) -> (x :141: a) -> Id -144- a -143- x -142- x
    subst :145: (a :146: Type) -> (P :147: (_x0 :148: a) -> Type) -> (x :149: a) -> (y :150: a) -> (eq :151: Id -154- a -153- x -152- y) -> (_x1 :155: P -156- x) -> P -157- y 
      a :158: Type P :159: (_x2 :160: a) -> Type x :161: a
        subst -166- a -165- P -164- x -163- [x] -162- [Refl -168- a -167- x] = (\z :169: P -170- x. z)
    constructor Bit :171: (_x0 :172: Nat) -> Type
    constructor I :173: Bit -174- 1
    constructor O :176: Bit -177- Z
    double :178: (_x1 :179: Nat) -> Nat 
      double -180- Z = Z
      n :181: Nat
        double -182- (S -183- n) = S -184- (S -185- (double -186- n))
    constructor Bin :187: (width :188: Nat) -> (value :189: Nat) -> Type
    constructor N :190: Bin -192- Z -191- Z
    constructor C :193: (width :194: Nat) -> (lsbVal :195: Nat) -> (lsb :R: Bit -196- lsbVal) -> (restVal :197: Nat) -> (rest :R: Bin -199- width -198- restVal) -> Bin -201- (S -202- width) -200- (plus -204- lsbVal -203- (double -205- restVal))
    constructor TwoBits :206: (_x2 :207: Nat) -> (_x3 :208: Nat) -> (_x4 :209: Nat) -> Type
    constructor TB :210: (c :211: Nat) -> (x :212: Nat) -> (y :213: Nat) -> (hi' :214: Nat) -> (hi :215: Bit -216- hi') -> (lo' :217: Nat) -> (lo :218: Bit -219- lo') -> (pf :220: Id -223- Nat -222- (plus -225- c -224- (plus -227- x -226- y)) -221- (plus -229- lo' -228- (double -230- hi'))) -> TwoBits -233- c -232- x -231- y
    adb :234: (c :235: Nat) -> (x :236: Nat) -> (y :237: Nat) -> (_x5 :238: Bit -239- c) -> (_x6 :240: Bit -241- x) -> (_x7 :242: Bit -243- y) -> TwoBits -246- c -245- x -244- y 
      adb -252- [Z] -251- [Z] -250- [Z] -249- O -248- O -247- O = TB -260- Z -259- Z -258- Z -257- Z -256- O -255- Z -254- O -253- (Refl -262- Nat -261- Z)
      adb -268- [1] -267- [Z] -266- [Z] -265- I -264- O -263- O = TB -277- 1 -276- Z -275- Z -274- Z -273- O -272- 1 -271- I -270- (Refl -281- Nat -280- 1)
      adb -288- [Z] -287- [1] -286- [Z] -285- O -284- I -283- O = TB -297- Z -296- 1 -295- Z -294- Z -293- O -292- 1 -291- I -290- (Refl -301- Nat -300- 1)
      adb -308- [Z] -307- [Z] -306- [1] -305- O -304- O -303- I = TB -317- Z -316- Z -315- 1 -314- Z -313- O -312- 1 -311- I -310- (Refl -321- Nat -320- 1)
      adb -328- [1] -327- [1] -326- [Z] -325- I -324- I -323- O = TB -338- 1 -337- 1 -336- Z -335- 1 -334- I -333- Z -332- O -331- (Refl -343- Nat -342- 2)
      adb -351- [1] -350- [Z] -349- [1] -348- I -347- O -346- I = TB -361- 1 -360- Z -359- 1 -358- 1 -357- I -356- Z -355- O -354- (Refl -366- Nat -365- 2)
      adb -374- [Z] -373- [1] -372- [1] -371- O -370- I -369- I = TB -384- Z -383- 1 -382- 1 -381- 1 -380- I -379- Z -378- O -377- (Refl -389- Nat -388- 2)
      adb -397- [1] -396- [1] -395- [1] -394- I -393- I -392- I = TB -408- 1 -407- 1 -406- 1 -405- 1 -404- I -403- 1 -402- I -401- (Refl -415- Nat -414- 3)
    add' :419: (w :420: Nat) -> (c :421: Nat) -> (x :422: Nat) -> (y :423: Nat) -> (_x8 :424: Bit -425- c) -> (_x9 :426: Bin -428- w -427- x) -> (_x10 :429: Bin -431- w -430- y) -> Bin -433- (S -434- w) -432- (plus -436- c -435- (plus -438- x -437- y)) 
      c :439: Nat cb :440: Bit -441- c
        add' -448- [Z] -447- c -446- [Z] -445- [Z] -444- cb -443- N -442- N = C -453- Z -452- c -451- cb -450- Z -449- N
      w :454: Nat c :455: Nat cb :456: Bit -457- c xb' :458: Nat xb :459: Bit -460- xb' xn' :461: Nat xn :462: Bin -464- w -463- xn' yb' :465: Nat yb :466: Bit -467- yb' yn' :468: Nat yn :469: Bin -471- w -470- yn'
        add' -478- ([S] -479- w) -477- c -476- [plus -481- xb' -480- (double -482- xn')] -475- [plus -484- yb' -483- (double -485- yn')] -474- cb -473- (C -490- [w] -489- xb' -488- xb -487- xn' -486- xn) -472- (C -495- [w] -494- yb' -493- yb -492- yn' -491- yn) = 
          let f :496: (_x11 :497: TwoBits -500- c -499- xb' -498- yb') -> Bin -502- (S -503- (S -504- w)) -501- (plus -506- c -505- (plus -508- (plus -510- xb' -509- (double -511- xn')) -507- (plus -513- yb' -512- (double -514- yn')))) 
            hi' :515: Nat hi :516: Bit -517- hi' lo' :518: Nat lo :519: Bit -520- lo' pf :521: Id -524- Nat -523- (plus -526- c -525- (plus -528- xb' -527- yb')) -522- (plus -530- lo' -529- (double -531- hi'))
              f -532- ([TB] -540- [c] -539- [xb'] -538- [yb'] -537- hi' -536- hi -535- lo' -534- lo -533- pf) = 
                let postulate eq :541: Id -544- Nat -543- (plus -546- lo' -545- (double -547- (plus -549- hi' -548- (plus -551- xn' -550- yn')))) -542- (plus -553- c -552- (plus -555- (plus -557- xb' -556- (double -558- xn')) -554- (plus -560- yb' -559- (double -561- yn'))))
                in subst -567- Nat -566- (Bin -568- (S -569- (S -570- w))) -565- (plus -572- lo' -571- (double -573- (plus -575- hi' -574- (plus -577- xn' -576- yn')))) -564- (plus -579- c -578- (plus -581- (plus -583- xb' -582- (double -584- xn')) -580- (plus -586- yb' -585- (double -587- yn')))) -563- eq -562- (C -592- (S -593- w) -591- lo' -590- lo -589- (plus -595- hi' -594- (plus -597- xn' -596- yn')) -588- (add' -604- w -603- hi' -602- xn' -601- yn' -600- hi -599- xn -598- yn))
          in f -605- (adb -611- c -610- xb' -609- yb' -608- cb -607- xb -606- yb)
    add :612: (w :613: Nat) -> (x :614: Nat) -> (y :615: Nat) -> (bx :616: Bin -618- w -617- x) -> (by :619: Bin -621- w -620- y) -> Bin -623- (S -624- w) -622- (plus -626- x -625- y) = (\w :627: Nat. (\x :628: Nat. (\y :629: Nat. (\bx :630: Bin -632- w -631- x. (\by :633: Bin -635- w -634- y. add' -642- w -641- Z -640- x -639- y -638- O -637- bx -636- by)))))
    foreign inputSize :643: Nat
    binVal :644: (_x12 :645: Bool) -> (_x13 :646: Nat) -> Nat 
      b :647: Bool
        binVal -649- b -648- Z = Z
      n :650: Nat
        binVal -652- True -651- (S -653- n) = S -654- (double -655- (binVal -657- False -656- n))
      n :658: Nat
        binVal -660- False -659- (S -661- n) = double -662- (binVal -664- True -663- n)
    mkBin :665: (b :666: Bool) -> (w :667: Nat) -> Bin -669- w -668- (binVal -671- b -670- w) 
      b :672: Bool
        mkBin -674- b -673- Z = N
      n :675: Nat
        mkBin -677- True -676- (S -678- n) = C -683- n -682- 1 -681- I -680- (binVal -686- False -685- n) -679- (mkBin -688- False -687- n)
      n :689: Nat
        mkBin -691- False -690- (S -692- n) = C -697- n -696- Z -695- O -694- (binVal -699- True -698- n) -693- (mkBin -701- True -700- n)
    main :702: Bin -704- (S -705- inputSize) -703- (plus -707- (binVal -709- True -708- inputSize) -706- (binVal -711- False -710- inputSize)) = 
      let
        x :712: Bin -714- inputSize -713- (binVal -716- True -715- inputSize) = mkBin -718- True -717- inputSize
        y :719: Bin -721- inputSize -720- (binVal -723- False -722- inputSize) = mkBin -725- False -724- inputSize
      in add -730- inputSize -729- (binVal -732- True -731- inputSize) -728- (binVal -734- False -733- inputSize) -727- x -726- y
  in main

### Constraints ###

[] -> [14,15,28,111,117,134,175,183,184,185,202,269,278,279,282,289,298,299,302,309,318,319,322,329,330,339,340,341,344,345,352,353,362,363,364,367,368,375,376,385,386,387,390,391,398,399,400,409,410,411,412,413,416,417,418,434,449,451,479,486,488,491,493,503,504,569,570,588,590,593,624,653,654,661,678,679,681,684,692,693,695,702,705,R]
[4] -> [2,3,4,7,9,13]
[4,8] -> [7]
[4,12] -> [11]
[4,13] -> [10]
[4,16] -> [11]
[4,17] -> [10]
[5] -> [9,13,17,30,204,225,227,229,436,438,481,484,506,508,510,513,526,528,530,546,549,551,553,555,557,560,572,575,577,579,581,583,586,595,597,626,707]
[6] -> [8,12,16,29,203,224,226,228,435,437,480,483,505,507,509,512,525,527,529,545,548,550,552,554,556,559,571,574,576,578,580,582,585,594,596,625,706]
[7] -> [4,8]
[8] -> [6]
[9] -> [5]
[10] -> [4,13,14]
[11] -> [4,12]
[12] -> [6]
[13] -> [5]
[16] -> [6]
[17] -> [5]
[18] -> [2,3,4,18,23,27]
[18,22] -> [21]
[18,26] -> [25]
[18,27] -> [24]
[18,29] -> [18]
[18,29,31] -> [25]
[18,29,32] -> [24]
[18,30] -> [25]
[19] -> [23,27,32]
[20] -> [22,26,31]
[21] -> [18,22]
[22] -> [20]
[23] -> [19]
[24] -> [18,27,28]
[25] -> [18,26]
[26] -> [20]
[27] -> [19]
[29] -> [6]
[30] -> [5]
[31] -> [20]
[32] -> [19]
[36] -> [34,35,36,38,39]
[37] -> [38,39]
[38] -> [37]
[39] -> [37]
[43] -> [51,57,74]
[44] -> [50,56,73]
[46] -> [68,85]
[47] -> [67,84]
[48] -> [66,83]
[49] -> [65,82]
[50] -> [44,56,73]
[51] -> [43,51]
[52] -> [52,60]
[52,62] -> [45]
[52,62,65] -> [61]
[52,62,66] -> [60]
[52,62,67] -> [59]
[52,62,68] -> [58]
[52,63] -> [59]
[52,64] -> [58]
[53] -> [64]
[54] -> [63]
[55] -> [62]
[56] -> [44,50]
[57] -> [43]
[58] -> [52,64]
[59] -> [52,63]
[60] -> [52,62,66]
[61] -> [52,62,65]
[62] -> [55]
[63] -> [54]
[64] -> [53]
[65] -> [49]
[66] -> [48]
[67] -> [47]
[68] -> [46]
[69] -> [69,78]
[69,79] -> [45]
[69,79,82] -> [78]
[69,79,83] -> [77]
[69,79,84] -> [76]
[69,79,85] -> [75]
[69,80] -> [76]
[69,81] -> [75]
[70] -> [81]
[71] -> [80]
[72] -> [79]
[73] -> [44,50]
[74] -> [43]
[75] -> [69,81]
[76] -> [69,80]
[77] -> [69,79,83]
[78] -> [69,79,82]
[79] -> [72]
[80] -> [71]
[81] -> [70]
[82] -> [49]
[83] -> [48]
[84] -> [47]
[85] -> [46]
[87] -> [94,100]
[88] -> [93,99]
[93] -> [88]
[94] -> [87]
[99] -> [88]
[100] -> [87]
[101] -> [105]
[102] -> [104]
[103] -> [105]
[104] -> [102]
[105] -> [103]
[107] -> [110,115,116]
[110] -> [107]
[115] -> [107]
[116] -> [107]
[119] -> [124,131,133]
[120] -> [123,130,132]
[123] -> [120]
[124] -> [119]
[130] -> [120]
[131] -> [119]
[132] -> [120]
[133] -> [119]
[136] -> [144,154,223,524,544]
[137] -> [143,153,222,523,543]
[138] -> [142,152,221,522,542]
[140] -> [168,262,281,301,321,343,366,389,415]
[141] -> [167,261,280,300,320,342,365,388,414]
[142] -> [138,152,221]
[143] -> [137,143]
[144] -> [136,144]
[145] -> [145,169]
[145,162] -> [139]
[145,162,167] -> [161]
[145,162,168] -> [158]
[145,163] -> [161]
[145,164] -> [161]
[145,165] -> [159]
[145,166] -> [158]
[146] -> [166,567]
[147] -> [165,566]
[148] -> [156,157,160,189]
[149] -> [164,565]
[150] -> [163,564]
[151] -> [162,563]
[152] -> [138,142,542]
[153] -> [137]
[154] -> [136]
[155] -> [169,562]
[156] -> [148,170,200]
[157] -> [148,170,501]
[158] -> [145,166]
[159] -> [145,165]
[160] -> [148,170]
[161] -> [145,164]
[162] -> [151]
[163] -> [150]
[164] -> [149]
[165] -> [147]
[166] -> [146]
[167] -> [141]
[168] -> [140]
[169] -> [155]
[170] -> [156,157,160]
[172] -> [174,177,196,216,219,239,241,243,425,441,457,460,467,517,520]
[174] -> [172,196,216,219,239,241,243]
[177] -> [172,196,216,219,239,241,243,425]
[178] -> [2,3,178,180,182]
[178,182] -> [181]
[178,186] -> [181]
[179] -> [180,182,186,205,230,482,485,511,514,531,547,558,561,573,584,587,655,662]
[180] -> [179]
[181] -> [178,182,183]
[182] -> [179]
[186] -> [179]
[188] -> [192,199,201,428,431,433,464,471,502,568,618,621,623,632,635,669,704,714,721]
[189] -> [148,191,198,200,427,430,432,463,470,501,617,620,622,631,634,668,703,713,720]
[191] -> [189,198,427,430,668]
[192] -> [188,192]
[194] -> [453,490,495,592,683,697]
[195] -> [452,489,494,591,682,696]
[196] -> [172,174,177,441,460,467,520]
[197] -> [450,487,492,589,680,694]
[198] -> [189,191,432,463,470,668]
[199] -> [188]
[200] -> [156,189,427,430,432,668]
[201] -> [188,201]
[203] -> [6,203]
[204] -> [5,204]
[205] -> [179,205]
[207] -> [233,246,500]
[208] -> [232,245,499]
[209] -> [231,244,498]
[211] -> [260,277,297,317,338,361,384,408,540]
[212] -> [259,276,296,316,337,360,383,407,539]
[213] -> [258,275,295,315,336,359,382,406,538]
[214] -> [257,274,294,314,335,358,381,405,537]
[215] -> [256,273,293,313,334,357,380,404,536]
[216] -> [172,174,177,517]
[217] -> [255,272,292,312,333,356,379,403,535]
[218] -> [254,271,291,311,332,355,378,402,534]
[219] -> [172,174,177,520]
[220] -> [253,270,290,310,331,354,377,401,533]
[221] -> [138,142,522]
[222] -> [137]
[223] -> [136]
[224] -> [6]
[225] -> [5]
[226] -> [6]
[227] -> [5]
[228] -> [6]
[229] -> [5]
[230] -> [179]
[231] -> [209,244,498]
[232] -> [208,232]
[233] -> [207,233]
[234] -> [173,176,210,234,247,248,249,263,264,265,283,284,285,303,304,305,323,324,325,346,347,348,369,370,371,392,393,394]
[234,250] -> [2]
[234,251] -> [2]
[234,252] -> [2]
[234,253] -> [139]
[234,253,261] -> [2]
[234,253,262] -> [1]
[234,254] -> [176]
[234,255] -> [2]
[234,256] -> [176]
[234,257] -> [2]
[234,258] -> [2]
[234,259] -> [2]
[234,260] -> [2]
[234,266] -> [2]
[234,267] -> [2]
[234,268] -> [2,3]
[234,270] -> [139]
[234,270,280] -> [2,3]
[234,270,281] -> [1]
[234,271] -> [173]
[234,272] -> [2,3]
[234,273] -> [176]
[234,274] -> [2]
[234,275] -> [2]
[234,276] -> [2]
[234,277] -> [2,3]
[234,286] -> [2]
[234,287] -> [2,3]
[234,288] -> [2]
[234,290] -> [139]
[234,290,300] -> [2,3]
[234,290,301] -> [1]
[234,291] -> [173]
[234,292] -> [2,3]
[234,293] -> [176]
[234,294] -> [2]
[234,295] -> [2]
[234,296] -> [2,3]
[234,297] -> [2]
[234,306] -> [2,3]
[234,307] -> [2]
[234,308] -> [2]
[234,310] -> [139]
[234,310,320] -> [2,3]
[234,310,321] -> [1]
[234,311] -> [173]
[234,312] -> [2,3]
[234,313] -> [176]
[234,314] -> [2]
[234,315] -> [2,3]
[234,316] -> [2]
[234,317] -> [2]
[234,326] -> [2]
[234,327] -> [2,3]
[234,328] -> [2,3]
[234,331] -> [139]
[234,331,342] -> [2,3]
[234,331,343] -> [1]
[234,332] -> [176]
[234,333] -> [2]
[234,334] -> [173]
[234,335] -> [2,3]
[234,336] -> [2]
[234,337] -> [2,3]
[234,338] -> [2,3]
[234,349] -> [2,3]
[234,350] -> [2]
[234,351] -> [2,3]
[234,354] -> [139]
[234,354,365] -> [2,3]
[234,354,366] -> [1]
[234,355] -> [176]
[234,356] -> [2]
[234,357] -> [173]
[234,358] -> [2,3]
[234,359] -> [2,3]
[234,360] -> [2]
[234,361] -> [2,3]
[234,372] -> [2,3]
[234,373] -> [2,3]
[234,374] -> [2]
[234,377] -> [139]
[234,377,388] -> [2,3]
[234,377,389] -> [1]
[234,378] -> [176]
[234,379] -> [2]
[234,380] -> [173]
[234,381] -> [2,3]
[234,382] -> [2,3]
[234,383] -> [2,3]
[234,384] -> [2]
[234,395] -> [2,3]
[234,396] -> [2,3]
[234,397] -> [2,3]
[234,401] -> [139]
[234,401,414] -> [2,3]
[234,401,415] -> [1]
[234,402] -> [173]
[234,403] -> [2,3]
[234,404] -> [173]
[234,405] -> [2,3]
[234,406] -> [2,3]
[234,407] -> [2,3]
[234,408] -> [2,3]
[235] -> [252,268,288,308,328,351,374,397,611]
[236] -> [251,267,287,307,327,350,373,396,610]
[237] -> [250,266,286,306,326,349,372,395,609]
[238] -> [249,265,285,305,325,348,371,394,608]
[239] -> [172,174,177,457]
[240] -> [248,264,284,304,324,347,370,393,607]
[241] -> [172,174,177,460]
[242] -> [247,263,283,303,323,346,369,392,606]
[243] -> [172,174,177,467]
[244] -> [209,231,498]
[245] -> [208,245]
[246] -> [207,246]
[247] -> [242]
[248] -> [240]
[249] -> [238]
[250] -> [237]
[251] -> [236]
[252] -> [235]
[253] -> [220]
[254] -> [218]
[255] -> [217]
[256] -> [215]
[257] -> [214]
[258] -> [213]
[259] -> [212]
[260] -> [211]
[261] -> [141]
[262] -> [140]
[263] -> [242]
[264] -> [240]
[265] -> [238]
[266] -> [237]
[267] -> [236]
[268] -> [235]
[270] -> [220]
[271] -> [218]
[272] -> [217]
[273] -> [215]
[274] -> [214]
[275] -> [213]
[276] -> [212]
[277] -> [211]
[280] -> [141]
[281] -> [140]
[283] -> [242]
[284] -> [240]
[285] -> [238]
[286] -> [237]
[287] -> [236]
[288] -> [235]
[290] -> [220]
[291] -> [218]
[292] -> [217]
[293] -> [215]
[294] -> [214]
[295] -> [213]
[296] -> [212]
[297] -> [211]
[300] -> [141]
[301] -> [140]
[303] -> [242]
[304] -> [240]
[305] -> [238]
[306] -> [237]
[307] -> [236]
[308] -> [235]
[310] -> [220]
[311] -> [218]
[312] -> [217]
[313] -> [215]
[314] -> [214]
[315] -> [213]
[316] -> [212]
[317] -> [211]
[320] -> [141]
[321] -> [140]
[323] -> [242]
[324] -> [240]
[325] -> [238]
[326] -> [237]
[327] -> [236]
[328] -> [235]
[331] -> [220]
[332] -> [218]
[333] -> [217]
[334] -> [215]
[335] -> [214]
[336] -> [213]
[337] -> [212]
[338] -> [211]
[342] -> [141]
[343] -> [140]
[346] -> [242]
[347] -> [240]
[348] -> [238]
[349] -> [237]
[350] -> [236]
[351] -> [235]
[354] -> [220]
[355] -> [218]
[356] -> [217]
[357] -> [215]
[358] -> [214]
[359] -> [213]
[360] -> [212]
[361] -> [211]
[365] -> [141]
[366] -> [140]
[369] -> [242]
[370] -> [240]
[371] -> [238]
[372] -> [237]
[373] -> [236]
[374] -> [235]
[377] -> [220]
[378] -> [218]
[379] -> [217]
[380] -> [215]
[381] -> [214]
[382] -> [213]
[383] -> [212]
[384] -> [211]
[388] -> [141]
[389] -> [140]
[392] -> [242]
[393] -> [240]
[394] -> [238]
[395] -> [237]
[396] -> [236]
[397] -> [235]
[401] -> [220]
[402] -> [218]
[403] -> [217]
[404] -> [215]
[405] -> [214]
[406] -> [213]
[407] -> [212]
[408] -> [211]
[414] -> [141]
[415] -> [140]
[419] -> [190,193,419,440,442,443,472,473,496]
[419,444] -> [440]
[419,445] -> [2]
[419,446] -> [2]
[419,447] -> [439]
[419,448] -> [2]
[419,450] -> [2]
[419,452] -> [439]
[419,453] -> [2]
[419,472] -> [466,469]
[419,472,492] -> [468]
[419,472,494] -> [465]
[419,472,495] -> [454]
[419,473] -> [459,462]
[419,473,487] -> [461]
[419,473,489] -> [458]
[419,473,490] -> [454]
[419,474] -> [456]
[419,475] -> [4]
[419,475,483] -> [178]
[419,475,483,485] -> [468]
[419,475,484] -> [465]
[419,476] -> [4]
[419,476,480] -> [178]
[419,476,480,482] -> [461]
[419,476,481] -> [458]
[419,477] -> [455]
[419,478] -> [3,454]
[419,605] -> [234]
[419,605,606] -> [466]
[419,605,607] -> [459]
[419,605,608] -> [456]
[419,605,609] -> [465]
[419,605,610] -> [458]
[419,605,611] -> [455]
[420] -> [448,478,604,642]
[421] -> [447,477,603,641]
[422] -> [446,476,602,640]
[423] -> [445,475,601,639]
[424] -> [444,474,600,638]
[425] -> [172,177,441,457,517]
[426] -> [443,473,599,637]
[427] -> [189,191,200,463,631]
[428] -> [188]
[429] -> [442,472,598,636]
[430] -> [189,191,200,470,634]
[431] -> [188]
[432] -> [189,198,200,501,622]
[433] -> [188,433]
[435] -> [6,435]
[436] -> [5,436]
[437] -> [6,437]
[438] -> [5,438]
[439] -> [419,447]
[440] -> [419,444]
[441] -> [172,196,425]
[442] -> [429]
[443] -> [426]
[444] -> [424]
[445] -> [423]
[446] -> [422]
[447] -> [421]
[448] -> [420]
[450] -> [197]
[452] -> [195]
[453] -> [194]
[454] -> [419,478,479]
[455] -> [419,477]
[456] -> [419,474]
[457] -> [172,239,425]
[458] -> [419,473,489]
[459] -> [419,473,488]
[460] -> [172,196,241]
[461] -> [419,473,487]
[462] -> [419,473,486]
[463] -> [189,198,427]
[464] -> [188,464]
[465] -> [419,472,494]
[466] -> [419,472,493]
[467] -> [172,196,243]
[468] -> [419,472,492]
[469] -> [419,472,491]
[470] -> [189,198,430]
[471] -> [188,471]
[472] -> [429]
[473] -> [426]
[474] -> [424]
[475] -> [423]
[476] -> [422]
[477] -> [421]
[478] -> [420]
[480] -> [6,480]
[481] -> [5,481]
[482] -> [179,482]
[483] -> [6,483]
[484] -> [5,484]
[485] -> [179,485]
[487] -> [197]
[489] -> [195]
[490] -> [194]
[492] -> [197]
[494] -> [195]
[495] -> [194]
[496] -> [145,496]
[496,532] -> [210]
[496,532,533] -> [521]
[496,532,534] -> [519]
[496,532,535] -> [518]
[496,532,536] -> [516]
[496,532,537] -> [515]
[496,532,538] -> [465]
[496,532,539] -> [458]
[496,532,540] -> [455]
[496,562] -> [193,419,519]
[496,562,589] -> [4]
[496,562,589,594] -> [4]
[496,562,589,594,596] -> [468]
[496,562,589,594,597] -> [461]
[496,562,589,595] -> [515]
[496,562,591] -> [518]
[496,562,592] -> [3,454]
[496,562,598] -> [469]
[496,562,599] -> [462]
[496,562,600] -> [516]
[496,562,601] -> [468]
[496,562,602] -> [461]
[496,562,603] -> [515]
[496,562,604] -> [454]
[496,563] -> [541]
[496,564] -> [4]
[496,564,578] -> [4]
[496,564,578,580] -> [4]
[496,564,578,580,585] -> [178]
[496,564,578,580,585,587] -> [468]
[496,564,578,580,586] -> [465]
[496,564,578,581] -> [4]
[496,564,578,581,582] -> [178]
[496,564,578,581,582,584] -> [461]
[496,564,578,581,583] -> [458]
[496,564,579] -> [455]
[496,565] -> [4]
[496,565,571] -> [178]
[496,565,571,573] -> [4]
[496,565,571,573,574] -> [4]
[496,565,571,573,574,576] -> [468]
[496,565,571,573,574,577] -> [461]
[496,565,571,573,575] -> [515]
[496,565,572] -> [518]
[496,566] -> [187]
[496,566,568] -> [3,454]
[496,567] -> [1]
[497] -> [532,605]
[498] -> [209,231,244]
[499] -> [208]
[500] -> [207]
[501] -> [157,189,432]
[502] -> [188,502]
[505] -> [6,505]
[506] -> [5,506]
[507] -> [6,507]
[508] -> [5,508]
[509] -> [6,509]
[510] -> [5,510]
[511] -> [179,511]
[512] -> [6,512]
[513] -> [5,513]
[514] -> [179,514]
[515] -> [496,532,537]
[516] -> [496,532,536]
[517] -> [172,216,425]
[518] -> [496,532,535]
[519] -> [496,532,534]
[520] -> [172,196,219]
[521] -> [496,532,533]
[522] -> [138,221]
[523] -> [137,523]
[524] -> [136,524]
[525] -> [6,525]
[526] -> [5,526]
[527] -> [6,527]
[528] -> [5,528]
[529] -> [6,529]
[530] -> [5,530]
[531] -> [179,531]
[532] -> [497]
[533] -> [220]
[534] -> [218]
[535] -> [217]
[536] -> [215]
[537] -> [214]
[538] -> [213]
[539] -> [212]
[540] -> [211]
[542] -> [138,152]
[543] -> [137,543]
[544] -> [136,544]
[545] -> [6,545]
[546] -> [5,546]
[547] -> [179,547]
[548] -> [6,548]
[549] -> [5,549]
[550] -> [6,550]
[551] -> [5,551]
[552] -> [6,552]
[553] -> [5,553]
[554] -> [6,554]
[555] -> [5,555]
[556] -> [6,556]
[557] -> [5,557]
[558] -> [179,558]
[559] -> [6,559]
[560] -> [5,560]
[561] -> [179,561]
[562] -> [155]
[563] -> [151]
[564] -> [150]
[565] -> [149]
[566] -> [147]
[567] -> [146]
[568] -> [188]
[571] -> [6]
[572] -> [5]
[573] -> [179]
[574] -> [6]
[575] -> [5]
[576] -> [6]
[577] -> [5]
[578] -> [6]
[579] -> [5]
[580] -> [6]
[581] -> [5]
[582] -> [6]
[583] -> [5]
[584] -> [179]
[585] -> [6]
[586] -> [5]
[587] -> [179]
[589] -> [197]
[591] -> [195]
[592] -> [194]
[594] -> [6,594]
[595] -> [5,595]
[596] -> [6,596]
[597] -> [5,597]
[598] -> [429]
[599] -> [426]
[600] -> [424]
[601] -> [423]
[602] -> [422]
[603] -> [421]
[604] -> [420]
[605] -> [497]
[606] -> [242]
[607] -> [240]
[608] -> [238]
[609] -> [237]
[610] -> [236]
[611] -> [235]
[612] -> [419]
[612,636] -> [633]
[612,637] -> [630]
[612,638] -> [176]
[612,639] -> [629]
[612,640] -> [628]
[612,641] -> [2]
[612,642] -> [627]
[613] -> [627,730]
[614] -> [628,729]
[615] -> [629,728]
[616] -> [630,727]
[617] -> [189,631,713]
[618] -> [188,618]
[619] -> [633,726]
[620] -> [189,634,720]
[621] -> [188,621]
[622] -> [189,432,703]
[623] -> [188,623]
[625] -> [6,625]
[626] -> [5,626]
[627] -> [613]
[628] -> [614]
[629] -> [615]
[630] -> [616]
[631] -> [189,427,617]
[632] -> [188,632]
[633] -> [619]
[634] -> [189,430,620]
[635] -> [188,635]
[636] -> [429]
[637] -> [426]
[638] -> [424]
[639] -> [423]
[640] -> [422]
[641] -> [421]
[642] -> [420]
[644] -> [2,3,34,35,178,644,648,651,652,659,660]
[644,649] -> [647]
[644,651] -> [650]
[644,655] -> [644]
[644,655,656] -> [650]
[644,655,657] -> [35]
[644,659] -> [658]
[644,662] -> [644]
[644,662,663] -> [658]
[644,662,664] -> [34]
[645] -> [649,652,657,660,664,671,686,699,709,711,716,723,732,734]
[646] -> [648,651,656,659,663,670,685,698,708,710,715,722,731,733]
[647] -> [644,649]
[648] -> [646]
[649] -> [645]
[650] -> [644,651,653]
[651] -> [646]
[652] -> [645]
[655] -> [179,655]
[656] -> [646,656]
[657] -> [645,657]
[658] -> [644,659,661]
[659] -> [646]
[660] -> [645]
[662] -> [179,662]
[663] -> [646,663]
[664] -> [645,664]
[665] -> [2,3,34,35,173,176,190,193,665,673,676,677,690,691]
[665,674] -> [672]
[665,676] -> [675]
[665,680] -> [644]
[665,680,685] -> [675]
[665,680,686] -> [35]
[665,682] -> [2,3]
[665,683] -> [675]
[665,687] -> [675]
[665,688] -> [35]
[665,690] -> [689]
[665,694] -> [644]
[665,694,698] -> [689]
[665,694,699] -> [34]
[665,696] -> [2]
[665,697] -> [689]
[665,700] -> [689]
[665,701] -> [34]
[666] -> [674,677,688,691,701,718,725]
[667] -> [673,676,687,690,700,717,724]
[668] -> [189,191,198,200,713,720]
[669] -> [188,669]
[670] -> [646,670]
[671] -> [645,671]
[672] -> [665,674]
[673] -> [667]
[674] -> [666]
[675] -> [665,676,678]
[676] -> [667]
[677] -> [666]
[680] -> [197]
[682] -> [195]
[683] -> [194]
[685] -> [646]
[686] -> [645]
[687] -> [667]
[688] -> [666]
[689] -> [665,690,692]
[690] -> [667]
[691] -> [666]
[694] -> [197]
[696] -> [195]
[697] -> [194]
[698] -> [646]
[699] -> [645]
[700] -> [667]
[701] -> [666]
[702] -> [612]
[702,726] -> [719]
[702,727] -> [712]
[702,728] -> [644]
[702,728,733] -> [643]
[702,728,734] -> [35]
[702,729] -> [644]
[702,729,731] -> [643]
[702,729,732] -> [34]
[702,730] -> [643]
[703] -> [189,622]
[704] -> [188,704]
[706] -> [6,706]
[707] -> [5,707]
[708] -> [646,708]
[709] -> [645,709]
[710] -> [646,710]
[711] -> [645,711]
[712] -> [665]
[712,717] -> [643]
[712,718] -> [34]
[713] -> [189,617,668]
[714] -> [188,714]
[715] -> [646,715]
[716] -> [645,716]
[717] -> [667]
[718] -> [666]
[719] -> [665]
[719,724] -> [643]
[719,725] -> [35]
[720] -> [189,620,668]
[721] -> [188,721]
[722] -> [646,722]
[723] -> [645,723]
[724] -> [667]
[725] -> [666]
[726] -> [619]
[727] -> [616]
[728] -> [615]
[729] -> [614]
[730] -> [613]
[731] -> [646]
[732] -> [645]
[733] -> [646]
[734] -> [645]

### Solution ###

[2,3,14,15,28,34,35,111,117,134,145,155,169,173,175,176,183,184,185,190,193,202,210,215,218,234,238,240,242,247,248,249,254,256,263,264,265,269,271,273,278,279,282,283,284,285,289,291,293,298,299,302,303,304,305,309,311,313,318,319,322,323,324,325,329,330,332,334,339,340,341,344,345,346,347,348,352,353,355,357,362,363,364,367,368,369,370,371,375,376,378,380,385,386,387,390,391,392,393,394,398,399,400,402,404,409,410,411,412,413,416,417,418,419,424,426,429,434,440,442,443,444,449,451,456,459,462,466,469,472,473,474,479,486,488,491,493,496,497,503,504,516,519,532,534,536,562,569,570,588,590,593,598,599,600,605,606,607,608,612,616,619,624,630,633,636,637,638,643,653,654,661,665,666,667,672,673,674,675,676,677,678,679,681,684,687,688,689,690,691,692,693,695,700,701,702,705,712,717,718,719,724,725,726,727,R]

### Annotated ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        snd -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        subst -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :R: Bit -E- 1
    constructor O :R: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      double -E- Z = Z
      n :E: Nat
        double -E- (S -R- n) = S -R- (S -R- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :R: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :R: Bit -E- hi') -> (lo' :E: Nat) -> (lo :R: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :R: Bit -E- c) -> (_x6 :R: Bit -E- x) -> (_x7 :R: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      adb -E- [Z] -E- [Z] -E- [Z] -R- O -R- O -R- O = TB -E- Z -E- Z -E- Z -E- Z -R- O -E- Z -R- O -E- (Refl -E- Nat -E- Z)
      adb -E- [1] -E- [Z] -E- [Z] -R- I -R- O -R- O = TB -E- 1 -E- Z -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [1] -E- [Z] -R- O -R- I -R- O = TB -E- Z -E- 1 -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [Z] -E- [1] -R- O -R- O -R- I = TB -E- Z -E- Z -E- 1 -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [1] -E- [1] -E- [Z] -R- I -R- I -R- O = TB -E- 1 -E- 1 -E- Z -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [Z] -E- [1] -R- I -R- O -R- I = TB -E- 1 -E- Z -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [Z] -E- [1] -E- [1] -R- O -R- I -R- I = TB -E- Z -E- 1 -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [1] -E- [1] -R- I -R- I -R- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -R- I -E- 1 -R- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :E: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :R: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :R: Bit -E- c
        add' -E- [Z] -E- c -E- [Z] -E- [Z] -R- cb -R- N -R- N = C -E- Z -E- c -R- cb -E- Z -R- N
      w :E: Nat c :E: Nat cb :R: Bit -E- c xb' :E: Nat xb :R: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :R: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        add' -E- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -R- cb -R- (C -E- [w] -E- xb' -R- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -R- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :R: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :R: Bit -E- hi' lo' :E: Nat lo :R: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              f -R- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -R- hi -E- lo' -R- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -R- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -E- w -E- hi' -E- xn' -E- yn' -R- hi -R- xn -R- yn))
          in f -R- (adb -E- c -E- xb' -E- yb' -R- cb -R- xb -R- yb)
    add :R: (w :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :E: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -E- w -E- Z -E- x -E- y -R- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        binVal -E- b -E- Z = Z
      n :E: Nat
        binVal -E- True -E- (S -R- n) = S -R- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        binVal -E- False -E- (S -R- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :R: Bool
        mkBin -R- b -R- Z = N
      n :R: Nat
        mkBin -R- True -R- (S -R- n) = C -E- n -E- 1 -R- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        mkBin -R- False -R- (S -R- n) = C -E- n -E- Z -R- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -E- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Specialised ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        snd -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        subst -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :R: Bit -E- 1
    constructor O :R: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      double -E- Z = Z
      n :E: Nat
        double -E- (S -R- n) = S -R- (S -R- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :R: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :R: Bit -E- hi') -> (lo' :E: Nat) -> (lo :R: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :R: Bit -E- c) -> (_x6 :R: Bit -E- x) -> (_x7 :R: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      adb -E- [Z] -E- [Z] -E- [Z] -R- O -R- O -R- O = TB -E- Z -E- Z -E- Z -E- Z -R- O -E- Z -R- O -E- (Refl -E- Nat -E- Z)
      adb -E- [1] -E- [Z] -E- [Z] -R- I -R- O -R- O = TB -E- 1 -E- Z -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [1] -E- [Z] -R- O -R- I -R- O = TB -E- Z -E- 1 -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [Z] -E- [1] -R- O -R- O -R- I = TB -E- Z -E- Z -E- 1 -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [1] -E- [1] -E- [Z] -R- I -R- I -R- O = TB -E- 1 -E- 1 -E- Z -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [Z] -E- [1] -R- I -R- O -R- I = TB -E- 1 -E- Z -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [Z] -E- [1] -E- [1] -R- O -R- I -R- I = TB -E- Z -E- 1 -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [1] -E- [1] -R- I -R- I -R- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -R- I -E- 1 -R- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :E: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :R: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :R: Bit -E- c
        add' -E- [Z] -E- c -E- [Z] -E- [Z] -R- cb -R- N -R- N = C -E- Z -E- c -R- cb -E- Z -R- N
      w :E: Nat c :E: Nat cb :R: Bit -E- c xb' :E: Nat xb :R: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :R: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        add' -E- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -R- cb -R- (C -E- [w] -E- xb' -R- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -R- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :R: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :R: Bit -E- hi' lo' :E: Nat lo :R: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              f -R- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -R- hi -E- lo' -R- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -R- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -E- w -E- hi' -E- xn' -E- yn' -R- hi -R- xn -R- yn))
          in f -R- (adb -E- c -E- xb' -E- yb' -R- cb -R- xb -R- yb)
    add :R: (w :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :E: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -E- w -E- Z -E- x -E- y -R- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        binVal -E- b -E- Z = Z
      n :E: Nat
        binVal -E- True -E- (S -R- n) = S -R- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        binVal -E- False -E- (S -R- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :R: Bool
        mkBin -R- b -R- Z = N
      n :R: Nat
        mkBin -R- True -R- (S -R- n) = C -E- n -E- 1 -R- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        mkBin -R- False -R- (S -R- n) = C -E- n -E- Z -R- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -E- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Final annotation ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        snd -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        subst -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :R: Bit -E- 1
    constructor O :R: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      double -E- Z = Z
      n :E: Nat
        double -E- (S -R- n) = S -R- (S -R- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :R: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :R: Bit -E- hi') -> (lo' :E: Nat) -> (lo :R: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :R: Bit -E- c) -> (_x6 :R: Bit -E- x) -> (_x7 :R: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      adb -E- [Z] -E- [Z] -E- [Z] -R- O -R- O -R- O = TB -E- Z -E- Z -E- Z -E- Z -R- O -E- Z -R- O -E- (Refl -E- Nat -E- Z)
      adb -E- [1] -E- [Z] -E- [Z] -R- I -R- O -R- O = TB -E- 1 -E- Z -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [1] -E- [Z] -R- O -R- I -R- O = TB -E- Z -E- 1 -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [Z] -E- [1] -R- O -R- O -R- I = TB -E- Z -E- Z -E- 1 -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [1] -E- [1] -E- [Z] -R- I -R- I -R- O = TB -E- 1 -E- 1 -E- Z -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [Z] -E- [1] -R- I -R- O -R- I = TB -E- 1 -E- Z -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [Z] -E- [1] -E- [1] -R- O -R- I -R- I = TB -E- Z -E- 1 -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [1] -E- [1] -R- I -R- I -R- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -R- I -E- 1 -R- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :E: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :R: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :R: Bit -E- c
        add' -E- [Z] -E- c -E- [Z] -E- [Z] -R- cb -R- N -R- N = C -E- Z -E- c -R- cb -E- Z -R- N
      w :E: Nat c :E: Nat cb :R: Bit -E- c xb' :E: Nat xb :R: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :R: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        add' -E- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -R- cb -R- (C -E- [w] -E- xb' -R- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -R- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :R: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :R: Bit -E- hi' lo' :E: Nat lo :R: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              f -R- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -R- hi -E- lo' -R- lo -E- pf) = 
                let postulate eq :E: Id -E- Nat -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn'))))
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -R- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -E- w -E- hi' -E- xn' -E- yn' -R- hi -R- xn -R- yn))
          in f -R- (adb -E- c -E- xb' -E- yb' -R- cb -R- xb -R- yb)
    add :R: (w :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :E: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -E- w -E- Z -E- x -E- y -R- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        binVal -E- b -E- Z = Z
      n :E: Nat
        binVal -E- True -E- (S -R- n) = S -R- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        binVal -E- False -E- (S -R- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :R: Bool
        mkBin -R- b -R- Z = N
      n :R: Nat
        mkBin -R- True -R- (S -R- n) = C -E- n -E- 1 -R- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        mkBin -R- False -R- (S -R- n) = C -E- n -E- Z -R- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -E- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    subst 
      subst = (\z. z)
    constructor I : Bit
    constructor O : Bit
    constructor N : Bin
    constructor C : (lsb) -> (rest) -> Bin
    constructor TB : (hi) -> (lo) -> TwoBits
    adb 
      adb O O O = TB O O
      adb I O O = TB O I
      adb O I O = TB O I
      adb O O I = TB O I
      adb I I O = TB I O
      adb I O I = TB I O
      adb O I I = TB I O
      adb I I I = TB I I
    add' 
      add' cb N N = C cb N
      add' cb (C xb xn) (C yb yn) = 
        let f 
          f ([_] hi lo) = subst (C lo (add' hi xn yn))
        in f (adb cb xb yb)
    add = (\bx. (\by. add' O bx by))
    foreign inputSize
    mkBin 
      mkBin b Z = N
      mkBin True (S n) = C I (mkBin False n)
      mkBin False (S n) = C O (mkBin True n)
    main = 
      let
        x = mkBin True inputSize
        y = mkBin False inputSize
      in add x y
  in main

### Intermediate representation ###

let Z = constructor 0
  in let S = constructor 1
    in let True = constructor 0
      in let False = constructor 0
        in let subst = \z. z
          in let I = constructor 0
            in let O = constructor 0
              in let N = constructor 0
                in let C = constructor 2
                  in let TB = constructor 2
                    in let adb = \_pv0. \_pv1. \_pv2.
                      case _pv0 of
                        I => case _pv1 of
                          I => case _pv2 of
                            I => ((TB I) I)
                            O => ((TB I) O)
                          O => case _pv2 of
                            I => ((TB I) O)
                            O => ((TB O) I)
                        O => case _pv1 of
                          I => case _pv2 of
                            I => ((TB I) O)
                            O => ((TB O) I)
                          O => case _pv2 of
                            I => ((TB O) I)
                            O => ((TB O) O)
                      in let add' = \_pv0. \_pv1. \_pv2.
                        case _pv1 of
                          C _pv3 _pv4 => case _pv2 of
                            C _pv5 _pv6 => let f = \_pv7.
                              case _pv7 of
                                _ _pv8 _pv9 => (subst ((C _pv9) (((add' _pv8) _pv4) _pv6)))
                              in (f (((adb _pv0) _pv3) _pv5))
                          N => ((C _pv0) N)
                        in let add = \bx. \by. (((add' O) bx) by)
                          in let inputSize = foreign "(rts-arg-peano 'Z 'S 0)"
                            in let mkBin = \_pv0. \_pv1.
                              case _pv1 of
                                Z => N
                                _ => case _pv0 of
                                  False => case _pv1 of
                                    S _pv2 => ((C O) ((mkBin True) _pv2))
                                  True => case _pv1 of
                                    S _pv2 => ((C I) ((mkBin False) _pv2))
                              in let main = let x = ((mkBin True) inputSize)
                                in let y = ((mkBin False) inputSize)
                                  in ((add x) y)
                                in main

### Normal forms ###

unerased:
  
  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        plus Z n = n
      m : Nat n : Nat
        plus (S m) n = S (plus m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    subst : (a : Type) -> (P : (_x0 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (_x1 : P x) -> P y 
      a : Type P : (_x2 : a) -> Type x : a
        subst a P x [x] [Refl a x] = (\z : P x. z)
    constructor Bit : (_x0 : Nat) -> Type
    constructor I : Bit 1
    constructor O : Bit Z
    double : (_x1 : Nat) -> Nat 
      double Z = Z
      n : Nat
        double (S n) = S (S (double n))
    constructor Bin : (width : Nat) -> (value : Nat) -> Type
    constructor N : Bin Z Z
    constructor C : (width : Nat) -> (lsbVal : Nat) -> (lsb :R: Bit lsbVal) -> (restVal : Nat) -> (rest :R: Bin width restVal) -> Bin (S width) (plus lsbVal (double restVal))
    constructor TwoBits : (_x2 : Nat) -> (_x3 : Nat) -> (_x4 : Nat) -> Type
    constructor TB : (c : Nat) -> (x : Nat) -> (y : Nat) -> (hi' : Nat) -> (hi : Bit hi') -> (lo' : Nat) -> (lo : Bit lo') -> (pf : Id Nat (plus c (plus x y)) (plus lo' (double hi'))) -> TwoBits c x y
    adb : (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x5 : Bit c) -> (_x6 : Bit x) -> (_x7 : Bit y) -> TwoBits c x y 
      adb [Z] [Z] [Z] O O O = TB Z Z Z Z O Z O (Refl Nat Z)
      adb [1] [Z] [Z] I O O = TB 1 Z Z Z O 1 I (Refl Nat 1)
      adb [Z] [1] [Z] O I O = TB Z 1 Z Z O 1 I (Refl Nat 1)
      adb [Z] [Z] [1] O O I = TB Z Z 1 Z O 1 I (Refl Nat 1)
      adb [1] [1] [Z] I I O = TB 1 1 Z 1 I Z O (Refl Nat 2)
      adb [1] [Z] [1] I O I = TB 1 Z 1 1 I Z O (Refl Nat 2)
      adb [Z] [1] [1] O I I = TB Z 1 1 1 I Z O (Refl Nat 2)
      adb [1] [1] [1] I I I = TB 1 1 1 1 I 1 I (Refl Nat 3)
    add' : (w : Nat) -> (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x8 : Bit c) -> (_x9 : Bin w x) -> (_x10 : Bin w y) -> Bin (S w) (plus c (plus x y)) 
      c : Nat cb : Bit c
        add' [Z] c [Z] [Z] cb N N = C Z c cb Z N
      w : Nat c : Nat cb : Bit c xb' : Nat xb : Bit xb' xn' : Nat xn : Bin w xn' yb' : Nat yb : Bit yb' yn' : Nat yn : Bin w yn'
        add' ([S] w) c [plus xb' (double xn')] [plus yb' (double yn')] cb (C [w] xb' xb xn' xn) (C [w] yb' yb yn' yn) = 
          let f : (_x11 : TwoBits c xb' yb') -> Bin (S (S w)) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) 
            hi' : Nat hi : Bit hi' lo' : Nat lo : Bit lo' pf : Id Nat (plus c (plus xb' yb')) (plus lo' (double hi'))
              f ([TB] [c] [xb'] [yb'] hi' hi lo' lo pf) = 
                let postulate eq : Id Nat (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn'))))
                in subst Nat (Bin (S (S w))) (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) eq (C (S w) lo' lo (plus hi' (plus xn' yn')) (add' w hi' xn' yn' hi xn yn))
          in f (adb c xb' yb' cb xb yb)
    foreign inputSize : Nat
    binVal : (_x12 : Bool) -> (_x13 : Nat) -> Nat 
      b : Bool
        binVal b Z = Z
      n : Nat
        binVal True (S n) = S (double (binVal False n))
      n : Nat
        binVal False (S n) = double (binVal True n)
    mkBin : (b : Bool) -> (w : Nat) -> Bin w (binVal b w) 
      b : Bool
        mkBin b Z = N
      n : Nat
        mkBin True (S n) = C n 1 I (binVal False n) (mkBin False n)
      n : Nat
        mkBin False (S n) = C n Z O (binVal True n) (mkBin True n)
  in add' inputSize Z (binVal True inputSize) (binVal False inputSize) O (mkBin True inputSize) (mkBin False inputSize)

erased:
  
  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    subst 
      subst = (\z. z)
    constructor I : Bit
    constructor O : Bit
    constructor N : Bin
    constructor C : (lsb) -> (rest) -> Bin
    constructor TB : (hi) -> (lo) -> TwoBits
    adb 
      adb O O O = TB O O
      adb I O O = TB O I
      adb O I O = TB O I
      adb O O I = TB O I
      adb I I O = TB I O
      adb I O I = TB I O
      adb O I I = TB I O
      adb I I I = TB I I
    add' 
      add' cb N N = C cb N
      add' cb (C xb xn) (C yb yn) = 
        let f 
          f ([_] hi lo) = subst (C lo (add' hi xn yn))
        in f (adb cb xb yb)
    foreign inputSize
    mkBin 
      mkBin b Z = N
      mkBin True (S n) = C I (mkBin False n)
      mkBin False (S n) = C O (mkBin True n)
  in add' O (mkBin True inputSize) (mkBin False inputSize)

