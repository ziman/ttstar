-- vim: ft=ttstar

### Desugared ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : _0
        plus Z n = n
      m : _1 n : _2
        plus (S m) n = S (plus m n)
    times : (_x2 : Nat) -> (_x3 : Nat) -> Nat 
      n : _3
        times Z n = Z
      m : _4 n : _5
        times (S m) n = plus n (times m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x4 : Bool) -> Bool 
      not True = False
      not False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x5 : Type) -> (_x6 : Type) -> Type
    constructor MkPair : (a : _6) -> (b : _7) -> (_x7 : a) -> (_x8 : b) -> Pair a b
    fst : (a : _8) -> (b : _9) -> (_x9 : Pair a b) -> a 
      a : _10 b : _11 x : _12 y : _13
        fst a b ([MkPair] [_14] [_15] x y) = x
    snd : (a : _16) -> (b : _17) -> (_x10 : Pair a b) -> b 
      a : _18 b : _19 x : _20 y : _21
        snd a b ([MkPair] [_22] [_23] x y) = y
    constructor Either : (_x11 : Type) -> (_x12 : Type) -> Type
    constructor Left : (a : _24) -> (b : _25) -> (_x13 : a) -> Either a b
    constructor Right : (a : _26) -> (b : _27) -> (_x14 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x15 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x16 : Fin n) -> Fin (S n)
    constructor Vect : (_x17 : Nat) -> (_x18 : Type) -> Type
    constructor VN : (a : _28) -> Vect Z a
    constructor VC : (n : _29) -> (a : _30) -> (_x19 : a) -> (_x20 : Vect n a) -> Vect (S n) a
    constructor List : (_x21 : Type) -> Type
    constructor Nil : (a : _31) -> List a
    constructor Cons : (a : _32) -> (_x22 : a) -> (_x23 : List a) -> List a
    constructor Id : (a : _33) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    subst : (a : _34) -> (P : (_x0 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (_x1 : P x) -> P y 
      a : _35 P : _36 x : _37
        subst a P x [_38] ([Refl] [_39] [_40]) = (\z : _41. z)
    constructor Bit : (_x0 : Nat) -> Type
    constructor I : Bit 1
    constructor O : Bit Z
    double : (_x1 : Nat) -> Nat 
      double Z = Z
      n : _42
        double (S n) = S (S (double n))
    constructor Bin : (width : Nat) -> (value : Nat) -> Type
    constructor N : Bin Z Z
    constructor C : (width : Nat) -> (lsbVal : Nat) -> (lsb :R: Bit lsbVal) -> (restVal : Nat) -> (rest :R: Bin width restVal) -> Bin (S width) (plus lsbVal (double restVal))
    constructor TwoBits : (_x2 : Nat) -> (_x3 : Nat) -> (_x4 : Nat) -> Type
    constructor TB : (c : Nat) -> (x : Nat) -> (y : Nat) -> (hi' : Nat) -> (hi : Bit hi') -> (lo' : Nat) -> (lo : Bit lo') -> (pf : Id Nat (plus c (plus x y)) (plus lo' (double hi'))) -> TwoBits c x y
    adb : (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x5 : Bit c) -> (_x6 : Bit x) -> (_x7 : Bit y) -> TwoBits c x y 
      adb [_43] [_44] [_45] O O O = TB Z Z Z _46 O _47 O (Refl _48 _49)
      adb [_50] [_51] [_52] I O O = TB 1 Z Z _53 O 1 I (Refl _54 _55)
      adb [_56] [_57] [_58] O I O = TB Z 1 Z _59 O 1 I (Refl _60 _61)
      adb [_62] [_63] [_64] O O I = TB Z Z 1 _65 O 1 I (Refl _66 _67)
      adb [_68] [_69] [_70] I I O = TB 1 1 Z 1 I _71 O (Refl _72 _73)
      adb [_74] [_75] [_76] I O I = TB 1 Z 1 1 I _77 O (Refl _78 _79)
      adb [_80] [_81] [_82] O I I = TB Z 1 1 1 I _83 O (Refl _84 _85)
      adb [_86] [_87] [_88] I I I = TB 1 1 1 1 I 1 I (Refl _89 _90)
    add' : (w : Nat) -> (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x8 : Bit c) -> (_x9 : Bin w x) -> (_x10 : Bin w y) -> Bin (S w) (plus c (plus x y)) 
      c : _91 cb : Bit c
        add' [Z] c [Z] [Z] cb N N = C Z c cb Z N
      w : _92 c : _93 cb : Bit c xb' : _94 xb : Bit xb' xn' : _95 xn : Bin w xn' yb' : _96 yb : Bit yb' yn' : _97 yn : Bin w yn'
        add' ([S] w) c [plus xb' (double xn')] [plus yb' (double yn')] cb (C [_98] xb' xb xn' xn) (C [_99] yb' yb yn' yn) = 
          let f : (_x11 : TwoBits c xb' yb') -> Bin (S (S w)) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) 
            hi' : _100 hi : Bit hi' lo' : _101 lo : Bit lo' pf : Id _102 (plus c (plus xb' yb')) (plus lo' (double hi'))
              f ([TB] [c] [xb'] [yb'] hi' hi lo' lo pf) = 
                let
                  x : _103 = plus lo' (double (plus hi' (plus xn' yn')))
                  y : _104 = plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))
                  postulate eq : Id Nat x y
                in subst Nat (Bin (S (S w))) (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) eq (C (S w) lo' lo (plus hi' (plus xn' yn')) (add' w hi' xn' yn' hi xn yn))
          in f (adb c xb' yb' cb xb yb)
    add : (w : Nat) -> (x : Nat) -> (y : Nat) -> (bx : Bin w x) -> (by : Bin w y) -> Bin (S w) (plus x y) = (\w : Nat. (\x : Nat. (\y : Nat. (\bx : Bin w x. (\by : Bin w y. add' w Z x y O bx by)))))
    foreign inputSize : Nat
    binVal : (_x12 : Bool) -> (_x13 : Nat) -> Nat 
      b : _105
        binVal b Z = Z
      n : _106
        binVal True (S n) = S (double (binVal False n))
      n : _107
        binVal False (S n) = double (binVal True n)
    mkBin : (b : Bool) -> (w : Nat) -> Bin w (binVal b w) 
      b : _108
        mkBin b Z = N
      n : _109
        mkBin True (S n) = C n 1 I (binVal False n) (mkBin False n)
      n : _110
        mkBin False (S n) = C n Z O (binVal True n) (mkBin True n)
    main : Bin (S inputSize) (plus (binVal True inputSize) (binVal False inputSize)) = 
      let
        x : Bin inputSize (binVal True inputSize) = mkBin True inputSize
        y : Bin inputSize (binVal False inputSize) = mkBin False inputSize
      in add inputSize (binVal True inputSize) (binVal False inputSize) x y
  in main

### Elaborated ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        plus Z n = n
      m : Nat n : Nat
        plus (S m) n = S (plus m n)
    times : (_x2 : Nat) -> (_x3 : Nat) -> Nat 
      n : Nat
        times Z n = Z
      m : Nat n : Nat
        times (S m) n = plus n (times m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x4 : Bool) -> Bool 
      not True = False
      not False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x5 : Type) -> (_x6 : Type) -> Type
    constructor MkPair : (a : Type) -> (b : Type) -> (_x7 : a) -> (_x8 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x9 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        fst a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x10 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        snd a b ([MkPair] [a] [b] x y) = y
    constructor Either : (_x11 : Type) -> (_x12 : Type) -> Type
    constructor Left : (a : Type) -> (b : Type) -> (_x13 : a) -> Either a b
    constructor Right : (a : Type) -> (b : Type) -> (_x14 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x15 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x16 : Fin n) -> Fin (S n)
    constructor Vect : (_x17 : Nat) -> (_x18 : Type) -> Type
    constructor VN : (a : Type) -> Vect Z a
    constructor VC : (n : Nat) -> (a : Type) -> (_x19 : a) -> (_x20 : Vect n a) -> Vect (S n) a
    constructor List : (_x21 : Type) -> Type
    constructor Nil : (a : Type) -> List a
    constructor Cons : (a : Type) -> (_x22 : a) -> (_x23 : List a) -> List a
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    subst : (a : Type) -> (P : (_x0 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (_x1 : P x) -> P y 
      a : Type P : (_x0 : a) -> Type x : a
        subst a P x [x] ([Refl] [a] [x]) = (\z : P x. z)
    constructor Bit : (_x0 : Nat) -> Type
    constructor I : Bit 1
    constructor O : Bit Z
    double : (_x1 : Nat) -> Nat 
      double Z = Z
      n : Nat
        double (S n) = S (S (double n))
    constructor Bin : (width : Nat) -> (value : Nat) -> Type
    constructor N : Bin Z Z
    constructor C : (width : Nat) -> (lsbVal : Nat) -> (lsb :R: Bit lsbVal) -> (restVal : Nat) -> (rest :R: Bin width restVal) -> Bin (S width) (plus lsbVal (double restVal))
    constructor TwoBits : (_x2 : Nat) -> (_x3 : Nat) -> (_x4 : Nat) -> Type
    constructor TB : (c : Nat) -> (x : Nat) -> (y : Nat) -> (hi' : Nat) -> (hi : Bit hi') -> (lo' : Nat) -> (lo : Bit lo') -> (pf : Id Nat (plus c (plus x y)) (plus lo' (double hi'))) -> TwoBits c x y
    adb : (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x5 : Bit c) -> (_x6 : Bit x) -> (_x7 : Bit y) -> TwoBits c x y 
      adb [Z] [Z] [Z] O O O = TB Z Z Z Z O Z O (Refl Nat Z)
      adb [1] [Z] [Z] I O O = TB 1 Z Z Z O 1 I (Refl Nat 1)
      adb [Z] [1] [Z] O I O = TB Z 1 Z Z O 1 I (Refl Nat 1)
      adb [Z] [Z] [1] O O I = TB Z Z 1 Z O 1 I (Refl Nat 1)
      adb [1] [1] [Z] I I O = TB 1 1 Z 1 I Z O (Refl Nat 2)
      adb [1] [Z] [1] I O I = TB 1 Z 1 1 I Z O (Refl Nat 2)
      adb [Z] [1] [1] O I I = TB Z 1 1 1 I Z O (Refl Nat 2)
      adb [1] [1] [1] I I I = TB 1 1 1 1 I 1 I (Refl Nat 3)
    add' : (w : Nat) -> (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x8 : Bit c) -> (_x9 : Bin w x) -> (_x10 : Bin w y) -> Bin (S w) (plus c (plus x y)) 
      c : Nat cb : Bit c
        add' [Z] c [Z] [Z] cb N N = C Z c cb Z N
      w : Nat c : Nat cb : Bit c xb' : Nat xb : Bit xb' xn' : Nat xn : Bin w xn' yb' : Nat yb : Bit yb' yn' : Nat yn : Bin w yn'
        add' ([S] w) c [plus xb' (double xn')] [plus yb' (double yn')] cb (C [w] xb' xb xn' xn) (C [w] yb' yb yn' yn) = 
          let f : (_x11 : TwoBits c xb' yb') -> Bin (S (S w)) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) 
            hi' : Nat hi : Bit hi' lo' : Nat lo : Bit lo' pf : Id Nat (plus c (plus xb' yb')) (plus lo' (double hi'))
              f ([TB] [c] [xb'] [yb'] hi' hi lo' lo pf) = 
                let
                  x : Nat = plus lo' (double (plus hi' (plus xn' yn')))
                  y : Nat = plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))
                  postulate eq : Id Nat x y
                in subst Nat (Bin (S (S w))) (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) eq (C (S w) lo' lo (plus hi' (plus xn' yn')) (add' w hi' xn' yn' hi xn yn))
          in f (adb c xb' yb' cb xb yb)
    add : (w : Nat) -> (x : Nat) -> (y : Nat) -> (bx : Bin w x) -> (by : Bin w y) -> Bin (S w) (plus x y) = (\w : Nat. (\x : Nat. (\y : Nat. (\bx : Bin w x. (\by : Bin w y. add' w Z x y O bx by)))))
    foreign inputSize : Nat
    binVal : (_x12 : Bool) -> (_x13 : Nat) -> Nat 
      b : Bool
        binVal b Z = Z
      n : Nat
        binVal True (S n) = S (double (binVal False n))
      n : Nat
        binVal False (S n) = double (binVal True n)
    mkBin : (b : Bool) -> (w : Nat) -> Bin w (binVal b w) 
      b : Bool
        mkBin b Z = N
      n : Nat
        mkBin True (S n) = C n 1 I (binVal False n) (mkBin False n)
      n : Nat
        mkBin False (S n) = C n Z O (binVal True n) (mkBin True n)
    main : Bin (S inputSize) (plus (binVal True inputSize) (binVal False inputSize)) = 
      let
        x : Bin inputSize (binVal True inputSize) = mkBin True inputSize
        y : Bin inputSize (binVal False inputSize) = mkBin False inputSize
      in add inputSize (binVal True inputSize) (binVal False inputSize) x y
  in main

### Evarified ###

  let
    constructor Nat :1: Type
    constructor Z :2: Nat
    constructor S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        plus -9- Z -8- n = n
      m :10: Nat n :11: Nat
        plus -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    times :18: (_x2 :19: Nat) -> (_x3 :20: Nat) -> Nat 
      n :21: Nat
        times -23- Z -22- n = Z
      m :24: Nat n :25: Nat
        times -27- (S -28- m) -26- n = plus -30- n -29- (times -32- m -31- n)
    constructor Bool :33: Type
    constructor True :34: Bool
    constructor False :35: Bool
    not :36: (_x4 :37: Bool) -> Bool 
      not -38- True = False
      not -39- False = True
    constructor Unit :40: Type
    constructor MkUnit :41: Unit
    constructor Pair :42: (_x5 :43: Type) -> (_x6 :44: Type) -> Type
    constructor MkPair :45: (a :46: Type) -> (b :47: Type) -> (_x7 :48: a) -> (_x8 :49: b) -> Pair -51- a -50- b
    fst :52: (a :53: Type) -> (b :54: Type) -> (_x9 :55: Pair -57- a -56- b) -> a 
      a :58: Type b :59: Type x :60: a y :61: b
        fst -64- a -63- b -62- ([MkPair] -68- [a] -67- [b] -66- x -65- y) = x
    snd :69: (a :70: Type) -> (b :71: Type) -> (_x10 :72: Pair -74- a -73- b) -> b 
      a :75: Type b :76: Type x :77: a y :78: b
        snd -81- a -80- b -79- ([MkPair] -85- [a] -84- [b] -83- x -82- y) = y
    constructor Either :86: (_x11 :87: Type) -> (_x12 :88: Type) -> Type
    constructor Left :89: (a :90: Type) -> (b :91: Type) -> (_x13 :92: a) -> Either -94- a -93- b
    constructor Right :95: (a :96: Type) -> (b :97: Type) -> (_x14 :98: b) -> Either -100- a -99- b
    id :101: (a :102: Type) -> (x :103: a) -> a = (\a :104: Type. (\x :105: a. x))
    constructor Fin :106: (_x15 :107: Nat) -> Type
    constructor FZ :108: (n :109: Nat) -> Fin -110- (S -111- n)
    constructor FS :112: (n :113: Nat) -> (_x16 :114: Fin -115- n) -> Fin -116- (S -117- n)
    constructor Vect :118: (_x17 :119: Nat) -> (_x18 :120: Type) -> Type
    constructor VN :121: (a :122: Type) -> Vect -124- Z -123- a
    constructor VC :125: (n :126: Nat) -> (a :127: Type) -> (_x19 :128: a) -> (_x20 :129: Vect -131- n -130- a) -> Vect -133- (S -134- n) -132- a
    constructor List :135: (_x21 :136: Type) -> Type
    constructor Nil :137: (a :138: Type) -> List -139- a
    constructor Cons :140: (a :141: Type) -> (_x22 :142: a) -> (_x23 :143: List -144- a) -> List -145- a
    constructor Id :146: (a :147: Type) -> (x :148: a) -> (y :149: a) -> Type
    constructor Refl :150: (a :151: Type) -> (x :152: a) -> Id -155- a -154- x -153- x
    subst :156: (a :157: Type) -> (P :158: (_x0 :159: a) -> Type) -> (x :160: a) -> (y :161: a) -> (eq :162: Id -165- a -164- x -163- y) -> (_x1 :166: P -167- x) -> P -168- y 
      a :169: Type P :170: (_x0 :171: a) -> Type x :172: a
        subst -177- a -176- P -175- x -174- [x] -173- ([Refl] -179- [a] -178- [x]) = (\z :180: P -181- x. z)
    constructor Bit :182: (_x0 :183: Nat) -> Type
    constructor I :184: Bit -185- 1
    constructor O :187: Bit -188- Z
    double :189: (_x1 :190: Nat) -> Nat 
      double -191- Z = Z
      n :192: Nat
        double -193- (S -194- n) = S -195- (S -196- (double -197- n))
    constructor Bin :198: (width :199: Nat) -> (value :200: Nat) -> Type
    constructor N :201: Bin -203- Z -202- Z
    constructor C :204: (width :205: Nat) -> (lsbVal :206: Nat) -> (lsb :R: Bit -207- lsbVal) -> (restVal :208: Nat) -> (rest :R: Bin -210- width -209- restVal) -> Bin -212- (S -213- width) -211- (plus -215- lsbVal -214- (double -216- restVal))
    constructor TwoBits :217: (_x2 :218: Nat) -> (_x3 :219: Nat) -> (_x4 :220: Nat) -> Type
    constructor TB :221: (c :222: Nat) -> (x :223: Nat) -> (y :224: Nat) -> (hi' :225: Nat) -> (hi :226: Bit -227- hi') -> (lo' :228: Nat) -> (lo :229: Bit -230- lo') -> (pf :231: Id -234- Nat -233- (plus -236- c -235- (plus -238- x -237- y)) -232- (plus -240- lo' -239- (double -241- hi'))) -> TwoBits -244- c -243- x -242- y
    adb :245: (c :246: Nat) -> (x :247: Nat) -> (y :248: Nat) -> (_x5 :249: Bit -250- c) -> (_x6 :251: Bit -252- x) -> (_x7 :253: Bit -254- y) -> TwoBits -257- c -256- x -255- y 
      adb -263- [Z] -262- [Z] -261- [Z] -260- O -259- O -258- O = TB -271- Z -270- Z -269- Z -268- Z -267- O -266- Z -265- O -264- (Refl -273- Nat -272- Z)
      adb -279- [1] -278- [Z] -277- [Z] -276- I -275- O -274- O = TB -288- 1 -287- Z -286- Z -285- Z -284- O -283- 1 -282- I -281- (Refl -292- Nat -291- 1)
      adb -299- [Z] -298- [1] -297- [Z] -296- O -295- I -294- O = TB -308- Z -307- 1 -306- Z -305- Z -304- O -303- 1 -302- I -301- (Refl -312- Nat -311- 1)
      adb -319- [Z] -318- [Z] -317- [1] -316- O -315- O -314- I = TB -328- Z -327- Z -326- 1 -325- Z -324- O -323- 1 -322- I -321- (Refl -332- Nat -331- 1)
      adb -339- [1] -338- [1] -337- [Z] -336- I -335- I -334- O = TB -349- 1 -348- 1 -347- Z -346- 1 -345- I -344- Z -343- O -342- (Refl -354- Nat -353- 2)
      adb -362- [1] -361- [Z] -360- [1] -359- I -358- O -357- I = TB -372- 1 -371- Z -370- 1 -369- 1 -368- I -367- Z -366- O -365- (Refl -377- Nat -376- 2)
      adb -385- [Z] -384- [1] -383- [1] -382- O -381- I -380- I = TB -395- Z -394- 1 -393- 1 -392- 1 -391- I -390- Z -389- O -388- (Refl -400- Nat -399- 2)
      adb -408- [1] -407- [1] -406- [1] -405- I -404- I -403- I = TB -419- 1 -418- 1 -417- 1 -416- 1 -415- I -414- 1 -413- I -412- (Refl -426- Nat -425- 3)
    add' :430: (w :431: Nat) -> (c :432: Nat) -> (x :433: Nat) -> (y :434: Nat) -> (_x8 :435: Bit -436- c) -> (_x9 :437: Bin -439- w -438- x) -> (_x10 :440: Bin -442- w -441- y) -> Bin -444- (S -445- w) -443- (plus -447- c -446- (plus -449- x -448- y)) 
      c :450: Nat cb :451: Bit -452- c
        add' -459- [Z] -458- c -457- [Z] -456- [Z] -455- cb -454- N -453- N = C -464- Z -463- c -462- cb -461- Z -460- N
      w :465: Nat c :466: Nat cb :467: Bit -468- c xb' :469: Nat xb :470: Bit -471- xb' xn' :472: Nat xn :473: Bin -475- w -474- xn' yb' :476: Nat yb :477: Bit -478- yb' yn' :479: Nat yn :480: Bin -482- w -481- yn'
        add' -489- ([S] -490- w) -488- c -487- [plus -492- xb' -491- (double -493- xn')] -486- [plus -495- yb' -494- (double -496- yn')] -485- cb -484- (C -501- [w] -500- xb' -499- xb -498- xn' -497- xn) -483- (C -506- [w] -505- yb' -504- yb -503- yn' -502- yn) = 
          let f :507: (_x11 :508: TwoBits -511- c -510- xb' -509- yb') -> Bin -513- (S -514- (S -515- w)) -512- (plus -517- c -516- (plus -519- (plus -521- xb' -520- (double -522- xn')) -518- (plus -524- yb' -523- (double -525- yn')))) 
            hi' :526: Nat hi :527: Bit -528- hi' lo' :529: Nat lo :530: Bit -531- lo' pf :532: Id -535- Nat -534- (plus -537- c -536- (plus -539- xb' -538- yb')) -533- (plus -541- lo' -540- (double -542- hi'))
              f -543- ([TB] -551- [c] -550- [xb'] -549- [yb'] -548- hi' -547- hi -546- lo' -545- lo -544- pf) = 
                let
                  x :552: Nat = plus -554- lo' -553- (double -555- (plus -557- hi' -556- (plus -559- xn' -558- yn')))
                  y :560: Nat = plus -562- c -561- (plus -564- (plus -566- xb' -565- (double -567- xn')) -563- (plus -569- yb' -568- (double -570- yn')))
                  postulate eq :571: Id -574- Nat -573- x -572- y
                in subst -580- Nat -579- (Bin -581- (S -582- (S -583- w))) -578- (plus -585- lo' -584- (double -586- (plus -588- hi' -587- (plus -590- xn' -589- yn')))) -577- (plus -592- c -591- (plus -594- (plus -596- xb' -595- (double -597- xn')) -593- (plus -599- yb' -598- (double -600- yn')))) -576- eq -575- (C -605- (S -606- w) -604- lo' -603- lo -602- (plus -608- hi' -607- (plus -610- xn' -609- yn')) -601- (add' -617- w -616- hi' -615- xn' -614- yn' -613- hi -612- xn -611- yn))
          in f -618- (adb -624- c -623- xb' -622- yb' -621- cb -620- xb -619- yb)
    add :625: (w :626: Nat) -> (x :627: Nat) -> (y :628: Nat) -> (bx :629: Bin -631- w -630- x) -> (by :632: Bin -634- w -633- y) -> Bin -636- (S -637- w) -635- (plus -639- x -638- y) = (\w :640: Nat. (\x :641: Nat. (\y :642: Nat. (\bx :643: Bin -645- w -644- x. (\by :646: Bin -648- w -647- y. add' -655- w -654- Z -653- x -652- y -651- O -650- bx -649- by)))))
    foreign inputSize :656: Nat
    binVal :657: (_x12 :658: Bool) -> (_x13 :659: Nat) -> Nat 
      b :660: Bool
        binVal -662- b -661- Z = Z
      n :663: Nat
        binVal -665- True -664- (S -666- n) = S -667- (double -668- (binVal -670- False -669- n))
      n :671: Nat
        binVal -673- False -672- (S -674- n) = double -675- (binVal -677- True -676- n)
    mkBin :678: (b :679: Bool) -> (w :680: Nat) -> Bin -682- w -681- (binVal -684- b -683- w) 
      b :685: Bool
        mkBin -687- b -686- Z = N
      n :688: Nat
        mkBin -690- True -689- (S -691- n) = C -696- n -695- 1 -694- I -693- (binVal -699- False -698- n) -692- (mkBin -701- False -700- n)
      n :702: Nat
        mkBin -704- False -703- (S -705- n) = C -710- n -709- Z -708- O -707- (binVal -712- True -711- n) -706- (mkBin -714- True -713- n)
    main :715: Bin -717- (S -718- inputSize) -716- (plus -720- (binVal -722- True -721- inputSize) -719- (binVal -724- False -723- inputSize)) = 
      let
        x :725: Bin -727- inputSize -726- (binVal -729- True -728- inputSize) = mkBin -731- True -730- inputSize
        y :732: Bin -734- inputSize -733- (binVal -736- False -735- inputSize) = mkBin -738- False -737- inputSize
      in add -743- inputSize -742- (binVal -745- True -744- inputSize) -741- (binVal -747- False -746- inputSize) -740- x -739- y
  in main

### Constraints ###

[] -> [14,15,28,111,117,134,186,194,195,196,213,280,289,290,293,300,309,310,313,320,329,330,333,340,341,350,351,352,355,356,363,364,373,374,375,378,379,386,387,396,397,398,401,402,409,410,411,420,421,422,423,424,427,428,429,445,460,462,490,497,499,502,504,514,515,582,583,601,603,606,637,666,667,674,691,692,694,697,705,706,708,715,718]
[4] -> [2,3,7,9,13]
[4,8] -> [7]
[4,12] -> [11]
[4,13,14] -> [10]
[4,15,16] -> [11]
[4,15,17] -> [10]
[5] -> [9,13,17,30,215,236,238,240,447,449,492,495,517,519,521,524,537,539,541,554,557,559,562,564,566,569,585,588,590,592,594,596,599,608,610,639,720]
[6] -> [8,12,16,29,214,235,237,239,446,448,491,494,516,518,520,523,536,538,540,553,556,558,561,563,565,568,584,587,589,591,593,595,598,607,609,638,719]
[7] -> [4,8]
[8] -> [6]
[9] -> [5]
[10] -> [4,13,14]
[11] -> [4,12]
[12] -> [6]
[13] -> [5]
[16] -> [6]
[17] -> [5]
[18] -> [2,3,4,23,27]
[18,22] -> [21]
[18,26] -> [25]
[18,27,28] -> [24]
[18,29,31] -> [25]
[18,29,32] -> [24]
[18,30] -> [25]
[19] -> [23,27,32]
[20] -> [22,26,31]
[21] -> [18,22]
[22] -> [20]
[23] -> [19]
[24] -> [18,27,28]
[25] -> [18,26]
[26] -> [20]
[27] -> [19]
[29] -> [6]
[30] -> [5]
[31] -> [20]
[32] -> [19]
[36] -> [34,35,38,39]
[37] -> [38,39]
[38] -> [37]
[39] -> [37]
[43] -> [51,57,74]
[44] -> [50,56,73]
[46] -> [68,85]
[47] -> [67,84]
[48] -> [66,83]
[49] -> [65,82]
[50] -> [44,56,73]
[51] -> [43]
[52] -> [60]
[52,62] -> [45]
[52,62,65] -> [61]
[52,62,66] -> [60]
[52,62,67] -> [59]
[52,62,68] -> [58]
[52,63] -> [59]
[52,64] -> [58]
[53] -> [64]
[54] -> [63]
[55] -> [62]
[56] -> [44,50]
[57] -> [43]
[58] -> [52,64]
[59] -> [52,63]
[60] -> [52,62,66]
[61] -> [52,62,65]
[62] -> [55]
[63] -> [54]
[64] -> [53]
[65] -> [49]
[66] -> [48]
[67] -> [47]
[68] -> [46]
[69] -> [78]
[69,79] -> [45]
[69,79,82] -> [78]
[69,79,83] -> [77]
[69,79,84] -> [76]
[69,79,85] -> [75]
[69,80] -> [76]
[69,81] -> [75]
[70] -> [81]
[71] -> [80]
[72] -> [79]
[73] -> [44,50]
[74] -> [43]
[75] -> [69,81]
[76] -> [69,80]
[77] -> [69,79,83]
[78] -> [69,79,82]
[79] -> [72]
[80] -> [71]
[81] -> [70]
[82] -> [49]
[83] -> [48]
[84] -> [47]
[85] -> [46]
[87] -> [94,100]
[88] -> [93,99]
[93] -> [88]
[94] -> [87]
[99] -> [88]
[100] -> [87]
[101] -> [105]
[102] -> [104]
[103] -> [105]
[104] -> [102]
[105] -> [103]
[107] -> [110,115,116]
[110] -> [107]
[115] -> [107]
[116] -> [107]
[119] -> [124,131,133]
[120] -> [123,130,132]
[123] -> [120]
[124] -> [119]
[130] -> [120]
[131] -> [119]
[132] -> [120]
[133] -> [119]
[136] -> [139,144,145]
[139] -> [136]
[144] -> [136]
[145] -> [136]
[147] -> [155,165,234,535,574]
[148] -> [154,164,233,534,573]
[149] -> [153,163,232,533,572]
[151] -> [179,273,292,312,332,354,377,400,426]
[152] -> [178,272,291,311,331,353,376,399,425]
[153] -> [149,163,232]
[154] -> [148]
[155] -> [147]
[156] -> [180]
[156,173] -> [150]
[156,173,178] -> [172]
[156,173,179] -> [169]
[156,174] -> [172]
[156,175] -> [172]
[156,176] -> [170]
[156,177] -> [169]
[157] -> [177,580]
[158] -> [176,579]
[159] -> [167,168,171,200]
[160] -> [175,578]
[161] -> [174,577]
[162] -> [173,576]
[163] -> [149,153,572]
[164] -> [148]
[165] -> [147]
[166] -> [180,575]
[167] -> [159,181,211]
[168] -> [159,181,512]
[169] -> [156,177]
[170] -> [156,176]
[171] -> [159,181]
[172] -> [156,175]
[173] -> [162]
[174] -> [161]
[175] -> [160]
[176] -> [158]
[177] -> [157]
[178] -> [152]
[179] -> [151]
[180] -> [166]
[181] -> [167,168,171]
[183] -> [185,188,207,227,230,250,252,254,436,452,468,471,478,528,531]
[185] -> [183,207,227,230,250,252,254]
[188] -> [183,207,227,230,250,252,254,436]
[189] -> [2,3,191,193]
[189,193,194] -> [192]
[189,195] -> [3]
[189,195,196,197] -> [192]
[190] -> [191,193,197,216,241,493,496,522,525,542,555,567,570,586,597,600,668,675]
[191] -> [190]
[192] -> [189,193,194]
[193] -> [190]
[197] -> [190]
[199] -> [203,210,212,439,442,444,475,482,513,581,631,634,636,645,648,682,717,727,734]
[200] -> [159,202,209,211,438,441,443,474,481,512,630,633,635,644,647,681,716,726,733]
[202] -> [200,209,438,441,681]
[203] -> [199]
[205] -> [464,501,506,605,696,710]
[206] -> [463,500,505,604,695,709]
[207] -> [183,185,188,452,471,478,531]
[208] -> [461,498,503,602,693,707]
[209] -> [200,202,443,474,481,681]
[210] -> [199]
[211] -> [167,200,438,441,443,681]
[212] -> [199]
[214] -> [6]
[215] -> [5]
[216] -> [190]
[218] -> [244,257,511]
[219] -> [243,256,510]
[220] -> [242,255,509]
[222] -> [271,288,308,328,349,372,395,419,551]
[223] -> [270,287,307,327,348,371,394,418,550]
[224] -> [269,286,306,326,347,370,393,417,549]
[225] -> [268,285,305,325,346,369,392,416,548]
[226] -> [267,284,304,324,345,368,391,415,547]
[227] -> [183,185,188,528]
[228] -> [266,283,303,323,344,367,390,414,546]
[229] -> [265,282,302,322,343,366,389,413,545]
[230] -> [183,185,188,531]
[231] -> [264,281,301,321,342,365,388,412,544]
[232] -> [149,153,533]
[233] -> [148]
[234] -> [147]
[235] -> [6]
[236] -> [5]
[237] -> [6]
[238] -> [5]
[239] -> [6]
[240] -> [5]
[241] -> [190]
[242] -> [220,255,509]
[243] -> [219]
[244] -> [218]
[245] -> [184,187,221,258,259,260,274,275,276,294,295,296,314,315,316,334,335,336,357,358,359,380,381,382,403,404,405]
[245,261] -> [2]
[245,262] -> [2]
[245,263] -> [2]
[245,264] -> [150]
[245,264,272] -> [2]
[245,264,273] -> [1]
[245,265] -> [187]
[245,266] -> [2]
[245,267] -> [187]
[245,268] -> [2]
[245,269] -> [2]
[245,270] -> [2]
[245,271] -> [2]
[245,277] -> [2]
[245,278] -> [2]
[245,279] -> [3]
[245,279,280] -> [2]
[245,281] -> [150]
[245,281,291] -> [3]
[245,281,291,293] -> [2]
[245,281,292] -> [1]
[245,282] -> [184]
[245,283] -> [3]
[245,283,290] -> [2]
[245,284] -> [187]
[245,285] -> [2]
[245,286] -> [2]
[245,287] -> [2]
[245,288] -> [3]
[245,288,289] -> [2]
[245,297] -> [2]
[245,298] -> [3]
[245,298,300] -> [2]
[245,299] -> [2]
[245,301] -> [150]
[245,301,311] -> [3]
[245,301,311,313] -> [2]
[245,301,312] -> [1]
[245,302] -> [184]
[245,303] -> [3]
[245,303,310] -> [2]
[245,304] -> [187]
[245,305] -> [2]
[245,306] -> [2]
[245,307] -> [3]
[245,307,309] -> [2]
[245,308] -> [2]
[245,317] -> [3]
[245,317,320] -> [2]
[245,318] -> [2]
[245,319] -> [2]
[245,321] -> [150]
[245,321,331] -> [3]
[245,321,331,333] -> [2]
[245,321,332] -> [1]
[245,322] -> [184]
[245,323] -> [3]
[245,323,330] -> [2]
[245,324] -> [187]
[245,325] -> [2]
[245,326] -> [3]
[245,326,329] -> [2]
[245,327] -> [2]
[245,328] -> [2]
[245,337] -> [2]
[245,338] -> [3]
[245,338,341] -> [2]
[245,339] -> [3]
[245,339,340] -> [2]
[245,342] -> [150]
[245,342,353] -> [3]
[245,342,353,355] -> [3]
[245,342,353,355,356] -> [2]
[245,342,354] -> [1]
[245,343] -> [187]
[245,344] -> [2]
[245,345] -> [184]
[245,346] -> [3]
[245,346,352] -> [2]
[245,347] -> [2]
[245,348] -> [3]
[245,348,351] -> [2]
[245,349] -> [3]
[245,349,350] -> [2]
[245,360] -> [3]
[245,360,364] -> [2]
[245,361] -> [2]
[245,362] -> [3]
[245,362,363] -> [2]
[245,365] -> [150]
[245,365,376] -> [3]
[245,365,376,378] -> [3]
[245,365,376,378,379] -> [2]
[245,365,377] -> [1]
[245,366] -> [187]
[245,367] -> [2]
[245,368] -> [184]
[245,369] -> [3]
[245,369,375] -> [2]
[245,370] -> [3]
[245,370,374] -> [2]
[245,371] -> [2]
[245,372] -> [3]
[245,372,373] -> [2]
[245,383] -> [3]
[245,383,387] -> [2]
[245,384] -> [3]
[245,384,386] -> [2]
[245,385] -> [2]
[245,388] -> [150]
[245,388,399] -> [3]
[245,388,399,401] -> [3]
[245,388,399,401,402] -> [2]
[245,388,400] -> [1]
[245,389] -> [187]
[245,390] -> [2]
[245,391] -> [184]
[245,392] -> [3]
[245,392,398] -> [2]
[245,393] -> [3]
[245,393,397] -> [2]
[245,394] -> [3]
[245,394,396] -> [2]
[245,395] -> [2]
[245,406] -> [3]
[245,406,411] -> [2]
[245,407] -> [3]
[245,407,410] -> [2]
[245,408] -> [3]
[245,408,409] -> [2]
[245,412] -> [150]
[245,412,425] -> [3]
[245,412,425,427] -> [3]
[245,412,425,427,428] -> [3]
[245,412,425,427,428,429] -> [2]
[245,412,426] -> [1]
[245,413] -> [184]
[245,414] -> [3]
[245,414,424] -> [2]
[245,415] -> [184]
[245,416] -> [3]
[245,416,423] -> [2]
[245,417] -> [3]
[245,417,422] -> [2]
[245,418] -> [3]
[245,418,421] -> [2]
[245,419] -> [3]
[245,419,420] -> [2]
[246] -> [263,279,299,319,339,362,385,408,624]
[247] -> [262,278,298,318,338,361,384,407,623]
[248] -> [261,277,297,317,337,360,383,406,622]
[249] -> [260,276,296,316,336,359,382,405,621]
[250] -> [183,185,188,468]
[251] -> [259,275,295,315,335,358,381,404,620]
[252] -> [183,185,188,471]
[253] -> [258,274,294,314,334,357,380,403,619]
[254] -> [183,185,188,478]
[255] -> [220,242,509]
[256] -> [219]
[257] -> [218]
[258] -> [253]
[259] -> [251]
[260] -> [249]
[261] -> [248]
[262] -> [247]
[263] -> [246]
[264] -> [231]
[265] -> [229]
[266] -> [228]
[267] -> [226]
[268] -> [225]
[269] -> [224]
[270] -> [223]
[271] -> [222]
[272] -> [152]
[273] -> [151]
[274] -> [253]
[275] -> [251]
[276] -> [249]
[277] -> [248]
[278] -> [247]
[279] -> [246]
[281] -> [231]
[282] -> [229]
[283] -> [228]
[284] -> [226]
[285] -> [225]
[286] -> [224]
[287] -> [223]
[288] -> [222]
[291] -> [152]
[292] -> [151]
[294] -> [253]
[295] -> [251]
[296] -> [249]
[297] -> [248]
[298] -> [247]
[299] -> [246]
[301] -> [231]
[302] -> [229]
[303] -> [228]
[304] -> [226]
[305] -> [225]
[306] -> [224]
[307] -> [223]
[308] -> [222]
[311] -> [152]
[312] -> [151]
[314] -> [253]
[315] -> [251]
[316] -> [249]
[317] -> [248]
[318] -> [247]
[319] -> [246]
[321] -> [231]
[322] -> [229]
[323] -> [228]
[324] -> [226]
[325] -> [225]
[326] -> [224]
[327] -> [223]
[328] -> [222]
[331] -> [152]
[332] -> [151]
[334] -> [253]
[335] -> [251]
[336] -> [249]
[337] -> [248]
[338] -> [247]
[339] -> [246]
[342] -> [231]
[343] -> [229]
[344] -> [228]
[345] -> [226]
[346] -> [225]
[347] -> [224]
[348] -> [223]
[349] -> [222]
[353] -> [152]
[354] -> [151]
[357] -> [253]
[358] -> [251]
[359] -> [249]
[360] -> [248]
[361] -> [247]
[362] -> [246]
[365] -> [231]
[366] -> [229]
[367] -> [228]
[368] -> [226]
[369] -> [225]
[370] -> [224]
[371] -> [223]
[372] -> [222]
[376] -> [152]
[377] -> [151]
[380] -> [253]
[381] -> [251]
[382] -> [249]
[383] -> [248]
[384] -> [247]
[385] -> [246]
[388] -> [231]
[389] -> [229]
[390] -> [228]
[391] -> [226]
[392] -> [225]
[393] -> [224]
[394] -> [223]
[395] -> [222]
[399] -> [152]
[400] -> [151]
[403] -> [253]
[404] -> [251]
[405] -> [249]
[406] -> [248]
[407] -> [247]
[408] -> [246]
[412] -> [231]
[413] -> [229]
[414] -> [228]
[415] -> [226]
[416] -> [225]
[417] -> [224]
[418] -> [223]
[419] -> [222]
[425] -> [152]
[426] -> [151]
[430] -> [201,204,453,454,483,484,507]
[430,455] -> [451]
[430,456] -> [2]
[430,457] -> [2]
[430,458] -> [450]
[430,459] -> [2]
[430,460] -> [201]
[430,461] -> [2]
[430,462] -> [451]
[430,463] -> [450]
[430,464] -> [2]
[430,483,502] -> [480]
[430,483,503] -> [479]
[430,483,504] -> [477]
[430,483,505] -> [476]
[430,483,506] -> [465]
[430,484,497] -> [473]
[430,484,498] -> [472]
[430,484,499] -> [470]
[430,484,500] -> [469]
[430,484,501] -> [465]
[430,485] -> [467]
[430,486] -> [4]
[430,486,494] -> [189]
[430,486,494,496] -> [479]
[430,486,495] -> [476]
[430,487] -> [4]
[430,487,491] -> [189]
[430,487,491,493] -> [472]
[430,487,492] -> [469]
[430,488] -> [466]
[430,489] -> [3]
[430,489,490] -> [465]
[430,618] -> [245]
[430,618,619] -> [477]
[430,618,620] -> [470]
[430,618,621] -> [467]
[430,618,622] -> [476]
[430,618,623] -> [469]
[430,618,624] -> [466]
[431] -> [459,489,617,655]
[432] -> [458,488,616,654]
[433] -> [457,487,615,653]
[434] -> [456,486,614,652]
[435] -> [455,485,613,651]
[436] -> [183,188,452,468,528]
[437] -> [454,484,612,650]
[438] -> [200,202,211,474,644]
[439] -> [199]
[440] -> [453,483,611,649]
[441] -> [200,202,211,481,647]
[442] -> [199]
[443] -> [200,209,211,512,635]
[444] -> [199]
[446] -> [6]
[447] -> [5]
[448] -> [6]
[449] -> [5]
[450] -> [430,458]
[451] -> [430,455]
[452] -> [183,207,436]
[453] -> [440]
[454] -> [437]
[455] -> [435]
[456] -> [434]
[457] -> [433]
[458] -> [432]
[459] -> [431]
[461] -> [208]
[463] -> [206]
[464] -> [205]
[465] -> [430,489,490]
[466] -> [430,488]
[467] -> [430,485]
[468] -> [183,250,436]
[469] -> [430,484,500]
[470] -> [430,484,499]
[471] -> [183,207,252]
[472] -> [430,484,498]
[473] -> [430,484,497]
[474] -> [200,209,438]
[475] -> [199]
[476] -> [430,483,505]
[477] -> [430,483,504]
[478] -> [183,207,254]
[479] -> [430,483,503]
[480] -> [430,483,502]
[481] -> [200,209,441]
[482] -> [199]
[483] -> [440]
[484] -> [437]
[485] -> [435]
[486] -> [434]
[487] -> [433]
[488] -> [432]
[489] -> [431]
[491] -> [6]
[492] -> [5]
[493] -> [190]
[494] -> [6]
[495] -> [5]
[496] -> [190]
[498] -> [208]
[500] -> [206]
[501] -> [205]
[503] -> [208]
[505] -> [206]
[506] -> [205]
[507] -> [156]
[507,543] -> [221]
[507,543,544] -> [532]
[507,543,545] -> [530]
[507,543,546] -> [529]
[507,543,547] -> [527]
[507,543,548] -> [526]
[507,543,549] -> [476]
[507,543,550] -> [469]
[507,543,551] -> [466]
[507,575] -> [204]
[507,575,601] -> [430]
[507,575,601,611] -> [480]
[507,575,601,612] -> [473]
[507,575,601,613] -> [527]
[507,575,601,614] -> [479]
[507,575,601,615] -> [472]
[507,575,601,616] -> [526]
[507,575,601,617] -> [465]
[507,575,602] -> [4]
[507,575,602,607] -> [4]
[507,575,602,607,609] -> [479]
[507,575,602,607,610] -> [472]
[507,575,602,608] -> [526]
[507,575,603] -> [530]
[507,575,604] -> [529]
[507,575,605] -> [3]
[507,575,605,606] -> [465]
[507,576] -> [571]
[507,577] -> [4]
[507,577,591] -> [4]
[507,577,591,593] -> [4]
[507,577,591,593,598] -> [189]
[507,577,591,593,598,600] -> [479]
[507,577,591,593,599] -> [476]
[507,577,591,594] -> [4]
[507,577,591,594,595] -> [189]
[507,577,591,594,595,597] -> [472]
[507,577,591,594,596] -> [469]
[507,577,592] -> [466]
[507,578] -> [4]
[507,578,584] -> [189]
[507,578,584,586] -> [4]
[507,578,584,586,587] -> [4]
[507,578,584,586,587,589] -> [479]
[507,578,584,586,587,590] -> [472]
[507,578,584,586,588] -> [526]
[507,578,585] -> [529]
[507,579] -> [198]
[507,579,581] -> [3]
[507,579,581,582] -> [3]
[507,579,581,582,583] -> [465]
[507,580] -> [1]
[508] -> [543,618]
[509] -> [220,242,255]
[510] -> [219]
[511] -> [218]
[512] -> [168,200,443]
[513] -> [199]
[516] -> [6]
[517] -> [5]
[518] -> [6]
[519] -> [5]
[520] -> [6]
[521] -> [5]
[522] -> [190]
[523] -> [6]
[524] -> [5]
[525] -> [190]
[526] -> [507,543,548]
[527] -> [507,543,547]
[528] -> [183,227,436]
[529] -> [507,543,546]
[530] -> [507,543,545]
[531] -> [183,207,230]
[532] -> [507,543,544]
[533] -> [149,232]
[534] -> [148]
[535] -> [147]
[536] -> [6]
[537] -> [5]
[538] -> [6]
[539] -> [5]
[540] -> [6]
[541] -> [5]
[542] -> [190]
[543] -> [508]
[544] -> [231]
[545] -> [229]
[546] -> [228]
[547] -> [226]
[548] -> [225]
[549] -> [224]
[550] -> [223]
[551] -> [222]
[552] -> [4]
[552,553] -> [189]
[552,553,555] -> [4]
[552,553,555,556] -> [4]
[552,553,555,556,558] -> [479]
[552,553,555,556,559] -> [472]
[552,553,555,557] -> [526]
[552,554] -> [529]
[553] -> [6]
[554] -> [5]
[555] -> [190]
[556] -> [6]
[557] -> [5]
[558] -> [6]
[559] -> [5]
[560] -> [4]
[560,561] -> [4]
[560,561,563] -> [4]
[560,561,563,568] -> [189]
[560,561,563,568,570] -> [479]
[560,561,563,569] -> [476]
[560,561,564] -> [4]
[560,561,564,565] -> [189]
[560,561,564,565,567] -> [472]
[560,561,564,566] -> [469]
[560,562] -> [466]
[561] -> [6]
[562] -> [5]
[563] -> [6]
[564] -> [5]
[565] -> [6]
[566] -> [5]
[567] -> [190]
[568] -> [6]
[569] -> [5]
[570] -> [190]
[572] -> [149,163]
[573] -> [148]
[574] -> [147]
[575] -> [166]
[576] -> [162]
[577] -> [161]
[578] -> [160]
[579] -> [158]
[580] -> [157]
[581] -> [199]
[584] -> [6]
[585] -> [5]
[586] -> [190]
[587] -> [6]
[588] -> [5]
[589] -> [6]
[590] -> [5]
[591] -> [6]
[592] -> [5]
[593] -> [6]
[594] -> [5]
[595] -> [6]
[596] -> [5]
[597] -> [190]
[598] -> [6]
[599] -> [5]
[600] -> [190]
[602] -> [208]
[604] -> [206]
[605] -> [205]
[607] -> [6]
[608] -> [5]
[609] -> [6]
[610] -> [5]
[611] -> [440]
[612] -> [437]
[613] -> [435]
[614] -> [434]
[615] -> [433]
[616] -> [432]
[617] -> [431]
[618] -> [508]
[619] -> [253]
[620] -> [251]
[621] -> [249]
[622] -> [248]
[623] -> [247]
[624] -> [246]
[625] -> [430]
[625,649] -> [646]
[625,650] -> [643]
[625,651] -> [187]
[625,652] -> [642]
[625,653] -> [641]
[625,654] -> [2]
[625,655] -> [640]
[626] -> [640,743]
[627] -> [641,742]
[628] -> [642,741]
[629] -> [643,740]
[630] -> [200,644,726]
[631] -> [199]
[632] -> [646,739]
[633] -> [200,647,733]
[634] -> [199]
[635] -> [200,443,716]
[636] -> [199]
[638] -> [6]
[639] -> [5]
[640] -> [626]
[641] -> [627]
[642] -> [628]
[643] -> [629]
[644] -> [200,438,630]
[645] -> [199]
[646] -> [632]
[647] -> [200,441,633]
[648] -> [199]
[649] -> [440]
[650] -> [437]
[651] -> [435]
[652] -> [434]
[653] -> [433]
[654] -> [432]
[655] -> [431]
[657] -> [2,3,34,35,189,661,664,665,672,673]
[657,662] -> [660]
[657,664,666] -> [663]
[657,667] -> [189]
[657,667,668,669] -> [663]
[657,667,668,670] -> [35]
[657,672,674] -> [671]
[657,675,676] -> [671]
[657,675,677] -> [34]
[658] -> [662,665,670,673,677,684,699,712,722,724,729,736,745,747]
[659] -> [661,664,669,672,676,683,698,711,721,723,728,735,744,746]
[660] -> [657,662]
[661] -> [659]
[662] -> [658]
[663] -> [657,664,666]
[664] -> [659]
[665] -> [658]
[668] -> [190]
[669] -> [659]
[670] -> [658]
[671] -> [657,672,674]
[672] -> [659]
[673] -> [658]
[675] -> [190]
[676] -> [659]
[677] -> [658]
[678] -> [2,3,34,35,201,204,686,689,690,703,704]
[678,687] -> [685]
[678,689,691] -> [688]
[678,692,700] -> [688]
[678,692,701] -> [35]
[678,693] -> [657]
[678,693,698] -> [688]
[678,693,699] -> [35]
[678,694] -> [184]
[678,695] -> [3]
[678,695,697] -> [2]
[678,696] -> [688]
[678,703,705] -> [702]
[678,706,713] -> [702]
[678,706,714] -> [34]
[678,707] -> [657]
[678,707,711] -> [702]
[678,707,712] -> [34]
[678,708] -> [187]
[678,709] -> [2]
[678,710] -> [702]
[679] -> [687,690,701,704,714,731,738]
[680] -> [686,689,700,703,713,730,737]
[681] -> [200,202,209,211,726,733]
[682] -> [199]
[683] -> [659]
[684] -> [658]
[685] -> [678,687]
[686] -> [680]
[687] -> [679]
[688] -> [678,689,691]
[689] -> [680]
[690] -> [679]
[693] -> [208]
[695] -> [206]
[696] -> [205]
[698] -> [659]
[699] -> [658]
[700] -> [680]
[701] -> [679]
[702] -> [678,703,705]
[703] -> [680]
[704] -> [679]
[707] -> [208]
[709] -> [206]
[710] -> [205]
[711] -> [659]
[712] -> [658]
[713] -> [680]
[714] -> [679]
[715] -> [625]
[715,739] -> [732]
[715,740] -> [725]
[715,741] -> [657]
[715,741,746] -> [656]
[715,741,747] -> [35]
[715,742] -> [657]
[715,742,744] -> [656]
[715,742,745] -> [34]
[715,743] -> [656]
[716] -> [200,635]
[717] -> [199]
[719] -> [6]
[720] -> [5]
[721] -> [659]
[722] -> [658]
[723] -> [659]
[724] -> [658]
[725] -> [678]
[725,730] -> [656]
[725,731] -> [34]
[726] -> [200,630,681]
[727] -> [199]
[728] -> [659]
[729] -> [658]
[730] -> [680]
[731] -> [679]
[732] -> [678]
[732,737] -> [656]
[732,738] -> [35]
[733] -> [200,633,681]
[734] -> [199]
[735] -> [659]
[736] -> [658]
[737] -> [680]
[738] -> [679]
[739] -> [632]
[740] -> [629]
[741] -> [628]
[742] -> [627]
[743] -> [626]
[744] -> [659]
[745] -> [658]
[746] -> [659]
[747] -> [658]

### Solution ###

[2,3,14,15,28,34,35,111,117,134,156,166,180,184,186,187,194,195,196,201,204,213,221,226,229,245,249,251,253,258,259,260,265,267,274,275,276,280,282,284,289,290,293,294,295,296,300,302,304,309,310,313,314,315,316,320,322,324,329,330,333,334,335,336,340,341,343,345,350,351,352,355,356,357,358,359,363,364,366,368,373,374,375,378,379,380,381,382,386,387,389,391,396,397,398,401,402,403,404,405,409,410,411,413,415,420,421,422,423,424,427,428,429,430,435,437,440,445,451,453,454,455,460,462,467,470,473,477,480,483,484,485,490,497,499,502,504,507,508,514,515,527,530,543,545,547,575,582,583,601,603,606,611,612,613,618,619,620,621,625,629,632,637,643,646,649,650,651,656,666,667,674,678,679,680,685,686,687,688,689,690,691,692,694,697,700,701,702,703,704,705,706,708,713,714,715,718,725,730,731,732,737,738,739,740,R]

### Annotated ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        snd -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (_x19 :E: a) -> (_x20 :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: (_x21 :E: Type) -> Type
    constructor Nil :E: (a :E: Type) -> List -E- a
    constructor Cons :E: (a :E: Type) -> (_x22 :E: a) -> (_x23 :E: List -E- a) -> List -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x0 :E: a) -> Type x :E: a
        subst -E- a -E- P -E- x -E- [x] -E- ([Refl] -E- [a] -E- [x]) = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :R: Bit -E- 1
    constructor O :R: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      double -E- Z = Z
      n :E: Nat
        double -E- (S -R- n) = S -R- (S -R- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :R: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :R: Bit -E- hi') -> (lo' :E: Nat) -> (lo :R: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :R: Bit -E- c) -> (_x6 :R: Bit -E- x) -> (_x7 :R: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      adb -E- [Z] -E- [Z] -E- [Z] -R- O -R- O -R- O = TB -E- Z -E- Z -E- Z -E- Z -R- O -E- Z -R- O -E- (Refl -E- Nat -E- Z)
      adb -E- [1] -E- [Z] -E- [Z] -R- I -R- O -R- O = TB -E- 1 -E- Z -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [1] -E- [Z] -R- O -R- I -R- O = TB -E- Z -E- 1 -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [Z] -E- [1] -R- O -R- O -R- I = TB -E- Z -E- Z -E- 1 -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [1] -E- [1] -E- [Z] -R- I -R- I -R- O = TB -E- 1 -E- 1 -E- Z -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [Z] -E- [1] -R- I -R- O -R- I = TB -E- 1 -E- Z -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [Z] -E- [1] -E- [1] -R- O -R- I -R- I = TB -E- Z -E- 1 -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [1] -E- [1] -R- I -R- I -R- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -R- I -E- 1 -R- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :E: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :R: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :R: Bit -E- c
        add' -E- [Z] -E- c -E- [Z] -E- [Z] -R- cb -R- N -R- N = C -E- Z -E- c -R- cb -E- Z -R- N
      w :E: Nat c :E: Nat cb :R: Bit -E- c xb' :E: Nat xb :R: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :R: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        add' -E- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -R- cb -R- (C -E- [w] -E- xb' -R- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -R- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :R: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :R: Bit -E- hi' lo' :E: Nat lo :R: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              f -R- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -R- hi -E- lo' -R- lo -E- pf) = 
                let
                  x :E: Nat = plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))
                  y :E: Nat = plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))
                  postulate eq :E: Id -E- Nat -E- x -E- y
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -R- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -E- w -E- hi' -E- xn' -E- yn' -R- hi -R- xn -R- yn))
          in f -R- (adb -E- c -E- xb' -E- yb' -R- cb -R- xb -R- yb)
    add :R: (w :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :E: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -E- w -E- Z -E- x -E- y -R- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        binVal -E- b -E- Z = Z
      n :E: Nat
        binVal -E- True -E- (S -R- n) = S -R- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        binVal -E- False -E- (S -R- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :R: Bool
        mkBin -R- b -R- Z = N
      n :R: Nat
        mkBin -R- True -R- (S -R- n) = C -E- n -E- 1 -R- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        mkBin -R- False -R- (S -R- n) = C -E- n -E- Z -R- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -E- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Specialised ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        snd -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (_x19 :E: a) -> (_x20 :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: (_x21 :E: Type) -> Type
    constructor Nil :E: (a :E: Type) -> List -E- a
    constructor Cons :E: (a :E: Type) -> (_x22 :E: a) -> (_x23 :E: List -E- a) -> List -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x0 :E: a) -> Type x :E: a
        subst -E- a -E- P -E- x -E- [x] -E- ([Refl] -E- [a] -E- [x]) = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :R: Bit -E- 1
    constructor O :R: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      double -E- Z = Z
      n :E: Nat
        double -E- (S -R- n) = S -R- (S -R- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :R: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :R: Bit -E- hi') -> (lo' :E: Nat) -> (lo :R: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :R: Bit -E- c) -> (_x6 :R: Bit -E- x) -> (_x7 :R: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      adb -E- [Z] -E- [Z] -E- [Z] -R- O -R- O -R- O = TB -E- Z -E- Z -E- Z -E- Z -R- O -E- Z -R- O -E- (Refl -E- Nat -E- Z)
      adb -E- [1] -E- [Z] -E- [Z] -R- I -R- O -R- O = TB -E- 1 -E- Z -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [1] -E- [Z] -R- O -R- I -R- O = TB -E- Z -E- 1 -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [Z] -E- [1] -R- O -R- O -R- I = TB -E- Z -E- Z -E- 1 -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [1] -E- [1] -E- [Z] -R- I -R- I -R- O = TB -E- 1 -E- 1 -E- Z -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [Z] -E- [1] -R- I -R- O -R- I = TB -E- 1 -E- Z -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [Z] -E- [1] -E- [1] -R- O -R- I -R- I = TB -E- Z -E- 1 -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [1] -E- [1] -R- I -R- I -R- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -R- I -E- 1 -R- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :E: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :R: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :R: Bit -E- c
        add' -E- [Z] -E- c -E- [Z] -E- [Z] -R- cb -R- N -R- N = C -E- Z -E- c -R- cb -E- Z -R- N
      w :E: Nat c :E: Nat cb :R: Bit -E- c xb' :E: Nat xb :R: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :R: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        add' -E- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -R- cb -R- (C -E- [w] -E- xb' -R- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -R- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :R: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :R: Bit -E- hi' lo' :E: Nat lo :R: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              f -R- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -R- hi -E- lo' -R- lo -E- pf) = 
                let
                  x :E: Nat = plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))
                  y :E: Nat = plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))
                  postulate eq :E: Id -E- Nat -E- x -E- y
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -R- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -E- w -E- hi' -E- xn' -E- yn' -R- hi -R- xn -R- yn))
          in f -R- (adb -E- c -E- xb' -E- yb' -R- cb -R- xb -R- yb)
    add :R: (w :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :E: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -E- w -E- Z -E- x -E- y -R- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        binVal -E- b -E- Z = Z
      n :E: Nat
        binVal -E- True -E- (S -R- n) = S -R- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        binVal -E- False -E- (S -R- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :R: Bool
        mkBin -R- b -R- Z = N
      n :R: Nat
        mkBin -R- True -R- (S -R- n) = C -E- n -E- 1 -R- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        mkBin -R- False -R- (S -R- n) = C -E- n -E- Z -R- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -E- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Final annotation ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :R: Bool
    constructor False :R: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: a) -> (_x8 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x10 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        snd -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (_x19 :E: a) -> (_x20 :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: (_x21 :E: Type) -> Type
    constructor Nil :E: (a :E: Type) -> List -E- a
    constructor Cons :E: (a :E: Type) -> (_x22 :E: a) -> (_x23 :E: List -E- a) -> List -E- a
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    subst :R: (a :E: Type) -> (P :E: (_x0 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (_x1 :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x0 :E: a) -> Type x :E: a
        subst -E- a -E- P -E- x -E- [x] -E- ([Refl] -E- [a] -E- [x]) = (\z :R: P -E- x. z)
    constructor Bit :E: (_x0 :E: Nat) -> Type
    constructor I :R: Bit -E- 1
    constructor O :R: Bit -E- Z
    double :E: (_x1 :E: Nat) -> Nat 
      double -E- Z = Z
      n :E: Nat
        double -E- (S -R- n) = S -R- (S -R- (double -E- n))
    constructor Bin :E: (width :E: Nat) -> (value :E: Nat) -> Type
    constructor N :R: Bin -E- Z -E- Z
    constructor C :R: (width :E: Nat) -> (lsbVal :E: Nat) -> (lsb :R: Bit -E- lsbVal) -> (restVal :E: Nat) -> (rest :R: Bin -E- width -E- restVal) -> Bin -E- (S -R- width) -E- (plus -E- lsbVal -E- (double -E- restVal))
    constructor TwoBits :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> (_x4 :E: Nat) -> Type
    constructor TB :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (hi' :E: Nat) -> (hi :R: Bit -E- hi') -> (lo' :E: Nat) -> (lo :R: Bit -E- lo') -> (pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- x -E- y)) -E- (plus -E- lo' -E- (double -E- hi'))) -> TwoBits -E- c -E- x -E- y
    adb :R: (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x5 :R: Bit -E- c) -> (_x6 :R: Bit -E- x) -> (_x7 :R: Bit -E- y) -> TwoBits -E- c -E- x -E- y 
      adb -E- [Z] -E- [Z] -E- [Z] -R- O -R- O -R- O = TB -E- Z -E- Z -E- Z -E- Z -R- O -E- Z -R- O -E- (Refl -E- Nat -E- Z)
      adb -E- [1] -E- [Z] -E- [Z] -R- I -R- O -R- O = TB -E- 1 -E- Z -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [1] -E- [Z] -R- O -R- I -R- O = TB -E- Z -E- 1 -E- Z -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [Z] -E- [Z] -E- [1] -R- O -R- O -R- I = TB -E- Z -E- Z -E- 1 -E- Z -R- O -E- 1 -R- I -E- (Refl -E- Nat -E- 1)
      adb -E- [1] -E- [1] -E- [Z] -R- I -R- I -R- O = TB -E- 1 -E- 1 -E- Z -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [Z] -E- [1] -R- I -R- O -R- I = TB -E- 1 -E- Z -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [Z] -E- [1] -E- [1] -R- O -R- I -R- I = TB -E- Z -E- 1 -E- 1 -E- 1 -R- I -E- Z -R- O -E- (Refl -E- Nat -E- 2)
      adb -E- [1] -E- [1] -E- [1] -R- I -R- I -R- I = TB -E- 1 -E- 1 -E- 1 -E- 1 -R- I -E- 1 -R- I -E- (Refl -E- Nat -E- 3)
    add' :R: (w :E: Nat) -> (c :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (_x8 :R: Bit -E- c) -> (_x9 :R: Bin -E- w -E- x) -> (_x10 :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- c -E- (plus -E- x -E- y)) 
      c :E: Nat cb :R: Bit -E- c
        add' -E- [Z] -E- c -E- [Z] -E- [Z] -R- cb -R- N -R- N = C -E- Z -E- c -R- cb -E- Z -R- N
      w :E: Nat c :E: Nat cb :R: Bit -E- c xb' :E: Nat xb :R: Bit -E- xb' xn' :E: Nat xn :R: Bin -E- w -E- xn' yb' :E: Nat yb :R: Bit -E- yb' yn' :E: Nat yn :R: Bin -E- w -E- yn'
        add' -E- ([S] -R- w) -E- c -E- [plus -E- xb' -E- (double -E- xn')] -E- [plus -E- yb' -E- (double -E- yn')] -R- cb -R- (C -E- [w] -E- xb' -R- xb -E- xn' -R- xn) -R- (C -E- [w] -E- yb' -R- yb -E- yn' -R- yn) = 
          let f :R: (_x11 :R: TwoBits -E- c -E- xb' -E- yb') -> Bin -E- (S -R- (S -R- w)) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) 
            hi' :E: Nat hi :R: Bit -E- hi' lo' :E: Nat lo :R: Bit -E- lo' pf :E: Id -E- Nat -E- (plus -E- c -E- (plus -E- xb' -E- yb')) -E- (plus -E- lo' -E- (double -E- hi'))
              f -R- ([TB] -E- [c] -E- [xb'] -E- [yb'] -E- hi' -R- hi -E- lo' -R- lo -E- pf) = 
                let
                  x :E: Nat = plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))
                  y :E: Nat = plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))
                  postulate eq :E: Id -E- Nat -E- x -E- y
                in subst -E- Nat -E- (Bin -E- (S -R- (S -R- w))) -E- (plus -E- lo' -E- (double -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')))) -E- (plus -E- c -E- (plus -E- (plus -E- xb' -E- (double -E- xn')) -E- (plus -E- yb' -E- (double -E- yn')))) -E- eq -R- (C -E- (S -R- w) -E- lo' -R- lo -E- (plus -E- hi' -E- (plus -E- xn' -E- yn')) -R- (add' -E- w -E- hi' -E- xn' -E- yn' -R- hi -R- xn -R- yn))
          in f -R- (adb -E- c -E- xb' -E- yb' -R- cb -R- xb -R- yb)
    add :R: (w :E: Nat) -> (x :E: Nat) -> (y :E: Nat) -> (bx :R: Bin -E- w -E- x) -> (by :R: Bin -E- w -E- y) -> Bin -E- (S -R- w) -E- (plus -E- x -E- y) = (\w :E: Nat. (\x :E: Nat. (\y :E: Nat. (\bx :R: Bin -E- w -E- x. (\by :R: Bin -E- w -E- y. add' -E- w -E- Z -E- x -E- y -R- O -R- bx -R- by)))))
    foreign inputSize :R: Nat
    binVal :E: (_x12 :E: Bool) -> (_x13 :E: Nat) -> Nat 
      b :E: Bool
        binVal -E- b -E- Z = Z
      n :E: Nat
        binVal -E- True -E- (S -R- n) = S -R- (double -E- (binVal -E- False -E- n))
      n :E: Nat
        binVal -E- False -E- (S -R- n) = double -E- (binVal -E- True -E- n)
    mkBin :R: (b :R: Bool) -> (w :R: Nat) -> Bin -E- w -E- (binVal -E- b -E- w) 
      b :R: Bool
        mkBin -R- b -R- Z = N
      n :R: Nat
        mkBin -R- True -R- (S -R- n) = C -E- n -E- 1 -R- I -E- (binVal -E- False -E- n) -R- (mkBin -R- False -R- n)
      n :R: Nat
        mkBin -R- False -R- (S -R- n) = C -E- n -E- Z -R- O -E- (binVal -E- True -E- n) -R- (mkBin -R- True -R- n)
    main :R: Bin -E- (S -R- inputSize) -E- (plus -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize)) = 
      let
        x :R: Bin -E- inputSize -E- (binVal -E- True -E- inputSize) = mkBin -R- True -R- inputSize
        y :R: Bin -E- inputSize -E- (binVal -E- False -E- inputSize) = mkBin -R- False -R- inputSize
      in add -E- inputSize -E- (binVal -E- True -E- inputSize) -E- (binVal -E- False -E- inputSize) -R- x -R- y
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    subst 
      subst = (\z. z)
    constructor I : Bit
    constructor O : Bit
    constructor N : Bin
    constructor C : (lsb) -> (rest) -> Bin
    constructor TB : (hi) -> (lo) -> TwoBits
    adb 
      adb O O O = TB O O
      adb I O O = TB O I
      adb O I O = TB O I
      adb O O I = TB O I
      adb I I O = TB I O
      adb I O I = TB I O
      adb O I I = TB I O
      adb I I I = TB I I
    add' 
      add' cb N N = C cb N
      add' cb (C xb xn) (C yb yn) = 
        let f 
          f ([_] hi lo) = subst (C lo (add' hi xn yn))
        in f (adb cb xb yb)
    add = (\bx. (\by. add' O bx by))
    foreign inputSize
    mkBin 
      mkBin b Z = N
      mkBin True (S n) = C I (mkBin False n)
      mkBin False (S n) = C O (mkBin True n)
    main = 
      let
        x = mkBin True inputSize
        y = mkBin False inputSize
      in add x y
  in main

### Intermediate representation ###

let Z = constructor 0
  in let S = constructor 1
    in let True = constructor 0
      in let False = constructor 0
        in let subst = \z. z
          in let I = constructor 0
            in let O = constructor 0
              in let N = constructor 0
                in let C = constructor 2
                  in let TB = constructor 2
                    in let adb = \_pv0. \_pv1. \_pv2.
                      case _pv0 of
                        I => case _pv1 of
                          I => case _pv2 of
                            I => ((TB I) I)
                            O => ((TB I) O)
                          O => case _pv2 of
                            I => ((TB I) O)
                            O => ((TB O) I)
                        O => case _pv1 of
                          I => case _pv2 of
                            I => ((TB I) O)
                            O => ((TB O) I)
                          O => case _pv2 of
                            I => ((TB O) I)
                            O => ((TB O) O)
                      in let add' = \_pv0. \_pv1. \_pv2.
                        case _pv1 of
                          C _pv3 _pv4 => case _pv2 of
                            C _pv5 _pv6 => let f = \_pv7.
                              case _pv7 of
                                _ _pv8 _pv9 => (subst ((C _pv9) (((add' _pv8) _pv4) _pv6)))
                              in (f (((adb _pv0) _pv3) _pv5))
                          N => ((C _pv0) N)
                        in let add = \bx. \by. (((add' O) bx) by)
                          in let inputSize = foreign "(rts-arg-peano 'Z 'S 0)"
                            in let mkBin = \_pv0. \_pv1.
                              case _pv1 of
                                Z => N
                                _ => case _pv0 of
                                  False => case _pv1 of
                                    S _pv2 => ((C O) ((mkBin True) _pv2))
                                  True => case _pv1 of
                                    S _pv2 => ((C I) ((mkBin False) _pv2))
                              in let main = let x = ((mkBin True) inputSize)
                                in let y = ((mkBin False) inputSize)
                                  in ((add x) y)
                                in main

### Normal forms ###

unerased:
  
  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        plus Z n = n
      m : Nat n : Nat
        plus (S m) n = S (plus m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    subst : (a : Type) -> (P : (_x0 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (_x1 : P x) -> P y 
      a : Type P : (_x0 : a) -> Type x : a
        subst a P x [x] ([Refl] [a] [x]) = (\z : P x. z)
    constructor Bit : (_x0 : Nat) -> Type
    constructor I : Bit 1
    constructor O : Bit Z
    double : (_x1 : Nat) -> Nat 
      double Z = Z
      n : Nat
        double (S n) = S (S (double n))
    constructor Bin : (width : Nat) -> (value : Nat) -> Type
    constructor N : Bin Z Z
    constructor C : (width : Nat) -> (lsbVal : Nat) -> (lsb :R: Bit lsbVal) -> (restVal : Nat) -> (rest :R: Bin width restVal) -> Bin (S width) (plus lsbVal (double restVal))
    constructor TwoBits : (_x2 : Nat) -> (_x3 : Nat) -> (_x4 : Nat) -> Type
    constructor TB : (c : Nat) -> (x : Nat) -> (y : Nat) -> (hi' : Nat) -> (hi : Bit hi') -> (lo' : Nat) -> (lo : Bit lo') -> (pf : Id Nat (plus c (plus x y)) (plus lo' (double hi'))) -> TwoBits c x y
    adb : (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x5 : Bit c) -> (_x6 : Bit x) -> (_x7 : Bit y) -> TwoBits c x y 
      adb [Z] [Z] [Z] O O O = TB Z Z Z Z O Z O (Refl Nat Z)
      adb [1] [Z] [Z] I O O = TB 1 Z Z Z O 1 I (Refl Nat 1)
      adb [Z] [1] [Z] O I O = TB Z 1 Z Z O 1 I (Refl Nat 1)
      adb [Z] [Z] [1] O O I = TB Z Z 1 Z O 1 I (Refl Nat 1)
      adb [1] [1] [Z] I I O = TB 1 1 Z 1 I Z O (Refl Nat 2)
      adb [1] [Z] [1] I O I = TB 1 Z 1 1 I Z O (Refl Nat 2)
      adb [Z] [1] [1] O I I = TB Z 1 1 1 I Z O (Refl Nat 2)
      adb [1] [1] [1] I I I = TB 1 1 1 1 I 1 I (Refl Nat 3)
    add' : (w : Nat) -> (c : Nat) -> (x : Nat) -> (y : Nat) -> (_x8 : Bit c) -> (_x9 : Bin w x) -> (_x10 : Bin w y) -> Bin (S w) (plus c (plus x y)) 
      c : Nat cb : Bit c
        add' [Z] c [Z] [Z] cb N N = C Z c cb Z N
      w : Nat c : Nat cb : Bit c xb' : Nat xb : Bit xb' xn' : Nat xn : Bin w xn' yb' : Nat yb : Bit yb' yn' : Nat yn : Bin w yn'
        add' ([S] w) c [plus xb' (double xn')] [plus yb' (double yn')] cb (C [w] xb' xb xn' xn) (C [w] yb' yb yn' yn) = 
          let f : (_x11 : TwoBits c xb' yb') -> Bin (S (S w)) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) 
            hi' : Nat hi : Bit hi' lo' : Nat lo : Bit lo' pf : Id Nat (plus c (plus xb' yb')) (plus lo' (double hi'))
              f ([TB] [c] [xb'] [yb'] hi' hi lo' lo pf) = 
                let
                  x : Nat = plus lo' (double (plus hi' (plus xn' yn')))
                  y : Nat = plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))
                  postulate eq : Id Nat x y
                in subst Nat (Bin (S (S w))) (plus lo' (double (plus hi' (plus xn' yn')))) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))) eq (C (S w) lo' lo (plus hi' (plus xn' yn')) (add' w hi' xn' yn' hi xn yn))
          in f (adb c xb' yb' cb xb yb)
    foreign inputSize : Nat
    binVal : (_x12 : Bool) -> (_x13 : Nat) -> Nat 
      b : Bool
        binVal b Z = Z
      n : Nat
        binVal True (S n) = S (double (binVal False n))
      n : Nat
        binVal False (S n) = double (binVal True n)
    mkBin : (b : Bool) -> (w : Nat) -> Bin w (binVal b w) 
      b : Bool
        mkBin b Z = N
      n : Nat
        mkBin True (S n) = C n 1 I (binVal False n) (mkBin False n)
      n : Nat
        mkBin False (S n) = C n Z O (binVal True n) (mkBin True n)
  in add' inputSize Z (binVal True inputSize) (binVal False inputSize) O (mkBin True inputSize) (mkBin False inputSize)

erased:
  
  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor True : Bool
    constructor False : Bool
    subst 
      subst = (\z. z)
    constructor I : Bit
    constructor O : Bit
    constructor N : Bin
    constructor C : (lsb) -> (rest) -> Bin
    constructor TB : (hi) -> (lo) -> TwoBits
    adb 
      adb O O O = TB O O
      adb I O O = TB O I
      adb O I O = TB O I
      adb O O I = TB O I
      adb I I O = TB I O
      adb I O I = TB I O
      adb O I I = TB I O
      adb I I I = TB I I
    add' 
      add' cb N N = C cb N
      add' cb (C xb xn) (C yb yn) = 
        let f 
          f ([_] hi lo) = subst (C lo (add' hi xn yn))
        in f (adb cb xb yb)
    foreign inputSize
    mkBin 
      mkBin b Z = N
      mkBin True (S n) = C I (mkBin False n)
      mkBin False (S n) = C O (mkBin True n)
  in add' O (mkBin True inputSize) (mkBin False inputSize)

