-- vim: ft=ttstar

### Desugared ###

  let
    constructor Bool : Type
    constructor T : Bool
    constructor F : Bool
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
    not : (_x0 : Bool) -> Bool 
      [not] T = F
      [not] F = T
    notnot : (x : Bool) -> Id Bool x (not (not x)) 
      [notnot] T = Refl Bool T
      [notnot] F = Refl Bool F
    subst : (a : Type) -> (P : (_x1 : a) -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (w : P x) -> P y 
      a : Type P : (_x2 : a) -> Type x : a
        [subst] a P x [x] [Refl a x] = (\w : P x. w)
    main : Id Bool F (not (not F)) = notnot (subst Type (\a : Type. a) Bool Bool (Refl Type Bool) F)
  in main

### Evarified ###

  let
    constructor Bool :1: Type
    constructor T :2: Bool
    constructor F :3: Bool
    constructor Id :4: (a :5: Type) -> (x :6: a) -> (y :7: a) -> Type
    constructor Refl :8: (a :9: Type) -> (x :10: a) -> Id -13- a -12- x -11- x
    not :14: (_x0 :15: Bool) -> Bool 
      [not] -16- T = F
      [not] -17- F = T
    notnot :18: (x :19: Bool) -> Id -22- Bool -21- x -20- (not -23- (not -24- x)) 
      [notnot] -25- T = Refl -27- Bool -26- T
      [notnot] -28- F = Refl -30- Bool -29- F
    subst :31: (a :32: Type) -> (P :33: (_x1 :34: a) -> Type) -> (x :35: a) -> (y :36: a) -> (eq :37: Id -40- a -39- x -38- y) -> (w :41: P -42- x) -> P -43- y 
      a :44: Type P :45: (_x2 :46: a) -> Type x :47: a
        [subst] -52- a -51- P -50- x -49- [x] -48- [Refl -54- a -53- x] = (\w :55: P -56- x. w)
    main :57: Id -60- Bool -59- F -58- (not -61- (not -62- F)) = notnot -63- (subst -69- Type -68- (\a :70: Type. a) -67- Bool -66- Bool -65- (Refl -72- Type -71- Bool) -64- F)
  in main

### Constraints ###

[9] -> [27,30]
[9,48,63] -> [54]
[9,63,65] -> [72]
[10] -> [26,29]
[10,48,63] -> [53]
[10,63,65] -> [71]
[11] -> [20]
[11,48,63] -> [38]
[11,63,65] -> [38]
[12] -> [21]
[12,48,63] -> [39]
[12,63,65] -> [39]
[13] -> [22]
[13,48,63] -> [40]
[13,63,65] -> [40]
[19] -> [63]
[19,R] -> [25,28]
[20] -> [11,58]
[21] -> [12,59]
[22] -> [13,60]
[25] -> [R]
[25,R] -> [19]
[26] -> [10]
[26,R] -> [2]
[27] -> [9]
[27,R] -> [1]
[28] -> [R]
[28,R] -> [19]
[29] -> [10]
[29,R] -> [3]
[30] -> [9]
[30,R] -> [1]
[32,63] -> [69]
[32,63,R] -> [52]
[33,63] -> [68]
[33,63,R] -> [51]
[34,51,63] -> [46]
[34,63,68] -> [70]
[35,63] -> [67]
[35,63,R] -> [50]
[36,63] -> [66]
[36,63,R] -> [49]
[37,63] -> [65]
[37,63,R] -> [48]
[38,48,63] -> [11]
[38,63,65] -> [11]
[39,48,63] -> [12]
[39,63,65] -> [12]
[40,48,63] -> [13]
[40,63,65] -> [13]
[41,42,63] -> [56]
[41,56,63] -> [42]
[41,63] -> [55,64]
[43,63] -> [56]
[44,63] -> [52]
[45,63] -> [51]
[46,51,63] -> [34]
[47,63] -> [50]
[48,53,63] -> [10]
[48,53,63,R] -> [47]
[48,54,63] -> [9]
[48,54,63,R] -> [44]
[48,63] -> [R]
[48,63,R] -> [8,37]
[49,63] -> [R]
[49,63,R] -> [36,47]
[50,63] -> [R]
[50,63,R] -> [35]
[51,63] -> [R]
[51,63,R] -> [33]
[52,63] -> [R]
[52,63,R] -> [32]
[55,63] -> [41]
[56,63] -> [43]
[58] -> [20]
[59] -> [21]
[60] -> [22]
[63] -> [19]
[63,64] -> [41]
[63,64,R] -> [3]
[63,65] -> [37]
[63,65,71] -> [10]
[63,65,71,R] -> [1]
[63,65,72] -> [9]
[63,65,72,R] -> [R]
[63,65,R] -> [8]
[63,66] -> [36]
[63,66,R] -> [1]
[63,67] -> [35]
[63,67,R] -> [1]
[63,68] -> [33]
[63,68,70] -> [34]
[63,68,R] -> [70]
[63,69] -> [32]
[63,69,R] -> [R]
[63,R] -> [31,55]
[R] -> [2,3,8,18,25,28,57]

### Solution ###

[2,3,8,18,19,25,28,31,41,55,57,63,64,R]

### Annotated ###

  let
    constructor Bool :E: Type
    constructor T :R: Bool
    constructor F :R: Bool
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :R: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    not :E: (_x0 :E: Bool) -> Bool 
      [not] -E- T = F
      [not] -E- F = T
    notnot :R: (x :R: Bool) -> Id -E- Bool -E- x -E- (not -E- (not -E- x)) 
      [notnot] -R- T = Refl -E- Bool -E- T
      [notnot] -R- F = Refl -E- Bool -E- F
    subst :R: (a :E: Type) -> (P :E: (_x1 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (w :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        [subst] -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\w :R: P -E- x. w)
    main :R: Id -E- Bool -E- F -E- (not -E- (not -E- F)) = notnot -R- (subst -E- Type -E- (\a :E: Type. a) -E- Bool -E- Bool -E- (Refl -E- Type -E- Bool) -R- F)
  in main

### Specialised ###

  let
    constructor Bool :E: Type
    constructor T :R: Bool
    constructor F :R: Bool
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :R: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    not :E: (_x0 :E: Bool) -> Bool 
      [not] -E- T = F
      [not] -E- F = T
    notnot :R: (x :R: Bool) -> Id -E- Bool -E- x -E- (not -E- (not -E- x)) 
      [notnot] -R- T = Refl -E- Bool -E- T
      [notnot] -R- F = Refl -E- Bool -E- F
    subst :R: (a :E: Type) -> (P :E: (_x1 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (w :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        [subst] -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\w :R: P -E- x. w)
    main :R: Id -E- Bool -E- F -E- (not -E- (not -E- F)) = notnot -R- (subst -E- Type -E- (\a :E: Type. a) -E- Bool -E- Bool -E- (Refl -E- Type -E- Bool) -R- F)
  in main

### Final annotation ###

  let
    constructor Bool :E: Type
    constructor T :R: Bool
    constructor F :R: Bool
    constructor Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    constructor Refl :R: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    not :E: (_x0 :E: Bool) -> Bool 
      [not] -E- T = F
      [not] -E- F = T
    notnot :R: (x :R: Bool) -> Id -E- Bool -E- x -E- (not -E- (not -E- x)) 
      [notnot] -R- T = Refl -E- Bool -E- T
      [notnot] -R- F = Refl -E- Bool -E- F
    subst :R: (a :E: Type) -> (P :E: (_x1 :E: a) -> Type) -> (x :E: a) -> (y :E: a) -> (eq :E: Id -E- a -E- x -E- y) -> (w :R: P -E- x) -> P -E- y 
      a :E: Type P :E: (_x2 :E: a) -> Type x :E: a
        [subst] -E- a -E- P -E- x -E- [x] -E- [Refl -E- a -E- x] = (\w :R: P -E- x. w)
    main :R: Id -E- Bool -E- F -E- (not -E- (not -E- F)) = notnot -R- (subst -E- Type -E- (\a :E: Type. a) -E- Bool -E- Bool -E- (Refl -E- Type -E- Bool) -R- F)
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor T : Bool
    constructor F : Bool
    constructor Refl : Id
    notnot 
      [_] T = Refl
      [_] F = Refl
    subst = (\w. w)
    main = notnot (subst F)
  in main

### Normal forms ###

unerased:
  
  let
    constructor Bool : Type
    constructor F : Bool
    constructor Id : (a : Type) -> (x : a) -> (y : a) -> Type
    constructor Refl : (a : Type) -> (x : a) -> Id a x x
  in Refl Bool F

erased:
  
  let constructor Refl : Id
  in Refl

