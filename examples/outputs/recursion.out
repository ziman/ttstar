-- vim: ft=ttstar

### Desugared ###

  let
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (n :R: Nat) -> Nat
    constructor Vec : (_x0 : Nat) -> (_x1 : Type) -> Type
    constructor VNil : (a : Type) -> Vec Z a
    constructor VCons : (a : Type) -> (n : Nat) -> (x : a) -> (xs : Vec n a) -> Vec (S n) a
    vlen : (a : Type) -> (n : Nat) -> (xs : Vec n a) -> Nat 
      (a : Type)
         a {Z} (VNil [a]) = Z
      (a : Type) (n : Nat) (x : a) (xs : Vec n a)
         a ({S} n) (VCons [a] [n] x xs) = S (vlen a n xs)
    testVec : Vec 2 Bool = VCons Bool 1 True (VCons Bool Z False (VNil Bool))
    main : Nat = vlen Bool 2 testVec
  in main

### Evarified ###

  let
    constructor Bool :1: Type
    constructor True :2: Bool
    constructor False :3: Bool
    constructor Nat :4: Type
    constructor Z :5: Nat
    constructor S :6: (n :R: Nat) -> Nat
    constructor Vec :7: (_x0 :8: Nat) -> (_x1 :9: Type) -> Type
    constructor VNil :10: (a :11: Type) -> Vec -13- Z -12- a
    constructor VCons :14: (a :15: Type) -> (n :16: Nat) -> (x :17: a) -> (xs :18: Vec -20- n -19- a) -> Vec -22- (S -23- n) -21- a
    vlen :24: (a :25: Type) -> (n :26: Nat) -> (xs :27: Vec -29- n -28- a) -> Nat 
      (a :30: Type)
         -31- a -32- {Z} -33- (VNil -34- [a]) = Z
      (a :35: Type) (n :36: Nat) (x :37: a) (xs :38: Vec -40- n -39- a)
         -41- a -42- ({S} -43- n) -44- (VCons -45- [a] -46- [n] -47- x -48- xs) = S -49- (vlen -52- a -51- n -50- xs)
    testVec :53: Vec -55- 2 -54- Bool = VCons -61- Bool -60- 1 -59- True -58- (VCons -66- Bool -65- Z -64- False -63- (VNil -67- Bool))
    main :68: Nat = vlen -71- Bool -70- 2 -69- testVec
  in main

### Constraints ###

[] -> [5,6,10,14,18,24,27,33,38,44,48,49,50,53,58,63,69,R]
[11] -> [1,34,67]
[12] -> [19,28]
[13] -> [20,29]
[15] -> [1,45,61,66]
[16] -> [46,60,62,65]
[17] -> [2,3,47,59,64]
[19] -> [12,21,39]
[20] -> [13,22,40]
[21] -> [19,28,54]
[22] -> [20,29,55]
[23] -> [43,56,62]
[25] -> [1,31,35,41,52,71]
[26] -> [32,36,42,51,70,72,73]
[28] -> [12,21,39,54]
[29] -> [13,22,40,55]
[30] -> [31]
[31] -> [25]
[32] -> [26]
[34] -> [11,30]
[35] -> [41]
[36] -> [43]
[37] -> [47]
[39] -> [19,28]
[40] -> [20,29]
[41] -> [25]
[42] -> [26,43]
[43] -> [23,42]
[45] -> [15,35]
[46] -> [16,36]
[47] -> [17]
[51] -> [26]
[52] -> [25]
[54] -> [21,28]
[55] -> [22,29]
[56] -> [23,72]
[57] -> [62,73]
[59] -> [17]
[60] -> [16]
[61] -> [15]
[62] -> [23,57]
[64] -> [17]
[65] -> [16]
[66] -> [15]
[67] -> [11]
[70] -> [26]
[71] -> [25]
[72] -> [56]
[73] -> [57]
[R] -> [68]

### Solution ###

[5,6,10,14,18,24,27,33,38,44,48,49,50,53,58,63,68,69,R]

### Annotated ###

  let
    constructor Bool :E: Type
    constructor True :E: Bool
    constructor False :E: Bool
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (n :R: Nat) -> Nat
    constructor Vec :E: (_x0 :E: Nat) -> (_x1 :E: Type) -> Type
    constructor VNil :R: (a :E: Type) -> Vec -E- Z -E- a
    constructor VCons :R: (a :E: Type) -> (n :E: Nat) -> (x :E: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
    vlen :R: (a :E: Type) -> (n :E: Nat) -> (xs :R: Vec -E- n -E- a) -> Nat 
      (a :E: Type)
         -E- a -E- {Z} -R- (VNil -E- [a]) = Z
      (a :E: Type) (n :E: Nat) (x :E: a) (xs :R: Vec -E- n -E- a)
         -E- a -E- ({S} -E- n) -R- (VCons -E- [a] -E- [n] -E- x -R- xs) = S -R- (vlen -E- a -E- n -R- xs)
    testVec :R: Vec -E- 2 -E- Bool = VCons -E- Bool -E- 1 -E- True -R- (VCons -E- Bool -E- Z -E- False -R- (VNil -E- Bool))
    main :R: Nat = vlen -E- Bool -E- 2 -R- testVec
  in main

### Specialised ###

  let
    constructor Bool :E: Type
    constructor True :E: Bool
    constructor False :E: Bool
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (n :R: Nat) -> Nat
    constructor Vec :E: (_x0 :E: Nat) -> (_x1 :E: Type) -> Type
    constructor VNil :R: (a :E: Type) -> Vec -E- Z -E- a
    constructor VCons :R: (a :E: Type) -> (n :E: Nat) -> (x :E: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
    vlen :R: (a :E: Type) -> (n :E: Nat) -> (xs :R: Vec -E- n -E- a) -> Nat 
      (a :E: Type)
         -E- a -E- {Z} -R- (VNil -E- [a]) = Z
      (a :E: Type) (n :E: Nat) (x :E: a) (xs :R: Vec -E- n -E- a)
         -E- a -E- ({S} -E- n) -R- (VCons -E- [a] -E- [n] -E- x -R- xs) = S -R- (vlen -E- a -E- n -R- xs)
    testVec :R: Vec -E- 2 -E- Bool = VCons -E- Bool -E- 1 -E- True -R- (VCons -E- Bool -E- Z -E- False -R- (VNil -E- Bool))
    main :R: Nat = vlen -E- Bool -E- 2 -R- testVec
  in main

### Final annotation ###

  let
    constructor Bool :E: Type
    constructor True :E: Bool
    constructor False :E: Bool
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (n :R: Nat) -> Nat
    constructor Vec :E: (_x0 :E: Nat) -> (_x1 :E: Type) -> Type
    constructor VNil :R: (a :E: Type) -> Vec -E- Z -E- a
    constructor VCons :R: (a :E: Type) -> (n :E: Nat) -> (x :E: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
    vlen :R: (a :E: Type) -> (n :E: Nat) -> (xs :R: Vec -E- n -E- a) -> Nat 
      (a :E: Type)
         -E- a -E- {Z} -R- (VNil -E- [a]) = Z
      (a :E: Type) (n :E: Nat) (x :E: a) (xs :R: Vec -E- n -E- a)
         -E- a -E- ({S} -E- n) -R- (VCons -E- [a] -E- [n] -E- x -R- xs) = S -R- (vlen -E- a -E- n -R- xs)
    testVec :R: Vec -E- 2 -E- Bool = VCons -E- Bool -E- 1 -E- True -R- (VCons -E- Bool -E- Z -E- False -R- (VNil -E- Bool))
    main :R: Nat = vlen -E- Bool -E- 2 -R- testVec
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Z : Nat
    constructor S : (n) -> Nat
    constructor VNil : Vec
    constructor VCons : (xs) -> Vec
    vlen 
       VNil = Z
       (VCons xs) = S (vlen xs)
    testVec = VCons (VCons VNil)
    main = vlen testVec
  in main

### Normal forms ###

unerased:
  
  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (n :R: Nat) -> Nat
  in 2

erased:
  
  let
    constructor Z : Nat
    constructor S : (n) -> Nat
  in 2

