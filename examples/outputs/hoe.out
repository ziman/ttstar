-- vim: ft=ttstar

### Desugared ###

  let
    constructor T : Type
    constructor A : T
    constructor B : T
    postulate Op : (x :R: T) -> (y :R: T) -> T
    id : (x : T) -> T = (\x : T. x)
    const_A : (x : T) -> T = (\x : T. A)
    f : (g : (_x0 : T) -> T) -> (z : T) -> (h : (_x1 : T) -> T) -> (w : T) -> T = (\g : (_x0 : T) -> T. (\z : T. (\h : (_x1 : T) -> T. (\w : T. Op (g z) (h w)))))
    main : T = f id B const_A B
  in main

### Evarified ###

  let
    constructor T :1: Type
    constructor A :2: T
    constructor B :3: T
    postulate Op :4: (x :R: T) -> (y :R: T) -> T
    id :5: (x :6: T) -> T = (\x :7: T. x)
    const_A :8: (x :9: T) -> T = (\x :10: T. A)
    f :11: (g :12: (_x0 :13: T) -> T) -> (z :14: T) -> (h :15: (_x1 :16: T) -> T) -> (w :17: T) -> T = (\g :18: (_x0 :19: T) -> T. (\z :20: T. (\h :21: (_x1 :22: T) -> T. (\w :23: T. Op -25- (g -26- z) -24- (h -27- w)))))
    main :28: T = f -32- id -31- B -30- const_A -29- B
  in main

### Constraints ###

[6,32] -> [7,13]
[7,32] -> [6]
[9,30] -> [10,16]
[10,30] -> [9]
[12] -> [18,32]
[12,13] -> [19]
[12,19] -> [13]
[13,32] -> [6]
[14] -> [20,31]
[15] -> [21,30]
[15,16] -> [22]
[15,22] -> [16]
[16,30] -> [9]
[17] -> [23,29]
[18] -> [12]
[19,25] -> [26]
[20] -> [14]
[21] -> [15]
[22,24] -> [27]
[23] -> [17]
[24] -> [R]
[24,27] -> [22]
[24,27,R] -> [23]
[24,R] -> [21]
[25] -> [R]
[25,26] -> [19]
[25,26,R] -> [20]
[25,R] -> [18]
[29] -> [17]
[29,R] -> [3]
[30] -> [15]
[30,R] -> [2,8]
[31] -> [14]
[31,R] -> [3]
[32] -> [12]
[32,R] -> [5,7]
[R] -> [4,11,24,25,28]

### Solution ###

[2,3,4,5,6,7,8,11,12,13,14,15,18,19,20,21,24,25,26,28,30,31,32,R]

### Annotated ###

  let
    constructor T :E: Type
    constructor A :R: T
    constructor B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (x :R: T) -> T = (\x :R: T. x)
    const_A :R: (x :E: T) -> T = (\x :E: T. A)
    f :R: (g :R: (_x0 :R: T) -> T) -> (z :R: T) -> (h :R: (_x1 :E: T) -> T) -> (w :E: T) -> T = (\g :R: (_x0 :R: T) -> T. (\z :R: T. (\h :R: (_x1 :E: T) -> T. (\w :E: T. Op -R- (g -R- z) -R- (h -E- w)))))
    main :R: T = f -R- id -R- B -R- const_A -E- B
  in main

### Specialised ###

  let
    constructor T :E: Type
    constructor A :R: T
    constructor B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (x :R: T) -> T = (\x :R: T. x)
    const_A :R: (x :E: T) -> T = (\x :E: T. A)
    f :R: (g :R: (_x0 :R: T) -> T) -> (z :R: T) -> (h :R: (_x1 :E: T) -> T) -> (w :E: T) -> T = (\g :R: (_x0 :R: T) -> T. (\z :R: T. (\h :R: (_x1 :E: T) -> T. (\w :E: T. Op -R- (g -R- z) -R- (h -E- w)))))
    main :R: T = f -R- id -R- B -R- const_A -E- B
  in main

### Final annotation ###

  let
    constructor T :E: Type
    constructor A :R: T
    constructor B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (x :R: T) -> T = (\x :R: T. x)
    const_A :R: (x :E: T) -> T = (\x :E: T. A)
    f :R: (g :R: (_x0 :R: T) -> T) -> (z :R: T) -> (h :R: (_x1 :E: T) -> T) -> (w :E: T) -> T = (\g :R: (_x0 :R: T) -> T. (\z :R: T. (\h :R: (_x1 :E: T) -> T. (\w :E: T. Op -R- (g -R- z) -R- (h -E- w)))))
    main :R: T = f -R- id -R- B -R- const_A -E- B
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor A : T
    constructor B : T
    postulate Op : (x) -> (y) -> T
    id = (\x. x)
    const_A = A
    f = (\g. (\z. (\h. Op (g z) h)))
    main = f id B const_A
  in main

### Normal forms ###

unerased:
  
  let
    constructor T : Type
    constructor A : T
    constructor B : T
    postulate Op : (x :R: T) -> (y :R: T) -> T
  in Op B A

erased:
  
  let
    constructor A : T
    constructor B : T
    postulate Op : (x) -> (y) -> T
  in Op B A

