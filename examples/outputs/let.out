-- vim: ft=ttstar

### Desugared ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      m : Nat
        [plus] Z m = m
      n : Nat m : Nat
        [plus] (S n) m = S (plus n m)
    id : (x : Nat) -> Nat = (\x : Nat. x)
    const : (x : Nat) -> (y : Nat) -> Nat = (\x : Nat. (\y : Nat. x))
    main : Nat = 
      let apply : (_x2 : (_x3 : Nat) -> Nat) -> (_x4 : Nat) -> Nat 
        f : (_x5 : Nat) -> Nat
          [apply] f Z = f Z
        f : (_x6 : Nat) -> Nat x : Nat
          [apply] f (S x) = f (S x)
      in 
        let
          postulate Q : Nat
          three : Nat = 3
        in plus (apply id 2) (apply (const Q) three)
  in main

### Evarified ###

  let
    constructor Nat :1: Type
    constructor Z :2: Nat
    constructor S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      m :7: Nat
        [plus] -9- Z -8- m = m
      n :10: Nat m :11: Nat
        [plus] -13- (S -14- n) -12- m = S -15- (plus -17- n -16- m)
    id :18: (x :19: Nat) -> Nat = (\x :20: Nat. x)
    const :21: (x :22: Nat) -> (y :23: Nat) -> Nat = (\x :24: Nat. (\y :25: Nat. x))
    main :26: Nat = 
      let apply :27: (_x2 :28: (_x3 :29: Nat) -> Nat) -> (_x4 :30: Nat) -> Nat 
        f :31: (_x5 :32: Nat) -> Nat
          [apply] -34- f -33- Z = f -35- Z
        f :36: (_x6 :37: Nat) -> Nat x :38: Nat
          [apply] -40- f -39- (S -41- x) = f -42- (S -43- x)
      in 
        let
          postulate Q :44: Nat
          three :45: Nat = 3
        in plus -50- (apply -52- id -51- 2) -49- (apply -56- (const -57- Q) -55- three)
  in main

### Constraints ###

[5] -> [50]
[5,15] -> [17]
[5,R] -> [9,13]
[6] -> [49]
[6,15] -> [16]
[6,R] -> [8,12]
[7] -> [8]
[8] -> [R]
[8,R] -> [6]
[9] -> [R]
[9,R] -> [5]
[10] -> [14]
[11] -> [12]
[12] -> [R]
[12,R] -> [6]
[13] -> [R]
[13,14] -> [R]
[13,R] -> [5,14]
[14] -> [13]
[15] -> [R]
[15,16] -> [6]
[15,16,R] -> [11]
[15,17] -> [5]
[15,17,R] -> [10]
[15,R] -> [4]
[19,50,52] -> [20,29]
[20,50,52] -> [19]
[22,49,56] -> [24,57]
[23,49,56] -> [25,29]
[24,49,56] -> [22]
[25,49,56] -> [23]
[28,49] -> [56]
[28,49,R] -> [34,40]
[28,50] -> [52]
[28,50,R] -> [34,40]
[29,34,49] -> [32]
[29,34,50] -> [32]
[29,40,49] -> [37]
[29,40,50] -> [37]
[29,49,56] -> [23]
[29,50,52] -> [19]
[30,49] -> [55]
[30,49,R] -> [33,39]
[30,50] -> [51]
[30,50,R] -> [33,39]
[31,49] -> [34]
[31,50] -> [34]
[32,34,49] -> [29]
[32,34,50] -> [29]
[32,49] -> [35]
[32,50] -> [35]
[33,49] -> [R]
[33,49,R] -> [30]
[33,50] -> [R]
[33,50,R] -> [30]
[34,49] -> [R]
[34,49,R] -> [28]
[34,50] -> [R]
[34,50,R] -> [28]
[35,49] -> [32]
[35,49,R] -> [2]
[35,50] -> [32]
[35,50,R] -> [2]
[36,49] -> [40]
[36,50] -> [40]
[37,40,49] -> [29]
[37,40,50] -> [29]
[37,49] -> [42]
[37,50] -> [42]
[38,49] -> [41]
[38,50] -> [41]
[39,41,49] -> [R]
[39,41,50] -> [R]
[39,49] -> [R]
[39,49,R] -> [30,41]
[39,50] -> [R]
[39,50,R] -> [30,41]
[40,49] -> [R]
[40,49,R] -> [28]
[40,50] -> [R]
[40,50,R] -> [28]
[41,49] -> [39]
[41,50] -> [39]
[42,43,49] -> [R]
[42,43,49,R] -> [38]
[42,43,50] -> [R]
[42,43,50,R] -> [38]
[42,49] -> [37]
[42,49,R] -> [3,43]
[42,50] -> [37]
[42,50,R] -> [3,43]
[46,47,48,49,55] -> [R]
[46,47,48,49,55,R] -> [2]
[46,47,49,55] -> [R]
[46,47,49,55,R] -> [3,48]
[46,49,55] -> [R]
[46,49,55,R] -> [3,47]
[49] -> [6]
[49,55] -> [30]
[49,55,R] -> [3,45,46]
[49,56] -> [28]
[49,56,57] -> [22]
[49,56,57,R] -> [44]
[49,56,R] -> [21,24]
[49,R] -> [2,3,27,31,33,36,39]
[50] -> [5]
[50,51] -> [30]
[50,51,53] -> [R]
[50,51,53,54] -> [R]
[50,51,53,54,R] -> [2]
[50,51,53,R] -> [3,54]
[50,51,R] -> [3,53]
[50,52] -> [28]
[50,52,R] -> [18,20]
[50,R] -> [2,3,27,31,33,36,39]
[R] -> [2,3,4,7,9,13,15,26]

### Solution ###

[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,R]

### Annotated ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :R: (_x0 :R: Nat) -> (_x1 :R: Nat) -> Nat 
      m :R: Nat
        [plus] -R- Z -R- m = m
      n :R: Nat m :R: Nat
        [plus] -R- (S -R- n) -R- m = S -R- (plus -R- n -R- m)
    id :R: (x :R: Nat) -> Nat = (\x :R: Nat. x)
    const :R: (x :R: Nat) -> (y :R: Nat) -> Nat = (\x :R: Nat. (\y :R: Nat. x))
    main :R: Nat = 
      let apply :R: (_x2 :R: (_x3 :R: Nat) -> Nat) -> (_x4 :R: Nat) -> Nat 
        f :R: (_x5 :R: Nat) -> Nat
          [apply] -R- f -R- Z = f -R- Z
        f :R: (_x6 :R: Nat) -> Nat x :R: Nat
          [apply] -R- f -R- (S -R- x) = f -R- (S -R- x)
      in 
        let
          postulate Q :R: Nat
          three :R: Nat = 3
        in plus -R- (apply -R- id -R- 2) -R- (apply -R- (const -R- Q) -R- three)
  in main

### Specialised ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :R: (_x0 :R: Nat) -> (_x1 :R: Nat) -> Nat 
      m :R: Nat
        [plus] -R- Z -R- m = m
      n :R: Nat m :R: Nat
        [plus] -R- (S -R- n) -R- m = S -R- (plus -R- n -R- m)
    id :R: (x :R: Nat) -> Nat = (\x :R: Nat. x)
    const :R: (x :R: Nat) -> (y :R: Nat) -> Nat = (\x :R: Nat. (\y :R: Nat. x))
    main :R: Nat = 
      let apply :R: (_x2 :R: (_x3 :R: Nat) -> Nat) -> (_x4 :R: Nat) -> Nat 
        f :R: (_x5 :R: Nat) -> Nat
          [apply] -R- f -R- Z = f -R- Z
        f :R: (_x6 :R: Nat) -> Nat x :R: Nat
          [apply] -R- f -R- (S -R- x) = f -R- (S -R- x)
      in 
        let
          postulate Q :R: Nat
          three :R: Nat = 3
        in plus -R- (apply -R- id -R- 2) -R- (apply -R- (const -R- Q) -R- three)
  in main

### Final annotation ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :R: (_x0 :R: Nat) -> (_x1 :R: Nat) -> Nat 
      m :R: Nat
        [plus] -R- Z -R- m = m
      n :R: Nat m :R: Nat
        [plus] -R- (S -R- n) -R- m = S -R- (plus -R- n -R- m)
    id :R: (x :R: Nat) -> Nat = (\x :R: Nat. x)
    const :R: (x :R: Nat) -> (y :R: Nat) -> Nat = (\x :R: Nat. (\y :R: Nat. x))
    main :R: Nat = 
      let apply :R: (_x2 :R: (_x3 :R: Nat) -> Nat) -> (_x4 :R: Nat) -> Nat 
        f :R: (_x5 :R: Nat) -> Nat
          [apply] -R- f -R- Z = f -R- Z
        f :R: (_x6 :R: Nat) -> Nat x :R: Nat
          [apply] -R- f -R- (S -R- x) = f -R- (S -R- x)
      in 
        let
          postulate Q :R: Nat
          three :R: Nat = 3
        in plus -R- (apply -R- id -R- 2) -R- (apply -R- (const -R- Q) -R- three)
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    plus 
      [_] Z m = m
      [_] (S n) m = S (plus n m)
    id = (\x. x)
    const = (\x. (\y. x))
    main = 
      let apply 
        [_] f Z = f Z
        [_] f (S x) = f (S x)
      in 
        let
          postulate Q : Nat
          three = 3
        in plus (apply id 2) (apply (const Q) three)
  in main

### Normal forms ###

unerased:
  
  let
    constructor Nat : Type
    constructor S : (x :R: Nat) -> Nat
  in 
    let postulate Q : Nat
    in S (S Q)

erased:
  
  let constructor S : (x) -> Nat
  in 
    let postulate Q : Nat
    in S (S Q)

