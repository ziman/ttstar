-- vim: ft=ttstar

### Desugared ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : _0
        plus Z n = n
      m : _1 n : _2
        plus (S m) n = S (plus m n)
    times : (_x2 : Nat) -> (_x3 : Nat) -> Nat 
      n : _3
        times Z n = Z
      m : _4 n : _5
        times (S m) n = plus n (times m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x4 : Bool) -> Bool 
      not True = False
      not False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x5 : Type) -> (_x6 : Type) -> Type
    constructor MkPair : (a : _6) -> (b : _7) -> (_x7 : a) -> (_x8 : b) -> Pair a b
    fst : (a : _8) -> (b : _9) -> (_x9 : Pair a b) -> a 
      a : _10 b : _11 x : _12 y : _13
        fst a b ([MkPair] [_14] [_15] x y) = x
    snd : (a : _16) -> (b : _17) -> (_x10 : Pair a b) -> b 
      a : _18 b : _19 x : _20 y : _21
        snd a b ([MkPair] [_22] [_23] x y) = y
    constructor Either : (_x11 : Type) -> (_x12 : Type) -> Type
    constructor Left : (a : _24) -> (b : _25) -> (_x13 : a) -> Either a b
    constructor Right : (a : _26) -> (b : _27) -> (_x14 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x15 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x16 : Fin n) -> Fin (S n)
    constructor Vect : (_x17 : Nat) -> (_x18 : Type) -> Type
    constructor VN : (a : _28) -> Vect Z a
    constructor VC : (n : _29) -> (a : _30) -> (_x19 : a) -> (_x20 : Vect n a) -> Vect (S n) a
    constructor List : (_x21 : Type) -> Type
    constructor Nil : (a : _31) -> List a
    constructor Cons : (a : _32) -> (_x22 : a) -> (_x23 : List a) -> List a
    constructor State : (_x0 : Type) -> (_x1 : Type) -> Type
    constructor MkSt : (st : _33) -> (a : _34) -> (run : (_x2 : st) -> Pair st a) -> State st a
    runState : (st : _35) -> (a : _36) -> (_x3 : State st a) -> (_x4 : st) -> Pair st a 
      st : _37 a : _38 run : (_x5 : st) -> Pair st a
        runState st a ([MkSt] [_39] [_40] run) = run
    execState : (st : Type) -> (a : Type) -> (x : State st a) -> (s : st) -> a = (\st : Type. (\a : Type. (\x : State st a. (\s : st. snd st a (runState st a x s)))))
    stGet : (st : Type) -> State st st = (\st : Type. MkSt st st (\s : st. MkPair st st s s))
    stReturn : (st : Type) -> (a : Type) -> (x : a) -> State st a = (\st : Type. (\a : Type. (\x : a. MkSt st a (\s : st. MkPair st a s x))))
    stBind : (st : _41) -> (a : _42) -> (b : _43) -> (x : State st a) -> (y : (z : a) -> State st b) -> State st b 
      st : Type a : Type b : Type f : (_x6 : st) -> Pair st a g : (_x7 : a) -> State st b
        stBind st a b ([MkSt] [st] [a] f) g = 
          let
            stBind3 : (st : Type) -> (b : Type) -> (_x8 : st) -> (_x9 : State st b) -> Pair st b 
              st : Type b : Type s : st f : (_x10 : st) -> Pair st b
                stBind3 st b s ([MkSt] [st] [b] f) = f s
            stBind2 : (st : Type) -> (a : Type) -> (b : Type) -> (g : (_x11 : a) -> State st b) -> (r : Pair st a) -> Pair st b 
              st : Type a : Type b : Type g : (_x12 : a) -> State st b x : a s : st
                stBind2 st a b g ([MkPair] [st] [a] s x) = stBind3 st b s (g x)
          in MkSt st b (\s : st. stBind2 st a b g (f s))
    postulate RealWorld : Type
    IO : (_x0 : Type) -> Type = State RealWorld
    ioReturn : (a : Type) -> (x : a) -> IO a = (\a : Type. (\x : a. stReturn RealWorld a x))
    ioBind : (a : Type) -> (b : Type) -> (x : IO a) -> (y : (_x1 : a) -> IO b) -> IO b = (\a : Type. (\b : Type. (\x : IO a. (\y : (_x1 : a) -> IO b. stBind RealWorld a b x y))))
    ioWrapImpure : (a : Type) -> (impureF : (w :R: RealWorld) -> a) -> IO a = (\a : Type. (\impureF : (w :R: RealWorld) -> a. stBind RealWorld RealWorld a (stGet RealWorld) (\w : _44. stReturn RealWorld a (impureF w))))
    unsafePerformIO : (a : Type) -> (x : IO a) -> a = (\a : Type. (\x : IO a. 
      let postulate TheWorld : RealWorld
      in execState RealWorld a x TheWorld))
    postulate Int : Type
    foreign intS : (x :R: Int) -> Int
    foreign intZ : Int
    postulate Unspec : Type
    printSchemeRepr : (a : Type) -> (x : a) -> IO Unspec = (\a : Type. (\x : a. 
      let foreign nativePrint : (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure Unspec (\w : _45. nativePrint a x)))
    natToInt : (_x0 : Nat) -> Int 
      natToInt Z = intZ
      n : Nat
        natToInt (S n) = intS (natToInt n)
    foreign intToNat : (x :R: Int) -> Nat
    printNat : (x : Nat) -> IO Unspec = (\x : Nat. printSchemeRepr Int (natToInt x))
    main : _46 = unsafePerformIO _47 (ioBind _48 _49 (ioReturn _50 4) (\v : _51. ioBind _52 _53 (printNat v) (\_do0 : _54. printSchemeRepr _55 (intToNat (intS (intS (intS intZ)))))))
  in main

### Elaborated ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        plus Z n = n
      m : Nat n : Nat
        plus (S m) n = S (plus m n)
    times : (_x2 : Nat) -> (_x3 : Nat) -> Nat 
      n : Nat
        times Z n = Z
      m : Nat n : Nat
        times (S m) n = plus n (times m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x4 : Bool) -> Bool 
      not True = False
      not False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x5 : Type) -> (_x6 : Type) -> Type
    constructor MkPair : (a : Type) -> (b : Type) -> (_x7 : a) -> (_x8 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x9 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        fst a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x10 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        snd a b ([MkPair] [a] [b] x y) = y
    constructor Either : (_x11 : Type) -> (_x12 : Type) -> Type
    constructor Left : (a : Type) -> (b : Type) -> (_x13 : a) -> Either a b
    constructor Right : (a : Type) -> (b : Type) -> (_x14 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x15 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x16 : Fin n) -> Fin (S n)
    constructor Vect : (_x17 : Nat) -> (_x18 : Type) -> Type
    constructor VN : (a : Type) -> Vect Z a
    constructor VC : (n : Nat) -> (a : Type) -> (_x19 : a) -> (_x20 : Vect n a) -> Vect (S n) a
    constructor List : (_x21 : Type) -> Type
    constructor Nil : (a : Type) -> List a
    constructor Cons : (a : Type) -> (_x22 : a) -> (_x23 : List a) -> List a
    constructor State : (_x0 : Type) -> (_x1 : Type) -> Type
    constructor MkSt : (st : Type) -> (a : Type) -> (run : (_x2 : st) -> Pair st a) -> State st a
    runState : (st : Type) -> (a : Type) -> (_x3 : State st a) -> (_x4 : st) -> Pair st a 
      st : Type a : Type run : (_x5 : st) -> Pair st a
        runState st a ([MkSt] [st] [a] run) = run
    execState : (st : Type) -> (a : Type) -> (x : State st a) -> (s : st) -> a = (\st : Type. (\a : Type. (\x : State st a. (\s : st. snd st a (runState st a x s)))))
    stGet : (st : Type) -> State st st = (\st : Type. MkSt st st (\s : st. MkPair st st s s))
    stReturn : (st : Type) -> (a : Type) -> (x : a) -> State st a = (\st : Type. (\a : Type. (\x : a. MkSt st a (\s : st. MkPair st a s x))))
    stBind : (st : Type) -> (a : Type) -> (b : Type) -> (x : State st a) -> (y : (z : a) -> State st b) -> State st b 
      st : Type a : Type b : Type f : (_x6 : st) -> Pair st a g : (_x7 : a) -> State st b
        stBind st a b ([MkSt] [st] [a] f) g = 
          let
            stBind3 : (st : Type) -> (b : Type) -> (_x8 : st) -> (_x9 : State st b) -> Pair st b 
              st : Type b : Type s : st f : (_x10 : st) -> Pair st b
                stBind3 st b s ([MkSt] [st] [b] f) = f s
            stBind2 : (st : Type) -> (a : Type) -> (b : Type) -> (g : (_x11 : a) -> State st b) -> (r : Pair st a) -> Pair st b 
              st : Type a : Type b : Type g : (_x12 : a) -> State st b x : a s : st
                stBind2 st a b g ([MkPair] [st] [a] s x) = stBind3 st b s (g x)
          in MkSt st b (\s : st. stBind2 st a b g (f s))
    postulate RealWorld : Type
    IO : (_x0 : Type) -> Type = State RealWorld
    ioReturn : (a : Type) -> (x : a) -> IO a = (\a : Type. (\x : a. stReturn RealWorld a x))
    ioBind : (a : Type) -> (b : Type) -> (x : IO a) -> (y : (_x1 : a) -> IO b) -> IO b = (\a : Type. (\b : Type. (\x : IO a. (\y : (_x1 : a) -> IO b. stBind RealWorld a b x y))))
    ioWrapImpure : (a : Type) -> (impureF : (w :R: RealWorld) -> a) -> IO a = (\a : Type. (\impureF : (w :R: RealWorld) -> a. stBind RealWorld RealWorld a (stGet RealWorld) (\w : RealWorld. stReturn RealWorld a (impureF w))))
    unsafePerformIO : (a : Type) -> (x : IO a) -> a = (\a : Type. (\x : IO a. 
      let postulate TheWorld : RealWorld
      in execState RealWorld a x TheWorld))
    postulate Int : Type
    foreign intS : (x :R: Int) -> Int
    foreign intZ : Int
    postulate Unspec : Type
    printSchemeRepr : (a : Type) -> (x : a) -> IO Unspec = (\a : Type. (\x : a. 
      let foreign nativePrint : (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure Unspec (\w : RealWorld. nativePrint a x)))
    natToInt : (_x0 : Nat) -> Int 
      natToInt Z = intZ
      n : Nat
        natToInt (S n) = intS (natToInt n)
    foreign intToNat : (x :R: Int) -> Nat
    printNat : (x : Nat) -> IO Unspec = (\x : Nat. printSchemeRepr Int (natToInt x))
    main : Unspec = unsafePerformIO Unspec (ioBind Nat Unspec (ioReturn Nat 4) (\v : Nat. ioBind Unspec Unspec (printNat v) (\_do0 : Unspec. printSchemeRepr Nat (intToNat (intS (intS (intS intZ)))))))
  in main

### Evarified ###

  let
    constructor Nat :1: Type
    constructor Z :2: Nat
    constructor S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        plus -9- Z -8- n = n
      m :10: Nat n :11: Nat
        plus -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    times :18: (_x2 :19: Nat) -> (_x3 :20: Nat) -> Nat 
      n :21: Nat
        times -23- Z -22- n = Z
      m :24: Nat n :25: Nat
        times -27- (S -28- m) -26- n = plus -30- n -29- (times -32- m -31- n)
    constructor Bool :33: Type
    constructor True :34: Bool
    constructor False :35: Bool
    not :36: (_x4 :37: Bool) -> Bool 
      not -38- True = False
      not -39- False = True
    constructor Unit :40: Type
    constructor MkUnit :41: Unit
    constructor Pair :42: (_x5 :43: Type) -> (_x6 :44: Type) -> Type
    constructor MkPair :45: (a :46: Type) -> (b :47: Type) -> (_x7 :48: a) -> (_x8 :49: b) -> Pair -51- a -50- b
    fst :52: (a :53: Type) -> (b :54: Type) -> (_x9 :55: Pair -57- a -56- b) -> a 
      a :58: Type b :59: Type x :60: a y :61: b
        fst -64- a -63- b -62- ([MkPair] -68- [a] -67- [b] -66- x -65- y) = x
    snd :69: (a :70: Type) -> (b :71: Type) -> (_x10 :72: Pair -74- a -73- b) -> b 
      a :75: Type b :76: Type x :77: a y :78: b
        snd -81- a -80- b -79- ([MkPair] -85- [a] -84- [b] -83- x -82- y) = y
    constructor Either :86: (_x11 :87: Type) -> (_x12 :88: Type) -> Type
    constructor Left :89: (a :90: Type) -> (b :91: Type) -> (_x13 :92: a) -> Either -94- a -93- b
    constructor Right :95: (a :96: Type) -> (b :97: Type) -> (_x14 :98: b) -> Either -100- a -99- b
    id :101: (a :102: Type) -> (x :103: a) -> a = (\a :104: Type. (\x :105: a. x))
    constructor Fin :106: (_x15 :107: Nat) -> Type
    constructor FZ :108: (n :109: Nat) -> Fin -110- (S -111- n)
    constructor FS :112: (n :113: Nat) -> (_x16 :114: Fin -115- n) -> Fin -116- (S -117- n)
    constructor Vect :118: (_x17 :119: Nat) -> (_x18 :120: Type) -> Type
    constructor VN :121: (a :122: Type) -> Vect -124- Z -123- a
    constructor VC :125: (n :126: Nat) -> (a :127: Type) -> (_x19 :128: a) -> (_x20 :129: Vect -131- n -130- a) -> Vect -133- (S -134- n) -132- a
    constructor List :135: (_x21 :136: Type) -> Type
    constructor Nil :137: (a :138: Type) -> List -139- a
    constructor Cons :140: (a :141: Type) -> (_x22 :142: a) -> (_x23 :143: List -144- a) -> List -145- a
    constructor State :146: (_x0 :147: Type) -> (_x1 :148: Type) -> Type
    constructor MkSt :149: (st :150: Type) -> (a :151: Type) -> (run :152: (_x2 :153: st) -> Pair -155- st -154- a) -> State -157- st -156- a
    runState :158: (st :159: Type) -> (a :160: Type) -> (_x3 :161: State -163- st -162- a) -> (_x4 :164: st) -> Pair -166- st -165- a 
      st :167: Type a :168: Type run :169: (_x5 :170: st) -> Pair -172- st -171- a
        runState -175- st -174- a -173- ([MkSt] -178- [st] -177- [a] -176- run) = run
    execState :179: (st :180: Type) -> (a :181: Type) -> (x :182: State -184- st -183- a) -> (s :185: st) -> a = (\st :186: Type. (\a :187: Type. (\x :188: State -190- st -189- a. (\s :191: st. snd -194- st -193- a -192- (runState -198- st -197- a -196- x -195- s)))))
    stGet :199: (st :200: Type) -> State -202- st -201- st = (\st :203: Type. MkSt -206- st -205- st -204- (\s :207: st. MkPair -211- st -210- st -209- s -208- s))
    stReturn :212: (st :213: Type) -> (a :214: Type) -> (x :215: a) -> State -217- st -216- a = (\st :218: Type. (\a :219: Type. (\x :220: a. MkSt -223- st -222- a -221- (\s :224: st. MkPair -228- st -227- a -226- s -225- x))))
    stBind :229: (st :230: Type) -> (a :231: Type) -> (b :232: Type) -> (x :233: State -235- st -234- a) -> (y :236: (z :237: a) -> State -239- st -238- b) -> State -241- st -240- b 
      st :242: Type a :243: Type b :244: Type f :245: (_x6 :246: st) -> Pair -248- st -247- a g :249: (_x7 :250: a) -> State -252- st -251- b
        stBind -257- st -256- a -255- b -254- ([MkSt] -260- [st] -259- [a] -258- f) -253- g = 
          let
            stBind3 :261: (st :262: Type) -> (b :263: Type) -> (_x8 :264: st) -> (_x9 :265: State -267- st -266- b) -> Pair -269- st -268- b 
              st :270: Type b :271: Type s :272: st f :273: (_x10 :274: st) -> Pair -276- st -275- b
                stBind3 -280- st -279- b -278- s -277- ([MkSt] -283- [st] -282- [b] -281- f) = f -284- s
            stBind2 :285: (st :286: Type) -> (a :287: Type) -> (b :288: Type) -> (g :289: (_x11 :290: a) -> State -292- st -291- b) -> (r :293: Pair -295- st -294- a) -> Pair -297- st -296- b 
              st :298: Type a :299: Type b :300: Type g :301: (_x12 :302: a) -> State -304- st -303- b x :305: a s :306: st
                stBind2 -311- st -310- a -309- b -308- g -307- ([MkPair] -315- [st] -314- [a] -313- s -312- x) = stBind3 -319- st -318- b -317- s -316- (g -320- x)
          in MkSt -323- st -322- b -321- (\s :324: st. stBind2 -329- st -328- a -327- b -326- g -325- (f -330- s))
    postulate RealWorld :331: Type
    IO :332: (_x0 :333: Type) -> Type = State -334- RealWorld
    ioReturn :335: (a :336: Type) -> (x :337: a) -> IO -338- a = (\a :339: Type. (\x :340: a. stReturn -343- RealWorld -342- a -341- x))
    ioBind :344: (a :345: Type) -> (b :346: Type) -> (x :347: IO -348- a) -> (y :349: (_x1 :350: a) -> IO -351- b) -> IO -352- b = (\a :353: Type. (\b :354: Type. (\x :355: IO -356- a. (\y :357: (_x1 :358: a) -> IO -359- b. stBind -364- RealWorld -363- a -362- b -361- x -360- y))))
    ioWrapImpure :365: (a :366: Type) -> (impureF :367: (w :R: RealWorld) -> a) -> IO -368- a = (\a :369: Type. (\impureF :370: (w :R: RealWorld) -> a. stBind -375- RealWorld -374- RealWorld -373- a -372- (stGet -376- RealWorld) -371- (\w :377: RealWorld. stReturn -380- RealWorld -379- a -378- (impureF -381- w))))
    unsafePerformIO :382: (a :383: Type) -> (x :384: IO -385- a) -> a = (\a :386: Type. (\x :387: IO -388- a. 
      let postulate TheWorld :389: RealWorld
      in execState -393- RealWorld -392- a -391- x -390- TheWorld))
    postulate Int :394: Type
    foreign intS :395: (x :R: Int) -> Int
    foreign intZ :396: Int
    postulate Unspec :397: Type
    printSchemeRepr :398: (a :399: Type) -> (x :400: a) -> IO -401- Unspec = (\a :402: Type. (\x :403: a. 
      let foreign nativePrint :404: (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure -406- Unspec -405- (\w :407: RealWorld. nativePrint -409- a -408- x)))
    natToInt :410: (_x0 :411: Nat) -> Int 
      natToInt -412- Z = intZ
      n :413: Nat
        natToInt -414- (S -415- n) = intS -416- (natToInt -417- n)
    foreign intToNat :418: (x :R: Int) -> Nat
    printNat :419: (x :420: Nat) -> IO -421- Unspec = (\x :422: Nat. printSchemeRepr -424- Int -423- (natToInt -425- x))
    main :426: Unspec = unsafePerformIO -428- Unspec -427- (ioBind -432- Nat -431- Unspec -430- (ioReturn -434- Nat -433- 4) -429- (\v :439: Nat. ioBind -443- Unspec -442- Unspec -441- (printNat -444- v) -440- (\_do0 :445: Unspec. printSchemeRepr -447- Nat -446- (intToNat -448- (intS -449- (intS -450- (intS -451- intZ)))))))
  in main

### Constraints ###

[] -> [14,15,28,111,117,134,381,407,408,415,416,426,435,436,437,438,448,449,450,451]
[4] -> [2,3,7,9,13]
[4,8] -> [7]
[4,12] -> [11]
[4,13,14] -> [10]
[4,15,16] -> [11]
[4,15,17] -> [10]
[5] -> [9,13,17,30]
[6] -> [8,12,16,29]
[7] -> [4,8]
[8] -> [6]
[9] -> [5]
[10] -> [4,13,14]
[11] -> [4,12]
[12] -> [6]
[13] -> [5]
[16] -> [6]
[17] -> [5]
[18] -> [2,3,4,23,27]
[18,22] -> [21]
[18,26] -> [25]
[18,27,28] -> [24]
[18,29,31] -> [25]
[18,29,32] -> [24]
[18,30] -> [25]
[19] -> [23,27,32]
[20] -> [22,26,31]
[21] -> [18,22]
[22] -> [20]
[23] -> [19]
[24] -> [18,27,28]
[25] -> [18,26]
[26] -> [20]
[27] -> [19]
[29] -> [6]
[30] -> [5]
[31] -> [20]
[32] -> [19]
[36] -> [34,35,38,39]
[37] -> [38,39]
[38] -> [37]
[39] -> [37]
[43] -> [51,57,74,155,166,172,248,269,276,295,297]
[44] -> [50,56,73,154,165,171,247,268,275,294,296]
[46] -> [68,85,211,228,315]
[47] -> [67,84,210,227,314]
[48] -> [66,83,209,226,313]
[49] -> [65,82,208,225,312]
[50] -> [44,56,73,154,294]
[51] -> [43]
[52] -> [60]
[52,62] -> [45]
[52,62,65] -> [61]
[52,62,66] -> [60]
[52,62,67] -> [59]
[52,62,68] -> [58]
[52,63] -> [59]
[52,64] -> [58]
[53] -> [64]
[54] -> [63]
[55] -> [62]
[56] -> [44,50]
[57] -> [43]
[58] -> [52,64]
[59] -> [52,63]
[60] -> [52,62,66]
[61] -> [52,62,65]
[62] -> [55]
[63] -> [54]
[64] -> [53]
[65] -> [49]
[66] -> [48]
[67] -> [47]
[68] -> [46]
[69] -> [78]
[69,79] -> [45]
[69,79,82] -> [78]
[69,79,83] -> [77]
[69,79,84] -> [76]
[69,79,85] -> [75]
[69,80] -> [76]
[69,81] -> [75]
[70] -> [81,194]
[71] -> [80,193]
[72] -> [79,192]
[73] -> [44,50,165]
[74] -> [43]
[75] -> [69,81]
[76] -> [69,80]
[77] -> [69,79,83]
[78] -> [69,79,82]
[79] -> [72]
[80] -> [71]
[81] -> [70]
[82] -> [49]
[83] -> [48]
[84] -> [47]
[85] -> [46]
[87] -> [94,100]
[88] -> [93,99]
[93] -> [88]
[94] -> [87]
[99] -> [88]
[100] -> [87]
[101] -> [105]
[102] -> [104]
[103] -> [105]
[104] -> [102]
[105] -> [103]
[107] -> [110,115,116]
[110] -> [107]
[115] -> [107]
[116] -> [107]
[119] -> [124,131,133]
[120] -> [123,130,132]
[123] -> [120]
[124] -> [119]
[130] -> [120]
[131] -> [119]
[132] -> [120]
[133] -> [119]
[136] -> [139,144,145]
[139] -> [136]
[144] -> [136]
[145] -> [136]
[147] -> [157,163,184,190,202,217,235,239,241,252,267,292,304,334]
[148] -> [156,162,183,189,201,216,234,238,240,251,266,291,303,333]
[150] -> [178,206,223,260,283,323]
[151] -> [177,205,222,259,282,322]
[152] -> [176,204,221,258,281,321]
[153] -> [170,207,224,246,274,324]
[154] -> [44,50,171,247,275,296]
[155] -> [43]
[156] -> [148,162,201,216,234,240,266]
[157] -> [147]
[158] -> [169]
[158,173] -> [149]
[158,173,176] -> [169]
[158,173,177] -> [168]
[158,173,178] -> [167]
[158,174] -> [168]
[158,175] -> [167]
[159] -> [175,198]
[160] -> [174,197]
[161] -> [173,196]
[162] -> [148,156,189]
[163] -> [147]
[164] -> [170,195]
[165] -> [44,73,171]
[166] -> [43]
[167] -> [158,175]
[168] -> [158,174]
[169] -> [158,173,176]
[170] -> [153,164]
[171] -> [44,154,165]
[172] -> [43]
[173] -> [161]
[174] -> [160]
[175] -> [159]
[176] -> [152]
[177] -> [151]
[178] -> [150]
[179] -> [69]
[179,192] -> [158]
[179,192,195] -> [191]
[179,192,196] -> [188]
[179,192,197] -> [187]
[179,192,198] -> [186]
[179,193] -> [187]
[179,194] -> [186]
[180] -> [186,393]
[181] -> [187,392]
[182] -> [188,391]
[183] -> [148,189,388]
[184] -> [147]
[185] -> [191,390]
[186] -> [180]
[187] -> [181]
[188] -> [182]
[189] -> [148,162,183]
[190] -> [147]
[191] -> [185]
[192] -> [72]
[193] -> [71]
[194] -> [70]
[195] -> [164]
[196] -> [161]
[197] -> [160]
[198] -> [159]
[199] -> [149]
[199,204] -> [45]
[199,204,208] -> [207]
[199,204,209] -> [207]
[199,204,210] -> [203]
[199,204,211] -> [203]
[199,205] -> [203]
[199,206] -> [203]
[200] -> [203,376]
[201] -> [148,156,234]
[202] -> [147]
[203] -> [200]
[204] -> [152]
[205] -> [151]
[206] -> [150]
[207] -> [153]
[208] -> [49]
[209] -> [48]
[210] -> [47]
[211] -> [46]
[212] -> [149]
[212,221] -> [45]
[212,221,225] -> [220]
[212,221,226] -> [224]
[212,221,227] -> [219]
[212,221,228] -> [218]
[212,222] -> [219]
[212,223] -> [218]
[213] -> [218,343,380]
[214] -> [219,342,379]
[215] -> [220,341,378]
[216] -> [148,156,238,338]
[217] -> [147]
[218] -> [213]
[219] -> [214]
[220] -> [215]
[221] -> [152]
[222] -> [151]
[223] -> [150]
[224] -> [153]
[225] -> [49]
[226] -> [48]
[227] -> [47]
[228] -> [46]
[229] -> [149]
[229,253] -> [249]
[229,254] -> [149]
[229,254,258] -> [245]
[229,254,259] -> [243]
[229,254,260] -> [242]
[229,255] -> [244]
[229,256] -> [243]
[229,257] -> [242]
[229,321] -> [285]
[229,321,325] -> [245]
[229,321,325,330] -> [324]
[229,321,326] -> [249]
[229,321,327] -> [244]
[229,321,328] -> [243]
[229,321,329] -> [242]
[229,322] -> [244]
[229,323] -> [242]
[230] -> [257,364,375]
[231] -> [256,363,374]
[232] -> [255,362,373]
[233] -> [254,361,372]
[234] -> [148,156,201,356]
[235] -> [147]
[236] -> [253,360,371]
[237] -> [250,358,377]
[238] -> [148,216,251,359]
[239] -> [147]
[240] -> [148,156,352,368]
[241] -> [147]
[242] -> [229,257]
[243] -> [229,256]
[244] -> [229,255]
[245] -> [229,254,258]
[246] -> [153,330]
[247] -> [44,154,294]
[248] -> [43]
[249] -> [229,253]
[250] -> [237,290]
[251] -> [148,238,291]
[252] -> [147]
[253] -> [236]
[254] -> [233]
[255] -> [232]
[256] -> [231]
[257] -> [230]
[258] -> [152]
[259] -> [151]
[260] -> [150]
[261] -> [273]
[261,277] -> [149]
[261,277,281] -> [273]
[261,277,282] -> [271]
[261,277,283] -> [270]
[261,278] -> [272]
[261,279] -> [271]
[261,280] -> [270]
[261,284] -> [272]
[262] -> [280,319]
[263] -> [279,318]
[264] -> [278,317]
[265] -> [277,316]
[266] -> [148,156,303]
[267] -> [147]
[268] -> [44,275,296]
[269] -> [43]
[270] -> [261,280]
[271] -> [261,279]
[272] -> [261,278]
[273] -> [261,277,281]
[274] -> [153,284]
[275] -> [44,154,268]
[276] -> [43]
[277] -> [265]
[278] -> [264]
[279] -> [263]
[280] -> [262]
[281] -> [152]
[282] -> [151]
[283] -> [150]
[284] -> [274]
[285] -> [261]
[285,307] -> [45]
[285,307,312] -> [305]
[285,307,313] -> [306]
[285,307,314] -> [299]
[285,307,315] -> [298]
[285,308] -> [301]
[285,309] -> [300]
[285,310] -> [299]
[285,311] -> [298]
[285,316] -> [301]
[285,316,320] -> [305]
[285,317] -> [306]
[285,318] -> [300]
[285,319] -> [298]
[286] -> [311,329]
[287] -> [310,328]
[288] -> [309,327]
[289] -> [308,326]
[290] -> [250,302]
[291] -> [148,251,303]
[292] -> [147]
[293] -> [307,325]
[294] -> [44,50,247]
[295] -> [43]
[296] -> [44,154,268]
[297] -> [43]
[298] -> [285,311]
[299] -> [285,310]
[300] -> [285,309]
[301] -> [285,308]
[302] -> [290,320]
[303] -> [148,266,291]
[304] -> [147]
[305] -> [285,307,312]
[306] -> [285,307,313]
[307] -> [293]
[308] -> [289]
[309] -> [288]
[310] -> [287]
[311] -> [286]
[312] -> [49]
[313] -> [48]
[314] -> [47]
[315] -> [46]
[316] -> [265]
[317] -> [264]
[318] -> [263]
[319] -> [262]
[320] -> [302]
[321] -> [152]
[322] -> [151]
[323] -> [150]
[324] -> [153]
[325] -> [293]
[326] -> [289]
[327] -> [288]
[328] -> [287]
[329] -> [286]
[330] -> [246]
[332] -> [146]
[332,334] -> [331]
[333] -> [148,338,348,351,352,356,359,368,385,388,401,421]
[334] -> [147]
[335] -> [212]
[335,341] -> [340]
[335,342] -> [339]
[335,343] -> [331]
[336] -> [339,434]
[337] -> [340,433]
[338] -> [216,333,348]
[339] -> [336]
[340] -> [337]
[341] -> [215]
[342] -> [214]
[343] -> [213]
[344] -> [229]
[344,360] -> [357]
[344,361] -> [355]
[344,362] -> [354]
[344,363] -> [353]
[344,364] -> [331]
[345] -> [353,432,443]
[346] -> [354,431,442]
[347] -> [355,430,441]
[348] -> [333,338,356,421]
[349] -> [357,429,440]
[350] -> [358,439,445]
[351] -> [333,352,359,401]
[352] -> [240,333,351,385]
[353] -> [345]
[354] -> [346]
[355] -> [347]
[356] -> [234,333,348]
[357] -> [349]
[358] -> [237,350]
[359] -> [238,333,351]
[360] -> [236]
[361] -> [233]
[362] -> [232]
[363] -> [231]
[364] -> [230]
[365] -> [229]
[365,371] -> [212]
[365,371,378] -> [370]
[365,371,378,381] -> [377]
[365,371,379] -> [369]
[365,371,380] -> [331]
[365,372] -> [199]
[365,372,376] -> [331]
[365,373] -> [369]
[365,374] -> [331]
[365,375] -> [331]
[366] -> [369,406]
[367] -> [370,405]
[368] -> [240,333,401]
[369] -> [366]
[370] -> [367]
[371] -> [236]
[372] -> [233]
[373] -> [232]
[374] -> [231]
[375] -> [230]
[376] -> [200]
[377] -> [237]
[378] -> [215]
[379] -> [214]
[380] -> [213]
[382] -> [179]
[382,390] -> [389]
[382,391] -> [387]
[382,392] -> [386]
[382,393] -> [331]
[383] -> [386,428]
[384] -> [387,427]
[385] -> [333,352,388]
[386] -> [383]
[387] -> [384]
[388] -> [183,333,385]
[390] -> [185]
[391] -> [182]
[392] -> [181]
[393] -> [180]
[398] -> [365]
[398,405] -> [404]
[398,405,408] -> [403]
[398,405,409] -> [402]
[398,406] -> [397]
[399] -> [402,424,447]
[400] -> [403,423,446]
[401] -> [333,351,368,421]
[402] -> [399]
[403] -> [400]
[405] -> [367]
[406] -> [366]
[409] -> [E]
[410] -> [2,3,395,396,412,414]
[410,414,415] -> [413]
[410,416,417] -> [413]
[411] -> [412,414,417,425]
[412] -> [411]
[413] -> [410,414,415]
[414] -> [411]
[417] -> [411]
[419] -> [398]
[419,423] -> [410]
[419,423,425] -> [422]
[419,424] -> [394]
[420] -> [422,444]
[421] -> [333,348,401]
[422] -> [420]
[423] -> [400]
[424] -> [399]
[425] -> [411]
[426] -> [382]
[426,427] -> [344]
[426,427,429] -> [344]
[426,427,429,440] -> [398]
[426,427,429,440,446] -> [418]
[426,427,429,440,446,448] -> [395]
[426,427,429,440,446,448,449] -> [395]
[426,427,429,440,446,448,449,450] -> [395]
[426,427,429,440,446,448,449,450,451] -> [396]
[426,427,429,440,447] -> [1]
[426,427,429,441] -> [419]
[426,427,429,441,444] -> [439]
[426,427,429,442] -> [397]
[426,427,429,443] -> [397]
[426,427,430] -> [335]
[426,427,430,433] -> [3]
[426,427,430,433,435] -> [3]
[426,427,430,433,435,436] -> [3]
[426,427,430,433,435,436,437] -> [3]
[426,427,430,433,435,436,437,438] -> [2]
[426,427,430,434] -> [1]
[426,427,431] -> [397]
[426,427,432] -> [1]
[426,428] -> [397]
[427] -> [384]
[428] -> [383]
[429] -> [349]
[430] -> [347]
[431] -> [346]
[432] -> [345]
[433] -> [337]
[434] -> [336]
[439] -> [350]
[440] -> [349]
[441] -> [347]
[442] -> [346]
[443] -> [345]
[444] -> [420]
[445] -> [350]
[446] -> [400]
[447] -> [399]

### Solution ###

[2,3,14,15,28,45,48,49,65,66,69,72,77,78,79,82,83,111,117,134,149,152,153,158,161,164,169,170,173,176,179,182,185,188,191,192,195,196,199,204,207,208,209,212,215,220,221,224,225,226,229,233,236,237,245,246,249,250,253,254,258,261,264,265,272,273,274,277,278,281,284,285,289,290,293,301,302,305,306,307,308,312,313,316,317,320,321,324,325,326,330,335,337,340,341,344,347,349,350,355,357,358,360,361,365,367,370,371,372,377,378,381,382,384,387,389,390,391,395,396,398,400,403,404,405,407,408,410,411,412,413,414,415,416,417,418,419,420,422,423,425,426,427,429,430,433,435,436,437,438,439,440,441,444,445,446,448,449,450,451,R]

### Annotated ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :E: Bool
    constructor False :E: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :R: (a :E: Type) -> (b :E: Type) -> (_x7 :R: a) -> (_x8 :R: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = x
    snd :R: (a :E: Type) -> (b :E: Type) -> (_x10 :R: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :R: a y :R: b
        snd -E- a -E- b -R- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (_x19 :E: a) -> (_x20 :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: (_x21 :E: Type) -> Type
    constructor Nil :E: (a :E: Type) -> List -E- a
    constructor Cons :E: (a :E: Type) -> (_x22 :E: a) -> (_x23 :E: List -E- a) -> List -E- a
    constructor State :E: (_x0 :E: Type) -> (_x1 :E: Type) -> Type
    constructor MkSt :R: (st :E: Type) -> (a :E: Type) -> (run :R: (_x2 :R: st) -> Pair -E- st -E- a) -> State -E- st -E- a
    runState :R: (st :E: Type) -> (a :E: Type) -> (_x3 :R: State -E- st -E- a) -> (_x4 :R: st) -> Pair -E- st -E- a 
      st :E: Type a :E: Type run :R: (_x5 :R: st) -> Pair -E- st -E- a
        runState -E- st -E- a -R- ([MkSt] -E- [st] -E- [a] -R- run) = run
    execState :R: (st :E: Type) -> (a :E: Type) -> (x :R: State -E- st -E- a) -> (s :R: st) -> a = (\st :E: Type. (\a :E: Type. (\x :R: State -E- st -E- a. (\s :R: st. snd -E- st -E- a -R- (runState -E- st -E- a -R- x -R- s)))))
    stGet :R: (st :E: Type) -> State -E- st -E- st = (\st :E: Type. MkSt -E- st -E- st -R- (\s :R: st. MkPair -E- st -E- st -R- s -R- s))
    stReturn :R: (st :E: Type) -> (a :E: Type) -> (x :R: a) -> State -E- st -E- a = (\st :E: Type. (\a :E: Type. (\x :R: a. MkSt -E- st -E- a -R- (\s :R: st. MkPair -E- st -E- a -R- s -R- x))))
    stBind :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (x :R: State -E- st -E- a) -> (y :R: (z :R: a) -> State -E- st -E- b) -> State -E- st -E- b 
      st :E: Type a :E: Type b :E: Type f :R: (_x6 :R: st) -> Pair -E- st -E- a g :R: (_x7 :R: a) -> State -E- st -E- b
        stBind -E- st -E- a -E- b -R- ([MkSt] -E- [st] -E- [a] -R- f) -R- g = 
          let
            stBind3 :R: (st :E: Type) -> (b :E: Type) -> (_x8 :R: st) -> (_x9 :R: State -E- st -E- b) -> Pair -E- st -E- b 
              st :E: Type b :E: Type s :R: st f :R: (_x10 :R: st) -> Pair -E- st -E- b
                stBind3 -E- st -E- b -R- s -R- ([MkSt] -E- [st] -E- [b] -R- f) = f -R- s
            stBind2 :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (g :R: (_x11 :R: a) -> State -E- st -E- b) -> (r :R: Pair -E- st -E- a) -> Pair -E- st -E- b 
              st :E: Type a :E: Type b :E: Type g :R: (_x12 :R: a) -> State -E- st -E- b x :R: a s :R: st
                stBind2 -E- st -E- a -E- b -R- g -R- ([MkPair] -E- [st] -E- [a] -R- s -R- x) = stBind3 -E- st -E- b -R- s -R- (g -R- x)
          in MkSt -E- st -E- b -R- (\s :R: st. stBind2 -E- st -E- a -E- b -R- g -R- (f -R- s))
    postulate RealWorld :E: Type
    IO :E: (_x0 :E: Type) -> Type = State -E- RealWorld
    ioReturn :R: (a :E: Type) -> (x :R: a) -> IO -E- a = (\a :E: Type. (\x :R: a. stReturn -E- RealWorld -E- a -R- x))
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (_x1 :R: a) -> IO -E- b) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\x :R: IO -E- a. (\y :R: (_x1 :R: a) -> IO -E- b. stBind -E- RealWorld -E- a -E- b -R- x -R- y))))
    ioWrapImpure :R: (a :E: Type) -> (impureF :R: (w :R: RealWorld) -> a) -> IO -E- a = (\a :E: Type. (\impureF :R: (w :R: RealWorld) -> a. stBind -E- RealWorld -E- RealWorld -E- a -R- (stGet -E- RealWorld) -R- (\w :R: RealWorld. stReturn -E- RealWorld -E- a -R- (impureF -R- w))))
    unsafePerformIO :R: (a :E: Type) -> (x :R: IO -E- a) -> a = (\a :E: Type. (\x :R: IO -E- a. 
      let postulate TheWorld :R: RealWorld
      in execState -E- RealWorld -E- a -R- x -R- TheWorld))
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure -E- Unspec -R- (\w :R: RealWorld. nativePrint -E- a -R- x)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      natToInt -R- Z = intZ
      n :R: Nat
        natToInt -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    main :R: Unspec = unsafePerformIO -E- Unspec -R- (ioBind -E- Nat -E- Unspec -R- (ioReturn -E- Nat -R- 4) -R- (\v :R: Nat. ioBind -E- Unspec -E- Unspec -R- (printNat -R- v) -R- (\_do0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ)))))))
  in main

### Specialised ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :E: Bool
    constructor False :E: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :R: (a :E: Type) -> (b :E: Type) -> (_x7 :R: a) -> (_x8 :R: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = x
    snd :R: (a :E: Type) -> (b :E: Type) -> (_x10 :R: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :R: a y :R: b
        snd -E- a -E- b -R- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (_x19 :E: a) -> (_x20 :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: (_x21 :E: Type) -> Type
    constructor Nil :E: (a :E: Type) -> List -E- a
    constructor Cons :E: (a :E: Type) -> (_x22 :E: a) -> (_x23 :E: List -E- a) -> List -E- a
    constructor State :E: (_x0 :E: Type) -> (_x1 :E: Type) -> Type
    constructor MkSt :R: (st :E: Type) -> (a :E: Type) -> (run :R: (_x2 :R: st) -> Pair -E- st -E- a) -> State -E- st -E- a
    runState :R: (st :E: Type) -> (a :E: Type) -> (_x3 :R: State -E- st -E- a) -> (_x4 :R: st) -> Pair -E- st -E- a 
      st :E: Type a :E: Type run :R: (_x5 :R: st) -> Pair -E- st -E- a
        runState -E- st -E- a -R- ([MkSt] -E- [st] -E- [a] -R- run) = run
    execState :R: (st :E: Type) -> (a :E: Type) -> (x :R: State -E- st -E- a) -> (s :R: st) -> a = (\st :E: Type. (\a :E: Type. (\x :R: State -E- st -E- a. (\s :R: st. snd -E- st -E- a -R- (runState -E- st -E- a -R- x -R- s)))))
    stGet :R: (st :E: Type) -> State -E- st -E- st = (\st :E: Type. MkSt -E- st -E- st -R- (\s :R: st. MkPair -E- st -E- st -R- s -R- s))
    stReturn :R: (st :E: Type) -> (a :E: Type) -> (x :R: a) -> State -E- st -E- a = (\st :E: Type. (\a :E: Type. (\x :R: a. MkSt -E- st -E- a -R- (\s :R: st. MkPair -E- st -E- a -R- s -R- x))))
    stBind :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (x :R: State -E- st -E- a) -> (y :R: (z :R: a) -> State -E- st -E- b) -> State -E- st -E- b 
      st :E: Type a :E: Type b :E: Type f :R: (_x6 :R: st) -> Pair -E- st -E- a g :R: (_x7 :R: a) -> State -E- st -E- b
        stBind -E- st -E- a -E- b -R- ([MkSt] -E- [st] -E- [a] -R- f) -R- g = 
          let
            stBind3 :R: (st :E: Type) -> (b :E: Type) -> (_x8 :R: st) -> (_x9 :R: State -E- st -E- b) -> Pair -E- st -E- b 
              st :E: Type b :E: Type s :R: st f :R: (_x10 :R: st) -> Pair -E- st -E- b
                stBind3 -E- st -E- b -R- s -R- ([MkSt] -E- [st] -E- [b] -R- f) = f -R- s
            stBind2 :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (g :R: (_x11 :R: a) -> State -E- st -E- b) -> (r :R: Pair -E- st -E- a) -> Pair -E- st -E- b 
              st :E: Type a :E: Type b :E: Type g :R: (_x12 :R: a) -> State -E- st -E- b x :R: a s :R: st
                stBind2 -E- st -E- a -E- b -R- g -R- ([MkPair] -E- [st] -E- [a] -R- s -R- x) = stBind3 -E- st -E- b -R- s -R- (g -R- x)
          in MkSt -E- st -E- b -R- (\s :R: st. stBind2 -E- st -E- a -E- b -R- g -R- (f -R- s))
    postulate RealWorld :E: Type
    IO :E: (_x0 :E: Type) -> Type = State -E- RealWorld
    ioReturn :R: (a :E: Type) -> (x :R: a) -> IO -E- a = (\a :E: Type. (\x :R: a. stReturn -E- RealWorld -E- a -R- x))
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (_x1 :R: a) -> IO -E- b) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\x :R: IO -E- a. (\y :R: (_x1 :R: a) -> IO -E- b. stBind -E- RealWorld -E- a -E- b -R- x -R- y))))
    ioWrapImpure :R: (a :E: Type) -> (impureF :R: (w :R: RealWorld) -> a) -> IO -E- a = (\a :E: Type. (\impureF :R: (w :R: RealWorld) -> a. stBind -E- RealWorld -E- RealWorld -E- a -R- (stGet -E- RealWorld) -R- (\w :R: RealWorld. stReturn -E- RealWorld -E- a -R- (impureF -R- w))))
    unsafePerformIO :R: (a :E: Type) -> (x :R: IO -E- a) -> a = (\a :E: Type. (\x :R: IO -E- a. 
      let postulate TheWorld :R: RealWorld
      in execState -E- RealWorld -E- a -R- x -R- TheWorld))
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure -E- Unspec -R- (\w :R: RealWorld. nativePrint -E- a -R- x)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      natToInt -R- Z = intZ
      n :R: Nat
        natToInt -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    main :R: Unspec = unsafePerformIO -E- Unspec -R- (ioBind -E- Nat -E- Unspec -R- (ioReturn -E- Nat -R- 4) -R- (\v :R: Nat. ioBind -E- Unspec -E- Unspec -R- (printNat -R- v) -R- (\_do0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ)))))))
  in main

### Final annotation ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        plus -E- Z -E- n = n
      m :E: Nat n :E: Nat
        plus -E- (S -R- m) -E- n = S -R- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        times -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        times -E- (S -R- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :E: Bool
    constructor False :E: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      not -E- True = False
      not -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :R: (a :E: Type) -> (b :E: Type) -> (_x7 :R: a) -> (_x8 :R: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        fst -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = x
    snd :R: (a :E: Type) -> (b :E: Type) -> (_x10 :R: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :R: a y :R: b
        snd -E- a -E- b -R- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -R- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -R- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (_x19 :E: a) -> (_x20 :E: Vect -E- n -E- a) -> Vect -E- (S -R- n) -E- a
    constructor List :E: (_x21 :E: Type) -> Type
    constructor Nil :E: (a :E: Type) -> List -E- a
    constructor Cons :E: (a :E: Type) -> (_x22 :E: a) -> (_x23 :E: List -E- a) -> List -E- a
    constructor State :E: (_x0 :E: Type) -> (_x1 :E: Type) -> Type
    constructor MkSt :R: (st :E: Type) -> (a :E: Type) -> (run :R: (_x2 :R: st) -> Pair -E- st -E- a) -> State -E- st -E- a
    runState :R: (st :E: Type) -> (a :E: Type) -> (_x3 :R: State -E- st -E- a) -> (_x4 :R: st) -> Pair -E- st -E- a 
      st :E: Type a :E: Type run :R: (_x5 :R: st) -> Pair -E- st -E- a
        runState -E- st -E- a -R- ([MkSt] -E- [st] -E- [a] -R- run) = run
    execState :R: (st :E: Type) -> (a :E: Type) -> (x :R: State -E- st -E- a) -> (s :R: st) -> a = (\st :E: Type. (\a :E: Type. (\x :R: State -E- st -E- a. (\s :R: st. snd -E- st -E- a -R- (runState -E- st -E- a -R- x -R- s)))))
    stGet :R: (st :E: Type) -> State -E- st -E- st = (\st :E: Type. MkSt -E- st -E- st -R- (\s :R: st. MkPair -E- st -E- st -R- s -R- s))
    stReturn :R: (st :E: Type) -> (a :E: Type) -> (x :R: a) -> State -E- st -E- a = (\st :E: Type. (\a :E: Type. (\x :R: a. MkSt -E- st -E- a -R- (\s :R: st. MkPair -E- st -E- a -R- s -R- x))))
    stBind :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (x :R: State -E- st -E- a) -> (y :R: (z :R: a) -> State -E- st -E- b) -> State -E- st -E- b 
      st :E: Type a :E: Type b :E: Type f :R: (_x6 :R: st) -> Pair -E- st -E- a g :R: (_x7 :R: a) -> State -E- st -E- b
        stBind -E- st -E- a -E- b -R- ([MkSt] -E- [st] -E- [a] -R- f) -R- g = 
          let
            stBind3 :R: (st :E: Type) -> (b :E: Type) -> (_x8 :R: st) -> (_x9 :R: State -E- st -E- b) -> Pair -E- st -E- b 
              st :E: Type b :E: Type s :R: st f :R: (_x10 :R: st) -> Pair -E- st -E- b
                stBind3 -E- st -E- b -R- s -R- ([MkSt] -E- [st] -E- [b] -R- f) = f -R- s
            stBind2 :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (g :R: (_x11 :R: a) -> State -E- st -E- b) -> (r :R: Pair -E- st -E- a) -> Pair -E- st -E- b 
              st :E: Type a :E: Type b :E: Type g :R: (_x12 :R: a) -> State -E- st -E- b x :R: a s :R: st
                stBind2 -E- st -E- a -E- b -R- g -R- ([MkPair] -E- [st] -E- [a] -R- s -R- x) = stBind3 -E- st -E- b -R- s -R- (g -R- x)
          in MkSt -E- st -E- b -R- (\s :R: st. stBind2 -E- st -E- a -E- b -R- g -R- (f -R- s))
    postulate RealWorld :E: Type
    IO :E: (_x0 :E: Type) -> Type = State -E- RealWorld
    ioReturn :R: (a :E: Type) -> (x :R: a) -> IO -E- a = (\a :E: Type. (\x :R: a. stReturn -E- RealWorld -E- a -R- x))
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (_x1 :R: a) -> IO -E- b) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\x :R: IO -E- a. (\y :R: (_x1 :R: a) -> IO -E- b. stBind -E- RealWorld -E- a -E- b -R- x -R- y))))
    ioWrapImpure :R: (a :E: Type) -> (impureF :R: (w :R: RealWorld) -> a) -> IO -E- a = (\a :E: Type. (\impureF :R: (w :R: RealWorld) -> a. stBind -E- RealWorld -E- RealWorld -E- a -R- (stGet -E- RealWorld) -R- (\w :R: RealWorld. stReturn -E- RealWorld -E- a -R- (impureF -R- w))))
    unsafePerformIO :R: (a :E: Type) -> (x :R: IO -E- a) -> a = (\a :E: Type. (\x :R: IO -E- a. 
      let postulate TheWorld :R: RealWorld
      in execState -E- RealWorld -E- a -R- x -R- TheWorld))
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure -E- Unspec -R- (\w :R: RealWorld. nativePrint -E- a -R- x)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      natToInt -R- Z = intZ
      n :R: Nat
        natToInt -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    main :R: Unspec = unsafePerformIO -E- Unspec -R- (ioBind -E- Nat -E- Unspec -R- (ioReturn -E- Nat -R- 4) -R- (\v :R: Nat. ioBind -E- Unspec -E- Unspec -R- (printNat -R- v) -R- (\_do0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ)))))))
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor MkPair : (_x7) -> (_x8) -> Pair
    snd 
      snd ([_] x y) = y
    constructor MkSt : (run) -> State
    runState 
      runState ([_] run) = run
    execState = (\x. (\s. snd (runState x s)))
    stGet = MkSt (\s. MkPair s s)
    stReturn = (\x. MkSt (\s. MkPair s x))
    stBind 
      stBind ([_] f) g = 
        let
          stBind3 
            stBind3 s ([_] f) = f s
          stBind2 
            stBind2 g ([_] s x) = stBind3 s (g x)
        in MkSt (\s. stBind2 g (f s))
    ioReturn = (\x. stReturn x)
    ioBind = (\x. (\y. stBind x y))
    ioWrapImpure = (\impureF. stBind stGet (\w. stReturn (impureF w)))
    unsafePerformIO = (\x. 
      let postulate TheWorld : RealWorld
      in execState x TheWorld)
    foreign intS
    foreign intZ
    printSchemeRepr = (\x. 
      let foreign nativePrint
      in ioWrapImpure (\w. nativePrint x))
    natToInt 
      natToInt Z = intZ
      natToInt (S n) = intS (natToInt n)
    foreign intToNat
    printNat = (\x. printSchemeRepr (natToInt x))
    main = unsafePerformIO (ioBind (ioReturn 4) (\v. ioBind (printNat v) (\_do0. printSchemeRepr (intToNat (intS (intS (intS intZ)))))))
  in main

### Intermediate representation ###

let Z = constructor 0
  in let S = constructor 1
    in let MkPair = constructor 2
      in let snd = \_pv0.
        case _pv0 of
          _ _pv1 _pv2 => _pv2
        in let MkSt = constructor 1
          in let runState = \_pv0.
            case _pv0 of
              _ _pv1 => _pv1
            in let execState = \x. \s. (snd ((runState x) s))
              in let stGet = (MkSt \s. ((MkPair s) s))
                in let stReturn = \x. (MkSt \s. ((MkPair s) x))
                  in let stBind = \_pv0. \_pv1.
                    case _pv0 of
                      _ _pv2 => let stBind3 = \_pv3. \_pv4.
                        case _pv4 of
                          _ _pv5 => (_pv5 _pv3)
                        in let stBind2 = \_pv3. \_pv4.
                          case _pv4 of
                            _ _pv5 _pv6 => ((stBind3 _pv5) (_pv3 _pv6))
                          in (MkSt \s. ((stBind2 _pv1) (_pv2 s)))
                    in let ioReturn = \x. (stReturn x)
                      in let ioBind = \x. \y. ((stBind x) y)
                        in let ioWrapImpure = \impureF. ((stBind stGet) \w. (stReturn (impureF w)))
                          in let unsafePerformIO = \x. let TheWorld = constructor 0
                            in ((execState x) TheWorld)
                            in let intS = foreign "(lambda (x) (+ x 1))"
                              in let intZ = foreign "0"
                                in let printSchemeRepr = \x. let nativePrint = foreign "print"
                                  in (ioWrapImpure \w. (nativePrint x))
                                  in let natToInt = \_pv0.
                                    case _pv0 of
                                      S _pv1 => (intS (natToInt _pv1))
                                      Z => intZ
                                    in let intToNat = foreign "(lambda (x) (number->peano 'Z 'S x))"
                                      in let printNat = \x. (printSchemeRepr (natToInt x))
                                        in let main = (unsafePerformIO ((ioBind (ioReturn (S (S (S (S Z)))))) \v. ((ioBind (printNat v)) \_do0. (printSchemeRepr (intToNat (intS (intS (intS intZ))))))))
                                          in main

### Normal forms ###

unerased:
  
  let
    constructor Nat : Type
    postulate Int : Type
    foreign intS : (x :R: Int) -> Int
    foreign intZ : Int
    postulate Unspec : Type
    foreign intToNat : (x :R: Int) -> Nat
  in 
    let foreign nativePrint0 : (a :E: Type) -> (x :R: a) -> Unspec
    in nativePrint0 Nat (intToNat (intS (intS (intS intZ))))

erased:
  
  let
    foreign intS
    foreign intZ
    foreign intToNat
  in 
    let foreign nativePrint0
    in nativePrint0 (intToNat (intS (intS (intS intZ))))

