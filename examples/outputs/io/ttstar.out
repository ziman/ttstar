-- vim: ft=ttstar

### Desugared ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x2 : Bool) -> Bool 
      [not] True = False
      [not] False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x3 : Type) -> (_x4 : Type) -> Type
    constructor MkPair : (a : Type) -> (b : Type) -> (_x5 : a) -> (_x6 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x7 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        [fst] a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x8 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        [snd] a b ([MkPair] [a] [b] x y) = y
    constructor Either : (_x9 : Type) -> (_x10 : Type) -> Type
    constructor Left : (a : Type) -> (b : Type) -> (_x11 : a) -> Either a b
    constructor Right : (a : Type) -> (b : Type) -> (_x12 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x13 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x14 : Fin n) -> Fin (S n)
    constructor Vect : (_x15 : Nat) -> (_x16 : Type) -> Type
    constructor VN : (a : Type) -> Vect Z a
    constructor VC : (n : Nat) -> (a : Type) -> (x : a) -> (xs : Vect n a) -> Vect (S n) a
    constructor State : (_x0 : Type) -> (_x1 : Type) -> Type
    constructor MkSt : (st : Type) -> (a : Type) -> (run : (_x2 : st) -> Pair st a) -> State st a
    runState : (st : Type) -> (a : Type) -> (_x3 : State st a) -> (_x4 : st) -> Pair st a 
      st : Type a : Type run : (_x5 : st) -> Pair st a
        [runState] st a ([MkSt] [st] [a] run) = run
    execState : (st : Type) -> (a : Type) -> (x : State st a) -> (s : st) -> a = (\st : Type. (\a : Type. (\x : State st a. (\s : st. snd st a (runState st a x s)))))
    stGet : (st : Type) -> State st st = (\st : Type. MkSt st st (\s : st. MkPair st st s s))
    stReturn : (st : Type) -> (a : Type) -> (x : a) -> State st a = (\st : Type. (\a : Type. (\x : a. MkSt st a (\s : st. MkPair st a s x))))
    stBind : (st : Type) -> (a : Type) -> (b : Type) -> (x : State st a) -> (y : (z : a) -> State st b) -> State st b 
      st : Type a : Type b : Type f : (_x6 : st) -> Pair st a g : (_x7 : a) -> State st b
        [stBind] st a b ([MkSt] [st] [a] f) g = 
          let
            stBind3 : (st : Type) -> (b : Type) -> (_x8 : st) -> (_x9 : State st b) -> Pair st b 
              st : Type b : Type s : st f : (_x10 : st) -> Pair st b
                [stBind3] st b s ([MkSt] [st] [b] f) = f s
            stBind2 : (st : Type) -> (a : Type) -> (b : Type) -> (g : (_x11 : a) -> State st b) -> (r : Pair st a) -> Pair st b 
              st : Type a : Type b : Type g : (_x12 : a) -> State st b x : a s : st
                [stBind2] st a b g ([MkPair] [st] [a] s x) = stBind3 st b s (g x)
          in MkSt st b (\s : st. stBind2 st a b g (f s))
    postulate RealWorld : Type
    IO : (_x0 : Type) -> Type = State RealWorld
    ioReturn : (a : Type) -> (x : a) -> IO a = (\a : Type. (\x : a. stReturn RealWorld a x))
    ioBind : (a : Type) -> (b : Type) -> (x : IO a) -> (y : (_x1 : a) -> IO b) -> IO b = (\a : Type. (\b : Type. (\x : IO a. (\y : (_x1 : a) -> IO b. stBind RealWorld a b x y))))
    ioWrapImpure : (a : Type) -> (impureF : (w :R: RealWorld) -> a) -> IO a = (\a : Type. (\impureF : (w :R: RealWorld) -> a. stBind RealWorld RealWorld a (stGet RealWorld) (\w : RealWorld. stReturn RealWorld a (impureF w))))
    unsafePerformIO : (a : Type) -> (x : IO a) -> a = (\a : Type. (\x : IO a. 
      let postulate TheWorld : RealWorld
      in execState RealWorld a x TheWorld))
    postulate Int : Type
    foreign intS : (x :R: Int) -> Int
    foreign intZ : Int
    postulate Unspec : Type
    printSchemeRepr : (a : Type) -> (x : a) -> IO Unspec = (\a : Type. (\x : a. 
      let foreign nativePrint : (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure Unspec (\w : RealWorld. nativePrint a x)))
    natToInt : (_x0 : Nat) -> Int 
      [natToInt] Z = intZ
      n : Nat
        [natToInt] (S n) = intS (natToInt n)
    foreign intToNat : (x :R: Int) -> Nat
    printNat : (x : Nat) -> IO Unspec = (\x : Nat. printSchemeRepr Int (natToInt x))
    main : Unspec = unsafePerformIO Unspec (ioBind Nat Unspec (ioReturn Nat 4) (\v : Nat. ioBind Unspec Unspec (printNat v) (\_0 : Unspec. printSchemeRepr Nat (intToNat (intS (intS (intS intZ)))))))
  in main

### Evarified ###

  let
    constructor Nat :1: Type
    constructor Z :2: Nat
    constructor S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        [plus] -9- Z -8- n = n
      m :10: Nat n :11: Nat
        [plus] -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    constructor Bool :18: Type
    constructor True :19: Bool
    constructor False :20: Bool
    not :21: (_x2 :22: Bool) -> Bool 
      [not] -23- True = False
      [not] -24- False = True
    constructor Unit :25: Type
    constructor MkUnit :26: Unit
    constructor Pair :27: (_x3 :28: Type) -> (_x4 :29: Type) -> Type
    constructor MkPair :30: (a :31: Type) -> (b :32: Type) -> (_x5 :33: a) -> (_x6 :34: b) -> Pair -36- a -35- b
    fst :37: (a :38: Type) -> (b :39: Type) -> (_x7 :40: Pair -42- a -41- b) -> a 
      a :43: Type b :44: Type x :45: a y :46: b
        [fst] -49- a -48- b -47- ([MkPair] -53- [a] -52- [b] -51- x -50- y) = x
    snd :54: (a :55: Type) -> (b :56: Type) -> (_x8 :57: Pair -59- a -58- b) -> b 
      a :60: Type b :61: Type x :62: a y :63: b
        [snd] -66- a -65- b -64- ([MkPair] -70- [a] -69- [b] -68- x -67- y) = y
    constructor Either :71: (_x9 :72: Type) -> (_x10 :73: Type) -> Type
    constructor Left :74: (a :75: Type) -> (b :76: Type) -> (_x11 :77: a) -> Either -79- a -78- b
    constructor Right :80: (a :81: Type) -> (b :82: Type) -> (_x12 :83: b) -> Either -85- a -84- b
    id :86: (a :87: Type) -> (x :88: a) -> a = (\a :89: Type. (\x :90: a. x))
    constructor Fin :91: (_x13 :92: Nat) -> Type
    constructor FZ :93: (n :94: Nat) -> Fin -95- (S -96- n)
    constructor FS :97: (n :98: Nat) -> (_x14 :99: Fin -100- n) -> Fin -101- (S -102- n)
    constructor Vect :103: (_x15 :104: Nat) -> (_x16 :105: Type) -> Type
    constructor VN :106: (a :107: Type) -> Vect -109- Z -108- a
    constructor VC :110: (n :111: Nat) -> (a :112: Type) -> (x :113: a) -> (xs :114: Vect -116- n -115- a) -> Vect -118- (S -119- n) -117- a
    constructor State :120: (_x0 :121: Type) -> (_x1 :122: Type) -> Type
    constructor MkSt :123: (st :124: Type) -> (a :125: Type) -> (run :126: (_x2 :127: st) -> Pair -129- st -128- a) -> State -131- st -130- a
    runState :132: (st :133: Type) -> (a :134: Type) -> (_x3 :135: State -137- st -136- a) -> (_x4 :138: st) -> Pair -140- st -139- a 
      st :141: Type a :142: Type run :143: (_x5 :144: st) -> Pair -146- st -145- a
        [runState] -149- st -148- a -147- ([MkSt] -152- [st] -151- [a] -150- run) = run
    execState :153: (st :154: Type) -> (a :155: Type) -> (x :156: State -158- st -157- a) -> (s :159: st) -> a = (\st :160: Type. (\a :161: Type. (\x :162: State -164- st -163- a. (\s :165: st. snd -168- st -167- a -166- (runState -172- st -171- a -170- x -169- s)))))
    stGet :173: (st :174: Type) -> State -176- st -175- st = (\st :177: Type. MkSt -180- st -179- st -178- (\s :181: st. MkPair -185- st -184- st -183- s -182- s))
    stReturn :186: (st :187: Type) -> (a :188: Type) -> (x :189: a) -> State -191- st -190- a = (\st :192: Type. (\a :193: Type. (\x :194: a. MkSt -197- st -196- a -195- (\s :198: st. MkPair -202- st -201- a -200- s -199- x))))
    stBind :203: (st :204: Type) -> (a :205: Type) -> (b :206: Type) -> (x :207: State -209- st -208- a) -> (y :210: (z :211: a) -> State -213- st -212- b) -> State -215- st -214- b 
      st :216: Type a :217: Type b :218: Type f :219: (_x6 :220: st) -> Pair -222- st -221- a g :223: (_x7 :224: a) -> State -226- st -225- b
        [stBind] -231- st -230- a -229- b -228- ([MkSt] -234- [st] -233- [a] -232- f) -227- g = 
          let
            stBind3 :235: (st :236: Type) -> (b :237: Type) -> (_x8 :238: st) -> (_x9 :239: State -241- st -240- b) -> Pair -243- st -242- b 
              st :244: Type b :245: Type s :246: st f :247: (_x10 :248: st) -> Pair -250- st -249- b
                [stBind3] -254- st -253- b -252- s -251- ([MkSt] -257- [st] -256- [b] -255- f) = f -258- s
            stBind2 :259: (st :260: Type) -> (a :261: Type) -> (b :262: Type) -> (g :263: (_x11 :264: a) -> State -266- st -265- b) -> (r :267: Pair -269- st -268- a) -> Pair -271- st -270- b 
              st :272: Type a :273: Type b :274: Type g :275: (_x12 :276: a) -> State -278- st -277- b x :279: a s :280: st
                [stBind2] -285- st -284- a -283- b -282- g -281- ([MkPair] -289- [st] -288- [a] -287- s -286- x) = stBind3 -293- st -292- b -291- s -290- (g -294- x)
          in MkSt -297- st -296- b -295- (\s :298: st. stBind2 -303- st -302- a -301- b -300- g -299- (f -304- s))
    postulate RealWorld :305: Type
    IO :306: (_x0 :307: Type) -> Type = State -308- RealWorld
    ioReturn :309: (a :310: Type) -> (x :311: a) -> IO -312- a = (\a :313: Type. (\x :314: a. stReturn -317- RealWorld -316- a -315- x))
    ioBind :318: (a :319: Type) -> (b :320: Type) -> (x :321: IO -322- a) -> (y :323: (_x1 :324: a) -> IO -325- b) -> IO -326- b = (\a :327: Type. (\b :328: Type. (\x :329: IO -330- a. (\y :331: (_x1 :332: a) -> IO -333- b. stBind -338- RealWorld -337- a -336- b -335- x -334- y))))
    ioWrapImpure :339: (a :340: Type) -> (impureF :341: (w :R: RealWorld) -> a) -> IO -342- a = (\a :343: Type. (\impureF :344: (w :R: RealWorld) -> a. stBind -349- RealWorld -348- RealWorld -347- a -346- (stGet -350- RealWorld) -345- (\w :351: RealWorld. stReturn -354- RealWorld -353- a -352- (impureF -355- w))))
    unsafePerformIO :356: (a :357: Type) -> (x :358: IO -359- a) -> a = (\a :360: Type. (\x :361: IO -362- a. 
      let postulate TheWorld :363: RealWorld
      in execState -367- RealWorld -366- a -365- x -364- TheWorld))
    postulate Int :368: Type
    foreign intS :369: (x :R: Int) -> Int
    foreign intZ :370: Int
    postulate Unspec :371: Type
    printSchemeRepr :372: (a :373: Type) -> (x :374: a) -> IO -375- Unspec = (\a :376: Type. (\x :377: a. 
      let foreign nativePrint :378: (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure -380- Unspec -379- (\w :381: RealWorld. nativePrint -383- a -382- x)))
    natToInt :384: (_x0 :385: Nat) -> Int 
      [natToInt] -386- Z = intZ
      n :387: Nat
        [natToInt] -388- (S -389- n) = intS -390- (natToInt -391- n)
    foreign intToNat :392: (x :R: Int) -> Nat
    printNat :393: (x :394: Nat) -> IO -395- Unspec = (\x :396: Nat. printSchemeRepr -398- Int -397- (natToInt -399- x))
    main :400: Unspec = unsafePerformIO -402- Unspec -401- (ioBind -406- Nat -405- Unspec -404- (ioReturn -408- Nat -407- 4) -403- (\v :413: Nat. ioBind -417- Unspec -416- Unspec -415- (printNat -418- v) -414- (\_0 :419: Unspec. printSchemeRepr -421- Nat -420- (intToNat -422- (intS -423- (intS -424- (intS -425- intZ)))))))
  in main

### Constraints ###

[] -> [2,3,30,33,34,54,57,63,64,67,68,123,126,127,132,135,138,143,144,147,150,153,156,159,162,165,166,169,170,173,178,181,182,183,186,189,194,195,198,199,200,203,207,210,211,219,220,223,224,227,228,232,235,238,239,246,247,248,251,252,255,258,259,263,264,267,275,276,279,280,281,282,286,287,290,291,294,295,298,299,300,304,309,311,314,315,318,321,323,324,329,331,332,334,335,339,341,344,345,346,351,352,355,356,358,361,363,364,365,369,370,372,374,377,378,379,381,382,384,385,386,387,388,389,390,391,392,393,394,396,397,399,401,403,404,407,409,410,411,412,413,414,415,418,419,420,422,423,424,425,R]
[31] -> [70,185,202,289]
[32] -> [69,184,201,288]
[35] -> [58,128,268]
[36] -> [59,129,269]
[55] -> [66,168]
[56] -> [65,167]
[58] -> [35,139]
[59] -> [36,140]
[60] -> [66]
[61] -> [65]
[62] -> [68]
[65] -> [56,R]
[66] -> [55,R]
[69] -> [32,61,64]
[70] -> [31,60,64]
[124] -> [152,180,197,234,257,297]
[125] -> [151,179,196,233,256,296]
[128] -> [35,145,221,249,270]
[129] -> [36,146,222,250,271]
[130] -> [136,175,190,208,214,240]
[131] -> [137,176,191,209,215,241]
[133] -> [149,172]
[134] -> [148,171]
[136] -> [130,163]
[137] -> [131,164]
[139] -> [58,145]
[140] -> [59,146]
[141] -> [149]
[142] -> [148]
[145] -> [128,139]
[146] -> [129,140]
[148] -> [134,R]
[149] -> [133,R]
[151] -> [125,142,147]
[152] -> [124,141,147]
[154] -> [160,367]
[155] -> [161,366]
[157] -> [163,362]
[158] -> [164,308]
[160] -> [154]
[161] -> [155]
[163] -> [136,157]
[164] -> [137,158]
[167] -> [56,161]
[168] -> [55,160]
[171] -> [134,161]
[172] -> [133,160]
[174] -> [177,350]
[175] -> [130,208]
[176] -> [131,209]
[177] -> [174]
[179] -> [125,177]
[180] -> [124,177]
[184] -> [32,177]
[185] -> [31,177]
[187] -> [192,317,354]
[188] -> [193,316,353]
[190] -> [130,212,312]
[191] -> [131,213,308]
[192] -> [187]
[193] -> [188]
[196] -> [125,193]
[197] -> [124,192]
[201] -> [32,193]
[202] -> [31,192]
[204] -> [231,338,349]
[205] -> [230,337,348]
[206] -> [229,336,347]
[208] -> [130,175,330]
[209] -> [131,176,308]
[212] -> [190,225,333]
[213] -> [191,226,308]
[214] -> [130,326,342]
[215] -> [131,308]
[216] -> [231]
[217] -> [230]
[218] -> [229]
[221] -> [128,268]
[222] -> [129,269]
[225] -> [212,265]
[226] -> [213,266]
[229] -> [206,R]
[230] -> [205,R]
[231] -> [204,R]
[233] -> [125,217,228]
[234] -> [124,216,228]
[236] -> [254,293]
[237] -> [253,292]
[240] -> [130,277]
[241] -> [131,278]
[242] -> [249,270]
[243] -> [250,271]
[244] -> [254]
[245] -> [253]
[249] -> [128,242]
[250] -> [129,243]
[253] -> [237,R]
[254] -> [236,R]
[256] -> [125,245,251]
[257] -> [124,244,251]
[260] -> [285,303]
[261] -> [284,302]
[262] -> [283,301]
[265] -> [225,277]
[266] -> [226,278]
[268] -> [35,221]
[269] -> [36,222]
[270] -> [128,242]
[271] -> [129,243]
[272] -> [285]
[273] -> [284]
[274] -> [283]
[277] -> [240,265]
[278] -> [241,266]
[283] -> [262,R]
[284] -> [261,R]
[285] -> [260,R]
[288] -> [32,273,281]
[289] -> [31,272,281]
[292] -> [237,274]
[293] -> [236,272]
[296] -> [125,218]
[297] -> [124,216]
[301] -> [218,262]
[302] -> [217,261]
[303] -> [216,260]
[308] -> [158,191,209,213,215,308]
[310] -> [313,408]
[312] -> [190,322]
[313] -> [310]
[316] -> [188,313]
[317] -> [187,305]
[319] -> [327,406,417]
[320] -> [328,405,416]
[322] -> [312,330,395]
[325] -> [326,333,375]
[326] -> [214,325,359]
[327] -> [319]
[328] -> [320]
[330] -> [208,322]
[333] -> [212,325]
[336] -> [206,328]
[337] -> [205,327]
[338] -> [204,305]
[340] -> [343,380]
[342] -> [214,375]
[343] -> [340]
[347] -> [206,343]
[348] -> [205,305]
[349] -> [204,305]
[350] -> [174,305]
[353] -> [188,343]
[354] -> [187,305]
[357] -> [360,402]
[359] -> [326,362]
[360] -> [357]
[362] -> [157,359]
[366] -> [155,360]
[367] -> [154,305]
[373] -> [376,398,421]
[375] -> [325,342,395]
[376] -> [373]
[380] -> [340,371]
[383] -> [376,E]
[395] -> [322,375]
[398] -> [368,373]
[402] -> [357,371]
[405] -> [320,371]
[406] -> [1,319]
[408] -> [1,310]
[416] -> [320,371]
[417] -> [319,371]
[421] -> [1,373]
[E] -> [383]
[R] -> [400]

### Solution ###

[2,3,30,33,34,54,57,63,64,67,68,123,126,127,132,135,138,143,144,147,150,153,156,159,162,165,166,169,170,173,178,181,182,183,186,189,194,195,198,199,200,203,207,210,211,219,220,223,224,227,228,232,235,238,239,246,247,248,251,252,255,258,259,263,264,267,275,276,279,280,281,282,286,287,290,291,294,295,298,299,300,304,309,311,314,315,318,321,323,324,329,331,332,334,335,339,341,344,345,346,351,352,355,356,358,361,363,364,365,369,370,372,374,377,378,379,381,382,384,385,386,387,388,389,390,391,392,393,394,396,397,399,400,401,403,404,407,409,410,411,412,413,414,415,418,419,420,422,423,424,425,R]

### Annotated ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    constructor Bool :E: Type
    constructor True :E: Bool
    constructor False :E: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    constructor MkPair :R: (a :E: Type) -> (b :E: Type) -> (_x5 :R: a) -> (_x6 :R: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :R: (a :E: Type) -> (b :E: Type) -> (_x8 :R: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :R: b
        [snd] -E- a -E- b -R- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = y
    constructor Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x13 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x14 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x15 :E: Nat) -> (_x16 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor State :E: (_x0 :E: Type) -> (_x1 :E: Type) -> Type
    constructor MkSt :R: (st :E: Type) -> (a :E: Type) -> (run :R: (_x2 :R: st) -> Pair -E- st -E- a) -> State -E- st -E- a
    runState :R: (st :E: Type) -> (a :E: Type) -> (_x3 :R: State -E- st -E- a) -> (_x4 :R: st) -> Pair -E- st -E- a 
      st :E: Type a :E: Type run :R: (_x5 :R: st) -> Pair -E- st -E- a
        [runState] -E- st -E- a -R- ([MkSt] -E- [st] -E- [a] -R- run) = run
    execState :R: (st :E: Type) -> (a :E: Type) -> (x :R: State -E- st -E- a) -> (s :R: st) -> a = (\st :E: Type. (\a :E: Type. (\x :R: State -E- st -E- a. (\s :R: st. snd -E- st -E- a -R- (runState -E- st -E- a -R- x -R- s)))))
    stGet :R: (st :E: Type) -> State -E- st -E- st = (\st :E: Type. MkSt -E- st -E- st -R- (\s :R: st. MkPair -E- st -E- st -R- s -R- s))
    stReturn :R: (st :E: Type) -> (a :E: Type) -> (x :R: a) -> State -E- st -E- a = (\st :E: Type. (\a :E: Type. (\x :R: a. MkSt -E- st -E- a -R- (\s :R: st. MkPair -E- st -E- a -R- s -R- x))))
    stBind :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (x :R: State -E- st -E- a) -> (y :R: (z :R: a) -> State -E- st -E- b) -> State -E- st -E- b 
      st :E: Type a :E: Type b :E: Type f :R: (_x6 :R: st) -> Pair -E- st -E- a g :R: (_x7 :R: a) -> State -E- st -E- b
        [stBind] -E- st -E- a -E- b -R- ([MkSt] -E- [st] -E- [a] -R- f) -R- g = 
          let
            stBind3 :R: (st :E: Type) -> (b :E: Type) -> (_x8 :R: st) -> (_x9 :R: State -E- st -E- b) -> Pair -E- st -E- b 
              st :E: Type b :E: Type s :R: st f :R: (_x10 :R: st) -> Pair -E- st -E- b
                [stBind3] -E- st -E- b -R- s -R- ([MkSt] -E- [st] -E- [b] -R- f) = f -R- s
            stBind2 :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (g :R: (_x11 :R: a) -> State -E- st -E- b) -> (r :R: Pair -E- st -E- a) -> Pair -E- st -E- b 
              st :E: Type a :E: Type b :E: Type g :R: (_x12 :R: a) -> State -E- st -E- b x :R: a s :R: st
                [stBind2] -E- st -E- a -E- b -R- g -R- ([MkPair] -E- [st] -E- [a] -R- s -R- x) = stBind3 -E- st -E- b -R- s -R- (g -R- x)
          in MkSt -E- st -E- b -R- (\s :R: st. stBind2 -E- st -E- a -E- b -R- g -R- (f -R- s))
    postulate RealWorld :E: Type
    IO :E: (_x0 :E: Type) -> Type = State -E- RealWorld
    ioReturn :R: (a :E: Type) -> (x :R: a) -> IO -E- a = (\a :E: Type. (\x :R: a. stReturn -E- RealWorld -E- a -R- x))
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (_x1 :R: a) -> IO -E- b) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\x :R: IO -E- a. (\y :R: (_x1 :R: a) -> IO -E- b. stBind -E- RealWorld -E- a -E- b -R- x -R- y))))
    ioWrapImpure :R: (a :E: Type) -> (impureF :R: (w :R: RealWorld) -> a) -> IO -E- a = (\a :E: Type. (\impureF :R: (w :R: RealWorld) -> a. stBind -E- RealWorld -E- RealWorld -E- a -R- (stGet -E- RealWorld) -R- (\w :R: RealWorld. stReturn -E- RealWorld -E- a -R- (impureF -R- w))))
    unsafePerformIO :R: (a :E: Type) -> (x :R: IO -E- a) -> a = (\a :E: Type. (\x :R: IO -E- a. 
      let postulate TheWorld :R: RealWorld
      in execState -E- RealWorld -E- a -R- x -R- TheWorld))
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure -E- Unspec -R- (\w :R: RealWorld. nativePrint -E- a -R- x)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    main :R: Unspec = unsafePerformIO -E- Unspec -R- (ioBind -E- Nat -E- Unspec -R- (ioReturn -E- Nat -R- 4) -R- (\v :R: Nat. ioBind -E- Unspec -E- Unspec -R- (printNat -R- v) -R- (\_0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ)))))))
  in main

### Specialised ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    constructor Bool :E: Type
    constructor True :E: Bool
    constructor False :E: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    constructor MkPair :R: (a :E: Type) -> (b :E: Type) -> (_x5 :R: a) -> (_x6 :R: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :R: (a :E: Type) -> (b :E: Type) -> (_x8 :R: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :R: b
        [snd] -E- a -E- b -R- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = y
    constructor Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x13 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x14 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x15 :E: Nat) -> (_x16 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor State :E: (_x0 :E: Type) -> (_x1 :E: Type) -> Type
    constructor MkSt :R: (st :E: Type) -> (a :E: Type) -> (run :R: (_x2 :R: st) -> Pair -E- st -E- a) -> State -E- st -E- a
    runState :R: (st :E: Type) -> (a :E: Type) -> (_x3 :R: State -E- st -E- a) -> (_x4 :R: st) -> Pair -E- st -E- a 
      st :E: Type a :E: Type run :R: (_x5 :R: st) -> Pair -E- st -E- a
        [runState] -E- st -E- a -R- ([MkSt] -E- [st] -E- [a] -R- run) = run
    execState :R: (st :E: Type) -> (a :E: Type) -> (x :R: State -E- st -E- a) -> (s :R: st) -> a = (\st :E: Type. (\a :E: Type. (\x :R: State -E- st -E- a. (\s :R: st. snd -E- st -E- a -R- (runState -E- st -E- a -R- x -R- s)))))
    stGet :R: (st :E: Type) -> State -E- st -E- st = (\st :E: Type. MkSt -E- st -E- st -R- (\s :R: st. MkPair -E- st -E- st -R- s -R- s))
    stReturn :R: (st :E: Type) -> (a :E: Type) -> (x :R: a) -> State -E- st -E- a = (\st :E: Type. (\a :E: Type. (\x :R: a. MkSt -E- st -E- a -R- (\s :R: st. MkPair -E- st -E- a -R- s -R- x))))
    stBind :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (x :R: State -E- st -E- a) -> (y :R: (z :R: a) -> State -E- st -E- b) -> State -E- st -E- b 
      st :E: Type a :E: Type b :E: Type f :R: (_x6 :R: st) -> Pair -E- st -E- a g :R: (_x7 :R: a) -> State -E- st -E- b
        [stBind] -E- st -E- a -E- b -R- ([MkSt] -E- [st] -E- [a] -R- f) -R- g = 
          let
            stBind3 :R: (st :E: Type) -> (b :E: Type) -> (_x8 :R: st) -> (_x9 :R: State -E- st -E- b) -> Pair -E- st -E- b 
              st :E: Type b :E: Type s :R: st f :R: (_x10 :R: st) -> Pair -E- st -E- b
                [stBind3] -E- st -E- b -R- s -R- ([MkSt] -E- [st] -E- [b] -R- f) = f -R- s
            stBind2 :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (g :R: (_x11 :R: a) -> State -E- st -E- b) -> (r :R: Pair -E- st -E- a) -> Pair -E- st -E- b 
              st :E: Type a :E: Type b :E: Type g :R: (_x12 :R: a) -> State -E- st -E- b x :R: a s :R: st
                [stBind2] -E- st -E- a -E- b -R- g -R- ([MkPair] -E- [st] -E- [a] -R- s -R- x) = stBind3 -E- st -E- b -R- s -R- (g -R- x)
          in MkSt -E- st -E- b -R- (\s :R: st. stBind2 -E- st -E- a -E- b -R- g -R- (f -R- s))
    postulate RealWorld :E: Type
    IO :E: (_x0 :E: Type) -> Type = State -E- RealWorld
    ioReturn :R: (a :E: Type) -> (x :R: a) -> IO -E- a = (\a :E: Type. (\x :R: a. stReturn -E- RealWorld -E- a -R- x))
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (_x1 :R: a) -> IO -E- b) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\x :R: IO -E- a. (\y :R: (_x1 :R: a) -> IO -E- b. stBind -E- RealWorld -E- a -E- b -R- x -R- y))))
    ioWrapImpure :R: (a :E: Type) -> (impureF :R: (w :R: RealWorld) -> a) -> IO -E- a = (\a :E: Type. (\impureF :R: (w :R: RealWorld) -> a. stBind -E- RealWorld -E- RealWorld -E- a -R- (stGet -E- RealWorld) -R- (\w :R: RealWorld. stReturn -E- RealWorld -E- a -R- (impureF -R- w))))
    unsafePerformIO :R: (a :E: Type) -> (x :R: IO -E- a) -> a = (\a :E: Type. (\x :R: IO -E- a. 
      let postulate TheWorld :R: RealWorld
      in execState -E- RealWorld -E- a -R- x -R- TheWorld))
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure -E- Unspec -R- (\w :R: RealWorld. nativePrint -E- a -R- x)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    main :R: Unspec = unsafePerformIO -E- Unspec -R- (ioBind -E- Nat -E- Unspec -R- (ioReturn -E- Nat -R- 4) -R- (\v :R: Nat. ioBind -E- Unspec -E- Unspec -R- (printNat -R- v) -R- (\_0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ)))))))
  in main

### Final annotation ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    constructor Bool :E: Type
    constructor True :E: Bool
    constructor False :E: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    constructor MkPair :R: (a :E: Type) -> (b :E: Type) -> (_x5 :R: a) -> (_x6 :R: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :R: (a :E: Type) -> (b :E: Type) -> (_x8 :R: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :R: b
        [snd] -E- a -E- b -R- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = y
    constructor Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x13 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x14 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x15 :E: Nat) -> (_x16 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor State :E: (_x0 :E: Type) -> (_x1 :E: Type) -> Type
    constructor MkSt :R: (st :E: Type) -> (a :E: Type) -> (run :R: (_x2 :R: st) -> Pair -E- st -E- a) -> State -E- st -E- a
    runState :R: (st :E: Type) -> (a :E: Type) -> (_x3 :R: State -E- st -E- a) -> (_x4 :R: st) -> Pair -E- st -E- a 
      st :E: Type a :E: Type run :R: (_x5 :R: st) -> Pair -E- st -E- a
        [runState] -E- st -E- a -R- ([MkSt] -E- [st] -E- [a] -R- run) = run
    execState :R: (st :E: Type) -> (a :E: Type) -> (x :R: State -E- st -E- a) -> (s :R: st) -> a = (\st :E: Type. (\a :E: Type. (\x :R: State -E- st -E- a. (\s :R: st. snd -E- st -E- a -R- (runState -E- st -E- a -R- x -R- s)))))
    stGet :R: (st :E: Type) -> State -E- st -E- st = (\st :E: Type. MkSt -E- st -E- st -R- (\s :R: st. MkPair -E- st -E- st -R- s -R- s))
    stReturn :R: (st :E: Type) -> (a :E: Type) -> (x :R: a) -> State -E- st -E- a = (\st :E: Type. (\a :E: Type. (\x :R: a. MkSt -E- st -E- a -R- (\s :R: st. MkPair -E- st -E- a -R- s -R- x))))
    stBind :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (x :R: State -E- st -E- a) -> (y :R: (z :R: a) -> State -E- st -E- b) -> State -E- st -E- b 
      st :E: Type a :E: Type b :E: Type f :R: (_x6 :R: st) -> Pair -E- st -E- a g :R: (_x7 :R: a) -> State -E- st -E- b
        [stBind] -E- st -E- a -E- b -R- ([MkSt] -E- [st] -E- [a] -R- f) -R- g = 
          let
            stBind3 :R: (st :E: Type) -> (b :E: Type) -> (_x8 :R: st) -> (_x9 :R: State -E- st -E- b) -> Pair -E- st -E- b 
              st :E: Type b :E: Type s :R: st f :R: (_x10 :R: st) -> Pair -E- st -E- b
                [stBind3] -E- st -E- b -R- s -R- ([MkSt] -E- [st] -E- [b] -R- f) = f -R- s
            stBind2 :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (g :R: (_x11 :R: a) -> State -E- st -E- b) -> (r :R: Pair -E- st -E- a) -> Pair -E- st -E- b 
              st :E: Type a :E: Type b :E: Type g :R: (_x12 :R: a) -> State -E- st -E- b x :R: a s :R: st
                [stBind2] -E- st -E- a -E- b -R- g -R- ([MkPair] -E- [st] -E- [a] -R- s -R- x) = stBind3 -E- st -E- b -R- s -R- (g -R- x)
          in MkSt -E- st -E- b -R- (\s :R: st. stBind2 -E- st -E- a -E- b -R- g -R- (f -R- s))
    postulate RealWorld :E: Type
    IO :E: (_x0 :E: Type) -> Type = State -E- RealWorld
    ioReturn :R: (a :E: Type) -> (x :R: a) -> IO -E- a = (\a :E: Type. (\x :R: a. stReturn -E- RealWorld -E- a -R- x))
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (_x1 :R: a) -> IO -E- b) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\x :R: IO -E- a. (\y :R: (_x1 :R: a) -> IO -E- b. stBind -E- RealWorld -E- a -E- b -R- x -R- y))))
    ioWrapImpure :R: (a :E: Type) -> (impureF :R: (w :R: RealWorld) -> a) -> IO -E- a = (\a :E: Type. (\impureF :R: (w :R: RealWorld) -> a. stBind -E- RealWorld -E- RealWorld -E- a -R- (stGet -E- RealWorld) -R- (\w :R: RealWorld. stReturn -E- RealWorld -E- a -R- (impureF -R- w))))
    unsafePerformIO :R: (a :E: Type) -> (x :R: IO -E- a) -> a = (\a :E: Type. (\x :R: IO -E- a. 
      let postulate TheWorld :R: RealWorld
      in execState -E- RealWorld -E- a -R- x -R- TheWorld))
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure -E- Unspec -R- (\w :R: RealWorld. nativePrint -E- a -R- x)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    main :R: Unspec = unsafePerformIO -E- Unspec -R- (ioBind -E- Nat -E- Unspec -R- (ioReturn -E- Nat -R- 4) -R- (\v :R: Nat. ioBind -E- Unspec -E- Unspec -R- (printNat -R- v) -R- (\_0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ)))))))
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor MkPair : (_x5) -> (_x6) -> Pair
    snd 
      [_] ([_] _ y) = y
    constructor MkSt : (run) -> State
    runState 
      [_] ([_] run) = run
    execState = (\x. (\s. snd (runState x s)))
    stGet = MkSt (\s. MkPair s s)
    stReturn = (\x. MkSt (\s. MkPair s x))
    stBind 
      [_] ([_] f) g = 
        let
          stBind3 
            [_] s ([_] f) = f s
          stBind2 
            [_] g ([_] s x) = stBind3 s (g x)
        in MkSt (\s. stBind2 g (f s))
    ioReturn = (\x. stReturn x)
    ioBind = (\x. (\y. stBind x y))
    ioWrapImpure = (\impureF. stBind stGet (\w. stReturn (impureF w)))
    unsafePerformIO = (\x. 
      let postulate TheWorld : RealWorld
      in execState x TheWorld)
    foreign intS
    foreign intZ
    printSchemeRepr = (\x. 
      let foreign nativePrint
      in ioWrapImpure (\w. nativePrint x))
    natToInt 
      [_] Z = intZ
      [_] (S n) = intS (natToInt n)
    foreign intToNat
    printNat = (\x. printSchemeRepr (natToInt x))
    main = unsafePerformIO (ioBind (ioReturn 4) (\v. ioBind (printNat v) (\_0. printSchemeRepr (intToNat (intS (intS (intS intZ)))))))
  in main

### Intermediate representation ###

let Z = constructor 0
  in let S = constructor 1
    in let MkPair = constructor 2
      in let snd = \_pv0.
        case _pv0 of
          _ _pv1 _pv2 => _pv2
        in let MkSt = constructor 1
          in let runState = \_pv0.
            case _pv0 of
              _ _pv1 => _pv1
            in let execState = \x. \s. (snd ((runState x) s))
              in let stGet = (MkSt \s. ((MkPair s) s))
                in let stReturn = \x. (MkSt \s. ((MkPair s) x))
                  in let stBind = \_pv0. \_pv1.
                    case _pv0 of
                      _ _pv2 => let stBind3 = \_pv3. \_pv4.
                        case _pv4 of
                          _ _pv5 => (_pv5 _pv3)
                        in let stBind2 = \_pv3. \_pv4.
                          case _pv4 of
                            _ _pv5 _pv6 => ((stBind3 _pv5) (_pv3 _pv6))
                          in (MkSt \s. ((stBind2 _pv1) (_pv2 s)))
                    in let ioReturn = \x. (stReturn x)
                      in let ioBind = \x. \y. ((stBind x) y)
                        in let ioWrapImpure = \impureF. ((stBind stGet) \w. (stReturn (impureF w)))
                          in let unsafePerformIO = \x. let TheWorld = constructor 0
                            in ((execState x) TheWorld)
                            in let intS = foreign "(lambda (x) (+ x 1))"
                              in let intZ = foreign "0"
                                in let printSchemeRepr = \x. let nativePrint = foreign "print"
                                  in (ioWrapImpure \w. (nativePrint x))
                                  in let natToInt = \_pv0.
                                    case _pv0 of
                                      S _pv1 => (intS (natToInt _pv1))
                                      Z => intZ
                                    in let intToNat = foreign "(lambda (x) (number->peano 'Z 'S x))"
                                      in let printNat = \x. (printSchemeRepr (natToInt x))
                                        in let main = (unsafePerformIO ((ioBind (ioReturn (S (S (S (S Z)))))) \v. ((ioBind (printNat v)) \_0. (printSchemeRepr (intToNat (intS (intS (intS intZ))))))))
                                          in main

### Normal forms ###

unerased:
  
  let
    constructor Nat : Type
    postulate Int : Type
    foreign intS : (x :R: Int) -> Int
    foreign intZ : Int
    postulate Unspec : Type
    foreign intToNat : (x :R: Int) -> Nat
  in 
    let foreign nativePrint0 : (a :E: Type) -> (x :R: a) -> Unspec
    in nativePrint0 Nat (intToNat (intS (intS (intS intZ))))

erased:
  
  let
    foreign intS
    foreign intZ
    foreign intToNat
  in 
    let foreign nativePrint0
    in nativePrint0 (intToNat (intS (intS (intS intZ))))

