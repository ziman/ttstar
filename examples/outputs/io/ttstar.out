-- vim: ft=ttstar

### Desugared ###

  let
    constructor Nat : Type
    constructor Z : Nat
    constructor S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    times : (_x2 : Nat) -> (_x3 : Nat) -> Nat 
      n : Nat
        [times] Z n = Z
      m : Nat n : Nat
        [times] (S m) n = plus n (times m n)
    constructor Bool : Type
    constructor True : Bool
    constructor False : Bool
    not : (_x4 : Bool) -> Bool 
      [not] True = False
      [not] False = True
    constructor Unit : Type
    constructor MkUnit : Unit
    constructor Pair : (_x5 : Type) -> (_x6 : Type) -> Type
    constructor MkPair : (a : Type) -> (b : Type) -> (_x7 : a) -> (_x8 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x9 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        [fst] a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x10 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        [snd] a b ([MkPair] [a] [b] x y) = y
    constructor Either : (_x11 : Type) -> (_x12 : Type) -> Type
    constructor Left : (a : Type) -> (b : Type) -> (_x13 : a) -> Either a b
    constructor Right : (a : Type) -> (b : Type) -> (_x14 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    constructor Fin : (_x15 : Nat) -> Type
    constructor FZ : (n : Nat) -> Fin (S n)
    constructor FS : (n : Nat) -> (_x16 : Fin n) -> Fin (S n)
    constructor Vect : (_x17 : Nat) -> (_x18 : Type) -> Type
    constructor VN : (a : Type) -> Vect Z a
    constructor VC : (n : Nat) -> (a : Type) -> (x : a) -> (xs : Vect n a) -> Vect (S n) a
    constructor State : (_x0 : Type) -> (_x1 : Type) -> Type
    constructor MkSt : (st : Type) -> (a : Type) -> (run : (_x2 : st) -> Pair st a) -> State st a
    runState : (st : Type) -> (a : Type) -> (_x3 : State st a) -> (_x4 : st) -> Pair st a 
      st : Type a : Type run : (_x5 : st) -> Pair st a
        [runState] st a ([MkSt] [st] [a] run) = run
    execState : (st : Type) -> (a : Type) -> (x : State st a) -> (s : st) -> a = (\st : Type. (\a : Type. (\x : State st a. (\s : st. snd st a (runState st a x s)))))
    stGet : (st : Type) -> State st st = (\st : Type. MkSt st st (\s : st. MkPair st st s s))
    stReturn : (st : Type) -> (a : Type) -> (x : a) -> State st a = (\st : Type. (\a : Type. (\x : a. MkSt st a (\s : st. MkPair st a s x))))
    stBind : (st : Type) -> (a : Type) -> (b : Type) -> (x : State st a) -> (y : (z : a) -> State st b) -> State st b 
      st : Type a : Type b : Type f : (_x6 : st) -> Pair st a g : (_x7 : a) -> State st b
        [stBind] st a b ([MkSt] [st] [a] f) g = 
          let
            stBind3 : (st : Type) -> (b : Type) -> (_x8 : st) -> (_x9 : State st b) -> Pair st b 
              st : Type b : Type s : st f : (_x10 : st) -> Pair st b
                [stBind3] st b s ([MkSt] [st] [b] f) = f s
            stBind2 : (st : Type) -> (a : Type) -> (b : Type) -> (g : (_x11 : a) -> State st b) -> (r : Pair st a) -> Pair st b 
              st : Type a : Type b : Type g : (_x12 : a) -> State st b x : a s : st
                [stBind2] st a b g ([MkPair] [st] [a] s x) = stBind3 st b s (g x)
          in MkSt st b (\s : st. stBind2 st a b g (f s))
    postulate RealWorld : Type
    IO : (_x0 : Type) -> Type = State RealWorld
    ioReturn : (a : Type) -> (x : a) -> IO a = (\a : Type. (\x : a. stReturn RealWorld a x))
    ioBind : (a : Type) -> (b : Type) -> (x : IO a) -> (y : (_x1 : a) -> IO b) -> IO b = (\a : Type. (\b : Type. (\x : IO a. (\y : (_x1 : a) -> IO b. stBind RealWorld a b x y))))
    ioWrapImpure : (a : Type) -> (impureF : (w :R: RealWorld) -> a) -> IO a = (\a : Type. (\impureF : (w :R: RealWorld) -> a. stBind RealWorld RealWorld a (stGet RealWorld) (\w : RealWorld. stReturn RealWorld a (impureF w))))
    unsafePerformIO : (a : Type) -> (x : IO a) -> a = (\a : Type. (\x : IO a. 
      let postulate TheWorld : RealWorld
      in execState RealWorld a x TheWorld))
    postulate Int : Type
    foreign intS : (x :R: Int) -> Int
    foreign intZ : Int
    postulate Unspec : Type
    printSchemeRepr : (a : Type) -> (x : a) -> IO Unspec = (\a : Type. (\x : a. 
      let foreign nativePrint : (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure Unspec (\w : RealWorld. nativePrint a x)))
    natToInt : (_x0 : Nat) -> Int 
      [natToInt] Z = intZ
      n : Nat
        [natToInt] (S n) = intS (natToInt n)
    foreign intToNat : (x :R: Int) -> Nat
    printNat : (x : Nat) -> IO Unspec = (\x : Nat. printSchemeRepr Int (natToInt x))
    main : Unspec = unsafePerformIO Unspec (ioBind Nat Unspec (ioReturn Nat 4) (\v : Nat. ioBind Unspec Unspec (printNat v) (\_0 : Unspec. printSchemeRepr Nat (intToNat (intS (intS (intS intZ)))))))
  in main

### Evarified ###

  let
    constructor Nat :1: Type
    constructor Z :2: Nat
    constructor S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        [plus] -9- Z -8- n = n
      m :10: Nat n :11: Nat
        [plus] -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    times :18: (_x2 :19: Nat) -> (_x3 :20: Nat) -> Nat 
      n :21: Nat
        [times] -23- Z -22- n = Z
      m :24: Nat n :25: Nat
        [times] -27- (S -28- m) -26- n = plus -30- n -29- (times -32- m -31- n)
    constructor Bool :33: Type
    constructor True :34: Bool
    constructor False :35: Bool
    not :36: (_x4 :37: Bool) -> Bool 
      [not] -38- True = False
      [not] -39- False = True
    constructor Unit :40: Type
    constructor MkUnit :41: Unit
    constructor Pair :42: (_x5 :43: Type) -> (_x6 :44: Type) -> Type
    constructor MkPair :45: (a :46: Type) -> (b :47: Type) -> (_x7 :48: a) -> (_x8 :49: b) -> Pair -51- a -50- b
    fst :52: (a :53: Type) -> (b :54: Type) -> (_x9 :55: Pair -57- a -56- b) -> a 
      a :58: Type b :59: Type x :60: a y :61: b
        [fst] -64- a -63- b -62- ([MkPair] -68- [a] -67- [b] -66- x -65- y) = x
    snd :69: (a :70: Type) -> (b :71: Type) -> (_x10 :72: Pair -74- a -73- b) -> b 
      a :75: Type b :76: Type x :77: a y :78: b
        [snd] -81- a -80- b -79- ([MkPair] -85- [a] -84- [b] -83- x -82- y) = y
    constructor Either :86: (_x11 :87: Type) -> (_x12 :88: Type) -> Type
    constructor Left :89: (a :90: Type) -> (b :91: Type) -> (_x13 :92: a) -> Either -94- a -93- b
    constructor Right :95: (a :96: Type) -> (b :97: Type) -> (_x14 :98: b) -> Either -100- a -99- b
    id :101: (a :102: Type) -> (x :103: a) -> a = (\a :104: Type. (\x :105: a. x))
    constructor Fin :106: (_x15 :107: Nat) -> Type
    constructor FZ :108: (n :109: Nat) -> Fin -110- (S -111- n)
    constructor FS :112: (n :113: Nat) -> (_x16 :114: Fin -115- n) -> Fin -116- (S -117- n)
    constructor Vect :118: (_x17 :119: Nat) -> (_x18 :120: Type) -> Type
    constructor VN :121: (a :122: Type) -> Vect -124- Z -123- a
    constructor VC :125: (n :126: Nat) -> (a :127: Type) -> (x :128: a) -> (xs :129: Vect -131- n -130- a) -> Vect -133- (S -134- n) -132- a
    constructor State :135: (_x0 :136: Type) -> (_x1 :137: Type) -> Type
    constructor MkSt :138: (st :139: Type) -> (a :140: Type) -> (run :141: (_x2 :142: st) -> Pair -144- st -143- a) -> State -146- st -145- a
    runState :147: (st :148: Type) -> (a :149: Type) -> (_x3 :150: State -152- st -151- a) -> (_x4 :153: st) -> Pair -155- st -154- a 
      st :156: Type a :157: Type run :158: (_x5 :159: st) -> Pair -161- st -160- a
        [runState] -164- st -163- a -162- ([MkSt] -167- [st] -166- [a] -165- run) = run
    execState :168: (st :169: Type) -> (a :170: Type) -> (x :171: State -173- st -172- a) -> (s :174: st) -> a = (\st :175: Type. (\a :176: Type. (\x :177: State -179- st -178- a. (\s :180: st. snd -183- st -182- a -181- (runState -187- st -186- a -185- x -184- s)))))
    stGet :188: (st :189: Type) -> State -191- st -190- st = (\st :192: Type. MkSt -195- st -194- st -193- (\s :196: st. MkPair -200- st -199- st -198- s -197- s))
    stReturn :201: (st :202: Type) -> (a :203: Type) -> (x :204: a) -> State -206- st -205- a = (\st :207: Type. (\a :208: Type. (\x :209: a. MkSt -212- st -211- a -210- (\s :213: st. MkPair -217- st -216- a -215- s -214- x))))
    stBind :218: (st :219: Type) -> (a :220: Type) -> (b :221: Type) -> (x :222: State -224- st -223- a) -> (y :225: (z :226: a) -> State -228- st -227- b) -> State -230- st -229- b 
      st :231: Type a :232: Type b :233: Type f :234: (_x6 :235: st) -> Pair -237- st -236- a g :238: (_x7 :239: a) -> State -241- st -240- b
        [stBind] -246- st -245- a -244- b -243- ([MkSt] -249- [st] -248- [a] -247- f) -242- g = 
          let
            stBind3 :250: (st :251: Type) -> (b :252: Type) -> (_x8 :253: st) -> (_x9 :254: State -256- st -255- b) -> Pair -258- st -257- b 
              st :259: Type b :260: Type s :261: st f :262: (_x10 :263: st) -> Pair -265- st -264- b
                [stBind3] -269- st -268- b -267- s -266- ([MkSt] -272- [st] -271- [b] -270- f) = f -273- s
            stBind2 :274: (st :275: Type) -> (a :276: Type) -> (b :277: Type) -> (g :278: (_x11 :279: a) -> State -281- st -280- b) -> (r :282: Pair -284- st -283- a) -> Pair -286- st -285- b 
              st :287: Type a :288: Type b :289: Type g :290: (_x12 :291: a) -> State -293- st -292- b x :294: a s :295: st
                [stBind2] -300- st -299- a -298- b -297- g -296- ([MkPair] -304- [st] -303- [a] -302- s -301- x) = stBind3 -308- st -307- b -306- s -305- (g -309- x)
          in MkSt -312- st -311- b -310- (\s :313: st. stBind2 -318- st -317- a -316- b -315- g -314- (f -319- s))
    postulate RealWorld :320: Type
    IO :321: (_x0 :322: Type) -> Type = State -323- RealWorld
    ioReturn :324: (a :325: Type) -> (x :326: a) -> IO -327- a = (\a :328: Type. (\x :329: a. stReturn -332- RealWorld -331- a -330- x))
    ioBind :333: (a :334: Type) -> (b :335: Type) -> (x :336: IO -337- a) -> (y :338: (_x1 :339: a) -> IO -340- b) -> IO -341- b = (\a :342: Type. (\b :343: Type. (\x :344: IO -345- a. (\y :346: (_x1 :347: a) -> IO -348- b. stBind -353- RealWorld -352- a -351- b -350- x -349- y))))
    ioWrapImpure :354: (a :355: Type) -> (impureF :356: (w :R: RealWorld) -> a) -> IO -357- a = (\a :358: Type. (\impureF :359: (w :R: RealWorld) -> a. stBind -364- RealWorld -363- RealWorld -362- a -361- (stGet -365- RealWorld) -360- (\w :366: RealWorld. stReturn -369- RealWorld -368- a -367- (impureF -370- w))))
    unsafePerformIO :371: (a :372: Type) -> (x :373: IO -374- a) -> a = (\a :375: Type. (\x :376: IO -377- a. 
      let postulate TheWorld :378: RealWorld
      in execState -382- RealWorld -381- a -380- x -379- TheWorld))
    postulate Int :383: Type
    foreign intS :384: (x :R: Int) -> Int
    foreign intZ :385: Int
    postulate Unspec :386: Type
    printSchemeRepr :387: (a :388: Type) -> (x :389: a) -> IO -390- Unspec = (\a :391: Type. (\x :392: a. 
      let foreign nativePrint :393: (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure -395- Unspec -394- (\w :396: RealWorld. nativePrint -398- a -397- x)))
    natToInt :399: (_x0 :400: Nat) -> Int 
      [natToInt] -401- Z = intZ
      n :402: Nat
        [natToInt] -403- (S -404- n) = intS -405- (natToInt -406- n)
    foreign intToNat :407: (x :R: Int) -> Nat
    printNat :408: (x :409: Nat) -> IO -410- Unspec = (\x :411: Nat. printSchemeRepr -413- Int -412- (natToInt -414- x))
    main :415: Unspec = unsafePerformIO -417- Unspec -416- (ioBind -421- Nat -420- Unspec -419- (ioReturn -423- Nat -422- 4) -418- (\v :428: Nat. ioBind -432- Unspec -431- Unspec -430- (printNat -433- v) -429- (\_0 :434: Unspec. printSchemeRepr -436- Nat -435- (intToNat -437- (intS -438- (intS -439- (intS -440- intZ)))))))
  in main

### Constraints ###

[] -> [2,3,45,48,49,69,72,78,79,82,83,138,141,142,147,150,153,158,159,162,165,168,171,174,177,180,181,184,185,188,193,196,197,198,201,204,209,210,213,214,215,218,222,225,226,234,235,238,239,242,243,247,250,253,254,261,262,263,266,267,270,273,274,278,279,282,290,291,294,295,296,297,301,302,305,306,309,310,313,314,315,319,324,326,329,330,333,336,338,339,344,346,347,349,350,354,356,359,360,361,366,367,370,371,373,376,378,379,380,384,385,387,389,392,393,394,396,397,399,400,401,402,403,404,405,406,407,408,409,411,412,414,416,418,419,422,424,425,426,427,428,429,430,433,434,435,437,438,439,440,R]
[46] -> [85,200,217,304]
[47] -> [84,199,216,303]
[50] -> [73,143,283]
[51] -> [74,144,284]
[70] -> [81,183]
[71] -> [80,182]
[73] -> [50,154]
[74] -> [51,155]
[75] -> [81]
[76] -> [80]
[77] -> [83]
[80] -> [71,R]
[81] -> [70,R]
[84] -> [47,76,79]
[85] -> [46,75,79]
[139] -> [167,195,212,249,272,312]
[140] -> [166,194,211,248,271,311]
[143] -> [50,160,236,264,285]
[144] -> [51,161,237,265,286]
[145] -> [151,190,205,223,229,255]
[146] -> [152,191,206,224,230,256]
[148] -> [164,187]
[149] -> [163,186]
[151] -> [145,178]
[152] -> [146,179]
[154] -> [73,160]
[155] -> [74,161]
[156] -> [164]
[157] -> [163]
[160] -> [143,154]
[161] -> [144,155]
[163] -> [149,R]
[164] -> [148,R]
[166] -> [140,157,162]
[167] -> [139,156,162]
[169] -> [175,382]
[170] -> [176,381]
[172] -> [178,377]
[173] -> [179,323]
[175] -> [169]
[176] -> [170]
[178] -> [151,172]
[179] -> [152,173]
[182] -> [71,176]
[183] -> [70,175]
[186] -> [149,176]
[187] -> [148,175]
[189] -> [192,365]
[190] -> [145,223]
[191] -> [146,224]
[192] -> [189]
[194] -> [140,192]
[195] -> [139,192]
[199] -> [47,192]
[200] -> [46,192]
[202] -> [207,332,369]
[203] -> [208,331,368]
[205] -> [145,227,327]
[206] -> [146,228,323]
[207] -> [202]
[208] -> [203]
[211] -> [140,208]
[212] -> [139,207]
[216] -> [47,208]
[217] -> [46,207]
[219] -> [246,353,364]
[220] -> [245,352,363]
[221] -> [244,351,362]
[223] -> [145,190,345]
[224] -> [146,191,323]
[227] -> [205,240,348]
[228] -> [206,241,323]
[229] -> [145,341,357]
[230] -> [146,323]
[231] -> [246]
[232] -> [245]
[233] -> [244]
[236] -> [143,283]
[237] -> [144,284]
[240] -> [227,280]
[241] -> [228,281]
[244] -> [221,R]
[245] -> [220,R]
[246] -> [219,R]
[248] -> [140,232,243]
[249] -> [139,231,243]
[251] -> [269,308]
[252] -> [268,307]
[255] -> [145,292]
[256] -> [146,293]
[257] -> [264,285]
[258] -> [265,286]
[259] -> [269]
[260] -> [268]
[264] -> [143,257]
[265] -> [144,258]
[268] -> [252,R]
[269] -> [251,R]
[271] -> [140,260,266]
[272] -> [139,259,266]
[275] -> [300,318]
[276] -> [299,317]
[277] -> [298,316]
[280] -> [240,292]
[281] -> [241,293]
[283] -> [50,236]
[284] -> [51,237]
[285] -> [143,257]
[286] -> [144,258]
[287] -> [300]
[288] -> [299]
[289] -> [298]
[292] -> [255,280]
[293] -> [256,281]
[298] -> [277,R]
[299] -> [276,R]
[300] -> [275,R]
[303] -> [47,288,296]
[304] -> [46,287,296]
[307] -> [252,289]
[308] -> [251,287]
[311] -> [140,233]
[312] -> [139,231]
[316] -> [233,277]
[317] -> [232,276]
[318] -> [231,275]
[323] -> [173,206,224,228,230,323]
[325] -> [328,423]
[327] -> [205,337]
[328] -> [325]
[331] -> [203,328]
[332] -> [202,320]
[334] -> [342,421,432]
[335] -> [343,420,431]
[337] -> [327,345,410]
[340] -> [341,348,390]
[341] -> [229,340,374]
[342] -> [334]
[343] -> [335]
[345] -> [223,337]
[348] -> [227,340]
[351] -> [221,343]
[352] -> [220,342]
[353] -> [219,320]
[355] -> [358,395]
[357] -> [229,390]
[358] -> [355]
[362] -> [221,358]
[363] -> [220,320]
[364] -> [219,320]
[365] -> [189,320]
[368] -> [203,358]
[369] -> [202,320]
[372] -> [375,417]
[374] -> [341,377]
[375] -> [372]
[377] -> [172,374]
[381] -> [170,375]
[382] -> [169,320]
[388] -> [391,413,436]
[390] -> [340,357,410]
[391] -> [388]
[395] -> [355,386]
[398] -> [391,E]
[410] -> [337,390]
[413] -> [383,388]
[417] -> [372,386]
[420] -> [335,386]
[421] -> [1,334]
[423] -> [1,325]
[431] -> [335,386]
[432] -> [334,386]
[436] -> [1,388]
[E] -> [398]
[R] -> [415]

### Solution ###

[2,3,45,48,49,69,72,78,79,82,83,138,141,142,147,150,153,158,159,162,165,168,171,174,177,180,181,184,185,188,193,196,197,198,201,204,209,210,213,214,215,218,222,225,226,234,235,238,239,242,243,247,250,253,254,261,262,263,266,267,270,273,274,278,279,282,290,291,294,295,296,297,301,302,305,306,309,310,313,314,315,319,324,326,329,330,333,336,338,339,344,346,347,349,350,354,356,359,360,361,366,367,370,371,373,376,378,379,380,384,385,387,389,392,393,394,396,397,399,400,401,402,403,404,405,406,407,408,409,411,412,414,415,416,418,419,422,424,425,426,427,428,429,430,433,434,435,437,438,439,440,R]

### Annotated ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        [times] -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        [times] -E- (S -E- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :E: Bool
    constructor False :E: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :R: (a :E: Type) -> (b :E: Type) -> (_x7 :R: a) -> (_x8 :R: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :R: (a :E: Type) -> (b :E: Type) -> (_x10 :R: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :R: b
        [snd] -E- a -E- b -R- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor State :E: (_x0 :E: Type) -> (_x1 :E: Type) -> Type
    constructor MkSt :R: (st :E: Type) -> (a :E: Type) -> (run :R: (_x2 :R: st) -> Pair -E- st -E- a) -> State -E- st -E- a
    runState :R: (st :E: Type) -> (a :E: Type) -> (_x3 :R: State -E- st -E- a) -> (_x4 :R: st) -> Pair -E- st -E- a 
      st :E: Type a :E: Type run :R: (_x5 :R: st) -> Pair -E- st -E- a
        [runState] -E- st -E- a -R- ([MkSt] -E- [st] -E- [a] -R- run) = run
    execState :R: (st :E: Type) -> (a :E: Type) -> (x :R: State -E- st -E- a) -> (s :R: st) -> a = (\st :E: Type. (\a :E: Type. (\x :R: State -E- st -E- a. (\s :R: st. snd -E- st -E- a -R- (runState -E- st -E- a -R- x -R- s)))))
    stGet :R: (st :E: Type) -> State -E- st -E- st = (\st :E: Type. MkSt -E- st -E- st -R- (\s :R: st. MkPair -E- st -E- st -R- s -R- s))
    stReturn :R: (st :E: Type) -> (a :E: Type) -> (x :R: a) -> State -E- st -E- a = (\st :E: Type. (\a :E: Type. (\x :R: a. MkSt -E- st -E- a -R- (\s :R: st. MkPair -E- st -E- a -R- s -R- x))))
    stBind :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (x :R: State -E- st -E- a) -> (y :R: (z :R: a) -> State -E- st -E- b) -> State -E- st -E- b 
      st :E: Type a :E: Type b :E: Type f :R: (_x6 :R: st) -> Pair -E- st -E- a g :R: (_x7 :R: a) -> State -E- st -E- b
        [stBind] -E- st -E- a -E- b -R- ([MkSt] -E- [st] -E- [a] -R- f) -R- g = 
          let
            stBind3 :R: (st :E: Type) -> (b :E: Type) -> (_x8 :R: st) -> (_x9 :R: State -E- st -E- b) -> Pair -E- st -E- b 
              st :E: Type b :E: Type s :R: st f :R: (_x10 :R: st) -> Pair -E- st -E- b
                [stBind3] -E- st -E- b -R- s -R- ([MkSt] -E- [st] -E- [b] -R- f) = f -R- s
            stBind2 :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (g :R: (_x11 :R: a) -> State -E- st -E- b) -> (r :R: Pair -E- st -E- a) -> Pair -E- st -E- b 
              st :E: Type a :E: Type b :E: Type g :R: (_x12 :R: a) -> State -E- st -E- b x :R: a s :R: st
                [stBind2] -E- st -E- a -E- b -R- g -R- ([MkPair] -E- [st] -E- [a] -R- s -R- x) = stBind3 -E- st -E- b -R- s -R- (g -R- x)
          in MkSt -E- st -E- b -R- (\s :R: st. stBind2 -E- st -E- a -E- b -R- g -R- (f -R- s))
    postulate RealWorld :E: Type
    IO :E: (_x0 :E: Type) -> Type = State -E- RealWorld
    ioReturn :R: (a :E: Type) -> (x :R: a) -> IO -E- a = (\a :E: Type. (\x :R: a. stReturn -E- RealWorld -E- a -R- x))
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (_x1 :R: a) -> IO -E- b) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\x :R: IO -E- a. (\y :R: (_x1 :R: a) -> IO -E- b. stBind -E- RealWorld -E- a -E- b -R- x -R- y))))
    ioWrapImpure :R: (a :E: Type) -> (impureF :R: (w :R: RealWorld) -> a) -> IO -E- a = (\a :E: Type. (\impureF :R: (w :R: RealWorld) -> a. stBind -E- RealWorld -E- RealWorld -E- a -R- (stGet -E- RealWorld) -R- (\w :R: RealWorld. stReturn -E- RealWorld -E- a -R- (impureF -R- w))))
    unsafePerformIO :R: (a :E: Type) -> (x :R: IO -E- a) -> a = (\a :E: Type. (\x :R: IO -E- a. 
      let postulate TheWorld :R: RealWorld
      in execState -E- RealWorld -E- a -R- x -R- TheWorld))
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure -E- Unspec -R- (\w :R: RealWorld. nativePrint -E- a -R- x)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    main :R: Unspec = unsafePerformIO -E- Unspec -R- (ioBind -E- Nat -E- Unspec -R- (ioReturn -E- Nat -R- 4) -R- (\v :R: Nat. ioBind -E- Unspec -E- Unspec -R- (printNat -R- v) -R- (\_0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ)))))))
  in main

### Specialised ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        [times] -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        [times] -E- (S -E- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :E: Bool
    constructor False :E: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :R: (a :E: Type) -> (b :E: Type) -> (_x7 :R: a) -> (_x8 :R: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :R: (a :E: Type) -> (b :E: Type) -> (_x10 :R: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :R: b
        [snd] -E- a -E- b -R- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor State :E: (_x0 :E: Type) -> (_x1 :E: Type) -> Type
    constructor MkSt :R: (st :E: Type) -> (a :E: Type) -> (run :R: (_x2 :R: st) -> Pair -E- st -E- a) -> State -E- st -E- a
    runState :R: (st :E: Type) -> (a :E: Type) -> (_x3 :R: State -E- st -E- a) -> (_x4 :R: st) -> Pair -E- st -E- a 
      st :E: Type a :E: Type run :R: (_x5 :R: st) -> Pair -E- st -E- a
        [runState] -E- st -E- a -R- ([MkSt] -E- [st] -E- [a] -R- run) = run
    execState :R: (st :E: Type) -> (a :E: Type) -> (x :R: State -E- st -E- a) -> (s :R: st) -> a = (\st :E: Type. (\a :E: Type. (\x :R: State -E- st -E- a. (\s :R: st. snd -E- st -E- a -R- (runState -E- st -E- a -R- x -R- s)))))
    stGet :R: (st :E: Type) -> State -E- st -E- st = (\st :E: Type. MkSt -E- st -E- st -R- (\s :R: st. MkPair -E- st -E- st -R- s -R- s))
    stReturn :R: (st :E: Type) -> (a :E: Type) -> (x :R: a) -> State -E- st -E- a = (\st :E: Type. (\a :E: Type. (\x :R: a. MkSt -E- st -E- a -R- (\s :R: st. MkPair -E- st -E- a -R- s -R- x))))
    stBind :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (x :R: State -E- st -E- a) -> (y :R: (z :R: a) -> State -E- st -E- b) -> State -E- st -E- b 
      st :E: Type a :E: Type b :E: Type f :R: (_x6 :R: st) -> Pair -E- st -E- a g :R: (_x7 :R: a) -> State -E- st -E- b
        [stBind] -E- st -E- a -E- b -R- ([MkSt] -E- [st] -E- [a] -R- f) -R- g = 
          let
            stBind3 :R: (st :E: Type) -> (b :E: Type) -> (_x8 :R: st) -> (_x9 :R: State -E- st -E- b) -> Pair -E- st -E- b 
              st :E: Type b :E: Type s :R: st f :R: (_x10 :R: st) -> Pair -E- st -E- b
                [stBind3] -E- st -E- b -R- s -R- ([MkSt] -E- [st] -E- [b] -R- f) = f -R- s
            stBind2 :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (g :R: (_x11 :R: a) -> State -E- st -E- b) -> (r :R: Pair -E- st -E- a) -> Pair -E- st -E- b 
              st :E: Type a :E: Type b :E: Type g :R: (_x12 :R: a) -> State -E- st -E- b x :R: a s :R: st
                [stBind2] -E- st -E- a -E- b -R- g -R- ([MkPair] -E- [st] -E- [a] -R- s -R- x) = stBind3 -E- st -E- b -R- s -R- (g -R- x)
          in MkSt -E- st -E- b -R- (\s :R: st. stBind2 -E- st -E- a -E- b -R- g -R- (f -R- s))
    postulate RealWorld :E: Type
    IO :E: (_x0 :E: Type) -> Type = State -E- RealWorld
    ioReturn :R: (a :E: Type) -> (x :R: a) -> IO -E- a = (\a :E: Type. (\x :R: a. stReturn -E- RealWorld -E- a -R- x))
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (_x1 :R: a) -> IO -E- b) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\x :R: IO -E- a. (\y :R: (_x1 :R: a) -> IO -E- b. stBind -E- RealWorld -E- a -E- b -R- x -R- y))))
    ioWrapImpure :R: (a :E: Type) -> (impureF :R: (w :R: RealWorld) -> a) -> IO -E- a = (\a :E: Type. (\impureF :R: (w :R: RealWorld) -> a. stBind -E- RealWorld -E- RealWorld -E- a -R- (stGet -E- RealWorld) -R- (\w :R: RealWorld. stReturn -E- RealWorld -E- a -R- (impureF -R- w))))
    unsafePerformIO :R: (a :E: Type) -> (x :R: IO -E- a) -> a = (\a :E: Type. (\x :R: IO -E- a. 
      let postulate TheWorld :R: RealWorld
      in execState -E- RealWorld -E- a -R- x -R- TheWorld))
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure -E- Unspec -R- (\w :R: RealWorld. nativePrint -E- a -R- x)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    main :R: Unspec = unsafePerformIO -E- Unspec -R- (ioBind -E- Nat -E- Unspec -R- (ioReturn -E- Nat -R- 4) -R- (\v :R: Nat. ioBind -E- Unspec -E- Unspec -R- (printNat -R- v) -R- (\_0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ)))))))
  in main

### Final annotation ###

  let
    constructor Nat :E: Type
    constructor Z :R: Nat
    constructor S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    times :E: (_x2 :E: Nat) -> (_x3 :E: Nat) -> Nat 
      n :E: Nat
        [times] -E- Z -E- n = Z
      m :E: Nat n :E: Nat
        [times] -E- (S -E- m) -E- n = plus -E- n -E- (times -E- m -E- n)
    constructor Bool :E: Type
    constructor True :E: Bool
    constructor False :E: Bool
    not :E: (_x4 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    constructor Unit :E: Type
    constructor MkUnit :E: Unit
    constructor Pair :E: (_x5 :E: Type) -> (_x6 :E: Type) -> Type
    constructor MkPair :R: (a :E: Type) -> (b :E: Type) -> (_x7 :R: a) -> (_x8 :R: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x9 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :R: (a :E: Type) -> (b :E: Type) -> (_x10 :R: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :R: b
        [snd] -E- a -E- b -R- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = y
    constructor Either :E: (_x11 :E: Type) -> (_x12 :E: Type) -> Type
    constructor Left :E: (a :E: Type) -> (b :E: Type) -> (_x13 :E: a) -> Either -E- a -E- b
    constructor Right :E: (a :E: Type) -> (b :E: Type) -> (_x14 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    constructor Fin :E: (_x15 :E: Nat) -> Type
    constructor FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    constructor FS :E: (n :E: Nat) -> (_x16 :E: Fin -E- n) -> Fin -E- (S -E- n)
    constructor Vect :E: (_x17 :E: Nat) -> (_x18 :E: Type) -> Type
    constructor VN :E: (a :E: Type) -> Vect -E- Z -E- a
    constructor VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    constructor State :E: (_x0 :E: Type) -> (_x1 :E: Type) -> Type
    constructor MkSt :R: (st :E: Type) -> (a :E: Type) -> (run :R: (_x2 :R: st) -> Pair -E- st -E- a) -> State -E- st -E- a
    runState :R: (st :E: Type) -> (a :E: Type) -> (_x3 :R: State -E- st -E- a) -> (_x4 :R: st) -> Pair -E- st -E- a 
      st :E: Type a :E: Type run :R: (_x5 :R: st) -> Pair -E- st -E- a
        [runState] -E- st -E- a -R- ([MkSt] -E- [st] -E- [a] -R- run) = run
    execState :R: (st :E: Type) -> (a :E: Type) -> (x :R: State -E- st -E- a) -> (s :R: st) -> a = (\st :E: Type. (\a :E: Type. (\x :R: State -E- st -E- a. (\s :R: st. snd -E- st -E- a -R- (runState -E- st -E- a -R- x -R- s)))))
    stGet :R: (st :E: Type) -> State -E- st -E- st = (\st :E: Type. MkSt -E- st -E- st -R- (\s :R: st. MkPair -E- st -E- st -R- s -R- s))
    stReturn :R: (st :E: Type) -> (a :E: Type) -> (x :R: a) -> State -E- st -E- a = (\st :E: Type. (\a :E: Type. (\x :R: a. MkSt -E- st -E- a -R- (\s :R: st. MkPair -E- st -E- a -R- s -R- x))))
    stBind :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (x :R: State -E- st -E- a) -> (y :R: (z :R: a) -> State -E- st -E- b) -> State -E- st -E- b 
      st :E: Type a :E: Type b :E: Type f :R: (_x6 :R: st) -> Pair -E- st -E- a g :R: (_x7 :R: a) -> State -E- st -E- b
        [stBind] -E- st -E- a -E- b -R- ([MkSt] -E- [st] -E- [a] -R- f) -R- g = 
          let
            stBind3 :R: (st :E: Type) -> (b :E: Type) -> (_x8 :R: st) -> (_x9 :R: State -E- st -E- b) -> Pair -E- st -E- b 
              st :E: Type b :E: Type s :R: st f :R: (_x10 :R: st) -> Pair -E- st -E- b
                [stBind3] -E- st -E- b -R- s -R- ([MkSt] -E- [st] -E- [b] -R- f) = f -R- s
            stBind2 :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (g :R: (_x11 :R: a) -> State -E- st -E- b) -> (r :R: Pair -E- st -E- a) -> Pair -E- st -E- b 
              st :E: Type a :E: Type b :E: Type g :R: (_x12 :R: a) -> State -E- st -E- b x :R: a s :R: st
                [stBind2] -E- st -E- a -E- b -R- g -R- ([MkPair] -E- [st] -E- [a] -R- s -R- x) = stBind3 -E- st -E- b -R- s -R- (g -R- x)
          in MkSt -E- st -E- b -R- (\s :R: st. stBind2 -E- st -E- a -E- b -R- g -R- (f -R- s))
    postulate RealWorld :E: Type
    IO :E: (_x0 :E: Type) -> Type = State -E- RealWorld
    ioReturn :R: (a :E: Type) -> (x :R: a) -> IO -E- a = (\a :E: Type. (\x :R: a. stReturn -E- RealWorld -E- a -R- x))
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (_x1 :R: a) -> IO -E- b) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\x :R: IO -E- a. (\y :R: (_x1 :R: a) -> IO -E- b. stBind -E- RealWorld -E- a -E- b -R- x -R- y))))
    ioWrapImpure :R: (a :E: Type) -> (impureF :R: (w :R: RealWorld) -> a) -> IO -E- a = (\a :E: Type. (\impureF :R: (w :R: RealWorld) -> a. stBind -E- RealWorld -E- RealWorld -E- a -R- (stGet -E- RealWorld) -R- (\w :R: RealWorld. stReturn -E- RealWorld -E- a -R- (impureF -R- w))))
    unsafePerformIO :R: (a :E: Type) -> (x :R: IO -E- a) -> a = (\a :E: Type. (\x :R: IO -E- a. 
      let postulate TheWorld :R: RealWorld
      in execState -E- RealWorld -E- a -R- x -R- TheWorld))
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure -E- Unspec -R- (\w :R: RealWorld. nativePrint -E- a -R- x)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    main :R: Unspec = unsafePerformIO -E- Unspec -R- (ioBind -E- Nat -E- Unspec -R- (ioReturn -E- Nat -R- 4) -R- (\v :R: Nat. ioBind -E- Unspec -E- Unspec -R- (printNat -R- v) -R- (\_0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ)))))))
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Z : Nat
    constructor S : (x) -> Nat
    constructor MkPair : (_x7) -> (_x8) -> Pair
    snd 
      [_] ([_] _ y) = y
    constructor MkSt : (run) -> State
    runState 
      [_] ([_] run) = run
    execState = (\x. (\s. snd (runState x s)))
    stGet = MkSt (\s. MkPair s s)
    stReturn = (\x. MkSt (\s. MkPair s x))
    stBind 
      [_] ([_] f) g = 
        let
          stBind3 
            [_] s ([_] f) = f s
          stBind2 
            [_] g ([_] s x) = stBind3 s (g x)
        in MkSt (\s. stBind2 g (f s))
    ioReturn = (\x. stReturn x)
    ioBind = (\x. (\y. stBind x y))
    ioWrapImpure = (\impureF. stBind stGet (\w. stReturn (impureF w)))
    unsafePerformIO = (\x. 
      let postulate TheWorld : RealWorld
      in execState x TheWorld)
    foreign intS
    foreign intZ
    printSchemeRepr = (\x. 
      let foreign nativePrint
      in ioWrapImpure (\w. nativePrint x))
    natToInt 
      [_] Z = intZ
      [_] (S n) = intS (natToInt n)
    foreign intToNat
    printNat = (\x. printSchemeRepr (natToInt x))
    main = unsafePerformIO (ioBind (ioReturn 4) (\v. ioBind (printNat v) (\_0. printSchemeRepr (intToNat (intS (intS (intS intZ)))))))
  in main

### Intermediate representation ###

let Z = constructor 0
  in let S = constructor 1
    in let MkPair = constructor 2
      in let snd = \_pv0.
        case _pv0 of
          _ _pv1 _pv2 => _pv2
        in let MkSt = constructor 1
          in let runState = \_pv0.
            case _pv0 of
              _ _pv1 => _pv1
            in let execState = \x. \s. (snd ((runState x) s))
              in let stGet = (MkSt \s. ((MkPair s) s))
                in let stReturn = \x. (MkSt \s. ((MkPair s) x))
                  in let stBind = \_pv0. \_pv1.
                    case _pv0 of
                      _ _pv2 => let stBind3 = \_pv3. \_pv4.
                        case _pv4 of
                          _ _pv5 => (_pv5 _pv3)
                        in let stBind2 = \_pv3. \_pv4.
                          case _pv4 of
                            _ _pv5 _pv6 => ((stBind3 _pv5) (_pv3 _pv6))
                          in (MkSt \s. ((stBind2 _pv1) (_pv2 s)))
                    in let ioReturn = \x. (stReturn x)
                      in let ioBind = \x. \y. ((stBind x) y)
                        in let ioWrapImpure = \impureF. ((stBind stGet) \w. (stReturn (impureF w)))
                          in let unsafePerformIO = \x. let TheWorld = constructor 0
                            in ((execState x) TheWorld)
                            in let intS = foreign "(lambda (x) (+ x 1))"
                              in let intZ = foreign "0"
                                in let printSchemeRepr = \x. let nativePrint = foreign "print"
                                  in (ioWrapImpure \w. (nativePrint x))
                                  in let natToInt = \_pv0.
                                    case _pv0 of
                                      S _pv1 => (intS (natToInt _pv1))
                                      Z => intZ
                                    in let intToNat = foreign "(lambda (x) (number->peano 'Z 'S x))"
                                      in let printNat = \x. (printSchemeRepr (natToInt x))
                                        in let main = (unsafePerformIO ((ioBind (ioReturn (S (S (S (S Z)))))) \v. ((ioBind (printNat v)) \_0. (printSchemeRepr (intToNat (intS (intS (intS intZ))))))))
                                          in main

### Normal forms ###

unerased:
  
  let
    constructor Nat : Type
    postulate Int : Type
    foreign intS : (x :R: Int) -> Int
    foreign intZ : Int
    postulate Unspec : Type
    foreign intToNat : (x :R: Int) -> Nat
  in 
    let foreign nativePrint0 : (a :E: Type) -> (x :R: a) -> Unspec
    in nativePrint0 Nat (intToNat (intS (intS (intS intZ))))

erased:
  
  let
    foreign intS
    foreign intZ
    foreign intToNat
  in 
    let foreign nativePrint0
    in nativePrint0 (intToNat (intS (intS (intS intZ))))

