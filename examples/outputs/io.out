-- vim: ft=idris

### Desugared ###

  let
    postulate Nat : Type
    postulate Z : Nat
    postulate S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    postulate Bool : Type
    postulate True : Bool
    postulate False : Bool
    not : (_x2 : Bool) -> Bool 
      [not] True = False
      [not] False = True
    postulate Unit : Type
    postulate MkUnit : Unit
    postulate Pair : (_x3 : Type) -> (_x4 : Type) -> Type
    postulate MkPair : (a : Type) -> (b : Type) -> (_x5 : a) -> (_x6 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x7 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        [fst] a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x8 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        [snd] a b ([MkPair] [a] [b] x y) = y
    postulate Either : (_x9 : Type) -> (_x10 : Type) -> Type
    postulate Left : (a : Type) -> (b : Type) -> (_x11 : a) -> Either a b
    postulate Right : (a : Type) -> (b : Type) -> (_x12 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    postulate State : (_x0 : Type) -> (_x1 : Type) -> Type
    postulate MkSt : (st : Type) -> (a : Type) -> (run : (_x2 : st) -> Pair st a) -> State st a
    runState : (st : Type) -> (a : Type) -> (_x3 : State st a) -> (_x4 : st) -> Pair st a 
      st : Type a : Type run : (_x5 : st) -> Pair st a
        [runState] st a ([MkSt] [st] [a] run) = run
    execState : (st : Type) -> (a : Type) -> (x : State st a) -> (s : st) -> a = (\st : Type. (\a : Type. (\x : State st a. (\s : st. snd st a (runState st a x s)))))
    stReturn : (st : Type) -> (a : Type) -> (x : a) -> State st a = (\st : Type. (\a : Type. (\x : a. MkSt st a (\s : st. MkPair st a s x))))
    stBind : (st : Type) -> (a : Type) -> (b : Type) -> (x : State st a) -> (y : (z : a) -> State st b) -> State st b 
      st : Type a : Type b : Type f : (_x6 : st) -> Pair st a g : (_x7 : a) -> State st b
        [stBind] st a b ([MkSt] [st] [a] f) g = 
          let
            stBind3 : (st : Type) -> (b : Type) -> (_x8 : st) -> (_x9 : State st b) -> Pair st b 
              st : Type b : Type s : st f : (_x10 : st) -> Pair st b
                [stBind3] st b s ([MkSt] [st] [b] f) = f s
            stBind2 : (st : Type) -> (a : Type) -> (b : Type) -> (g : (_x11 : a) -> State st b) -> (r : Pair st a) -> Pair st b 
              st : Type a : Type b : Type g : (_x12 : a) -> State st b x : a s : st
                [stBind2] st a b g ([MkPair] [st] [a] s x) = stBind3 st b s (g x)
          in MkSt st b (\s : st. stBind2 st a b g (f s))
    postulate RealWorld : Type
    IO : (_x0 : Type) -> Type = State RealWorld
    ioReturn : (a : Type) -> (x : a) -> IO a = (\a : Type. (\x : a. stReturn RealWorld a x))
    ioBind : (a : Type) -> (b : Type) -> (x : IO a) -> (y : (_x1 : a) -> IO b) -> IO b = (\a : Type. (\b : Type. (\x : IO a. (\y : (_x1 : a) -> IO b. stBind RealWorld a b x y))))
    ioWrapImpure : (a : Type) -> (impureF : (delayToken :R: Unit) -> a) -> IO a = (\a : Type. (\impureF : (delayToken :R: Unit) -> a. MkSt RealWorld a (\w :R: RealWorld. MkPair RealWorld a w (impureF MkUnit))))
    unsafePerformIO : (a : Type) -> (x : IO a) -> a = (\a : Type. (\x : IO a. 
      let postulate TheWorld : RealWorld
      in execState RealWorld a x TheWorld))
    postulate Int : Type
    foreign intS : (x :R: Int) -> Int
    foreign intZ : Int
    postulate Unspec : Type
    printSchemeRepr : (a : Type) -> (x : a) -> IO Unspec = (\a : Type. (\x : a. 
      let foreign nativePrint : (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure Unspec (\delayToken : Unit. nativePrint a x)))
    natToInt : (_x0 : Nat) -> Int 
      [natToInt] Z = intZ
      n : Nat
        [natToInt] (S n) = intS (natToInt n)
    foreign intToNat : (x :R: Int) -> Nat
    printNat : (x : Nat) -> IO Unspec = (\x : Nat. printSchemeRepr Int (natToInt x))
    main : Unspec = unsafePerformIO Unspec (ioBind Nat Unspec (ioReturn Nat 4) (\v : Nat. ioBind Unspec Unspec (printNat v) (\_0 : Unspec. printSchemeRepr Nat (intToNat (intS (intS (intS intZ)))))))
  in main

### Evarified ###

  let
    postulate Nat :1: Type
    postulate Z :2: Nat
    postulate S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        [plus] -9- Z -8- n = n
      m :10: Nat n :11: Nat
        [plus] -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    postulate Bool :18: Type
    postulate True :19: Bool
    postulate False :20: Bool
    not :21: (_x2 :22: Bool) -> Bool 
      [not] -23- True = False
      [not] -24- False = True
    postulate Unit :25: Type
    postulate MkUnit :26: Unit
    postulate Pair :27: (_x3 :28: Type) -> (_x4 :29: Type) -> Type
    postulate MkPair :30: (a :31: Type) -> (b :32: Type) -> (_x5 :33: a) -> (_x6 :34: b) -> Pair -36- a -35- b
    fst :37: (a :38: Type) -> (b :39: Type) -> (_x7 :40: Pair -42- a -41- b) -> a 
      a :43: Type b :44: Type x :45: a y :46: b
        [fst] -49- a -48- b -47- ([MkPair] -53- [a] -52- [b] -51- x -50- y) = x
    snd :54: (a :55: Type) -> (b :56: Type) -> (_x8 :57: Pair -59- a -58- b) -> b 
      a :60: Type b :61: Type x :62: a y :63: b
        [snd] -66- a -65- b -64- ([MkPair] -70- [a] -69- [b] -68- x -67- y) = y
    postulate Either :71: (_x9 :72: Type) -> (_x10 :73: Type) -> Type
    postulate Left :74: (a :75: Type) -> (b :76: Type) -> (_x11 :77: a) -> Either -79- a -78- b
    postulate Right :80: (a :81: Type) -> (b :82: Type) -> (_x12 :83: b) -> Either -85- a -84- b
    id :86: (a :87: Type) -> (x :88: a) -> a = (\a :89: Type. (\x :90: a. x))
    postulate State :91: (_x0 :92: Type) -> (_x1 :93: Type) -> Type
    postulate MkSt :94: (st :95: Type) -> (a :96: Type) -> (run :97: (_x2 :98: st) -> Pair -100- st -99- a) -> State -102- st -101- a
    runState :103: (st :104: Type) -> (a :105: Type) -> (_x3 :106: State -108- st -107- a) -> (_x4 :109: st) -> Pair -111- st -110- a 
      st :112: Type a :113: Type run :114: (_x5 :115: st) -> Pair -117- st -116- a
        [runState] -120- st -119- a -118- ([MkSt] -123- [st] -122- [a] -121- run) = run
    execState :124: (st :125: Type) -> (a :126: Type) -> (x :127: State -129- st -128- a) -> (s :130: st) -> a = (\st :131: Type. (\a :132: Type. (\x :133: State -135- st -134- a. (\s :136: st. snd -139- st -138- a -137- (runState -143- st -142- a -141- x -140- s)))))
    stReturn :144: (st :145: Type) -> (a :146: Type) -> (x :147: a) -> State -149- st -148- a = (\st :150: Type. (\a :151: Type. (\x :152: a. MkSt -155- st -154- a -153- (\s :156: st. MkPair -160- st -159- a -158- s -157- x))))
    stBind :161: (st :162: Type) -> (a :163: Type) -> (b :164: Type) -> (x :165: State -167- st -166- a) -> (y :168: (z :169: a) -> State -171- st -170- b) -> State -173- st -172- b 
      st :174: Type a :175: Type b :176: Type f :177: (_x6 :178: st) -> Pair -180- st -179- a g :181: (_x7 :182: a) -> State -184- st -183- b
        [stBind] -189- st -188- a -187- b -186- ([MkSt] -192- [st] -191- [a] -190- f) -185- g = 
          let
            stBind3 :193: (st :194: Type) -> (b :195: Type) -> (_x8 :196: st) -> (_x9 :197: State -199- st -198- b) -> Pair -201- st -200- b 
              st :202: Type b :203: Type s :204: st f :205: (_x10 :206: st) -> Pair -208- st -207- b
                [stBind3] -212- st -211- b -210- s -209- ([MkSt] -215- [st] -214- [b] -213- f) = f -216- s
            stBind2 :217: (st :218: Type) -> (a :219: Type) -> (b :220: Type) -> (g :221: (_x11 :222: a) -> State -224- st -223- b) -> (r :225: Pair -227- st -226- a) -> Pair -229- st -228- b 
              st :230: Type a :231: Type b :232: Type g :233: (_x12 :234: a) -> State -236- st -235- b x :237: a s :238: st
                [stBind2] -243- st -242- a -241- b -240- g -239- ([MkPair] -247- [st] -246- [a] -245- s -244- x) = stBind3 -251- st -250- b -249- s -248- (g -252- x)
          in MkSt -255- st -254- b -253- (\s :256: st. stBind2 -261- st -260- a -259- b -258- g -257- (f -262- s))
    postulate RealWorld :263: Type
    IO :264: (_x0 :265: Type) -> Type = State -266- RealWorld
    ioReturn :267: (a :268: Type) -> (x :269: a) -> IO -270- a = (\a :271: Type. (\x :272: a. stReturn -275- RealWorld -274- a -273- x))
    ioBind :276: (a :277: Type) -> (b :278: Type) -> (x :279: IO -280- a) -> (y :281: (_x1 :282: a) -> IO -283- b) -> IO -284- b = (\a :285: Type. (\b :286: Type. (\x :287: IO -288- a. (\y :289: (_x1 :290: a) -> IO -291- b. stBind -296- RealWorld -295- a -294- b -293- x -292- y))))
    ioWrapImpure :297: (a :298: Type) -> (impureF :299: (delayToken :R: Unit) -> a) -> IO -300- a = (\a :301: Type. (\impureF :302: (delayToken :R: Unit) -> a. MkSt -305- RealWorld -304- a -303- (\w :R: RealWorld. MkPair -309- RealWorld -308- a -307- w -306- (impureF -310- MkUnit))))
    unsafePerformIO :311: (a :312: Type) -> (x :313: IO -314- a) -> a = (\a :315: Type. (\x :316: IO -317- a. 
      let postulate TheWorld :318: RealWorld
      in execState -322- RealWorld -321- a -320- x -319- TheWorld))
    postulate Int :323: Type
    foreign intS :324: (x :R: Int) -> Int
    foreign intZ :325: Int
    postulate Unspec :326: Type
    printSchemeRepr :327: (a :328: Type) -> (x :329: a) -> IO -330- Unspec = (\a :331: Type. (\x :332: a. 
      let foreign nativePrint :333: (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure -335- Unspec -334- (\delayToken :336: Unit. nativePrint -338- a -337- x)))
    natToInt :339: (_x0 :340: Nat) -> Int 
      [natToInt] -341- Z = intZ
      n :342: Nat
        [natToInt] -343- (S -344- n) = intS -345- (natToInt -346- n)
    foreign intToNat :347: (x :R: Int) -> Nat
    printNat :348: (x :349: Nat) -> IO -350- Unspec = (\x :351: Nat. printSchemeRepr -353- Int -352- (natToInt -354- x))
    main :355: Unspec = unsafePerformIO -357- Unspec -356- (ioBind -361- Nat -360- Unspec -359- (ioReturn -363- Nat -362- 4) -358- (\v :368: Nat. ioBind -372- Unspec -371- Unspec -370- (printNat -373- v) -369- (\_0 :374: Unspec. printSchemeRepr -376- Nat -375- (intToNat -377- (intS -378- (intS -379- (intS -380- intZ)))))))
  in main

### Constraints ###

[] -> [2,3,26,30,33,34,54,57,63,64,67,68,94,97,98,103,106,109,114,115,118,121,124,127,130,133,136,137,140,141,144,147,152,153,156,157,158,161,165,168,169,177,178,181,182,185,186,190,193,196,197,204,205,206,209,210,213,216,217,221,222,225,233,234,237,238,239,240,244,245,248,249,252,253,256,257,258,262,267,269,272,273,276,279,281,282,287,289,290,292,293,297,299,302,303,306,307,310,311,313,316,318,319,320,324,325,327,329,332,333,334,336,337,339,340,341,342,343,344,345,346,347,348,349,351,352,354,356,358,359,362,364,365,366,367,368,369,370,373,374,375,377,378,379,380,R]
[31] -> [70,150,160,247,263,309]
[32] -> [69,151,159,246,301,308]
[35] -> [58,99,226]
[36] -> [59,100,227]
[55] -> [66,131,139]
[56] -> [65,132,138]
[58] -> [35,110]
[59] -> [36,111]
[60] -> [66]
[61] -> [65]
[65] -> [56]
[66] -> [55]
[69] -> [32,61]
[70] -> [31,60]
[95] -> [123,150,155,174,192,215,255,263,305]
[96] -> [122,151,154,176,191,214,254,301,304]
[99] -> [35,116,179,207,228]
[100] -> [36,117,180,208,229]
[101] -> [107,148,166,172,198,300]
[102] -> [108,149,167,173,199,266]
[104] -> [120,131,143]
[105] -> [119,132,142]
[107] -> [101,134]
[108] -> [102,135]
[110] -> [58,116]
[111] -> [59,117]
[112] -> [120]
[113] -> [119]
[116] -> [99,110]
[117] -> [100,111]
[119] -> [105]
[120] -> [104]
[122] -> [96,113]
[123] -> [95,112]
[125] -> [131,263,322]
[126] -> [132,315,321]
[128] -> [134,317]
[129] -> [135,266]
[131] -> [125]
[132] -> [126]
[134] -> [107,128]
[135] -> [108,129]
[138] -> [56]
[139] -> [55]
[142] -> [105]
[143] -> [104]
[145] -> [150,263,275]
[146] -> [151,271,274]
[148] -> [101,270]
[149] -> [102,266]
[150] -> [145]
[151] -> [146]
[154] -> [96]
[155] -> [95]
[159] -> [32]
[160] -> [31]
[162] -> [189,263,296]
[163] -> [188,285,295]
[164] -> [187,286,294]
[166] -> [101,288]
[167] -> [102,266]
[170] -> [183,291]
[171] -> [184,266]
[172] -> [101,284]
[173] -> [102,266]
[174] -> [189]
[175] -> [188]
[176] -> [187]
[179] -> [99,226]
[180] -> [100,227]
[183] -> [170,223]
[184] -> [171,224]
[187] -> [164]
[188] -> [163]
[189] -> [162]
[191] -> [96,175]
[192] -> [95,174]
[194] -> [212,230,251]
[195] -> [211,232,250]
[198] -> [101,235]
[199] -> [102,236]
[200] -> [207,228]
[201] -> [208,229]
[202] -> [212]
[203] -> [211]
[207] -> [99,200]
[208] -> [100,201]
[211] -> [195]
[212] -> [194]
[214] -> [96,203]
[215] -> [95,202]
[218] -> [174,243,261]
[219] -> [175,242,260]
[220] -> [176,241,259]
[223] -> [183,235]
[224] -> [184,236]
[226] -> [35,179]
[227] -> [36,180]
[228] -> [99,200]
[229] -> [100,201]
[230] -> [243]
[231] -> [242]
[232] -> [241]
[235] -> [198,223]
[236] -> [199,224]
[241] -> [220]
[242] -> [219]
[243] -> [218]
[246] -> [32,231]
[247] -> [31,230]
[250] -> [195]
[251] -> [194]
[254] -> [96]
[255] -> [95]
[259] -> [220]
[260] -> [219]
[261] -> [218]
[266] -> [102,129,149,167,171,173,266]
[268] -> [1,271,363]
[270] -> [148,280]
[271] -> [268]
[274] -> [146]
[275] -> [145]
[277] -> [1,285,326,361,372]
[278] -> [286,326,360,371]
[280] -> [270,288,350]
[283] -> [284,291,330]
[284] -> [172,283,314]
[285] -> [277]
[286] -> [278]
[288] -> [166,280]
[291] -> [170,283]
[294] -> [164]
[295] -> [163]
[296] -> [162]
[298] -> [301,326,335]
[300] -> [101,330]
[301] -> [298]
[304] -> [96]
[305] -> [95]
[308] -> [32]
[309] -> [31]
[312] -> [315,326,357]
[314] -> [284,317]
[315] -> [312]
[317] -> [128,314]
[321] -> [126]
[322] -> [125]
[328] -> [1,323,331,353,376]
[330] -> [283,300,350]
[331] -> [328]
[335] -> [298]
[338] -> [E]
[350] -> [280,330]
[353] -> [328]
[357] -> [312]
[360] -> [278]
[361] -> [277]
[363] -> [268]
[371] -> [278]
[372] -> [277]
[376] -> [328]
[E] -> [331,338]
[R] -> [355]

### Solution ###

[2,3,26,30,33,34,54,57,63,64,67,68,94,97,98,103,106,109,114,115,118,121,124,127,130,133,136,137,140,141,144,147,152,153,156,157,158,161,165,168,169,177,178,181,182,185,186,190,193,196,197,204,205,206,209,210,213,216,217,221,222,225,233,234,237,238,239,240,244,245,248,249,252,253,256,257,258,262,267,269,272,273,276,279,281,282,287,289,290,292,293,297,299,302,303,306,307,310,311,313,316,318,319,320,324,325,327,329,332,333,334,336,337,339,340,341,342,343,344,345,346,347,348,349,351,352,354,355,356,358,359,362,364,365,366,367,368,369,370,373,374,375,377,378,379,380,R]

### Annotated ###

  let
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    postulate Unit :E: Type
    postulate MkUnit :R: Unit
    postulate Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    postulate MkPair :R: (a :E: Type) -> (b :E: Type) -> (_x5 :R: a) -> (_x6 :R: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :R: (a :E: Type) -> (b :E: Type) -> (_x8 :R: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :R: b
        [snd] -E- a -E- b -R- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = y
    postulate Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    postulate Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    postulate Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    postulate State :E: (_x0 :E: Type) -> (_x1 :E: Type) -> Type
    postulate MkSt :R: (st :E: Type) -> (a :E: Type) -> (run :R: (_x2 :R: st) -> Pair -E- st -E- a) -> State -E- st -E- a
    runState :R: (st :E: Type) -> (a :E: Type) -> (_x3 :R: State -E- st -E- a) -> (_x4 :R: st) -> Pair -E- st -E- a 
      st :E: Type a :E: Type run :R: (_x5 :R: st) -> Pair -E- st -E- a
        [runState] -E- st -E- a -R- ([MkSt] -E- [st] -E- [a] -R- run) = run
    execState :R: (st :E: Type) -> (a :E: Type) -> (x :R: State -E- st -E- a) -> (s :R: st) -> a = (\st :E: Type. (\a :E: Type. (\x :R: State -E- st -E- a. (\s :R: st. snd -E- st -E- a -R- (runState -E- st -E- a -R- x -R- s)))))
    stReturn :R: (st :E: Type) -> (a :E: Type) -> (x :R: a) -> State -E- st -E- a = (\st :E: Type. (\a :E: Type. (\x :R: a. MkSt -E- st -E- a -R- (\s :R: st. MkPair -E- st -E- a -R- s -R- x))))
    stBind :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (x :R: State -E- st -E- a) -> (y :R: (z :R: a) -> State -E- st -E- b) -> State -E- st -E- b 
      st :E: Type a :E: Type b :E: Type f :R: (_x6 :R: st) -> Pair -E- st -E- a g :R: (_x7 :R: a) -> State -E- st -E- b
        [stBind] -E- st -E- a -E- b -R- ([MkSt] -E- [st] -E- [a] -R- f) -R- g = 
          let
            stBind3 :R: (st :E: Type) -> (b :E: Type) -> (_x8 :R: st) -> (_x9 :R: State -E- st -E- b) -> Pair -E- st -E- b 
              st :E: Type b :E: Type s :R: st f :R: (_x10 :R: st) -> Pair -E- st -E- b
                [stBind3] -E- st -E- b -R- s -R- ([MkSt] -E- [st] -E- [b] -R- f) = f -R- s
            stBind2 :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (g :R: (_x11 :R: a) -> State -E- st -E- b) -> (r :R: Pair -E- st -E- a) -> Pair -E- st -E- b 
              st :E: Type a :E: Type b :E: Type g :R: (_x12 :R: a) -> State -E- st -E- b x :R: a s :R: st
                [stBind2] -E- st -E- a -E- b -R- g -R- ([MkPair] -E- [st] -E- [a] -R- s -R- x) = stBind3 -E- st -E- b -R- s -R- (g -R- x)
          in MkSt -E- st -E- b -R- (\s :R: st. stBind2 -E- st -E- a -E- b -R- g -R- (f -R- s))
    postulate RealWorld :E: Type
    IO :E: (_x0 :E: Type) -> Type = State -E- RealWorld
    ioReturn :R: (a :E: Type) -> (x :R: a) -> IO -E- a = (\a :E: Type. (\x :R: a. stReturn -E- RealWorld -E- a -R- x))
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (_x1 :R: a) -> IO -E- b) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\x :R: IO -E- a. (\y :R: (_x1 :R: a) -> IO -E- b. stBind -E- RealWorld -E- a -E- b -R- x -R- y))))
    ioWrapImpure :R: (a :E: Type) -> (impureF :R: (delayToken :R: Unit) -> a) -> IO -E- a = (\a :E: Type. (\impureF :R: (delayToken :R: Unit) -> a. MkSt -E- RealWorld -E- a -R- (\w :R: RealWorld. MkPair -E- RealWorld -E- a -R- w -R- (impureF -R- MkUnit))))
    unsafePerformIO :R: (a :E: Type) -> (x :R: IO -E- a) -> a = (\a :E: Type. (\x :R: IO -E- a. 
      let postulate TheWorld :R: RealWorld
      in execState -E- RealWorld -E- a -R- x -R- TheWorld))
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure -E- Unspec -R- (\delayToken :R: Unit. nativePrint -E- a -R- x)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    main :R: Unspec = unsafePerformIO -E- Unspec -R- (ioBind -E- Nat -E- Unspec -R- (ioReturn -E- Nat -R- 4) -R- (\v :R: Nat. ioBind -E- Unspec -E- Unspec -R- (printNat -R- v) -R- (\_0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ)))))))
  in main

### Specialised ###

  let
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    postulate Unit :E: Type
    postulate MkUnit :R: Unit
    postulate Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    postulate MkPair :R: (a :E: Type) -> (b :E: Type) -> (_x5 :R: a) -> (_x6 :R: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :R: (a :E: Type) -> (b :E: Type) -> (_x8 :R: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :R: b
        [snd] -E- a -E- b -R- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = y
    postulate Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    postulate Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    postulate Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    postulate State :E: (_x0 :E: Type) -> (_x1 :E: Type) -> Type
    postulate MkSt :R: (st :E: Type) -> (a :E: Type) -> (run :R: (_x2 :R: st) -> Pair -E- st -E- a) -> State -E- st -E- a
    runState :R: (st :E: Type) -> (a :E: Type) -> (_x3 :R: State -E- st -E- a) -> (_x4 :R: st) -> Pair -E- st -E- a 
      st :E: Type a :E: Type run :R: (_x5 :R: st) -> Pair -E- st -E- a
        [runState] -E- st -E- a -R- ([MkSt] -E- [st] -E- [a] -R- run) = run
    execState :R: (st :E: Type) -> (a :E: Type) -> (x :R: State -E- st -E- a) -> (s :R: st) -> a = (\st :E: Type. (\a :E: Type. (\x :R: State -E- st -E- a. (\s :R: st. snd -E- st -E- a -R- (runState -E- st -E- a -R- x -R- s)))))
    stReturn :R: (st :E: Type) -> (a :E: Type) -> (x :R: a) -> State -E- st -E- a = (\st :E: Type. (\a :E: Type. (\x :R: a. MkSt -E- st -E- a -R- (\s :R: st. MkPair -E- st -E- a -R- s -R- x))))
    stBind :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (x :R: State -E- st -E- a) -> (y :R: (z :R: a) -> State -E- st -E- b) -> State -E- st -E- b 
      st :E: Type a :E: Type b :E: Type f :R: (_x6 :R: st) -> Pair -E- st -E- a g :R: (_x7 :R: a) -> State -E- st -E- b
        [stBind] -E- st -E- a -E- b -R- ([MkSt] -E- [st] -E- [a] -R- f) -R- g = 
          let
            stBind3 :R: (st :E: Type) -> (b :E: Type) -> (_x8 :R: st) -> (_x9 :R: State -E- st -E- b) -> Pair -E- st -E- b 
              st :E: Type b :E: Type s :R: st f :R: (_x10 :R: st) -> Pair -E- st -E- b
                [stBind3] -E- st -E- b -R- s -R- ([MkSt] -E- [st] -E- [b] -R- f) = f -R- s
            stBind2 :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (g :R: (_x11 :R: a) -> State -E- st -E- b) -> (r :R: Pair -E- st -E- a) -> Pair -E- st -E- b 
              st :E: Type a :E: Type b :E: Type g :R: (_x12 :R: a) -> State -E- st -E- b x :R: a s :R: st
                [stBind2] -E- st -E- a -E- b -R- g -R- ([MkPair] -E- [st] -E- [a] -R- s -R- x) = stBind3 -E- st -E- b -R- s -R- (g -R- x)
          in MkSt -E- st -E- b -R- (\s :R: st. stBind2 -E- st -E- a -E- b -R- g -R- (f -R- s))
    postulate RealWorld :E: Type
    IO :E: (_x0 :E: Type) -> Type = State -E- RealWorld
    ioReturn :R: (a :E: Type) -> (x :R: a) -> IO -E- a = (\a :E: Type. (\x :R: a. stReturn -E- RealWorld -E- a -R- x))
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (_x1 :R: a) -> IO -E- b) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\x :R: IO -E- a. (\y :R: (_x1 :R: a) -> IO -E- b. stBind -E- RealWorld -E- a -E- b -R- x -R- y))))
    ioWrapImpure :R: (a :E: Type) -> (impureF :R: (delayToken :R: Unit) -> a) -> IO -E- a = (\a :E: Type. (\impureF :R: (delayToken :R: Unit) -> a. MkSt -E- RealWorld -E- a -R- (\w :R: RealWorld. MkPair -E- RealWorld -E- a -R- w -R- (impureF -R- MkUnit))))
    unsafePerformIO :R: (a :E: Type) -> (x :R: IO -E- a) -> a = (\a :E: Type. (\x :R: IO -E- a. 
      let postulate TheWorld :R: RealWorld
      in execState -E- RealWorld -E- a -R- x -R- TheWorld))
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure -E- Unspec -R- (\delayToken :R: Unit. nativePrint -E- a -R- x)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    main :R: Unspec = unsafePerformIO -E- Unspec -R- (ioBind -E- Nat -E- Unspec -R- (ioReturn -E- Nat -R- 4) -R- (\v :R: Nat. ioBind -E- Unspec -E- Unspec -R- (printNat -R- v) -R- (\_0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ)))))))
  in main

### Final annotation ###

  let
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    postulate Unit :E: Type
    postulate MkUnit :R: Unit
    postulate Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    postulate MkPair :R: (a :E: Type) -> (b :E: Type) -> (_x5 :R: a) -> (_x6 :R: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :R: (a :E: Type) -> (b :E: Type) -> (_x8 :R: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :R: b
        [snd] -E- a -E- b -R- ([MkPair] -E- [a] -E- [b] -R- x -R- y) = y
    postulate Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    postulate Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    postulate Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    postulate State :E: (_x0 :E: Type) -> (_x1 :E: Type) -> Type
    postulate MkSt :R: (st :E: Type) -> (a :E: Type) -> (run :R: (_x2 :R: st) -> Pair -E- st -E- a) -> State -E- st -E- a
    runState :R: (st :E: Type) -> (a :E: Type) -> (_x3 :R: State -E- st -E- a) -> (_x4 :R: st) -> Pair -E- st -E- a 
      st :E: Type a :E: Type run :R: (_x5 :R: st) -> Pair -E- st -E- a
        [runState] -E- st -E- a -R- ([MkSt] -E- [st] -E- [a] -R- run) = run
    execState :R: (st :E: Type) -> (a :E: Type) -> (x :R: State -E- st -E- a) -> (s :R: st) -> a = (\st :E: Type. (\a :E: Type. (\x :R: State -E- st -E- a. (\s :R: st. snd -E- st -E- a -R- (runState -E- st -E- a -R- x -R- s)))))
    stReturn :R: (st :E: Type) -> (a :E: Type) -> (x :R: a) -> State -E- st -E- a = (\st :E: Type. (\a :E: Type. (\x :R: a. MkSt -E- st -E- a -R- (\s :R: st. MkPair -E- st -E- a -R- s -R- x))))
    stBind :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (x :R: State -E- st -E- a) -> (y :R: (z :R: a) -> State -E- st -E- b) -> State -E- st -E- b 
      st :E: Type a :E: Type b :E: Type f :R: (_x6 :R: st) -> Pair -E- st -E- a g :R: (_x7 :R: a) -> State -E- st -E- b
        [stBind] -E- st -E- a -E- b -R- ([MkSt] -E- [st] -E- [a] -R- f) -R- g = 
          let
            stBind3 :R: (st :E: Type) -> (b :E: Type) -> (_x8 :R: st) -> (_x9 :R: State -E- st -E- b) -> Pair -E- st -E- b 
              st :E: Type b :E: Type s :R: st f :R: (_x10 :R: st) -> Pair -E- st -E- b
                [stBind3] -E- st -E- b -R- s -R- ([MkSt] -E- [st] -E- [b] -R- f) = f -R- s
            stBind2 :R: (st :E: Type) -> (a :E: Type) -> (b :E: Type) -> (g :R: (_x11 :R: a) -> State -E- st -E- b) -> (r :R: Pair -E- st -E- a) -> Pair -E- st -E- b 
              st :E: Type a :E: Type b :E: Type g :R: (_x12 :R: a) -> State -E- st -E- b x :R: a s :R: st
                [stBind2] -E- st -E- a -E- b -R- g -R- ([MkPair] -E- [st] -E- [a] -R- s -R- x) = stBind3 -E- st -E- b -R- s -R- (g -R- x)
          in MkSt -E- st -E- b -R- (\s :R: st. stBind2 -E- st -E- a -E- b -R- g -R- (f -R- s))
    postulate RealWorld :E: Type
    IO :E: (_x0 :E: Type) -> Type = State -E- RealWorld
    ioReturn :R: (a :E: Type) -> (x :R: a) -> IO -E- a = (\a :E: Type. (\x :R: a. stReturn -E- RealWorld -E- a -R- x))
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (_x1 :R: a) -> IO -E- b) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\x :R: IO -E- a. (\y :R: (_x1 :R: a) -> IO -E- b. stBind -E- RealWorld -E- a -E- b -R- x -R- y))))
    ioWrapImpure :R: (a :E: Type) -> (impureF :R: (delayToken :R: Unit) -> a) -> IO -E- a = (\a :E: Type. (\impureF :R: (delayToken :R: Unit) -> a. MkSt -E- RealWorld -E- a -R- (\w :R: RealWorld. MkPair -E- RealWorld -E- a -R- w -R- (impureF -R- MkUnit))))
    unsafePerformIO :R: (a :E: Type) -> (x :R: IO -E- a) -> a = (\a :E: Type. (\x :R: IO -E- a. 
      let postulate TheWorld :R: RealWorld
      in execState -E- RealWorld -E- a -R- x -R- TheWorld))
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> Unspec
      in ioWrapImpure -E- Unspec -R- (\delayToken :R: Unit. nativePrint -E- a -R- x)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    main :R: Unspec = unsafePerformIO -E- Unspec -R- (ioBind -E- Nat -E- Unspec -R- (ioReturn -E- Nat -R- 4) -R- (\v :R: Nat. ioBind -E- Unspec -E- Unspec -R- (printNat -R- v) -R- (\_0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ)))))))
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Z : Nat
    postulate S : (x) -> Nat
    postulate MkUnit : Unit
    postulate MkPair : (_x5) -> (_x6) -> Pair
    snd 
      [_] ([_] _ y) = y
    postulate MkSt : (run) -> State
    runState 
      [_] ([_] run) = run
    execState = (\x. (\s. snd (runState x s)))
    stReturn = (\x. MkSt (\s. MkPair s x))
    stBind 
      [_] ([_] f) g = 
        let
          stBind3 
            [_] s ([_] f) = f s
          stBind2 
            [_] g ([_] s x) = stBind3 s (g x)
        in MkSt (\s. stBind2 g (f s))
    ioReturn = (\x. stReturn x)
    ioBind = (\x. (\y. stBind x y))
    ioWrapImpure = (\impureF. MkSt (\w. MkPair w (impureF MkUnit)))
    unsafePerformIO = (\x. 
      let postulate TheWorld : RealWorld
      in execState x TheWorld)
    foreign intS
    foreign intZ
    printSchemeRepr = (\x. 
      let foreign nativePrint
      in ioWrapImpure (\delayToken. nativePrint x))
    natToInt 
      [_] Z = intZ
      [_] (S n) = intS (natToInt n)
    foreign intToNat
    printNat = (\x. printSchemeRepr (natToInt x))
    main = unsafePerformIO (ioBind (ioReturn 4) (\v. ioBind (printNat v) (\_0. printSchemeRepr (intToNat (intS (intS (intS intZ)))))))
  in main

### Normal forms ###

unerased:
  
  let
    postulate Nat : Type
    postulate Pair : (_x3 : Type) -> (_x4 : Type) -> Type
    postulate MkPair : (a : Type) -> (b : Type) -> (_x5 : a) -> (_x6 : b) -> Pair a b
    snd : (a : Type) -> (b : Type) -> (_x8 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        [snd] a b ([MkPair] [a] [b] x y) = y
    postulate State : (_x0 : Type) -> (_x1 : Type) -> Type
    postulate MkSt : (st : Type) -> (a : Type) -> (run : (_x2 : st) -> Pair st a) -> State st a
    runState : (st : Type) -> (a : Type) -> (_x3 : State st a) -> (_x4 : st) -> Pair st a 
      st : Type a : Type run : (_x5 : st) -> Pair st a
        [runState] st a ([MkSt] [st] [a] run) = run
    stBind : (st : Type) -> (a : Type) -> (b : Type) -> (x : State st a) -> (y : (z : a) -> State st b) -> State st b 
      st : Type a : Type b : Type f : (_x6 : st) -> Pair st a g : (_x7 : a) -> State st b
        [stBind] st a b ([MkSt] [st] [a] f) g = 
          let
            stBind3 : (st : Type) -> (b : Type) -> (_x8 : st) -> (_x9 : State st b) -> Pair st b 
              st : Type b : Type s : st f : (_x10 : st) -> Pair st b
                [stBind3] st b s ([MkSt] [st] [b] f) = f s
            stBind2 : (st : Type) -> (a : Type) -> (b : Type) -> (g : (_x11 : a) -> State st b) -> (r : Pair st a) -> Pair st b 
              st : Type a : Type b : Type g : (_x12 : a) -> State st b x : a s : st
                [stBind2] st a b g ([MkPair] [st] [a] s x) = stBind3 st b s (g x)
          in MkSt st b (\s : st. stBind2 st a b g (f s))
    postulate RealWorld : Type
    postulate Int : Type
    foreign intS : (x :R: Int) -> Int
    foreign intZ : Int
    postulate Unspec : Type
    foreign intToNat : (x :R: Int) -> Nat
  in 
    let postulate TheWorld : RealWorld
    in snd RealWorld Unspec (runState RealWorld Unspec 
      let stBind3 : (st : Type) -> (b : Type) -> (_x8 : st) -> (_x9 : State st b) -> Pair st b 
        st : Type b : Type s : st f : (_x10 : st) -> Pair st b
          [stBind3] st b s ([MkSt] [st] [b] f) = f s
      in MkSt RealWorld Unspec (\s : RealWorld. stBind3 RealWorld Unspec s (stBind RealWorld Unspec Unspec 
        let foreign nativePrint : (a :E: Type) -> (x :R: a) -> Unspec
        in MkSt RealWorld Unspec (\w :R: RealWorld. MkPair RealWorld Unspec w (nativePrint Int (intS (intS (intS (intS intZ)))))) (\_0 : Unspec. 
        let foreign nativePrint : (a :E: Type) -> (x :R: a) -> Unspec
        in MkSt RealWorld Unspec (\w :R: RealWorld. MkPair RealWorld Unspec w (nativePrint Nat (intToNat (intS (intS (intS intZ))))))))) TheWorld)

erased:
  
  let
    postulate MkPair : (_x5) -> (_x6) -> Pair
    snd 
      [_] ([_] _ y) = y
    postulate MkSt : (run) -> State
    runState 
      [_] ([_] run) = run
    stBind 
      [_] ([_] f) g = 
        let
          stBind3 
            [_] s ([_] f) = f s
          stBind2 
            [_] g ([_] s x) = stBind3 s (g x)
        in MkSt (\s. stBind2 g (f s))
    foreign intS
    foreign intZ
    foreign intToNat
  in 
    let postulate TheWorld : RealWorld
    in snd (runState 
      let stBind3 
        [_] s ([_] f) = f s
      in MkSt (\s. stBind3 s (stBind 
        let foreign nativePrint
        in MkSt (\w. MkPair w (nativePrint (intS (intS (intS (intS intZ)))))) (\_0. 
        let foreign nativePrint
        in MkSt (\w. MkPair w (nativePrint (intToNat (intS (intS (intS intZ))))))))) TheWorld)

