-- vim: ft=idris

### Desugared ###

  let
    postulate RealWorld : Type
    postulate IOResult : (_x0 : Type) -> Type
    postulate MkIOR : (a : Type) -> (x : a) -> (w : RealWorld) -> IOResult a
    postulate IO : (_x1 : Type) -> Type
    postulate MkIO : (a : Type) -> (f : (w : RealWorld) -> IOResult a) -> IO a
    ioReturn : (a : Type) -> (x : a) -> IO a 
      a : Type x : a
        [ioReturn] a x = MkIO a (\w : RealWorld. MkIOR a x w)
    ioBind : (a : Type) -> (b : Type) -> (x : IO a) -> (y : (z :R: a) -> IO b) -> IO b 
      a : Type b : Type f : (_x2 : RealWorld) -> IOResult a g : (_x3 : a) -> IO b
        [ioBind] a b ([MkIO] [a] f) g = 
          let
            ioBind3 : (b : Type) -> (_x4 : RealWorld) -> (_x5 : IO b) -> IOResult b 
              b : Type w : RealWorld f : (_x6 : RealWorld) -> IOResult b
                [ioBind3] b w ([MkIO] [b] f) = f w
            ioBind2 : (a : Type) -> (b : Type) -> (g : (x : a) -> IO b) -> (r : IOResult a) -> IOResult b 
              a : Type b : Type g : (_x7 : a) -> IO b x : a w : RealWorld
                [ioBind2] a b g ([MkIOR] [a] x w) = ioBind3 b w (g x)
          in MkIO b (\w : RealWorld. ioBind2 a b g (f w))
    ioIgnore : (a : Type) -> (b : Type) -> (r : b) -> (x : IO a) -> IO b = (\a : Type. (\b : Type. (\r : b. (\x : IO a. ioBind a b x (\v : a. ioReturn b r)))))
    postulate Nat : Type
    postulate Z : Nat
    postulate S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    postulate Bool : Type
    postulate T : Bool
    postulate F : Bool
    not : (_x2 : Bool) -> Bool 
      [not] T = F
      [not] F = T
    postulate Unit : Type
    postulate MkUnit : Unit
    postulate Int : Type
    foreign intS : (x :R: Int) -> Int
    foreign intZ : Int
    postulate Unspec : Type
    printSchemeRepr : (a : Type) -> (x : a) -> IO Unspec = (\a : Type. (\x : a. 
      let foreign nativePrint : (a :E: Type) -> (x :R: a) -> Unspec
      in MkIO Unspec (\w :R: RealWorld. MkIOR Unspec (nativePrint a x) w)))
    natToInt : (_x0 : Nat) -> Int 
      [natToInt] Z = intZ
      n : Nat
        [natToInt] (S n) = intS (natToInt n)
    foreign intToNat : (x :R: Int) -> Nat
    printNat : (x : Nat) -> IO Unspec = (\x : Nat. printSchemeRepr Int (natToInt x))
    runIO : (a : Type) -> (_x1 : IO a) -> a 
      a : Type f : (_x2 : RealWorld) -> IOResult a
        [runIO] a ([MkIO] [a] f) = 
          let
            runIO2 : (a : Type) -> (_x3 : IOResult a) -> a 
              a : Type x : a w : RealWorld
                [runIO2] a ([MkIOR] [a] x w) = x
            postulate TheWorld : RealWorld
          in runIO2 a (f TheWorld)
    main : Unspec = runIO Unspec (ioBind Unspec Unspec (printNat 4) (\_0 : Unspec. printSchemeRepr Nat (intToNat (intS (intS (intS intZ))))))
  in main

### Evarified ###

  let
    postulate RealWorld :1: Type
    postulate IOResult :2: (_x0 :3: Type) -> Type
    postulate MkIOR :4: (a :5: Type) -> (x :6: a) -> (w :7: RealWorld) -> IOResult -8- a
    postulate IO :9: (_x1 :10: Type) -> Type
    postulate MkIO :11: (a :12: Type) -> (f :13: (w :14: RealWorld) -> IOResult -15- a) -> IO -16- a
    ioReturn :17: (a :18: Type) -> (x :19: a) -> IO -20- a 
      a :21: Type x :22: a
        [ioReturn] -24- a -23- x = MkIO -26- a -25- (\w :27: RealWorld. MkIOR -30- a -29- x -28- w)
    ioBind :31: (a :32: Type) -> (b :33: Type) -> (x :34: IO -35- a) -> (y :36: (z :R: a) -> IO -37- b) -> IO -38- b 
      a :39: Type b :40: Type f :41: (_x2 :42: RealWorld) -> IOResult -43- a g :44: (_x3 :45: a) -> IO -46- b
        [ioBind] -50- a -49- b -48- ([MkIO] -52- [a] -51- f) -47- g = 
          let
            ioBind3 :53: (b :54: Type) -> (_x4 :55: RealWorld) -> (_x5 :56: IO -57- b) -> IOResult -58- b 
              b :59: Type w :60: RealWorld f :61: (_x6 :62: RealWorld) -> IOResult -63- b
                [ioBind3] -66- b -65- w -64- ([MkIO] -68- [b] -67- f) = f -69- w
            ioBind2 :70: (a :71: Type) -> (b :72: Type) -> (g :73: (x :74: a) -> IO -75- b) -> (r :76: IOResult -77- a) -> IOResult -78- b 
              a :79: Type b :80: Type g :81: (_x7 :82: a) -> IO -83- b x :84: a w :85: RealWorld
                [ioBind2] -89- a -88- b -87- g -86- ([MkIOR] -92- [a] -91- x -90- w) = ioBind3 -95- b -94- w -93- (g -96- x)
          in MkIO -98- b -97- (\w :99: RealWorld. ioBind2 -103- a -102- b -101- g -100- (f -104- w))
    ioIgnore :105: (a :106: Type) -> (b :107: Type) -> (r :108: b) -> (x :109: IO -110- a) -> IO -111- b = (\a :112: Type. (\b :113: Type. (\r :114: b. (\x :115: IO -116- a. ioBind -120- a -119- b -118- x -117- (\v :121: a. ioReturn -123- b -122- r)))))
    postulate Nat :124: Type
    postulate Z :125: Nat
    postulate S :126: (x :R: Nat) -> Nat
    plus :127: (_x0 :128: Nat) -> (_x1 :129: Nat) -> Nat 
      n :130: Nat
        [plus] -132- Z -131- n = n
      m :133: Nat n :134: Nat
        [plus] -136- (S -137- m) -135- n = S -138- (plus -140- m -139- n)
    postulate Bool :141: Type
    postulate T :142: Bool
    postulate F :143: Bool
    not :144: (_x2 :145: Bool) -> Bool 
      [not] -146- T = F
      [not] -147- F = T
    postulate Unit :148: Type
    postulate MkUnit :149: Unit
    postulate Int :150: Type
    foreign intS :151: (x :R: Int) -> Int
    foreign intZ :152: Int
    postulate Unspec :153: Type
    printSchemeRepr :154: (a :155: Type) -> (x :156: a) -> IO -157- Unspec = (\a :158: Type. (\x :159: a. 
      let foreign nativePrint :160: (a :E: Type) -> (x :R: a) -> Unspec
      in MkIO -162- Unspec -161- (\w :R: RealWorld. MkIOR -165- Unspec -164- (nativePrint -167- a -166- x) -163- w)))
    natToInt :168: (_x0 :169: Nat) -> Int 
      [natToInt] -170- Z = intZ
      n :171: Nat
        [natToInt] -172- (S -173- n) = intS -174- (natToInt -175- n)
    foreign intToNat :176: (x :R: Int) -> Nat
    printNat :177: (x :178: Nat) -> IO -179- Unspec = (\x :180: Nat. printSchemeRepr -182- Int -181- (natToInt -183- x))
    runIO :184: (a :185: Type) -> (_x1 :186: IO -187- a) -> a 
      a :188: Type f :189: (_x2 :190: RealWorld) -> IOResult -191- a
        [runIO] -193- a -192- ([MkIO] -195- [a] -194- f) = 
          let
            runIO2 :196: (a :197: Type) -> (_x3 :198: IOResult -199- a) -> a 
              a :200: Type x :201: a w :202: RealWorld
                [runIO2] -204- a -203- ([MkIOR] -207- [a] -206- x -205- w) = x
            postulate TheWorld :208: RealWorld
          in runIO2 -210- a -209- (f -211- TheWorld)
    main :212: Unspec = runIO -214- Unspec -213- (ioBind -218- Unspec -217- Unspec -216- (printNat -219- 4) -215- (\_0 :224: Unspec. printSchemeRepr -226- Nat -225- (intToNat -227- (intS -228- (intS -229- (intS -230- intZ))))))
  in main

### Constraints ###

[] -> [4,6,7,11,13,14,31,34,36,41,42,44,45,47,48,51,53,55,56,60,61,62,64,65,67,69,70,73,74,76,81,82,84,85,86,87,90,91,93,94,96,97,99,100,101,104,125,126,151,152,154,156,159,160,161,163,164,166,168,169,170,171,172,173,174,175,176,177,178,180,181,183,184,186,189,190,192,194,196,198,201,203,205,206,208,209,211,213,215,216,219,220,221,222,223,224,225,227,228,229,230,R]
[5] -> [92,153,165,207]
[8] -> [15,77,199]
[12] -> [40,52,68,98,153,162,195]
[15] -> [8,43,63,78,191]
[16] -> [35,38,57,157,187]
[32] -> [50,153,218]
[33] -> [49,153,217]
[35] -> [16,179]
[37] -> [46,157]
[38] -> [16,187]
[39] -> [50]
[40] -> [49]
[43] -> [15,77]
[46] -> [37,75]
[49] -> [33]
[50] -> [32]
[52] -> [12,39]
[54] -> [66,80,95]
[57] -> [16,83]
[58] -> [63,78]
[59] -> [66]
[63] -> [15,58]
[66] -> [54]
[68] -> [12,59]
[71] -> [39,89,103]
[72] -> [40,88,102]
[75] -> [46,83]
[77] -> [8,43]
[78] -> [15,58]
[79] -> [89]
[80] -> [88]
[83] -> [57,75]
[88] -> [72]
[89] -> [71]
[92] -> [5,79]
[95] -> [54]
[98] -> [12]
[102] -> [72]
[103] -> [71]
[155] -> [124,150,158,182,226]
[157] -> [16,37,179]
[158] -> [155]
[162] -> [12]
[165] -> [5]
[167] -> [E]
[179] -> [35,157]
[182] -> [155]
[185] -> [153,193,214]
[187] -> [16,38]
[188] -> [193]
[191] -> [15,199]
[193] -> [185]
[195] -> [12,188]
[197] -> [188,204,210]
[199] -> [8,191]
[200] -> [204]
[204] -> [197]
[207] -> [5,200]
[210] -> [197]
[214] -> [185]
[217] -> [33]
[218] -> [32]
[226] -> [155]
[E] -> [158,167]
[R] -> [212]

### Solution ###

[4,6,7,11,13,14,31,34,36,41,42,44,45,47,48,51,53,55,56,60,61,62,64,65,67,69,70,73,74,76,81,82,84,85,86,87,90,91,93,94,96,97,99,100,101,104,125,126,151,152,154,156,159,160,161,163,164,166,168,169,170,171,172,173,174,175,176,177,178,180,181,183,184,186,189,190,192,194,196,198,201,203,205,206,208,209,211,212,213,215,216,219,220,221,222,223,224,225,227,228,229,230,R]

### Annotated ###

  let
    postulate RealWorld :E: Type
    postulate IOResult :E: (_x0 :E: Type) -> Type
    postulate MkIOR :R: (a :E: Type) -> (x :R: a) -> (w :R: RealWorld) -> IOResult -E- a
    postulate IO :E: (_x1 :E: Type) -> Type
    postulate MkIO :R: (a :E: Type) -> (f :R: (w :R: RealWorld) -> IOResult -E- a) -> IO -E- a
    ioReturn :E: (a :E: Type) -> (x :E: a) -> IO -E- a 
      a :E: Type x :E: a
        [ioReturn] -E- a -E- x = MkIO -E- a -E- (\w :E: RealWorld. MkIOR -E- a -E- x -E- w)
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (z :R: a) -> IO -E- b) -> IO -E- b 
      a :E: Type b :E: Type f :R: (_x2 :R: RealWorld) -> IOResult -E- a g :R: (_x3 :R: a) -> IO -E- b
        [ioBind] -E- a -E- b -R- ([MkIO] -E- [a] -R- f) -R- g = 
          let
            ioBind3 :R: (b :E: Type) -> (_x4 :R: RealWorld) -> (_x5 :R: IO -E- b) -> IOResult -E- b 
              b :E: Type w :R: RealWorld f :R: (_x6 :R: RealWorld) -> IOResult -E- b
                [ioBind3] -E- b -R- w -R- ([MkIO] -E- [b] -R- f) = f -R- w
            ioBind2 :R: (a :E: Type) -> (b :E: Type) -> (g :R: (x :R: a) -> IO -E- b) -> (r :R: IOResult -E- a) -> IOResult -E- b 
              a :E: Type b :E: Type g :R: (_x7 :R: a) -> IO -E- b x :R: a w :R: RealWorld
                [ioBind2] -E- a -E- b -R- g -R- ([MkIOR] -E- [a] -R- x -R- w) = ioBind3 -E- b -R- w -R- (g -R- x)
          in MkIO -E- b -R- (\w :R: RealWorld. ioBind2 -E- a -E- b -R- g -R- (f -R- w))
    ioIgnore :E: (a :E: Type) -> (b :E: Type) -> (r :E: b) -> (x :E: IO -E- a) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\r :E: b. (\x :E: IO -E- a. ioBind -E- a -E- b -E- x -E- (\v :E: a. ioReturn -E- b -E- r)))))
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate T :E: Bool
    postulate F :E: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- T = F
      [not] -E- F = T
    postulate Unit :E: Type
    postulate MkUnit :E: Unit
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> Unspec
      in MkIO -E- Unspec -R- (\w :R: RealWorld. MkIOR -E- Unspec -R- (nativePrint -E- a -R- x) -R- w)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    runIO :R: (a :E: Type) -> (_x1 :R: IO -E- a) -> a 
      a :E: Type f :R: (_x2 :R: RealWorld) -> IOResult -E- a
        [runIO] -E- a -R- ([MkIO] -E- [a] -R- f) = 
          let
            runIO2 :R: (a :E: Type) -> (_x3 :R: IOResult -E- a) -> a 
              a :E: Type x :R: a w :E: RealWorld
                [runIO2] -E- a -R- ([MkIOR] -E- [a] -R- x -R- w) = x
            postulate TheWorld :R: RealWorld
          in runIO2 -E- a -R- (f -R- TheWorld)
    main :R: Unspec = runIO -E- Unspec -R- (ioBind -E- Unspec -E- Unspec -R- (printNat -R- 4) -R- (\_0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ))))))
  in main

### Specialised ###

  let
    postulate RealWorld :E: Type
    postulate IOResult :E: (_x0 :E: Type) -> Type
    postulate MkIOR :R: (a :E: Type) -> (x :R: a) -> (w :R: RealWorld) -> IOResult -E- a
    postulate IO :E: (_x1 :E: Type) -> Type
    postulate MkIO :R: (a :E: Type) -> (f :R: (w :R: RealWorld) -> IOResult -E- a) -> IO -E- a
    ioReturn :E: (a :E: Type) -> (x :E: a) -> IO -E- a 
      a :E: Type x :E: a
        [ioReturn] -E- a -E- x = MkIO -E- a -E- (\w :E: RealWorld. MkIOR -E- a -E- x -E- w)
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (z :R: a) -> IO -E- b) -> IO -E- b 
      a :E: Type b :E: Type f :R: (_x2 :R: RealWorld) -> IOResult -E- a g :R: (_x3 :R: a) -> IO -E- b
        [ioBind] -E- a -E- b -R- ([MkIO] -E- [a] -R- f) -R- g = 
          let
            ioBind3 :R: (b :E: Type) -> (_x4 :R: RealWorld) -> (_x5 :R: IO -E- b) -> IOResult -E- b 
              b :E: Type w :R: RealWorld f :R: (_x6 :R: RealWorld) -> IOResult -E- b
                [ioBind3] -E- b -R- w -R- ([MkIO] -E- [b] -R- f) = f -R- w
            ioBind2 :R: (a :E: Type) -> (b :E: Type) -> (g :R: (x :R: a) -> IO -E- b) -> (r :R: IOResult -E- a) -> IOResult -E- b 
              a :E: Type b :E: Type g :R: (_x7 :R: a) -> IO -E- b x :R: a w :R: RealWorld
                [ioBind2] -E- a -E- b -R- g -R- ([MkIOR] -E- [a] -R- x -R- w) = ioBind3 -E- b -R- w -R- (g -R- x)
          in MkIO -E- b -R- (\w :R: RealWorld. ioBind2 -E- a -E- b -R- g -R- (f -R- w))
    ioIgnore :E: (a :E: Type) -> (b :E: Type) -> (r :E: b) -> (x :E: IO -E- a) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\r :E: b. (\x :E: IO -E- a. ioBind -E- a -E- b -E- x -E- (\v :E: a. ioReturn -E- b -E- r)))))
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate T :E: Bool
    postulate F :E: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- T = F
      [not] -E- F = T
    postulate Unit :E: Type
    postulate MkUnit :E: Unit
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> Unspec
      in MkIO -E- Unspec -R- (\w :R: RealWorld. MkIOR -E- Unspec -R- (nativePrint -E- a -R- x) -R- w)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    runIO :R: (a :E: Type) -> (_x1 :R: IO -E- a) -> a 
      a :E: Type f :R: (_x2 :R: RealWorld) -> IOResult -E- a
        [runIO] -E- a -R- ([MkIO] -E- [a] -R- f) = 
          let
            runIO2 :R: (a :E: Type) -> (_x3 :R: IOResult -E- a) -> a 
              a :E: Type x :R: a w :E: RealWorld
                [runIO2] -E- a -R- ([MkIOR] -E- [a] -R- x -R- w) = x
            postulate TheWorld :R: RealWorld
          in runIO2 -E- a -R- (f -R- TheWorld)
    main :R: Unspec = runIO -E- Unspec -R- (ioBind -E- Unspec -E- Unspec -R- (printNat -R- 4) -R- (\_0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ))))))
  in main

### Final annotation ###

  let
    postulate RealWorld :E: Type
    postulate IOResult :E: (_x0 :E: Type) -> Type
    postulate MkIOR :R: (a :E: Type) -> (x :R: a) -> (w :R: RealWorld) -> IOResult -E- a
    postulate IO :E: (_x1 :E: Type) -> Type
    postulate MkIO :R: (a :E: Type) -> (f :R: (w :R: RealWorld) -> IOResult -E- a) -> IO -E- a
    ioReturn :E: (a :E: Type) -> (x :E: a) -> IO -E- a 
      a :E: Type x :E: a
        [ioReturn] -E- a -E- x = MkIO -E- a -E- (\w :E: RealWorld. MkIOR -E- a -E- x -E- w)
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (z :R: a) -> IO -E- b) -> IO -E- b 
      a :E: Type b :E: Type f :R: (_x2 :R: RealWorld) -> IOResult -E- a g :R: (_x3 :R: a) -> IO -E- b
        [ioBind] -E- a -E- b -R- ([MkIO] -E- [a] -R- f) -R- g = 
          let
            ioBind3 :R: (b :E: Type) -> (_x4 :R: RealWorld) -> (_x5 :R: IO -E- b) -> IOResult -E- b 
              b :E: Type w :R: RealWorld f :R: (_x6 :R: RealWorld) -> IOResult -E- b
                [ioBind3] -E- b -R- w -R- ([MkIO] -E- [b] -R- f) = f -R- w
            ioBind2 :R: (a :E: Type) -> (b :E: Type) -> (g :R: (x :R: a) -> IO -E- b) -> (r :R: IOResult -E- a) -> IOResult -E- b 
              a :E: Type b :E: Type g :R: (_x7 :R: a) -> IO -E- b x :R: a w :R: RealWorld
                [ioBind2] -E- a -E- b -R- g -R- ([MkIOR] -E- [a] -R- x -R- w) = ioBind3 -E- b -R- w -R- (g -R- x)
          in MkIO -E- b -R- (\w :R: RealWorld. ioBind2 -E- a -E- b -R- g -R- (f -R- w))
    ioIgnore :E: (a :E: Type) -> (b :E: Type) -> (r :E: b) -> (x :E: IO -E- a) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\r :E: b. (\x :E: IO -E- a. ioBind -E- a -E- b -E- x -E- (\v :E: a. ioReturn -E- b -E- r)))))
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate T :E: Bool
    postulate F :E: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- T = F
      [not] -E- F = T
    postulate Unit :E: Type
    postulate MkUnit :E: Unit
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> Unspec
      in MkIO -E- Unspec -R- (\w :R: RealWorld. MkIOR -E- Unspec -R- (nativePrint -E- a -R- x) -R- w)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    runIO :R: (a :E: Type) -> (_x1 :R: IO -E- a) -> a 
      a :E: Type f :R: (_x2 :R: RealWorld) -> IOResult -E- a
        [runIO] -E- a -R- ([MkIO] -E- [a] -R- f) = 
          let
            runIO2 :R: (a :E: Type) -> (_x3 :R: IOResult -E- a) -> a 
              a :E: Type x :R: a w :E: RealWorld
                [runIO2] -E- a -R- ([MkIOR] -E- [a] -R- x -R- w) = x
            postulate TheWorld :R: RealWorld
          in runIO2 -E- a -R- (f -R- TheWorld)
    main :R: Unspec = runIO -E- Unspec -R- (ioBind -E- Unspec -E- Unspec -R- (printNat -R- 4) -R- (\_0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ))))))
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate MkIOR : (x) -> (w) -> IOResult
    postulate MkIO : (f) -> IO
    ioBind 
      [_] ([_] f) g = 
        let
          ioBind3 
            [_] w ([_] f) = f w
          ioBind2 
            [_] g ([_] x w) = ioBind3 w (g x)
        in MkIO (\w. ioBind2 g (f w))
    postulate Z : Nat
    postulate S : (x) -> Nat
    foreign intS
    foreign intZ
    printSchemeRepr = (\x. 
      let foreign nativePrint
      in MkIO (\w. MkIOR (nativePrint x) w))
    natToInt 
      [_] Z = intZ
      [_] (S n) = intS (natToInt n)
    foreign intToNat
    printNat = (\x. printSchemeRepr (natToInt x))
    runIO 
      [_] ([_] f) = 
        let
          runIO2 
            [_] ([_] x _) = x
          postulate TheWorld : RealWorld
        in runIO2 (f TheWorld)
    main = runIO (ioBind (printNat 4) (\_0. printSchemeRepr (intToNat (intS (intS (intS intZ))))))
  in main

### Normal forms ###

unerased:
  
  let
    postulate RealWorld : Type
    postulate IOResult : (_x0 : Type) -> Type
    postulate MkIOR : (a : Type) -> (x : a) -> (w : RealWorld) -> IOResult a
    postulate IO : (_x1 : Type) -> Type
    postulate MkIO : (a : Type) -> (f : (w : RealWorld) -> IOResult a) -> IO a
    ioBind : (a : Type) -> (b : Type) -> (x : IO a) -> (y : (z :R: a) -> IO b) -> IO b 
      a : Type b : Type f : (_x2 : RealWorld) -> IOResult a g : (_x3 : a) -> IO b
        [ioBind] a b ([MkIO] [a] f) g = 
          let
            ioBind3 : (b : Type) -> (_x4 : RealWorld) -> (_x5 : IO b) -> IOResult b 
              b : Type w : RealWorld f : (_x6 : RealWorld) -> IOResult b
                [ioBind3] b w ([MkIO] [b] f) = f w
            ioBind2 : (a : Type) -> (b : Type) -> (g : (x : a) -> IO b) -> (r : IOResult a) -> IOResult b 
              a : Type b : Type g : (_x7 : a) -> IO b x : a w : RealWorld
                [ioBind2] a b g ([MkIOR] [a] x w) = ioBind3 b w (g x)
          in MkIO b (\w : RealWorld. ioBind2 a b g (f w))
    postulate Nat : Type
    postulate Int : Type
    foreign intS : (x :R: Int) -> Int
    foreign intZ : Int
    postulate Unspec : Type
    foreign intToNat : (x :R: Int) -> Nat
    runIO : (a : Type) -> (_x1 : IO a) -> a 
      a : Type f : (_x2 : RealWorld) -> IOResult a
        [runIO] a ([MkIO] [a] f) = 
          let
            runIO2 : (a : Type) -> (_x3 : IOResult a) -> a 
              a : Type x : a w : RealWorld
                [runIO2] a ([MkIOR] [a] x w) = x
            postulate TheWorld : RealWorld
          in runIO2 a (f TheWorld)
  in runIO Unspec (ioBind Unspec Unspec 
    let foreign nativePrint : (a :E: Type) -> (x :R: a) -> Unspec
    in MkIO Unspec (\w :R: RealWorld. MkIOR Unspec (nativePrint Int (intS (intS (intS (intS intZ))))) w) (\_0 : Unspec. 
    let foreign nativePrint : (a :E: Type) -> (x :R: a) -> Unspec
    in MkIO Unspec (\w :R: RealWorld. MkIOR Unspec (nativePrint Nat (intToNat (intS (intS (intS intZ))))) w)))

erased:
  
  let
    postulate MkIOR : (x) -> (w) -> IOResult
    postulate MkIO : (f) -> IO
    ioBind 
      [_] ([_] f) g = 
        let
          ioBind3 
            [_] w ([_] f) = f w
          ioBind2 
            [_] g ([_] x w) = ioBind3 w (g x)
        in MkIO (\w. ioBind2 g (f w))
    foreign intS
    foreign intZ
    foreign intToNat
    runIO 
      [_] ([_] f) = 
        let
          runIO2 
            [_] ([_] x _) = x
          postulate TheWorld : RealWorld
        in runIO2 (f TheWorld)
  in runIO (ioBind 
    let foreign nativePrint
    in MkIO (\w. MkIOR (nativePrint (intS (intS (intS (intS intZ))))) w) (\_0. 
    let foreign nativePrint
    in MkIO (\w. MkIOR (nativePrint (intToNat (intS (intS (intS intZ))))) w)))

