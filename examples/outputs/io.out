-- vim: ft=idris

### Desugared ###

  let
    postulate RealWorld : Type
    postulate IOResult : (_x0 : Type) -> Type
    postulate MkIOR : (a :E: Type) -> (x :R: a) -> (w :R: RealWorld) -> IOResult a
    postulate IO : (_x1 : Type) -> Type
    postulate MkIO : (a : Type) -> (f : (w : RealWorld) -> IOResult a) -> IO a
    ioReturn : (a : Type) -> (x : a) -> IO a 
      a : Type x : a
        [ioReturn] a x = MkIO a (\w : RealWorld. MkIOR a x w)
    ioBind : (a : Type) -> (b : Type) -> (x : IO a) -> (y : (z :R: a) -> IO b) -> IO b 
      a : Type b : Type f : (_x2 : RealWorld) -> IOResult a g : (_x3 : a) -> IO b
        [ioBind] a b ([MkIO] [a] f) g = 
          let
            ioBind3 : (b : Type) -> (_x4 : RealWorld) -> (_x5 : IO b) -> IOResult b 
              b : Type w : RealWorld f : (_x6 : RealWorld) -> IOResult b
                [ioBind3] b w ([MkIO] [b] f) = f w
            ioBind2 : (a : Type) -> (b : Type) -> (g : (x : a) -> IO b) -> (r : IOResult a) -> IOResult b 
              a : Type b : Type g : (_x7 : a) -> IO b x : a w : RealWorld
                [ioBind2] a b g ([MkIOR] [a] x w) = ioBind3 b w (g x)
          in MkIO b (\w : RealWorld. ioBind2 a b g (f w))
    ioIgnore : (a : Type) -> (b : Type) -> (r : b) -> (x : IO a) -> IO b = (\a : Type. (\b : Type. (\r : b. (\x : IO a. ioBind a b x (\v : a. ioReturn b r)))))
    postulate Nat : Type
    postulate Z : Nat
    postulate S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    postulate Bool : Type
    postulate T : Bool
    postulate F : Bool
    not : (_x2 : Bool) -> Bool 
      [not] T = F
      [not] F = T
    postulate Unit : Type
    postulate tt : Unit
    postulate Int : Type
    foreign intS : (x :R: Int) -> Int
    foreign intZ : Int
    postulate Unspec : Type
    printSchemeRepr : (a : Type) -> (x : a) -> IO Unspec = (\a : Type. (\x : a. 
      let foreign nativePrint : (a :E: Type) -> (x :R: a) -> (w :R: RealWorld) -> IOResult Unspec
      in MkIO Unspec (nativePrint a x)))
    natToInt : (_x0 : Nat) -> Int 
      [natToInt] Z = intZ
      n : Nat
        [natToInt] (S n) = intS (natToInt n)
    foreign intToNat : (x :R: Int) -> Nat
    printNat : (x : Nat) -> IO Unspec = (\x : Nat. printSchemeRepr Int (natToInt x))
    foreign runIO_prim : (a :E: Type) -> (f :R: (w :R: RealWorld) -> IOResult a) -> IOResult a
    runIO : (a : Type) -> (_x1 : IO a) -> a 
      a : Type f : (_x2 : RealWorld) -> IOResult a
        [runIO] a ([MkIO] [a] f) = 
          let runIO2 : (a : Type) -> (_x3 : IOResult a) -> a 
            a : Type x : a w : RealWorld
              [runIO2] a ([MkIOR] [a] x w) = x
          in runIO2 a (runIO_prim a f)
    main : Unspec = runIO Unspec (ioBind Unspec Unspec (printNat 4) (\_0 : Unspec. printSchemeRepr Nat (intToNat (intS (intS (intS intZ))))))
  in main

### Evarified ###

  let
    postulate RealWorld :1: Type
    postulate IOResult :2: (_x0 :3: Type) -> Type
    postulate MkIOR :4: (a :E: Type) -> (x :R: a) -> (w :R: RealWorld) -> IOResult -5- a
    postulate IO :6: (_x1 :7: Type) -> Type
    postulate MkIO :8: (a :9: Type) -> (f :10: (w :11: RealWorld) -> IOResult -12- a) -> IO -13- a
    ioReturn :14: (a :15: Type) -> (x :16: a) -> IO -17- a 
      a :18: Type x :19: a
        [ioReturn] -21- a -20- x = MkIO -23- a -22- (\w :24: RealWorld. MkIOR -27- a -26- x -25- w)
    ioBind :28: (a :29: Type) -> (b :30: Type) -> (x :31: IO -32- a) -> (y :33: (z :R: a) -> IO -34- b) -> IO -35- b 
      a :36: Type b :37: Type f :38: (_x2 :39: RealWorld) -> IOResult -40- a g :41: (_x3 :42: a) -> IO -43- b
        [ioBind] -47- a -46- b -45- ([MkIO] -49- [a] -48- f) -44- g = 
          let
            ioBind3 :50: (b :51: Type) -> (_x4 :52: RealWorld) -> (_x5 :53: IO -54- b) -> IOResult -55- b 
              b :56: Type w :57: RealWorld f :58: (_x6 :59: RealWorld) -> IOResult -60- b
                [ioBind3] -63- b -62- w -61- ([MkIO] -65- [b] -64- f) = f -66- w
            ioBind2 :67: (a :68: Type) -> (b :69: Type) -> (g :70: (x :71: a) -> IO -72- b) -> (r :73: IOResult -74- a) -> IOResult -75- b 
              a :76: Type b :77: Type g :78: (_x7 :79: a) -> IO -80- b x :81: a w :82: RealWorld
                [ioBind2] -86- a -85- b -84- g -83- ([MkIOR] -89- [a] -88- x -87- w) = ioBind3 -92- b -91- w -90- (g -93- x)
          in MkIO -95- b -94- (\w :96: RealWorld. ioBind2 -100- a -99- b -98- g -97- (f -101- w))
    ioIgnore :102: (a :103: Type) -> (b :104: Type) -> (r :105: b) -> (x :106: IO -107- a) -> IO -108- b = (\a :109: Type. (\b :110: Type. (\r :111: b. (\x :112: IO -113- a. ioBind -117- a -116- b -115- x -114- (\v :118: a. ioReturn -120- b -119- r)))))
    postulate Nat :121: Type
    postulate Z :122: Nat
    postulate S :123: (x :R: Nat) -> Nat
    plus :124: (_x0 :125: Nat) -> (_x1 :126: Nat) -> Nat 
      n :127: Nat
        [plus] -129- Z -128- n = n
      m :130: Nat n :131: Nat
        [plus] -133- (S -134- m) -132- n = S -135- (plus -137- m -136- n)
    postulate Bool :138: Type
    postulate T :139: Bool
    postulate F :140: Bool
    not :141: (_x2 :142: Bool) -> Bool 
      [not] -143- T = F
      [not] -144- F = T
    postulate Unit :145: Type
    postulate tt :146: Unit
    postulate Int :147: Type
    foreign intS :148: (x :R: Int) -> Int
    foreign intZ :149: Int
    postulate Unspec :150: Type
    printSchemeRepr :151: (a :152: Type) -> (x :153: a) -> IO -154- Unspec = (\a :155: Type. (\x :156: a. 
      let foreign nativePrint :157: (a :E: Type) -> (x :R: a) -> (w :R: RealWorld) -> IOResult -158- Unspec
      in MkIO -160- Unspec -159- (nativePrint -162- a -161- x)))
    natToInt :163: (_x0 :164: Nat) -> Int 
      [natToInt] -165- Z = intZ
      n :166: Nat
        [natToInt] -167- (S -168- n) = intS -169- (natToInt -170- n)
    foreign intToNat :171: (x :R: Int) -> Nat
    printNat :172: (x :173: Nat) -> IO -174- Unspec = (\x :175: Nat. printSchemeRepr -177- Int -176- (natToInt -178- x))
    foreign runIO_prim :179: (a :E: Type) -> (f :R: (w :R: RealWorld) -> IOResult -180- a) -> IOResult -181- a
    runIO :182: (a :183: Type) -> (_x1 :184: IO -185- a) -> a 
      a :186: Type f :187: (_x2 :188: RealWorld) -> IOResult -189- a
        [runIO] -191- a -190- ([MkIO] -193- [a] -192- f) = 
          let runIO2 :194: (a :195: Type) -> (_x3 :196: IOResult -197- a) -> a 
            a :198: Type x :199: a w :200: RealWorld
              [runIO2] -202- a -201- ([MkIOR] -205- [a] -204- x -203- w) = x
          in runIO2 -207- a -206- (runIO_prim -209- a -208- f)
    main :210: Unspec = runIO -212- Unspec -211- (ioBind -216- Unspec -215- Unspec -214- (printNat -217- 4) -213- (\_0 :222: Unspec. printSchemeRepr -224- Nat -223- (intToNat -225- (intS -226- (intS -227- (intS -228- intZ))))))
  in main

### Constraints ###

[] -> [4,8,10,11,28,31,33,38,39,41,42,44,45,48,50,52,53,57,58,59,61,62,64,66,67,70,71,73,78,79,81,82,83,84,87,88,90,91,93,94,96,97,98,101,122,123,148,149,151,153,156,157,159,161,163,164,165,166,167,168,169,170,171,172,173,175,176,178,179,182,184,187,188,190,192,194,196,199,201,203,204,206,208,211,213,214,217,218,219,220,221,222,223,225,226,227,228,R]
[5] -> [74,197]
[9] -> [37,49,65,95,150,160,193]
[12] -> [40,60,75,158,189]
[13] -> [32,35,54,154,185]
[29] -> [47,150,216]
[30] -> [46,150,215]
[32] -> [13,174]
[34] -> [43,154]
[35] -> [13,185]
[36] -> [47]
[37] -> [46]
[40] -> [12,74]
[43] -> [34,72]
[46] -> [30]
[47] -> [29]
[49] -> [9,36]
[51] -> [63,77,92]
[54] -> [13,80]
[55] -> [60,75]
[56] -> [63]
[60] -> [12,55]
[63] -> [51]
[65] -> [9,56]
[68] -> [36,86,100]
[69] -> [37,85,99]
[72] -> [43,80]
[74] -> [5,40]
[75] -> [12,55]
[76] -> [86]
[77] -> [85]
[80] -> [54,72]
[85] -> [69]
[86] -> [68]
[89] -> [76,E]
[92] -> [51]
[95] -> [9]
[99] -> [69]
[100] -> [68]
[152] -> [121,147,155,177,224]
[154] -> [13,34,174]
[155] -> [152]
[158] -> [12]
[160] -> [9]
[162] -> [E]
[174] -> [32,154]
[177] -> [152]
[180] -> [189]
[181] -> [197]
[183] -> [150,191,212]
[185] -> [13,35]
[186] -> [191]
[189] -> [12,180]
[191] -> [183]
[193] -> [9,186]
[195] -> [186,202,207]
[197] -> [5,181]
[198] -> [202]
[202] -> [195]
[205] -> [198,E]
[207] -> [195]
[209] -> [E]
[212] -> [183]
[215] -> [30]
[216] -> [29]
[224] -> [152]
[E] -> [89,155,162,186,205,209]
[R] -> [210]

### Solution ###

[4,8,10,11,28,31,33,38,39,41,42,44,45,48,50,52,53,57,58,59,61,62,64,66,67,70,71,73,78,79,81,82,83,84,87,88,90,91,93,94,96,97,98,101,122,123,148,149,151,153,156,157,159,161,163,164,165,166,167,168,169,170,171,172,173,175,176,178,179,182,184,187,188,190,192,194,196,199,201,203,204,206,208,210,211,213,214,217,218,219,220,221,222,223,225,226,227,228,R]

### Annotated ###

  let
    postulate RealWorld :E: Type
    postulate IOResult :E: (_x0 :E: Type) -> Type
    postulate MkIOR :R: (a :E: Type) -> (x :R: a) -> (w :R: RealWorld) -> IOResult -E- a
    postulate IO :E: (_x1 :E: Type) -> Type
    postulate MkIO :R: (a :E: Type) -> (f :R: (w :R: RealWorld) -> IOResult -E- a) -> IO -E- a
    ioReturn :E: (a :E: Type) -> (x :E: a) -> IO -E- a 
      a :E: Type x :E: a
        [ioReturn] -E- a -E- x = MkIO -E- a -E- (\w :E: RealWorld. MkIOR -E- a -E- x -E- w)
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (z :R: a) -> IO -E- b) -> IO -E- b 
      a :E: Type b :E: Type f :R: (_x2 :R: RealWorld) -> IOResult -E- a g :R: (_x3 :R: a) -> IO -E- b
        [ioBind] -E- a -E- b -R- ([MkIO] -E- [a] -R- f) -R- g = 
          let
            ioBind3 :R: (b :E: Type) -> (_x4 :R: RealWorld) -> (_x5 :R: IO -E- b) -> IOResult -E- b 
              b :E: Type w :R: RealWorld f :R: (_x6 :R: RealWorld) -> IOResult -E- b
                [ioBind3] -E- b -R- w -R- ([MkIO] -E- [b] -R- f) = f -R- w
            ioBind2 :R: (a :E: Type) -> (b :E: Type) -> (g :R: (x :R: a) -> IO -E- b) -> (r :R: IOResult -E- a) -> IOResult -E- b 
              a :E: Type b :E: Type g :R: (_x7 :R: a) -> IO -E- b x :R: a w :R: RealWorld
                [ioBind2] -E- a -E- b -R- g -R- ([MkIOR] -E- [a] -R- x -R- w) = ioBind3 -E- b -R- w -R- (g -R- x)
          in MkIO -E- b -R- (\w :R: RealWorld. ioBind2 -E- a -E- b -R- g -R- (f -R- w))
    ioIgnore :E: (a :E: Type) -> (b :E: Type) -> (r :E: b) -> (x :E: IO -E- a) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\r :E: b. (\x :E: IO -E- a. ioBind -E- a -E- b -E- x -E- (\v :E: a. ioReturn -E- b -E- r)))))
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate T :E: Bool
    postulate F :E: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- T = F
      [not] -E- F = T
    postulate Unit :E: Type
    postulate tt :E: Unit
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> (w :R: RealWorld) -> IOResult -E- Unspec
      in MkIO -E- Unspec -R- (nativePrint -E- a -R- x)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    foreign runIO_prim :R: (a :E: Type) -> (f :R: (w :R: RealWorld) -> IOResult -E- a) -> IOResult -E- a
    runIO :R: (a :E: Type) -> (_x1 :R: IO -E- a) -> a 
      a :E: Type f :R: (_x2 :R: RealWorld) -> IOResult -E- a
        [runIO] -E- a -R- ([MkIO] -E- [a] -R- f) = 
          let runIO2 :R: (a :E: Type) -> (_x3 :R: IOResult -E- a) -> a 
            a :E: Type x :R: a w :E: RealWorld
              [runIO2] -E- a -R- ([MkIOR] -E- [a] -R- x -R- w) = x
          in runIO2 -E- a -R- (runIO_prim -E- a -R- f)
    main :R: Unspec = runIO -E- Unspec -R- (ioBind -E- Unspec -E- Unspec -R- (printNat -R- 4) -R- (\_0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ))))))
  in main

### Specialised ###

  let
    postulate RealWorld :E: Type
    postulate IOResult :E: (_x0 :E: Type) -> Type
    postulate MkIOR :R: (a :E: Type) -> (x :R: a) -> (w :R: RealWorld) -> IOResult -E- a
    postulate IO :E: (_x1 :E: Type) -> Type
    postulate MkIO :R: (a :E: Type) -> (f :R: (w :R: RealWorld) -> IOResult -E- a) -> IO -E- a
    ioReturn :E: (a :E: Type) -> (x :E: a) -> IO -E- a 
      a :E: Type x :E: a
        [ioReturn] -E- a -E- x = MkIO -E- a -E- (\w :E: RealWorld. MkIOR -E- a -E- x -E- w)
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (z :R: a) -> IO -E- b) -> IO -E- b 
      a :E: Type b :E: Type f :R: (_x2 :R: RealWorld) -> IOResult -E- a g :R: (_x3 :R: a) -> IO -E- b
        [ioBind] -E- a -E- b -R- ([MkIO] -E- [a] -R- f) -R- g = 
          let
            ioBind3 :R: (b :E: Type) -> (_x4 :R: RealWorld) -> (_x5 :R: IO -E- b) -> IOResult -E- b 
              b :E: Type w :R: RealWorld f :R: (_x6 :R: RealWorld) -> IOResult -E- b
                [ioBind3] -E- b -R- w -R- ([MkIO] -E- [b] -R- f) = f -R- w
            ioBind2 :R: (a :E: Type) -> (b :E: Type) -> (g :R: (x :R: a) -> IO -E- b) -> (r :R: IOResult -E- a) -> IOResult -E- b 
              a :E: Type b :E: Type g :R: (_x7 :R: a) -> IO -E- b x :R: a w :R: RealWorld
                [ioBind2] -E- a -E- b -R- g -R- ([MkIOR] -E- [a] -R- x -R- w) = ioBind3 -E- b -R- w -R- (g -R- x)
          in MkIO -E- b -R- (\w :R: RealWorld. ioBind2 -E- a -E- b -R- g -R- (f -R- w))
    ioIgnore :E: (a :E: Type) -> (b :E: Type) -> (r :E: b) -> (x :E: IO -E- a) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\r :E: b. (\x :E: IO -E- a. ioBind -E- a -E- b -E- x -E- (\v :E: a. ioReturn -E- b -E- r)))))
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate T :E: Bool
    postulate F :E: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- T = F
      [not] -E- F = T
    postulate Unit :E: Type
    postulate tt :E: Unit
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> (w :R: RealWorld) -> IOResult -E- Unspec
      in MkIO -E- Unspec -R- (nativePrint -E- a -R- x)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    foreign runIO_prim :R: (a :E: Type) -> (f :R: (w :R: RealWorld) -> IOResult -E- a) -> IOResult -E- a
    runIO :R: (a :E: Type) -> (_x1 :R: IO -E- a) -> a 
      a :E: Type f :R: (_x2 :R: RealWorld) -> IOResult -E- a
        [runIO] -E- a -R- ([MkIO] -E- [a] -R- f) = 
          let runIO2 :R: (a :E: Type) -> (_x3 :R: IOResult -E- a) -> a 
            a :E: Type x :R: a w :E: RealWorld
              [runIO2] -E- a -R- ([MkIOR] -E- [a] -R- x -R- w) = x
          in runIO2 -E- a -R- (runIO_prim -E- a -R- f)
    main :R: Unspec = runIO -E- Unspec -R- (ioBind -E- Unspec -E- Unspec -R- (printNat -R- 4) -R- (\_0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ))))))
  in main

### Final annotation ###

  let
    postulate RealWorld :E: Type
    postulate IOResult :E: (_x0 :E: Type) -> Type
    postulate MkIOR :R: (a :E: Type) -> (x :R: a) -> (w :R: RealWorld) -> IOResult -E- a
    postulate IO :E: (_x1 :E: Type) -> Type
    postulate MkIO :R: (a :E: Type) -> (f :R: (w :R: RealWorld) -> IOResult -E- a) -> IO -E- a
    ioReturn :E: (a :E: Type) -> (x :E: a) -> IO -E- a 
      a :E: Type x :E: a
        [ioReturn] -E- a -E- x = MkIO -E- a -E- (\w :E: RealWorld. MkIOR -E- a -E- x -E- w)
    ioBind :R: (a :E: Type) -> (b :E: Type) -> (x :R: IO -E- a) -> (y :R: (z :R: a) -> IO -E- b) -> IO -E- b 
      a :E: Type b :E: Type f :R: (_x2 :R: RealWorld) -> IOResult -E- a g :R: (_x3 :R: a) -> IO -E- b
        [ioBind] -E- a -E- b -R- ([MkIO] -E- [a] -R- f) -R- g = 
          let
            ioBind3 :R: (b :E: Type) -> (_x4 :R: RealWorld) -> (_x5 :R: IO -E- b) -> IOResult -E- b 
              b :E: Type w :R: RealWorld f :R: (_x6 :R: RealWorld) -> IOResult -E- b
                [ioBind3] -E- b -R- w -R- ([MkIO] -E- [b] -R- f) = f -R- w
            ioBind2 :R: (a :E: Type) -> (b :E: Type) -> (g :R: (x :R: a) -> IO -E- b) -> (r :R: IOResult -E- a) -> IOResult -E- b 
              a :E: Type b :E: Type g :R: (_x7 :R: a) -> IO -E- b x :R: a w :R: RealWorld
                [ioBind2] -E- a -E- b -R- g -R- ([MkIOR] -E- [a] -R- x -R- w) = ioBind3 -E- b -R- w -R- (g -R- x)
          in MkIO -E- b -R- (\w :R: RealWorld. ioBind2 -E- a -E- b -R- g -R- (f -R- w))
    ioIgnore :E: (a :E: Type) -> (b :E: Type) -> (r :E: b) -> (x :E: IO -E- a) -> IO -E- b = (\a :E: Type. (\b :E: Type. (\r :E: b. (\x :E: IO -E- a. ioBind -E- a -E- b -E- x -E- (\v :E: a. ioReturn -E- b -E- r)))))
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate T :E: Bool
    postulate F :E: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- T = F
      [not] -E- F = T
    postulate Unit :E: Type
    postulate tt :E: Unit
    postulate Int :E: Type
    foreign intS :R: (x :R: Int) -> Int
    foreign intZ :R: Int
    postulate Unspec :E: Type
    printSchemeRepr :R: (a :E: Type) -> (x :R: a) -> IO -E- Unspec = (\a :E: Type. (\x :R: a. 
      let foreign nativePrint :R: (a :E: Type) -> (x :R: a) -> (w :R: RealWorld) -> IOResult -E- Unspec
      in MkIO -E- Unspec -R- (nativePrint -E- a -R- x)))
    natToInt :R: (_x0 :R: Nat) -> Int 
      [natToInt] -R- Z = intZ
      n :R: Nat
        [natToInt] -R- (S -R- n) = intS -R- (natToInt -R- n)
    foreign intToNat :R: (x :R: Int) -> Nat
    printNat :R: (x :R: Nat) -> IO -E- Unspec = (\x :R: Nat. printSchemeRepr -E- Int -R- (natToInt -R- x))
    foreign runIO_prim :R: (a :E: Type) -> (f :R: (w :R: RealWorld) -> IOResult -E- a) -> IOResult -E- a
    runIO :R: (a :E: Type) -> (_x1 :R: IO -E- a) -> a 
      a :E: Type f :R: (_x2 :R: RealWorld) -> IOResult -E- a
        [runIO] -E- a -R- ([MkIO] -E- [a] -R- f) = 
          let runIO2 :R: (a :E: Type) -> (_x3 :R: IOResult -E- a) -> a 
            a :E: Type x :R: a w :E: RealWorld
              [runIO2] -E- a -R- ([MkIOR] -E- [a] -R- x -R- w) = x
          in runIO2 -E- a -R- (runIO_prim -E- a -R- f)
    main :R: Unspec = runIO -E- Unspec -R- (ioBind -E- Unspec -E- Unspec -R- (printNat -R- 4) -R- (\_0 :R: Unspec. printSchemeRepr -E- Nat -R- (intToNat -R- (intS -R- (intS -R- (intS -R- intZ))))))
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate MkIOR : (x) -> (w) -> IOResult
    postulate MkIO : (f) -> IO
    ioBind 
      [_] ([_] f) g = 
        let
          ioBind3 
            [_] w ([_] f) = f w
          ioBind2 
            [_] g ([_] x w) = ioBind3 w (g x)
        in MkIO (\w. ioBind2 g (f w))
    postulate Z : Nat
    postulate S : (x) -> Nat
    foreign intS
    foreign intZ
    printSchemeRepr = (\x. 
      let foreign nativePrint
      in MkIO (nativePrint x))
    natToInt 
      [_] Z = intZ
      [_] (S n) = intS (natToInt n)
    foreign intToNat
    printNat = (\x. printSchemeRepr (natToInt x))
    foreign runIO_prim
    runIO 
      [_] ([_] f) = 
        let runIO2 
          [_] ([_] x _) = x
        in runIO2 (runIO_prim f)
    main = runIO (ioBind (printNat 4) (\_0. printSchemeRepr (intToNat (intS (intS (intS intZ))))))
  in main

### Normal forms ###

unerased:
  
  let
    postulate RealWorld : Type
    postulate IOResult : (_x0 : Type) -> Type
    postulate MkIOR : (a :E: Type) -> (x :R: a) -> (w :R: RealWorld) -> IOResult a
    postulate IO : (_x1 : Type) -> Type
    postulate MkIO : (a : Type) -> (f : (w : RealWorld) -> IOResult a) -> IO a
    ioBind : (a : Type) -> (b : Type) -> (x : IO a) -> (y : (z :R: a) -> IO b) -> IO b 
      a : Type b : Type f : (_x2 : RealWorld) -> IOResult a g : (_x3 : a) -> IO b
        [ioBind] a b ([MkIO] [a] f) g = 
          let
            ioBind3 : (b : Type) -> (_x4 : RealWorld) -> (_x5 : IO b) -> IOResult b 
              b : Type w : RealWorld f : (_x6 : RealWorld) -> IOResult b
                [ioBind3] b w ([MkIO] [b] f) = f w
            ioBind2 : (a : Type) -> (b : Type) -> (g : (x : a) -> IO b) -> (r : IOResult a) -> IOResult b 
              a : Type b : Type g : (_x7 : a) -> IO b x : a w : RealWorld
                [ioBind2] a b g ([MkIOR] [a] x w) = ioBind3 b w (g x)
          in MkIO b (\w : RealWorld. ioBind2 a b g (f w))
    postulate Nat : Type
    postulate Int : Type
    foreign intS : (x :R: Int) -> Int
    foreign intZ : Int
    postulate Unspec : Type
    foreign intToNat : (x :R: Int) -> Nat
    foreign runIO_prim : (a :E: Type) -> (f :R: (w :R: RealWorld) -> IOResult a) -> IOResult a
    runIO : (a : Type) -> (_x1 : IO a) -> a 
      a : Type f : (_x2 : RealWorld) -> IOResult a
        [runIO] a ([MkIO] [a] f) = 
          let runIO2 : (a : Type) -> (_x3 : IOResult a) -> a 
            a : Type x : a w : RealWorld
              [runIO2] a ([MkIOR] [a] x w) = x
          in runIO2 a (runIO_prim a f)
  in runIO Unspec (ioBind Unspec Unspec 
    let foreign nativePrint : (a :E: Type) -> (x :R: a) -> (w :R: RealWorld) -> IOResult Unspec
    in MkIO Unspec (nativePrint Int (intS (intS (intS (intS intZ))))) (\_0 : Unspec. 
    let foreign nativePrint : (a :E: Type) -> (x :R: a) -> (w :R: RealWorld) -> IOResult Unspec
    in MkIO Unspec (nativePrint Nat (intToNat (intS (intS (intS intZ)))))))

erased:
  
  let
    postulate MkIO : (f) -> IO
    ioBind 
      [_] ([_] f) g = 
        let
          ioBind3 
            [_] w ([_] f) = f w
          ioBind2 
            [_] g ([_] x w) = ioBind3 w (g x)
        in MkIO (\w. ioBind2 g (f w))
    foreign intS
    foreign intZ
    foreign intToNat
    foreign runIO_prim
    runIO 
      [_] ([_] f) = 
        let runIO2 
          [_] ([_] x _) = x
        in runIO2 (runIO_prim f)
  in runIO (ioBind 
    let foreign nativePrint
    in MkIO (nativePrint (intS (intS (intS (intS intZ))))) (\_0. 
    let foreign nativePrint
    in MkIO (nativePrint (intToNat (intS (intS (intS intZ)))))))

