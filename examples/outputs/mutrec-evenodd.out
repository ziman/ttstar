-- vim: ft=ttstar

### Desugared ###

  let
    postulate Nat : Type
    postulate Z : Nat
    postulate S : (x :R: Nat) -> Nat
    plus : (_x0 : Nat) -> (_x1 : Nat) -> Nat 
      n : Nat
        [plus] Z n = n
      m : Nat n : Nat
        [plus] (S m) n = S (plus m n)
    postulate Bool : Type
    postulate True : Bool
    postulate False : Bool
    not : (_x2 : Bool) -> Bool 
      [not] True = False
      [not] False = True
    postulate Unit : Type
    postulate MkUnit : Unit
    postulate Pair : (_x3 : Type) -> (_x4 : Type) -> Type
    postulate MkPair : (a : Type) -> (b : Type) -> (_x5 : a) -> (_x6 : b) -> Pair a b
    fst : (a : Type) -> (b : Type) -> (_x7 : Pair a b) -> a 
      a : Type b : Type x : a y : b
        [fst] a b ([MkPair] [a] [b] x y) = x
    snd : (a : Type) -> (b : Type) -> (_x8 : Pair a b) -> b 
      a : Type b : Type x : a y : b
        [snd] a b ([MkPair] [a] [b] x y) = y
    postulate Either : (_x9 : Type) -> (_x10 : Type) -> Type
    postulate Left : (a : Type) -> (b : Type) -> (_x11 : a) -> Either a b
    postulate Right : (a : Type) -> (b : Type) -> (_x12 : b) -> Either a b
    id : (a : Type) -> (x : a) -> a = (\a : Type. (\x : a. x))
    postulate Fin : (_x13 : Nat) -> Type
    postulate FZ : (n : Nat) -> Fin (S n)
    postulate FS : (n : Nat) -> (_x14 : Fin n) -> Fin (S n)
    postulate Vect : (_x15 : Nat) -> (_x16 : Type) -> Type
    postulate VN : (a : Type) -> Vect Z a
    postulate VC : (n : Nat) -> (a : Type) -> (x : a) -> (xs : Vect n a) -> Vect (S n) a
    even : (_x0 : Nat) -> Bool 
      [even] Z = True
      n : Nat
        [even] (S n) = 
          let odd : (_x1 : Nat) -> Bool 
            [odd] Z = False
            n : Nat
              [odd] (S n) = even n
          in odd n
    main : Bool = even 5
  in main

### Evarified ###

  let
    postulate Nat :1: Type
    postulate Z :2: Nat
    postulate S :3: (x :R: Nat) -> Nat
    plus :4: (_x0 :5: Nat) -> (_x1 :6: Nat) -> Nat 
      n :7: Nat
        [plus] -9- Z -8- n = n
      m :10: Nat n :11: Nat
        [plus] -13- (S -14- m) -12- n = S -15- (plus -17- m -16- n)
    postulate Bool :18: Type
    postulate True :19: Bool
    postulate False :20: Bool
    not :21: (_x2 :22: Bool) -> Bool 
      [not] -23- True = False
      [not] -24- False = True
    postulate Unit :25: Type
    postulate MkUnit :26: Unit
    postulate Pair :27: (_x3 :28: Type) -> (_x4 :29: Type) -> Type
    postulate MkPair :30: (a :31: Type) -> (b :32: Type) -> (_x5 :33: a) -> (_x6 :34: b) -> Pair -36- a -35- b
    fst :37: (a :38: Type) -> (b :39: Type) -> (_x7 :40: Pair -42- a -41- b) -> a 
      a :43: Type b :44: Type x :45: a y :46: b
        [fst] -49- a -48- b -47- ([MkPair] -53- [a] -52- [b] -51- x -50- y) = x
    snd :54: (a :55: Type) -> (b :56: Type) -> (_x8 :57: Pair -59- a -58- b) -> b 
      a :60: Type b :61: Type x :62: a y :63: b
        [snd] -66- a -65- b -64- ([MkPair] -70- [a] -69- [b] -68- x -67- y) = y
    postulate Either :71: (_x9 :72: Type) -> (_x10 :73: Type) -> Type
    postulate Left :74: (a :75: Type) -> (b :76: Type) -> (_x11 :77: a) -> Either -79- a -78- b
    postulate Right :80: (a :81: Type) -> (b :82: Type) -> (_x12 :83: b) -> Either -85- a -84- b
    id :86: (a :87: Type) -> (x :88: a) -> a = (\a :89: Type. (\x :90: a. x))
    postulate Fin :91: (_x13 :92: Nat) -> Type
    postulate FZ :93: (n :94: Nat) -> Fin -95- (S -96- n)
    postulate FS :97: (n :98: Nat) -> (_x14 :99: Fin -100- n) -> Fin -101- (S -102- n)
    postulate Vect :103: (_x15 :104: Nat) -> (_x16 :105: Type) -> Type
    postulate VN :106: (a :107: Type) -> Vect -109- Z -108- a
    postulate VC :110: (n :111: Nat) -> (a :112: Type) -> (x :113: a) -> (xs :114: Vect -116- n -115- a) -> Vect -118- (S -119- n) -117- a
    even :120: (_x0 :121: Nat) -> Bool 
      [even] -122- Z = True
      n :123: Nat
        [even] -124- (S -125- n) = 
          let odd :126: (_x1 :127: Nat) -> Bool 
            [odd] -128- Z = False
            n :129: Nat
              [odd] -130- (S -131- n) = even -132- n
          in odd -133- n
    main :134: Bool = even -135- 5
  in main

### Constraints ###

[] -> [2,3,19,20,120,121,122,123,124,125,126,127,128,129,130,131,132,133,135,136,137,138,139,140,R]
[R] -> [134]

### Solution ###

[2,3,19,20,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,R]

### Annotated ###

  let
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate True :R: Bool
    postulate False :R: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    postulate Unit :E: Type
    postulate MkUnit :E: Unit
    postulate Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    postulate MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    postulate Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    postulate Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    postulate Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    postulate Fin :E: (_x13 :E: Nat) -> Type
    postulate FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    postulate FS :E: (n :E: Nat) -> (_x14 :E: Fin -E- n) -> Fin -E- (S -E- n)
    postulate Vect :E: (_x15 :E: Nat) -> (_x16 :E: Type) -> Type
    postulate VN :E: (a :E: Type) -> Vect -E- Z -E- a
    postulate VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    even :R: (_x0 :R: Nat) -> Bool 
      [even] -R- Z = True
      n :R: Nat
        [even] -R- (S -R- n) = 
          let odd :R: (_x1 :R: Nat) -> Bool 
            [odd] -R- Z = False
            n :R: Nat
              [odd] -R- (S -R- n) = even -R- n
          in odd -R- n
    main :R: Bool = even -R- 5
  in main

### Specialised ###

  let
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate True :R: Bool
    postulate False :R: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    postulate Unit :E: Type
    postulate MkUnit :E: Unit
    postulate Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    postulate MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    postulate Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    postulate Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    postulate Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    postulate Fin :E: (_x13 :E: Nat) -> Type
    postulate FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    postulate FS :E: (n :E: Nat) -> (_x14 :E: Fin -E- n) -> Fin -E- (S -E- n)
    postulate Vect :E: (_x15 :E: Nat) -> (_x16 :E: Type) -> Type
    postulate VN :E: (a :E: Type) -> Vect -E- Z -E- a
    postulate VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    even :R: (_x0 :R: Nat) -> Bool 
      [even] -R- Z = True
      n :R: Nat
        [even] -R- (S -R- n) = 
          let odd :R: (_x1 :R: Nat) -> Bool 
            [odd] -R- Z = False
            n :R: Nat
              [odd] -R- (S -R- n) = even -R- n
          in odd -R- n
    main :R: Bool = even -R- 5
  in main

### Final annotation ###

  let
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (x :R: Nat) -> Nat
    plus :E: (_x0 :E: Nat) -> (_x1 :E: Nat) -> Nat 
      n :E: Nat
        [plus] -E- Z -E- n = n
      m :E: Nat n :E: Nat
        [plus] -E- (S -E- m) -E- n = S -E- (plus -E- m -E- n)
    postulate Bool :E: Type
    postulate True :R: Bool
    postulate False :R: Bool
    not :E: (_x2 :E: Bool) -> Bool 
      [not] -E- True = False
      [not] -E- False = True
    postulate Unit :E: Type
    postulate MkUnit :E: Unit
    postulate Pair :E: (_x3 :E: Type) -> (_x4 :E: Type) -> Type
    postulate MkPair :E: (a :E: Type) -> (b :E: Type) -> (_x5 :E: a) -> (_x6 :E: b) -> Pair -E- a -E- b
    fst :E: (a :E: Type) -> (b :E: Type) -> (_x7 :E: Pair -E- a -E- b) -> a 
      a :E: Type b :E: Type x :E: a y :E: b
        [fst] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = x
    snd :E: (a :E: Type) -> (b :E: Type) -> (_x8 :E: Pair -E- a -E- b) -> b 
      a :E: Type b :E: Type x :E: a y :E: b
        [snd] -E- a -E- b -E- ([MkPair] -E- [a] -E- [b] -E- x -E- y) = y
    postulate Either :E: (_x9 :E: Type) -> (_x10 :E: Type) -> Type
    postulate Left :E: (a :E: Type) -> (b :E: Type) -> (_x11 :E: a) -> Either -E- a -E- b
    postulate Right :E: (a :E: Type) -> (b :E: Type) -> (_x12 :E: b) -> Either -E- a -E- b
    id :E: (a :E: Type) -> (x :E: a) -> a = (\a :E: Type. (\x :E: a. x))
    postulate Fin :E: (_x13 :E: Nat) -> Type
    postulate FZ :E: (n :E: Nat) -> Fin -E- (S -E- n)
    postulate FS :E: (n :E: Nat) -> (_x14 :E: Fin -E- n) -> Fin -E- (S -E- n)
    postulate Vect :E: (_x15 :E: Nat) -> (_x16 :E: Type) -> Type
    postulate VN :E: (a :E: Type) -> Vect -E- Z -E- a
    postulate VC :E: (n :E: Nat) -> (a :E: Type) -> (x :E: a) -> (xs :E: Vect -E- n -E- a) -> Vect -E- (S -E- n) -E- a
    even :R: (_x0 :R: Nat) -> Bool 
      [even] -R- Z = True
      n :R: Nat
        [even] -R- (S -R- n) = 
          let odd :R: (_x1 :R: Nat) -> Bool 
            [odd] -R- Z = False
            n :R: Nat
              [odd] -R- (S -R- n) = even -R- n
          in odd -R- n
    main :R: Bool = even -R- 5
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Z : Nat
    postulate S : (x) -> Nat
    postulate True : Bool
    postulate False : Bool
    even 
      [_] Z = True
      [_] (S n) = 
        let odd 
          [_] Z = False
          [_] (S n) = even n
        in odd n
    main = even 5
  in main

### Normal forms ###

unerased:
  
  let
    postulate Bool : Type
    postulate False : Bool
  in False

erased:
  
  let postulate False : Bool
  in False

