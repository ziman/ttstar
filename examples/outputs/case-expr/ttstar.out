-- vim: ft=ttstar

### Desugared ###

  let
    constructor Bool : Type
    constructor T : Bool
    constructor F : Bool
    constructor Unit : Type
    constructor MkUnit : Unit
    not : (_x0 : Bool) -> Bool 
      not T = F
      not F = T
    retTy : (_x1 : Bool) -> Type 
      retTy T = Bool
      retTy F = Unit
    main : Bool = not 
      let f : (x : Bool) -> (_x2 : retTy x) -> retTy x 
        f F MkUnit = MkUnit
        f T T = F
        f T F = T
      in f (not F) T
  in main

### Elaborated ###

  let
    constructor Bool : Type
    constructor T : Bool
    constructor F : Bool
    constructor Unit : Type
    constructor MkUnit : Unit
    not : (_x0 : Bool) -> Bool 
      not T = F
      not F = T
    retTy : (_x1 : Bool) -> Type 
      retTy T = Bool
      retTy F = Unit
    main : Bool = not 
      let f : (x : Bool) -> (_x2 : retTy x) -> retTy x 
        f F MkUnit = MkUnit
        f T T = F
        f T F = T
      in f (not F) T
  in main

### Evarified ###

  let
    constructor Bool :1: Type
    constructor T :2: Bool
    constructor F :3: Bool
    constructor Unit :4: Type
    constructor MkUnit :5: Unit
    not :6: (_x0 :7: Bool) -> Bool 
      not -8- T = F
      not -9- F = T
    retTy :10: (_x1 :11: Bool) -> Type 
      retTy -12- T = Bool
      retTy -13- F = Unit
    main :14: Bool = not -15- 
      let f :16: (x :17: Bool) -> (_x2 :18: retTy -19- x) -> retTy -20- x 
        f -22- F -21- MkUnit = MkUnit
        f -24- T -23- T = F
        f -26- T -25- F = T
      in f -28- (not -29- F) -27- T
  in main

### Constraints ###

[] -> [14]
[6] -> [2,3,8,9]
[7] -> [8,9,15,29]
[8] -> [7]
[9] -> [7]
[10] -> [1,2,3,4,12,13]
[11] -> [12,13,19,20]
[12] -> [11]
[13] -> [11]
[14] -> [6]
[14,15] -> [16]
[14,15,27] -> [2]
[14,15,28] -> [6]
[14,15,28,29] -> [3]
[15] -> [7]
[16] -> [2,3,5,21,22,23,24,25,26]
[17] -> [22,24,26,28]
[18] -> [21,23,25,27]
[19] -> [11]
[20] -> [11]
[21] -> [18]
[22] -> [17]
[23] -> [18]
[24] -> [17]
[25] -> [18]
[26] -> [17]
[27] -> [18]
[28] -> [17]
[29] -> [7]

### Solution ###

[2,3,5,6,7,8,9,14,15,16,17,18,21,22,23,24,25,26,27,28,29,R]

### Annotated ###

  let
    constructor Bool :E: Type
    constructor T :R: Bool
    constructor F :R: Bool
    constructor Unit :E: Type
    constructor MkUnit :R: Unit
    not :R: (_x0 :R: Bool) -> Bool 
      not -R- T = F
      not -R- F = T
    retTy :E: (_x1 :E: Bool) -> Type 
      retTy -E- T = Bool
      retTy -E- F = Unit
    main :R: Bool = not -R- 
      let f :R: (x :R: Bool) -> (_x2 :R: retTy -E- x) -> retTy -E- x 
        f -R- F -R- MkUnit = MkUnit
        f -R- T -R- T = F
        f -R- T -R- F = T
      in f -R- (not -R- F) -R- T
  in main

### Specialised ###

  let
    constructor Bool :E: Type
    constructor T :R: Bool
    constructor F :R: Bool
    constructor Unit :E: Type
    constructor MkUnit :R: Unit
    not :R: (_x0 :R: Bool) -> Bool 
      not -R- T = F
      not -R- F = T
    retTy :E: (_x1 :E: Bool) -> Type 
      retTy -E- T = Bool
      retTy -E- F = Unit
    main :R: Bool = not -R- 
      let f :R: (x :R: Bool) -> (_x2 :R: retTy -E- x) -> retTy -E- x 
        f -R- F -R- MkUnit = MkUnit
        f -R- T -R- T = F
        f -R- T -R- F = T
      in f -R- (not -R- F) -R- T
  in main

### Final annotation ###

  let
    constructor Bool :E: Type
    constructor T :R: Bool
    constructor F :R: Bool
    constructor Unit :E: Type
    constructor MkUnit :R: Unit
    not :R: (_x0 :R: Bool) -> Bool 
      not -R- T = F
      not -R- F = T
    retTy :E: (_x1 :E: Bool) -> Type 
      retTy -E- T = Bool
      retTy -E- F = Unit
    main :R: Bool = not -R- 
      let f :R: (x :R: Bool) -> (_x2 :R: retTy -E- x) -> retTy -E- x 
        f -R- F -R- MkUnit = MkUnit
        f -R- T -R- T = F
        f -R- T -R- F = T
      in f -R- (not -R- F) -R- T
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor T : Bool
    constructor F : Bool
    constructor MkUnit : Unit
    not 
      not T = F
      not F = T
    main = not 
      let f 
        f F MkUnit = MkUnit
        f T T = F
        f T F = T
      in f (not F) T
  in main

### Intermediate representation ###

let T = constructor 0
  in let F = constructor 0
    in let MkUnit = constructor 0
      in let not = \_pv0.
        case _pv0 of
          F => T
          T => F
        in let main = (not let f = \_pv0. \_pv1.
          case _pv0 of
            F => MkUnit
            T => case _pv1 of
              F => T
              T => F
          in ((f (not F)) T))
          in main

### Normal forms ###

unerased:
  
  let
    constructor Bool : Type
    constructor T : Bool
  in T

erased:
  
  let constructor T : Bool
  in T

