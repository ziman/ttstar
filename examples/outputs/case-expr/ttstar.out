-- vim: ft=ttstar

### Desugared ###

  let
    constructor Bool : Type
    constructor T : Bool
    constructor F : Bool
    constructor Unit : Type
    constructor MkUnit : Unit
    not : (_x0 : Bool) -> Bool 
      [not] T = F
      [not] F = T
    retTy : (_x1 : Bool) -> Type 
      [retTy] T = Bool
      [retTy] F = Unit
    main : Bool = not 
      let f : (x : Bool) -> (_x2 : retTy x) -> retTy x 
        [f] F MkUnit = MkUnit
        x : Bool
          [f] T x = not x
      in f (not F) T
  in main

### Evarified ###

  let
    constructor Bool :1: Type
    constructor T :2: Bool
    constructor F :3: Bool
    constructor Unit :4: Type
    constructor MkUnit :5: Unit
    not :6: (_x0 :7: Bool) -> Bool 
      [not] -8- T = F
      [not] -9- F = T
    retTy :10: (_x1 :11: Bool) -> Type 
      [retTy] -12- T = Bool
      [retTy] -13- F = Unit
    main :14: Bool = not -15- 
      let f :16: (x :17: Bool) -> (_x2 :18: retTy -19- x) -> retTy -20- x 
        [f] -22- F -21- MkUnit = MkUnit
        x :23: Bool
          [f] -25- T -24- x = not -26- x
      in f -28- (not -29- F) -27- T
  in main

### Constraints ###

[] -> [2,3,5,6,7,8,9,15,16,17,18,21,22,23,24,25,26,27,28,29,R]
[R] -> [14]

### Solution ###

[2,3,5,6,7,8,9,14,15,16,17,18,21,22,23,24,25,26,27,28,29,R]

### Annotated ###

  let
    constructor Bool :E: Type
    constructor T :R: Bool
    constructor F :R: Bool
    constructor Unit :E: Type
    constructor MkUnit :R: Unit
    not :R: (_x0 :R: Bool) -> Bool 
      [not] -R- T = F
      [not] -R- F = T
    retTy :E: (_x1 :E: Bool) -> Type 
      [retTy] -E- T = Bool
      [retTy] -E- F = Unit
    main :R: Bool = not -R- 
      let f :R: (x :R: Bool) -> (_x2 :R: retTy -E- x) -> retTy -E- x 
        [f] -R- F -R- MkUnit = MkUnit
        x :R: Bool
          [f] -R- T -R- x = not -R- x
      in f -R- (not -R- F) -R- T
  in main

### Specialised ###

  let
    constructor Bool :E: Type
    constructor T :R: Bool
    constructor F :R: Bool
    constructor Unit :E: Type
    constructor MkUnit :R: Unit
    not :R: (_x0 :R: Bool) -> Bool 
      [not] -R- T = F
      [not] -R- F = T
    retTy :E: (_x1 :E: Bool) -> Type 
      [retTy] -E- T = Bool
      [retTy] -E- F = Unit
    main :R: Bool = not -R- 
      let f :R: (x :R: Bool) -> (_x2 :R: retTy -E- x) -> retTy -E- x 
        [f] -R- F -R- MkUnit = MkUnit
        x :R: Bool
          [f] -R- T -R- x = not -R- x
      in f -R- (not -R- F) -R- T
  in main

### Final annotation ###

  let
    constructor Bool :E: Type
    constructor T :R: Bool
    constructor F :R: Bool
    constructor Unit :E: Type
    constructor MkUnit :R: Unit
    not :R: (_x0 :R: Bool) -> Bool 
      [not] -R- T = F
      [not] -R- F = T
    retTy :E: (_x1 :E: Bool) -> Type 
      [retTy] -E- T = Bool
      [retTy] -E- F = Unit
    main :R: Bool = not -R- 
      let f :R: (x :R: Bool) -> (_x2 :R: retTy -E- x) -> retTy -E- x 
        [f] -R- F -R- MkUnit = MkUnit
        x :R: Bool
          [f] -R- T -R- x = not -R- x
      in f -R- (not -R- F) -R- T
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor T : Bool
    constructor F : Bool
    constructor MkUnit : Unit
    not 
      [_] T = F
      [_] F = T
    main = not 
      let f 
        [_] F MkUnit = MkUnit
        [_] T x = not x
      in f (not F) T
  in main

### Intermediate representation ###

let T = constructor 0
  in let F = constructor 0
    in let MkUnit = constructor 0
      in let not = \_pv0.
        case _pv0 of
          F => T
          T => F
        in let main = (not let f = \_pv0. \_pv1.
          case _pv0 of
            F => MkUnit
            T => (not _pv1)
          in ((f (not F)) T))
          in main

### Normal forms ###

unerased:
  
  let
    constructor Bool : Type
    constructor T : Bool
  in T

erased:
  
  let constructor T : Bool
  in T

