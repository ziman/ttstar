-- vim: ft=ttstar

### Desugared ###

  let
    constructor N : Type
    constructor Z : N
    constructor S : (x :R: N) -> N
    constructor Vec : (_x0 : N) -> (_x1 : Type) -> Type
    constructor Nil : (a : Type) -> Vec Z a
    constructor Cons : (a : Type) -> (n : N) -> (x :R: a) -> (xs :R: Vec n a) -> Vec (S n) a
    vlen : (n : N) -> (xs : Vec n N) -> N 
      [vlen] [Z] (Nil [N]) = Z
      m : N y : N ys : Vec m N
        [vlen] ([S] m) (Cons [N] [m] y ys) = S (vlen m ys)
    main : N = vlen 1 (Cons N Z 3 (Nil N))
  in main

### Evarified ###

  let
    constructor N :1: Type
    constructor Z :2: N
    constructor S :3: (x :R: N) -> N
    constructor Vec :4: (_x0 :5: N) -> (_x1 :6: Type) -> Type
    constructor Nil :7: (a :8: Type) -> Vec -10- Z -9- a
    constructor Cons :11: (a :12: Type) -> (n :13: N) -> (x :R: a) -> (xs :R: Vec -15- n -14- a) -> Vec -17- (S -18- n) -16- a
    vlen :19: (n :20: N) -> (xs :21: Vec -23- n -22- N) -> N 
      [vlen] -25- [Z] -24- (Nil -26- [N]) = Z
      m :27: N y :28: N ys :29: Vec -31- m -30- N
        [vlen] -33- ([S] -34- m) -32- (Cons -38- [N] -37- [m] -36- y -35- ys) = S -39- (vlen -41- m -40- ys)
    main :42: N = vlen -44- 1 -43- (Cons -49- N -48- Z -47- 3 -46- (Nil -53- N))
  in main

### Constraints ###

[8,24] -> [26]
[8,43,46] -> [53]
[9,24] -> [22]
[9,43,46] -> [14]
[10,24] -> [23]
[10,43,46] -> [15]
[12,32] -> [38]
[12,43] -> [49]
[13,32] -> [37]
[13,43] -> [48]
[14,35] -> [30]
[14,43,46] -> [9]
[15,35] -> [31]
[15,43,46] -> [10]
[16,32] -> [22]
[16,43] -> [22]
[17,18,32] -> [34]
[17,18,43] -> [45]
[17,32] -> [23]
[17,32,34] -> [18]
[17,43] -> [23]
[17,43,45] -> [18]
[20] -> [44]
[20,39] -> [41]
[20,R] -> [25,33]
[21] -> [43]
[21,39] -> [40]
[21,R] -> [24,32]
[22,24] -> [9]
[22,32] -> [16]
[22,39,40] -> [30]
[22,43] -> [16]
[23,24] -> [10]
[23,32] -> [17]
[23,39,40] -> [31]
[23,43] -> [17]
[24] -> [R]
[24,26] -> [8]
[24,R] -> [21]
[25] -> [R]
[25,R] -> [2,20]
[26] -> [24]
[26,R] -> [1]
[27] -> [34]
[28] -> [36]
[29] -> [35]
[30,35] -> [14]
[30,39,40] -> [22]
[31,35] -> [15]
[31,39,40] -> [23]
[32] -> [R]
[32,35] -> [R]
[32,36] -> [R]
[32,37] -> [13]
[32,38] -> [12]
[32,R] -> [21,35,36]
[33] -> [R]
[33,34] -> [R]
[33,R] -> [3,20,34]
[34] -> [33]
[35] -> [32]
[36] -> [32]
[37] -> [32]
[37,R] -> [27]
[38] -> [32]
[38,R] -> [1]
[39] -> [R]
[39,40] -> [21]
[39,40,R] -> [29]
[39,41] -> [20]
[39,41,R] -> [27]
[39,R] -> [19]
[43] -> [21]
[43,46] -> [R]
[43,46,53] -> [8]
[43,46,53,R] -> [1]
[43,46,R] -> [7]
[43,47] -> [R]
[43,47,50] -> [R]
[43,47,50,51] -> [R]
[43,47,50,51,52] -> [R]
[43,47,50,51,52,R] -> [2]
[43,47,50,51,R] -> [3,52]
[43,47,50,R] -> [3,51]
[43,47,R] -> [3,50]
[43,48] -> [13]
[43,48,R] -> [2]
[43,49] -> [12]
[43,49,R] -> [1]
[43,R] -> [11,46,47]
[44] -> [20]
[44,45] -> [R]
[44,45,R] -> [2]
[44,R] -> [3,45]
[R] -> [2,3,7,11,19,24,32,39,42]

### Solution ###

[2,3,7,11,19,21,24,29,32,35,36,39,40,42,43,46,47,50,51,52,R]

### Annotated ###

  let
    constructor N :E: Type
    constructor Z :R: N
    constructor S :R: (x :R: N) -> N
    constructor Vec :E: (_x0 :E: N) -> (_x1 :E: Type) -> Type
    constructor Nil :R: (a :E: Type) -> Vec -E- Z -E- a
    constructor Cons :R: (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
    vlen :R: (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N 
      [vlen] -E- [Z] -R- (Nil -E- [N]) = Z
      m :E: N y :E: N ys :R: Vec -E- m -E- N
        [vlen] -E- ([S] -E- m) -R- (Cons -E- [N] -E- [m] -R- y -R- ys) = S -R- (vlen -E- m -R- ys)
    main :R: N = vlen -E- 1 -R- (Cons -E- N -E- Z -R- 3 -R- (Nil -E- N))
  in main

### Specialised ###

  let
    constructor N :E: Type
    constructor Z :R: N
    constructor S :R: (x :R: N) -> N
    constructor Vec :E: (_x0 :E: N) -> (_x1 :E: Type) -> Type
    constructor Nil :R: (a :E: Type) -> Vec -E- Z -E- a
    constructor Cons :R: (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
    vlen :R: (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N 
      [vlen] -E- [Z] -R- (Nil -E- [N]) = Z
      m :E: N y :E: N ys :R: Vec -E- m -E- N
        [vlen] -E- ([S] -E- m) -R- (Cons -E- [N] -E- [m] -R- y -R- ys) = S -R- (vlen -E- m -R- ys)
    main :R: N = vlen -E- 1 -R- (Cons -E- N -E- Z -R- 3 -R- (Nil -E- N))
  in main

### Final annotation ###

  let
    constructor N :E: Type
    constructor Z :R: N
    constructor S :R: (x :R: N) -> N
    constructor Vec :E: (_x0 :E: N) -> (_x1 :E: Type) -> Type
    constructor Nil :R: (a :E: Type) -> Vec -E- Z -E- a
    constructor Cons :R: (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
    vlen :R: (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N 
      [vlen] -E- [Z] -R- (Nil -E- [N]) = Z
      m :E: N y :E: N ys :R: Vec -E- m -E- N
        [vlen] -E- ([S] -E- m) -R- (Cons -E- [N] -E- [m] -R- y -R- ys) = S -R- (vlen -E- m -R- ys)
    main :R: N = vlen -E- 1 -R- (Cons -E- N -E- Z -R- 3 -R- (Nil -E- N))
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor Z : N
    constructor S : (x) -> N
    constructor Nil : Vec
    constructor Cons : (x) -> (xs) -> Vec
    vlen 
      [_] Nil = Z
      [_] (Cons _ ys) = S (vlen ys)
    main = vlen (Cons 3 Nil)
  in main

### Normal forms ###

unerased:
  
  let
    constructor N : Type
    constructor Z : N
    constructor S : (x :R: N) -> N
  in 1

erased:
  
  let
    constructor Z : N
    constructor S : (x) -> N
  in 1

