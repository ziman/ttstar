-- vim: ft=ttstar

### Desugared ###

  let
    constructor T : Type
    constructor A : T
    constructor B : T
    postulate Op : (x :R: T) -> (y :R: T) -> T
    id : (y : T) -> T = (\y : T. y)
    constA : (x : T) -> T = (\x : T. A)
    apply : (f : (_x0 : T) -> T) -> (x : T) -> T = (\f : (_x0 : T) -> T. (\x : T. f x))
    test1 : T = [apply : (_x1 : (_x2 : T) -> T) -> (_x3 : T) -> T] id B
    test2 : T = [apply : (_x4 : (_x5 : T) -> T) -> (_x6 : T) -> T] constA B
    main : T = Op test1 test2
  in main

### Evarified ###

  let
    constructor T :1: Type
    constructor A :2: T
    constructor B :3: T
    postulate Op :4: (x :R: T) -> (y :R: T) -> T
    id :5: (y :6: T) -> T = (\y :7: T. y)
    constA :8: (x :9: T) -> T = (\x :10: T. A)
    apply :11: (f :12: (_x0 :13: T) -> T) -> (x :14: T) -> T = (\f :15: (_x0 :16: T) -> T. (\x :17: T. f -18- x))
    test1 :19: T = [apply : (_x1 :22: (_x2 :23: T) -> T) -> (_x3 :24: T) -> T] -21- id -20- B
    test2 :25: T = [apply : (_x4 :28: (_x5 :29: T) -> T) -> (_x6 :30: T) -> T] -27- constA -26- B
    main :31: T = Op -33- test1 -32- test2
  in main

### Constraints ###

[6,21,33] -> [7,23]
[7,21,33] -> [6]
[9,27,32] -> [10,29]
[10,27,32] -> [9]
[20,33] -> [24]
[20,33,R] -> [3]
[21,23,33] -> [6]
[21,33] -> [22]
[21,33,R] -> [5,7]
[22,33] -> [21,35]
[23,33,35] -> [36]
[24,33] -> [20,37]
[26,32] -> [30]
[26,32,R] -> [3]
[27,29,32] -> [9]
[27,32] -> [28]
[27,32,R] -> [2,8]
[28,32] -> [27,43]
[29,32,43] -> [44]
[30,32] -> [26,45]
[32] -> [R]
[32,43] -> [28,46]
[32,43,44] -> [29,47]
[32,43,47] -> [44]
[32,45] -> [30,48]
[32,46] -> [43]
[32,47] -> [49]
[32,48] -> [45]
[32,49] -> [47]
[32,49,R] -> [48]
[32,R] -> [25,42,46]
[33] -> [R]
[33,35] -> [22,38]
[33,35,36] -> [23,39]
[33,35,39] -> [36]
[33,37] -> [24,40]
[33,38] -> [35]
[33,39] -> [41]
[33,40] -> [37]
[33,41] -> [39]
[33,41,R] -> [40]
[33,R] -> [19,34,38]
[R] -> [4,31,32,33]

### Solution ###

[2,3,4,5,6,7,8,19,20,21,22,23,24,25,27,28,31,32,33,34,35,36,37,38,39,40,41,42,43,46,R]

### Annotated ###

  let
    constructor T :E: Type
    constructor A :R: T
    constructor B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (y :R: T) -> T = (\y :R: T. y)
    constA :R: (x :E: T) -> T = (\x :E: T. A)
    apply :E: (f :E: (_x0 :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_x0 :E: T) -> T. (\x :E: T. f -E- x))
    test1 :R: T = [apply : (_x1 :R: (_x2 :R: T) -> T) -> (_x3 :R: T) -> T] -R- id -R- B
    test2 :R: T = [apply : (_x4 :R: (_x5 :E: T) -> T) -> (_x6 :E: T) -> T] -R- constA -E- B
    main :R: T = Op -R- test1 -R- test2
  in main

### Specialised ###

  let
    constructor T :E: Type
    constructor A :R: T
    constructor B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (y :R: T) -> T = (\y :R: T. y)
    constA :R: (x :E: T) -> T = (\x :E: T. A)
    apply :E: (f :E: (_x0 :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_x0 :E: T) -> T. (\x :E: T. f -E- x))
    apply_REE :34: (f :R: (_x0 :E: T) -> T) -> (x :E: T) -> T = (\f :35: (_x0 :36: T) -> T. (\x :37: T. f -38- x))
    apply_RRR :39: (f :R: (_x0 :R: T) -> T) -> (x :R: T) -> T = (\f :40: (_x0 :41: T) -> T. (\x :42: T. f -43- x))
    test1 :R: T = apply_RRR -R- id -R- B
    test2 :R: T = apply_REE -R- constA -E- B
    main :R: T = Op -R- test1 -R- test2
  in main

### Constraints ###

[35,R] -> [R]
[36,R] -> [38,E]
[37,R] -> [E]
[38,R] -> [36,37]
[40,R] -> [R]
[41,R] -> [43,R]
[42,R] -> [R]
[43,R] -> [41,42]
[E,R] -> [36,37,E,R]
[R] -> [34,35,39,40,41,42,R]

### Solution ###

[34,35,39,40,41,42,43,R]

### Annotated ###

  let
    constructor T :E: Type
    constructor A :R: T
    constructor B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (y :R: T) -> T = (\y :R: T. y)
    constA :R: (x :E: T) -> T = (\x :E: T. A)
    apply :E: (f :E: (_x0 :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_x0 :E: T) -> T. (\x :E: T. f -E- x))
    apply_REE :R: (f :R: (_x0 :E: T) -> T) -> (x :E: T) -> T = (\f :R: (_x0 :E: T) -> T. (\x :E: T. f -E- x))
    apply_RRR :R: (f :R: (_x0 :R: T) -> T) -> (x :R: T) -> T = (\f :R: (_x0 :R: T) -> T. (\x :R: T. f -R- x))
    test1 :R: T = apply_RRR -R- id -R- B
    test2 :R: T = apply_REE -R- constA -E- B
    main :R: T = Op -R- test1 -R- test2
  in main

### Specialised ###

  let
    constructor T :E: Type
    constructor A :R: T
    constructor B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (y :R: T) -> T = (\y :R: T. y)
    constA :R: (x :E: T) -> T = (\x :E: T. A)
    apply :E: (f :E: (_x0 :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_x0 :E: T) -> T. (\x :E: T. f -E- x))
    apply_REE :R: (f :R: (_x0 :E: T) -> T) -> (x :E: T) -> T = (\f :R: (_x0 :E: T) -> T. (\x :E: T. f -E- x))
    apply_RRR :R: (f :R: (_x0 :R: T) -> T) -> (x :R: T) -> T = (\f :R: (_x0 :R: T) -> T. (\x :R: T. f -R- x))
    test1 :R: T = apply_RRR -R- id -R- B
    test2 :R: T = apply_REE -R- constA -E- B
    main :R: T = Op -R- test1 -R- test2
  in main

### Final annotation ###

  let
    constructor T :E: Type
    constructor A :R: T
    constructor B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (y :R: T) -> T = (\y :R: T. y)
    constA :R: (x :E: T) -> T = (\x :E: T. A)
    apply :E: (f :E: (_x0 :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_x0 :E: T) -> T. (\x :E: T. f -E- x))
    apply_REE :R: (f :R: (_x0 :E: T) -> T) -> (x :E: T) -> T = (\f :R: (_x0 :E: T) -> T. (\x :E: T. f -E- x))
    apply_RRR :R: (f :R: (_x0 :R: T) -> T) -> (x :R: T) -> T = (\f :R: (_x0 :R: T) -> T. (\x :R: T. f -R- x))
    test1 :R: T = apply_RRR -R- id -R- B
    test2 :R: T = apply_REE -R- constA -E- B
    main :R: T = Op -R- test1 -R- test2
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    constructor A : T
    constructor B : T
    postulate Op : (x) -> (y) -> T
    id = (\y. y)
    constA = A
    apply_REE = (\f. f)
    apply_RRR = (\f. (\x. f x))
    test1 = apply_RRR id B
    test2 = apply_REE constA
    main = Op test1 test2
  in main

### Normal forms ###

unerased:
  
  let
    constructor T : Type
    constructor A : T
    constructor B : T
    postulate Op : (x :R: T) -> (y :R: T) -> T
  in Op B A

erased:
  
  let
    constructor A : T
    constructor B : T
    postulate Op : (x) -> (y) -> T
  in Op B A

