-- vim: ft=agda

### Desugared ###

  let
    postulate Bool : Type
    postulate True : Bool
    postulate False : Bool
    postulate Foo : (_ : Bool) -> Type
    postulate Yeah : Foo True
    postulate Nope : Foo False
    postulate Maybe : (_ : Type) -> Type
    postulate Nothing : (a : Type) -> Maybe a
    postulate Just : (a : Type) -> (x : a) -> Maybe a
    f : (x : Maybe Bool) -> Bool = \(x : Maybe Bool).
      case x of
        Just (a : Type) (b : Bool)
          | a = Bool
          => b
        Nothing (a : Type)
          | a = Bool
          => False
    g : (x : Maybe Bool) -> Foo (f x) = \(x : Maybe Bool).
      case x of
        Just (a : Type) (b : Bool)
          | a = Bool
          => case b of
            True
              => Yeah
            False
              => Nope
        Nothing (a : Type)
          | a = Bool
          => Nope
    main : Foo True = g (Just Bool True)
  in main

### Metaified ###

  let
    postulate Bool :1: Type
    postulate True :2: Bool
    postulate False :3: Bool
    postulate Foo :4: (_ :5: Bool) -> Type
    postulate Yeah :6: Foo -7- True
    postulate Nope :8: Foo -9- False
    postulate Maybe :10: (_ :11: Type) -> Type
    postulate Nothing :12: (a :13: Type) -> Maybe -14- a
    postulate Just :15: (a :16: Type) -> (x :17: a) -> Maybe -18- a
    f :19: (x :20: Maybe -21- Bool) -> Bool = \(x :22: Maybe -23- Bool).
      case -24- x of
        Just/25 (a :26: Type) (b :27: Bool)
          | a = Bool
          => b
        Nothing/28 (a :29: Type)
          | a = Bool
          => False
    g :30: (x :31: Maybe -32- Bool) -> Foo -33- (f -34- x) = \(x :35: Maybe -36- Bool).
      case -37- x of
        Just/38 (a :39: Type) (b :40: Bool)
          | a = Bool
          => case -41- b of
            True/42
              => Yeah
            False/43
              => Nope
        Nothing/44 (a :45: Type)
          | a = Bool
          => Nope
    main :46: Foo -47- True = g -48- (Just -50- Bool -49- True)
  in main

### Constraints ###

[] -> [2,6,8,15,17,30,31,35,37,38,40,41,42,48,49,R]
[3] -> [43]
[7] -> [33]
[9] -> [33]
[12] -> [44]
[13] -> [45]
[14] -> [32]
[16] -> [1,39,50]
[18] -> [32]
[32] -> [14,18]
[33] -> [7,9,47]
[39] -> [16]
[43] -> [3]
[44] -> [12]
[45] -> [13]
[47] -> [33]
[50] -> [16]
[R] -> [46]

### Solution ###

[2,6,8,15,17,30,31,35,37,38,40,41,42,46,48,49,R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate True :R: Bool
    postulate False :E: Bool
    postulate Foo :E: (_ :E: Bool) -> Type
    postulate Yeah :R: Foo -E- True
    postulate Nope :R: Foo -E- False
    postulate Maybe :E: (_ :E: Type) -> Type
    postulate Nothing :E: (a :E: Type) -> Maybe -E- a
    postulate Just :R: (a :E: Type) -> (x :R: a) -> Maybe -E- a
    f :E: (x :E: Maybe -E- Bool) -> Bool = \(x :E: Maybe -E- Bool).
      case -E- x of
        Just/E (a :E: Type) (b :E: Bool)
          | a = Bool
          => b
        Nothing/E (a :E: Type)
          | a = Bool
          => False
    g :R: (x :R: Maybe -E- Bool) -> Foo -E- (f -E- x) = \(x :R: Maybe -E- Bool).
      case -R- x of
        Just/R (a :E: Type) (b :R: Bool)
          | a = Bool
          => case -R- b of
            True/R
              => Yeah
            False/E
              => Nope
        Nothing/E (a :E: Type)
          | a = Bool
          => Nope
    main :R: Foo -E- True = g -R- (Just -E- Bool -R- True)
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate True :R: Bool
    postulate False :E: Bool
    postulate Foo :E: (_ :E: Bool) -> Type
    postulate Yeah :R: Foo -E- True
    postulate Nope :R: Foo -E- False
    postulate Maybe :E: (_ :E: Type) -> Type
    postulate Nothing :E: (a :E: Type) -> Maybe -E- a
    postulate Just :R: (a :E: Type) -> (x :R: a) -> Maybe -E- a
    f :E: (x :E: Maybe -E- Bool) -> Bool = \(x :E: Maybe -E- Bool).
      case -E- x of
        Just/E (a :E: Type) (b :E: Bool)
          | a = Bool
          => b
        Nothing/E (a :E: Type)
          | a = Bool
          => False
    g :R: (x :R: Maybe -E- Bool) -> Foo -E- (f -E- x) = \(x :R: Maybe -E- Bool).
      case -R- x of
        Just/R (a :E: Type) (b :R: Bool)
          | a = Bool
          => case -R- b of
            True/R
              => Yeah
            False/E
              => Nope
        Nothing/E (a :E: Type)
          | a = Bool
          => Nope
    main :R: Foo -E- True = g -R- (Just -E- Bool -R- True)
  in main

### Constraints ###

[E] -> [E]
[R] -> [R]

### Solution ###

[R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate True :R: Bool
    postulate False :E: Bool
    postulate Foo :E: (_ :E: Bool) -> Type
    postulate Yeah :R: Foo -E- True
    postulate Nope :R: Foo -E- False
    postulate Maybe :E: (_ :E: Type) -> Type
    postulate Nothing :E: (a :E: Type) -> Maybe -E- a
    postulate Just :R: (a :E: Type) -> (x :R: a) -> Maybe -E- a
    f :E: (x :E: Maybe -E- Bool) -> Bool = \(x :E: Maybe -E- Bool).
      case -E- x of
        Just/E (a :E: Type) (b :E: Bool)
          | a = Bool
          => b
        Nothing/E (a :E: Type)
          | a = Bool
          => False
    g :R: (x :R: Maybe -E- Bool) -> Foo -E- (f -E- x) = \(x :R: Maybe -E- Bool).
      case -R- x of
        Just/R (a :E: Type) (b :R: Bool)
          | a = Bool
          => case -R- b of
            True/R
              => Yeah
            False/E
              => Nope
        Nothing/E (a :E: Type)
          | a = Bool
          => Nope
    main :R: Foo -E- True = g -R- (Just -E- Bool -R- True)
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate True :R: Bool
    postulate False :E: Bool
    postulate Foo :E: (_ :E: Bool) -> Type
    postulate Yeah :R: Foo -E- True
    postulate Nope :R: Foo -E- False
    postulate Maybe :E: (_ :E: Type) -> Type
    postulate Nothing :E: (a :E: Type) -> Maybe -E- a
    postulate Just :R: (a :E: Type) -> (x :R: a) -> Maybe -E- a
    f :E: (x :E: Maybe -E- Bool) -> Bool = \(x :E: Maybe -E- Bool).
      case -E- x of
        Just/E (a :E: Type) (b :E: Bool)
          | a = Bool
          => b
        Nothing/E (a :E: Type)
          | a = Bool
          => False
    g :R: (x :R: Maybe -E- Bool) -> Foo -E- (f -E- x) = \(x :R: Maybe -E- Bool).
      case -R- x of
        Just/R (a :E: Type) (b :R: Bool)
          | a = Bool
          => case -R- b of
            True/R
              => Yeah
            False/E
              => Nope
        Nothing/E (a :E: Type)
          | a = Bool
          => Nope
    main :R: Foo -E- True = g -R- (Just -E- Bool -R- True)
  in main

### Final annotation ###

  let
    postulate Bool :E: Type
    postulate True :R: Bool
    postulate False :E: Bool
    postulate Foo :E: (_ :E: Bool) -> Type
    postulate Yeah :R: Foo -E- True
    postulate Nope :R: Foo -E- False
    postulate Maybe :E: (_ :E: Type) -> Type
    postulate Nothing :E: (a :E: Type) -> Maybe -E- a
    postulate Just :R: (a :E: Type) -> (x :R: a) -> Maybe -E- a
    f :E: (x :E: Maybe -E- Bool) -> Bool = \(x :E: Maybe -E- Bool).
      case -E- x of
        Just/E (a :E: Type) (b :E: Bool)
          | a = Bool
          => b
        Nothing/E (a :E: Type)
          | a = Bool
          => False
    g :R: (x :R: Maybe -E- Bool) -> Foo -E- (f -E- x) = \(x :R: Maybe -E- Bool).
      case -R- x of
        Just/R (a :E: Type) (b :R: Bool)
          | a = Bool
          => case -R- b of
            True/R
              => Yeah
            False/E
              => Nope
        Nothing/E (a :E: Type)
          | a = Bool
          => Nope
    main :R: Foo -E- True = g -R- (Just -E- Bool -R- True)
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate True : Bool
    postulate Yeah : Foo
    postulate Nope : Foo
    postulate Just : (x) -> Maybe
    g = \x.
      case x of
        Just b
          => case b of
            True
              => Yeah
    main = g (Just True)
  in main

### Normal forms ###

unerased:
  
  let postulate Yeah : Foo True
  in Yeah

erased:
  
  let postulate Yeah : Foo
  in Yeah

