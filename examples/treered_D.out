-- vim: ft=idris

### Desugared ###

  let
    postulate Bool : Type
    postulate True : Bool
    postulate False : Bool
    postulate Foo : (_x0 : Bool) -> Type
    postulate Yeah : Foo True
    postulate Nope : Foo False
    postulate Maybe : (_x1 : Type) -> Type
    postulate Nothing : (a : Type) -> Maybe a
    postulate Just : (a : Type) -> (x : a) -> Maybe a
    f : (x : Maybe Bool) -> Bool = \(x : Maybe Bool).
      case x of
        Just (a : Type) (b : Bool) =>
          case a of [Bool] =>
            b
        Nothing (a : Type) =>
          case a of [Bool] =>
            False
    g : (x : Maybe Bool) -> Foo (f x) = \(x : Maybe Bool).
      case x of
        Just (a : Type) (b : Bool) =>
          case a of [Bool] =>
            case b of
              True =>
                Yeah
              False =>
                Nope
        Nothing (a : Type) =>
          case a of [Bool] =>
            Nope
    main : Foo True = g (Just Bool True)
  in main

### Metaified ###

  let
    postulate Bool :1: Type
    postulate True :2: Bool
    postulate False :3: Bool
    postulate Foo :4: (_x0 :5: Bool) -> Type
    postulate Yeah :6: Foo -7- True
    postulate Nope :8: Foo -9- False
    postulate Maybe :10: (_x1 :11: Type) -> Type
    postulate Nothing :12: (a :13: Type) -> Maybe -14- a
    postulate Just :15: (a :16: Type) -> (x :17: a) -> Maybe -18- a
    f :19: (x :20: Maybe -21- Bool) -> Bool = \(x :22: Maybe -23- Bool).
      case -24- x of
        Just/25 (a :26: Type) (b :27: Bool) =>
          case -28- a of [Bool] =>
            b
        Nothing/29 (a :30: Type) =>
          case -31- a of [Bool] =>
            False
    g :32: (x :33: Maybe -34- Bool) -> Foo -35- (f -36- x) = \(x :37: Maybe -38- Bool).
      case -39- x of
        Just/40 (a :41: Type) (b :42: Bool) =>
          case -43- a of [Bool] =>
            case -44- b of
              True/45 =>
                Yeah
              False/46 =>
                Nope
        Nothing/47 (a :48: Type) =>
          case -49- a of [Bool] =>
            Nope
    main :50: Foo -51- True = g -52- (Just -54- Bool -53- True)
  in main

### Constraints ###

[] -> [2,6,8,15,17,32,33,37,39,40,42,44,45,52,53,R]
[3] -> [46]
[7] -> [35]
[9] -> [35]
[12] -> [47]
[13] -> [48]
[14] -> [34]
[16] -> [1,41,54]
[18] -> [34]
[34] -> [14,18]
[35] -> [7,9,51]
[41] -> [16]
[43] -> [41]
[46] -> [3]
[47] -> [12]
[48] -> [13]
[49] -> [48]
[51] -> [35]
[54] -> [16]
[R] -> [50]

### Solution ###

[2,6,8,15,17,32,33,37,39,40,42,44,45,50,52,53,R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate True :R: Bool
    postulate False :E: Bool
    postulate Foo :E: (_x0 :E: Bool) -> Type
    postulate Yeah :R: Foo -E- True
    postulate Nope :R: Foo -E- False
    postulate Maybe :E: (_x1 :E: Type) -> Type
    postulate Nothing :E: (a :E: Type) -> Maybe -E- a
    postulate Just :R: (a :E: Type) -> (x :R: a) -> Maybe -E- a
    f :E: (x :E: Maybe -E- Bool) -> Bool = \(x :E: Maybe -E- Bool).
      case -E- x of
        Just/E (a :E: Type) (b :E: Bool) =>
          case -E- a of [Bool] =>
            b
        Nothing/E (a :E: Type) =>
          case -E- a of [Bool] =>
            False
    g :R: (x :R: Maybe -E- Bool) -> Foo -E- (f -E- x) = \(x :R: Maybe -E- Bool).
      case -R- x of
        Just/R (a :E: Type) (b :R: Bool) =>
          case -E- a of [Bool] =>
            case -R- b of
              True/R =>
                Yeah
              False/E =>
                Nope
        Nothing/E (a :E: Type) =>
          case -E- a of [Bool] =>
            Nope
    main :R: Foo -E- True = g -R- (Just -E- Bool -R- True)
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate True :R: Bool
    postulate False :E: Bool
    postulate Foo :E: (_x0 :E: Bool) -> Type
    postulate Yeah :R: Foo -E- True
    postulate Nope :R: Foo -E- False
    postulate Maybe :E: (_x1 :E: Type) -> Type
    postulate Nothing :E: (a :E: Type) -> Maybe -E- a
    postulate Just :R: (a :E: Type) -> (x :R: a) -> Maybe -E- a
    f :E: (x :E: Maybe -E- Bool) -> Bool = \(x :E: Maybe -E- Bool).
      case -E- x of
        Just/E (a :E: Type) (b :E: Bool) =>
          case -E- a of [Bool] =>
            b
        Nothing/E (a :E: Type) =>
          case -E- a of [Bool] =>
            False
    g :R: (x :R: Maybe -E- Bool) -> Foo -E- (f -E- x) = \(x :R: Maybe -E- Bool).
      case -R- x of
        Just/R (a :E: Type) (b :R: Bool) =>
          case -E- a of [Bool] =>
            case -R- b of
              True/R =>
                Yeah
              False/E =>
                Nope
        Nothing/E (a :E: Type) =>
          case -E- a of [Bool] =>
            Nope
    main :R: Foo -E- True = g -R- (Just -E- Bool -R- True)
  in main

### Final annotation ###

  let
    postulate Bool :E: Type
    postulate True :R: Bool
    postulate False :E: Bool
    postulate Foo :E: (_x0 :E: Bool) -> Type
    postulate Yeah :R: Foo -E- True
    postulate Nope :R: Foo -E- False
    postulate Maybe :E: (_x1 :E: Type) -> Type
    postulate Nothing :E: (a :E: Type) -> Maybe -E- a
    postulate Just :R: (a :E: Type) -> (x :R: a) -> Maybe -E- a
    f :E: (x :E: Maybe -E- Bool) -> Bool = \(x :E: Maybe -E- Bool).
      case -E- x of
        Just/E (a :E: Type) (b :E: Bool) =>
          case -E- a of [Bool] =>
            b
        Nothing/E (a :E: Type) =>
          case -E- a of [Bool] =>
            False
    g :R: (x :R: Maybe -E- Bool) -> Foo -E- (f -E- x) = \(x :R: Maybe -E- Bool).
      case -R- x of
        Just/R (a :E: Type) (b :R: Bool) =>
          case -E- a of [Bool] =>
            case -R- b of
              True/R =>
                Yeah
              False/E =>
                Nope
        Nothing/E (a :E: Type) =>
          case -E- a of [Bool] =>
            Nope
    main :R: Foo -E- True = g -R- (Just -E- Bool -R- True)
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate True : Bool
    postulate Yeah : Foo
    postulate Nope : Foo
    postulate Just : (x) -> Maybe
    g = \x.
      case x of
        Just b =>
          case b of
            True =>
              Yeah
    main = g (Just True)
  in main

### Normal forms ###

unerased:
  
  let postulate Yeah : Foo True
  in Yeah

erased:
  
  let postulate Yeah : Foo
  in Yeah

