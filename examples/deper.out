-- vim: ft=agda

### Desugared ###

  let
    postulate Bool : Type
    postulate T : Bool
    postulate F : Bool
    postulate TwoBools : Type
    postulate TB : (x :R: Bool) -> (y :R: Bool) -> TwoBools
    id : (x : Bool) -> Bool = (\x : Bool. x)
    constT : (_ : Bool) -> Bool = (\_ : Bool. T)
    fty : (x : Bool) -> Type = \(x : Bool).
      case x of
        T
          => (_ : Bool) -> Bool
        F
          => (_ : Bool) -> Bool
    f : (x : Bool) -> fty x = \(x : Bool).
      case x of
        T
          => id
        F
          => constT
    main :R: TwoBools = TB (f T F) (f F F)
  in main

### Metaified ###

  let
    postulate Bool :1: Type
    postulate T :2: Bool
    postulate F :3: Bool
    postulate TwoBools :4: Type
    postulate TB :5: (x :R: Bool) -> (y :R: Bool) -> TwoBools
    id :6: (x :7: Bool) -> Bool = (\x :8: Bool. x)
    constT :9: (_ :10: Bool) -> Bool = (\_ :11: Bool. T)
    fty :12: (x :13: Bool) -> Type = \(x :14: Bool).
      case -15- x of
        T/16
          => (_ :17: Bool) -> Bool
        F/18
          => (_ :19: Bool) -> Bool
    f :20: (x :21: Bool) -> fty -22- x = \(x :23: Bool).
      case -24- x of
        T/25
          => id
        F/26
          => constT
    main :R: TwoBools = TB -28- (f -30- T -29- F) -27- (f -32- F -31- F)
  in main

### Constraints ###

[] -> [2,3,5,6,7,8,9,17,20,21,23,24,25,26,27,28,29,30,32,R]
[10] -> [11,19]
[11] -> [10]
[19] -> [10,31]
[31] -> [19]
[R] -> [R]

### Solution ###

[2,3,5,6,7,8,9,17,20,21,23,24,25,26,27,28,29,30,32,R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate TwoBools :E: Type
    postulate TB :R: (x :R: Bool) -> (y :R: Bool) -> TwoBools
    id :R: (x :R: Bool) -> Bool = (\x :R: Bool. x)
    constT :R: (_ :E: Bool) -> Bool = (\_ :E: Bool. T)
    fty :E: (x :E: Bool) -> Type = \(x :E: Bool).
      case -E- x of
        T/E
          => (_ :R: Bool) -> Bool
        F/E
          => (_ :E: Bool) -> Bool
    f :R: (x :R: Bool) -> fty -E- x = \(x :R: Bool).
      case -R- x of
        T/R
          => id
        F/R
          => constT
    main :R: TwoBools = TB -R- (f -R- T -R- F) -R- (f -R- F -E- F)
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate TwoBools :E: Type
    postulate TB :R: (x :R: Bool) -> (y :R: Bool) -> TwoBools
    id :R: (x :R: Bool) -> Bool = (\x :R: Bool. x)
    constT :R: (_ :E: Bool) -> Bool = (\_ :E: Bool. T)
    fty :E: (x :E: Bool) -> Type = \(x :E: Bool).
      case -E- x of
        T/E
          => (_ :R: Bool) -> Bool
        F/E
          => (_ :E: Bool) -> Bool
    f :R: (x :R: Bool) -> fty -E- x = \(x :R: Bool).
      case -R- x of
        T/R
          => id
        F/R
          => constT
    main :R: TwoBools = TB -R- (f -R- T -R- F) -R- (f -R- F -E- F)
  in main

### Constraints ###

[E] -> [E]
[R] -> [R]

### Solution ###

[R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate TwoBools :E: Type
    postulate TB :R: (x :R: Bool) -> (y :R: Bool) -> TwoBools
    id :R: (x :R: Bool) -> Bool = (\x :R: Bool. x)
    constT :R: (_ :E: Bool) -> Bool = (\_ :E: Bool. T)
    fty :E: (x :E: Bool) -> Type = \(x :E: Bool).
      case -E- x of
        T/E
          => (_ :R: Bool) -> Bool
        F/E
          => (_ :E: Bool) -> Bool
    f :R: (x :R: Bool) -> fty -E- x = \(x :R: Bool).
      case -R- x of
        T/R
          => id
        F/R
          => constT
    main :R: TwoBools = TB -R- (f -R- T -R- F) -R- (f -R- F -E- F)
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate TwoBools :E: Type
    postulate TB :R: (x :R: Bool) -> (y :R: Bool) -> TwoBools
    id :R: (x :R: Bool) -> Bool = (\x :R: Bool. x)
    constT :R: (_ :E: Bool) -> Bool = (\_ :E: Bool. T)
    fty :E: (x :E: Bool) -> Type = \(x :E: Bool).
      case -E- x of
        T/E
          => (_ :R: Bool) -> Bool
        F/E
          => (_ :E: Bool) -> Bool
    f :R: (x :R: Bool) -> fty -E- x = \(x :R: Bool).
      case -R- x of
        T/R
          => id
        F/R
          => constT
    main :R: TwoBools = TB -R- (f -R- T -R- F) -R- (f -R- F -E- F)
  in main

### Final annotation ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate TwoBools :E: Type
    postulate TB :R: (x :R: Bool) -> (y :R: Bool) -> TwoBools
    id :R: (x :R: Bool) -> Bool = (\x :R: Bool. x)
    constT :R: (_ :E: Bool) -> Bool = (\_ :E: Bool. T)
    fty :E: (x :E: Bool) -> Type = \(x :E: Bool).
      case -E- x of
        T/E
          => (_ :R: Bool) -> Bool
        F/E
          => (_ :E: Bool) -> Bool
    f :R: (x :R: Bool) -> fty -E- x = \(x :R: Bool).
      case -R- x of
        T/R
          => id
        F/R
          => constT
    main :R: TwoBools = TB -R- (f -R- T -R- F) -R- (f -R- F -E- F)
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate T : Bool
    postulate F : Bool
    postulate TB : (x) -> (y) -> TwoBools
    id = (\x. x)
    constT = T
    f = \x.
      case x of
        T
          => id
        F
          => constT
    main = TB (f T F) (f F)
  in main

### Normal forms ###

unerased:
  
  let
    postulate T : Bool
    postulate F : Bool
    postulate TB : (x :R: Bool) -> (y :R: Bool) -> TwoBools
  in TB F T

erased:
  
  let
    postulate T : Bool
    postulate F : Bool
    postulate TB : (x) -> (y) -> TwoBools
  in TB F T

