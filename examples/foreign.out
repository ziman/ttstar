-- vim: ft=idris

### Desugared ###

  let
    postulate N : Type
    postulate Z : N
    postulate S : (x :R: N) -> N
    postulate B : Type
    postulate T : B
    postulate F : B
    postulate List : Type
    postulate Cons : (_x0 : B) -> (_x1 : List) -> List
    postulate Nil : List
    not : (_x2 : B) -> B 
      [not] T = F
      [not] F = T
    foreign input : N
    genList : (_x3 : B) -> (_x4 : N) -> List 
      b : B
        [genList] b Z = Nil
      b : B n : N
        [genList] b (S n) = Cons b (genList (not b) n)
    postulate Eq : (a : Type) -> (_x5 : a) -> (_x6 : a) -> Type
    postulate Refl : (a : Type) -> (x : a) -> Eq a x x
    postulate Maybe : (_x7 : Type) -> Type
    postulate Nothing : (a : Type) -> Maybe a
    postulate Just : (a : Type) -> (x :R: a) -> Maybe a
    semiDecEqB : (x : B) -> (y : B) -> Maybe (Eq B x y) 
      [semiDecEqB] T T = Just (Eq B T T) (Refl B T)
      [semiDecEqB] F F = Just (Eq B F F) (Refl B F)
      [semiDecEqB] T F = Nothing (Eq B T F)
      [semiDecEqB] F T = Nothing (Eq B F T)
    semiDecEq : (xs : List) -> (ys : List) -> Maybe (Eq List xs ys) 
      b : B ys : List
        [semiDecEq] Nil (Cons b ys) = Nothing (Eq List Nil (Cons b ys))
      b : B xs : List
        [semiDecEq] (Cons b xs) Nil = Nothing (Eq List (Cons b xs) Nil)
      [semiDecEq] Nil Nil = Just (Eq List Nil Nil) (Refl List Nil)
      x : B y : B xs : List ys : List
        [semiDecEq] (Cons x xs) (Cons y ys) = 
          let semiDecEq' : (x : B) -> (y : B) -> (xs : List) -> (ys : List) -> (pfH : Maybe (Eq B x y)) -> (pfT : Maybe (Eq List xs ys)) -> Maybe (Eq List (Cons x xs) (Cons y ys)) 
            x : B y : B xs : List ys : List pfT : Maybe (Eq List xs ys)
              [semiDecEq'] x y xs ys (Nothing [Eq B x y]) pfT = Nothing (Eq List (Cons x xs) (Cons y ys))
            x : B y : B xs : List ys : List pfH : Maybe (Eq B x y)
              [semiDecEq'] x y xs ys pfH (Nothing [Eq List xs ys]) = Nothing (Eq List (Cons x xs) (Cons y ys))
            x : B xs : List
              [semiDecEq'] x [x] xs [xs] (Just [Eq B x x] [Refl B x]) (Just [Eq List xs xs] [Refl List xs]) = Just (Eq List (Cons x xs) (Cons x xs)) (Refl List (Cons x xs))
          in semiDecEq' x y xs ys (semiDecEqB x y) (semiDecEq xs ys)
    sampleList : List = genList T input
    main : Maybe (Eq List sampleList sampleList) 
      [main] = semiDecEq sampleList sampleList
  in main

### Evarified ###

  let
    postulate N :1: Type
    postulate Z :2: N
    postulate S :3: (x :R: N) -> N
    postulate B :4: Type
    postulate T :5: B
    postulate F :6: B
    postulate List :7: Type
    postulate Cons :8: (_x0 :9: B) -> (_x1 :10: List) -> List
    postulate Nil :11: List
    not :12: (_x2 :13: B) -> B 
      [not] -14- T = F
      [not] -15- F = T
    foreign input :16: N
    genList :17: (_x3 :18: B) -> (_x4 :19: N) -> List 
      b :20: B
        [genList] -22- b -21- Z = Nil
      b :23: B n :24: N
        [genList] -26- b -25- (S -27- n) = Cons -29- b -28- (genList -31- (not -32- b) -30- n)
    postulate Eq :33: (a :34: Type) -> (_x5 :35: a) -> (_x6 :36: a) -> Type
    postulate Refl :37: (a :38: Type) -> (x :39: a) -> Eq -42- a -41- x -40- x
    postulate Maybe :43: (_x7 :44: Type) -> Type
    postulate Nothing :45: (a :46: Type) -> Maybe -47- a
    postulate Just :48: (a :49: Type) -> (x :R: a) -> Maybe -50- a
    semiDecEqB :51: (x :52: B) -> (y :53: B) -> Maybe -54- (Eq -57- B -56- x -55- y) 
      [semiDecEqB] -59- T -58- T = Just -61- (Eq -64- B -63- T -62- T) -60- (Refl -66- B -65- T)
      [semiDecEqB] -68- F -67- F = Just -70- (Eq -73- B -72- F -71- F) -69- (Refl -75- B -74- F)
      [semiDecEqB] -77- T -76- F = Nothing -78- (Eq -81- B -80- T -79- F)
      [semiDecEqB] -83- F -82- T = Nothing -84- (Eq -87- B -86- F -85- T)
    semiDecEq :88: (xs :89: List) -> (ys :90: List) -> Maybe -91- (Eq -94- List -93- xs -92- ys) 
      b :95: B ys :96: List
        [semiDecEq] -98- Nil -97- (Cons -100- b -99- ys) = Nothing -101- (Eq -104- List -103- Nil -102- (Cons -106- b -105- ys))
      b :107: B xs :108: List
        [semiDecEq] -110- (Cons -112- b -111- xs) -109- Nil = Nothing -113- (Eq -116- List -115- (Cons -118- b -117- xs) -114- Nil)
      [semiDecEq] -120- Nil -119- Nil = Just -122- (Eq -125- List -124- Nil -123- Nil) -121- (Refl -127- List -126- Nil)
      x :128: B y :129: B xs :130: List ys :131: List
        [semiDecEq] -133- (Cons -135- x -134- xs) -132- (Cons -137- y -136- ys) = 
          let semiDecEq' :138: (x :139: B) -> (y :140: B) -> (xs :141: List) -> (ys :142: List) -> (pfH :143: Maybe -144- (Eq -147- B -146- x -145- y)) -> (pfT :148: Maybe -149- (Eq -152- List -151- xs -150- ys)) -> Maybe -153- (Eq -156- List -155- (Cons -158- x -157- xs) -154- (Cons -160- y -159- ys)) 
            x :161: B y :162: B xs :163: List ys :164: List pfT :165: Maybe -166- (Eq -169- List -168- xs -167- ys)
              [semiDecEq'] -175- x -174- y -173- xs -172- ys -171- (Nothing -176- [Eq -179- B -178- x -177- y]) -170- pfT = Nothing -180- (Eq -183- List -182- (Cons -185- x -184- xs) -181- (Cons -187- y -186- ys))
            x :188: B y :189: B xs :190: List ys :191: List pfH :192: Maybe -193- (Eq -196- B -195- x -194- y)
              [semiDecEq'] -202- x -201- y -200- xs -199- ys -198- pfH -197- (Nothing -203- [Eq -206- List -205- xs -204- ys]) = Nothing -207- (Eq -210- List -209- (Cons -212- x -211- xs) -208- (Cons -214- y -213- ys))
            x :215: B xs :216: List
              [semiDecEq'] -222- x -221- [x] -220- xs -219- [xs] -218- (Just -224- [Eq -227- B -226- x -225- x] -223- [Refl -229- B -228- x]) -217- (Just -231- [Eq -234- List -233- xs -232- xs] -230- [Refl -236- List -235- xs]) = Just -238- (Eq -241- List -240- (Cons -243- x -242- xs) -239- (Cons -245- x -244- xs)) -237- (Refl -247- List -246- (Cons -249- x -248- xs))
          in semiDecEq' -255- x -254- y -253- xs -252- ys -251- (semiDecEqB -257- x -256- y) -250- (semiDecEq -259- xs -258- ys)
    sampleList :260: List = genList -262- T -261- input
    main :263: Maybe -264- (Eq -267- List -266- sampleList -265- sampleList) 
      [main] = semiDecEq -269- sampleList -268- sampleList
  in main

### Constraints ###

[] -> [2,3,5,6,8,9,10,11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,30,31,32,37,45,48,51,52,53,58,59,60,67,68,69,76,77,82,83,88,89,90,97,98,99,100,105,106,109,110,111,112,117,118,119,120,121,128,129,130,131,132,133,134,135,136,137,138,143,148,157,158,159,160,170,171,184,185,186,187,197,198,211,212,213,214,217,218,223,230,237,242,243,244,245,248,249,250,251,256,257,258,259,260,261,262,263,268,269,R]
[34,46] -> [4,7,81,87,104,116,183,210]
[34,49] -> [4,7,64,73,125,241]
[34,176] -> [4,179]
[34,203] -> [7,206]
[34,224] -> [4,227]
[34,231] -> [7,234]
[35,46] -> [80,86,103,107,108,115,161,163,182,188,190,209]
[35,49] -> [63,72,124,215,216,240]
[35,176] -> [161,178]
[35,203] -> [190,205]
[35,224] -> [215,226]
[35,231] -> [216,233]
[36,46] -> [79,85,95,96,102,114,162,164,181,189,191,208]
[36,49] -> [62,71,123,215,216,239]
[36,176] -> [162,177]
[36,203] -> [191,204]
[36,224] -> [215,225]
[36,231] -> [216,232]
[38] -> [4,7,66,75,127,229,236,247]
[39] -> [65,74,126,215,216,228,235,246]
[40] -> [62,71,123,225,232,239]
[41] -> [63,72,124,226,233,240]
[42] -> [64,73,125,227,234,241]
[46] -> [33,78,84,101,113,176,180,203,207]
[46,79] -> [36]
[46,80] -> [35]
[46,81] -> [34]
[46,85] -> [36]
[46,86] -> [35]
[46,87] -> [34]
[46,102] -> [36]
[46,103] -> [35]
[46,104] -> [34]
[46,114] -> [36]
[46,115] -> [35]
[46,116] -> [34]
[46,181] -> [36]
[46,182] -> [35]
[46,183] -> [34]
[46,208] -> [36]
[46,209] -> [35]
[46,210] -> [34]
[47] -> [54,91,144,149,153]
[49] -> [33,61,70,122,224,231,238]
[49,62] -> [36]
[49,63] -> [35]
[49,64] -> [34]
[49,71] -> [36]
[49,72] -> [35]
[49,73] -> [34]
[49,123] -> [36]
[49,124] -> [35]
[49,125] -> [34]
[49,239] -> [36]
[49,240] -> [35]
[49,241] -> [34]
[50] -> [54,91,144,149,153]
[54] -> [47,50,144]
[55] -> [62,71,79,85,145]
[56] -> [63,72,80,86,146]
[57] -> [64,73,81,87,147]
[61] -> [49]
[62] -> [40,55]
[63] -> [41,56]
[64] -> [42,57]
[65] -> [39]
[66] -> [38]
[70] -> [49]
[71] -> [40,55]
[72] -> [41,56]
[73] -> [42,57]
[74] -> [39]
[75] -> [38]
[78] -> [46]
[79] -> [55]
[80] -> [56]
[81] -> [57]
[84] -> [46]
[85] -> [55]
[86] -> [56]
[87] -> [57]
[91] -> [47,50,149,153,264]
[92] -> [102,114,123,150,154,265]
[93] -> [103,115,124,151,155,266]
[94] -> [104,116,125,152,156,267]
[101] -> [46]
[102] -> [92]
[103] -> [93]
[104] -> [94]
[113] -> [46]
[114] -> [92]
[115] -> [93]
[116] -> [94]
[122] -> [49]
[123] -> [40,92]
[124] -> [41,93]
[125] -> [42,94]
[126] -> [39]
[127] -> [38]
[139] -> [175,202,222,255]
[140] -> [174,201,221,254]
[141] -> [173,200,220,253]
[142] -> [172,199,219,252]
[144] -> [47,50,54,193]
[145] -> [55,177,194,225]
[146] -> [56,178,195,226]
[147] -> [57,179,196,227]
[149] -> [47,50,91,166]
[150] -> [92,167,204,232]
[151] -> [93,168,205,233]
[152] -> [94,169,206,234]
[153] -> [47,50,91]
[154] -> [92,181,208,239]
[155] -> [93,182,209,240]
[156] -> [94,183,210,241]
[161] -> [175]
[162] -> [174]
[163] -> [173]
[164] -> [172]
[166] -> [149]
[167] -> [150]
[168] -> [151]
[169] -> [152]
[172] -> [142]
[173] -> [141]
[174] -> [140]
[175] -> [139]
[176] -> [33,46]
[176,177] -> [36]
[176,178] -> [35]
[176,179] -> [34]
[177] -> [145]
[178] -> [146]
[179] -> [147]
[180] -> [46]
[181] -> [154]
[182] -> [155]
[183] -> [156]
[188] -> [202]
[189] -> [201]
[190] -> [200]
[191] -> [199]
[193] -> [144]
[194] -> [145]
[195] -> [146]
[196] -> [147]
[199] -> [142]
[200] -> [141]
[201] -> [140]
[202] -> [139]
[203] -> [33,46]
[203,204] -> [36]
[203,205] -> [35]
[203,206] -> [34]
[204] -> [150]
[205] -> [151]
[206] -> [152]
[207] -> [46]
[208] -> [154]
[209] -> [155]
[210] -> [156]
[215] -> [222]
[216] -> [220]
[219] -> [142,216]
[220] -> [141]
[221] -> [140,215]
[222] -> [139]
[224] -> [33,49]
[224,225] -> [36]
[224,226] -> [35]
[224,227] -> [34]
[225] -> [40,145]
[226] -> [41,146]
[227] -> [42,147]
[228] -> [39]
[229] -> [38]
[231] -> [33,49]
[231,232] -> [36]
[231,233] -> [35]
[231,234] -> [34]
[232] -> [40,150]
[233] -> [41,151]
[234] -> [42,152]
[235] -> [39]
[236] -> [38]
[238] -> [49]
[239] -> [40,154]
[240] -> [41,155]
[241] -> [42,156]
[246] -> [39]
[247] -> [38]
[252] -> [142]
[253] -> [141]
[254] -> [140]
[255] -> [139]
[264] -> [91]
[265] -> [92]
[266] -> [93]
[267] -> [94]
[R] -> [263]

### Solution ###

[2,3,5,6,8,9,10,11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,30,31,32,37,45,48,51,52,53,58,59,60,67,68,69,76,77,82,83,88,89,90,97,98,99,100,105,106,109,110,111,112,117,118,119,120,121,128,129,130,131,132,133,134,135,136,137,138,143,148,157,158,159,160,170,171,184,185,186,187,197,198,211,212,213,214,217,218,223,230,237,242,243,244,245,248,249,250,251,256,257,258,259,260,261,262,263,268,269,R]

### Annotated ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (x :R: N) -> N
    postulate B :E: Type
    postulate T :R: B
    postulate F :R: B
    postulate List :E: Type
    postulate Cons :R: (_x0 :R: B) -> (_x1 :R: List) -> List
    postulate Nil :R: List
    not :R: (_x2 :R: B) -> B 
      [not] -R- T = F
      [not] -R- F = T
    foreign input :R: N
    genList :R: (_x3 :R: B) -> (_x4 :R: N) -> List 
      b :E: B
        [genList] -R- b -R- Z = Nil
      b :R: B n :R: N
        [genList] -R- b -R- (S -R- n) = Cons -R- b -R- (genList -R- (not -R- b) -R- n)
    postulate Eq :E: (a :E: Type) -> (_x5 :E: a) -> (_x6 :E: a) -> Type
    postulate Refl :R: (a :E: Type) -> (x :E: a) -> Eq -E- a -E- x -E- x
    postulate Maybe :E: (_x7 :E: Type) -> Type
    postulate Nothing :R: (a :E: Type) -> Maybe -E- a
    postulate Just :R: (a :E: Type) -> (x :R: a) -> Maybe -E- a
    semiDecEqB :R: (x :R: B) -> (y :R: B) -> Maybe -E- (Eq -E- B -E- x -E- y) 
      [semiDecEqB] -R- T -R- T = Just -E- (Eq -E- B -E- T -E- T) -R- (Refl -E- B -E- T)
      [semiDecEqB] -R- F -R- F = Just -E- (Eq -E- B -E- F -E- F) -R- (Refl -E- B -E- F)
      [semiDecEqB] -R- T -R- F = Nothing -E- (Eq -E- B -E- T -E- F)
      [semiDecEqB] -R- F -R- T = Nothing -E- (Eq -E- B -E- F -E- T)
    semiDecEq :R: (xs :R: List) -> (ys :R: List) -> Maybe -E- (Eq -E- List -E- xs -E- ys) 
      b :E: B ys :E: List
        [semiDecEq] -R- Nil -R- (Cons -R- b -R- ys) = Nothing -E- (Eq -E- List -E- Nil -E- (Cons -R- b -R- ys))
      b :E: B xs :E: List
        [semiDecEq] -R- (Cons -R- b -R- xs) -R- Nil = Nothing -E- (Eq -E- List -E- (Cons -R- b -R- xs) -E- Nil)
      [semiDecEq] -R- Nil -R- Nil = Just -E- (Eq -E- List -E- Nil -E- Nil) -R- (Refl -E- List -E- Nil)
      x :R: B y :R: B xs :R: List ys :R: List
        [semiDecEq] -R- (Cons -R- x -R- xs) -R- (Cons -R- y -R- ys) = 
          let semiDecEq' :R: (x :E: B) -> (y :E: B) -> (xs :E: List) -> (ys :E: List) -> (pfH :R: Maybe -E- (Eq -E- B -E- x -E- y)) -> (pfT :R: Maybe -E- (Eq -E- List -E- xs -E- ys)) -> Maybe -E- (Eq -E- List -E- (Cons -R- x -R- xs) -E- (Cons -R- y -R- ys)) 
            x :E: B y :E: B xs :E: List ys :E: List pfT :E: Maybe -E- (Eq -E- List -E- xs -E- ys)
              [semiDecEq'] -E- x -E- y -E- xs -E- ys -R- (Nothing -E- [Eq -E- B -E- x -E- y]) -R- pfT = Nothing -E- (Eq -E- List -E- (Cons -R- x -R- xs) -E- (Cons -R- y -R- ys))
            x :E: B y :E: B xs :E: List ys :E: List pfH :E: Maybe -E- (Eq -E- B -E- x -E- y)
              [semiDecEq'] -E- x -E- y -E- xs -E- ys -R- pfH -R- (Nothing -E- [Eq -E- List -E- xs -E- ys]) = Nothing -E- (Eq -E- List -E- (Cons -R- x -R- xs) -E- (Cons -R- y -R- ys))
            x :E: B xs :E: List
              [semiDecEq'] -E- x -E- [x] -E- xs -E- [xs] -R- (Just -E- [Eq -E- B -E- x -E- x] -R- [Refl -E- B -E- x]) -R- (Just -E- [Eq -E- List -E- xs -E- xs] -R- [Refl -E- List -E- xs]) = Just -E- (Eq -E- List -E- (Cons -R- x -R- xs) -E- (Cons -R- x -R- xs)) -R- (Refl -E- List -E- (Cons -R- x -R- xs))
          in semiDecEq' -E- x -E- y -E- xs -E- ys -R- (semiDecEqB -R- x -R- y) -R- (semiDecEq -R- xs -R- ys)
    sampleList :R: List = genList -R- T -R- input
    main :R: Maybe -E- (Eq -E- List -E- sampleList -E- sampleList) 
      [main] = semiDecEq -R- sampleList -R- sampleList
  in main

### Specialised ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (x :R: N) -> N
    postulate B :E: Type
    postulate T :R: B
    postulate F :R: B
    postulate List :E: Type
    postulate Cons :R: (_x0 :R: B) -> (_x1 :R: List) -> List
    postulate Nil :R: List
    not :R: (_x2 :R: B) -> B 
      [not] -R- T = F
      [not] -R- F = T
    foreign input :R: N
    genList :R: (_x3 :R: B) -> (_x4 :R: N) -> List 
      b :E: B
        [genList] -R- b -R- Z = Nil
      b :R: B n :R: N
        [genList] -R- b -R- (S -R- n) = Cons -R- b -R- (genList -R- (not -R- b) -R- n)
    postulate Eq :E: (a :E: Type) -> (_x5 :E: a) -> (_x6 :E: a) -> Type
    postulate Refl :R: (a :E: Type) -> (x :E: a) -> Eq -E- a -E- x -E- x
    postulate Maybe :E: (_x7 :E: Type) -> Type
    postulate Nothing :R: (a :E: Type) -> Maybe -E- a
    postulate Just :R: (a :E: Type) -> (x :R: a) -> Maybe -E- a
    semiDecEqB :R: (x :R: B) -> (y :R: B) -> Maybe -E- (Eq -E- B -E- x -E- y) 
      [semiDecEqB] -R- T -R- T = Just -E- (Eq -E- B -E- T -E- T) -R- (Refl -E- B -E- T)
      [semiDecEqB] -R- F -R- F = Just -E- (Eq -E- B -E- F -E- F) -R- (Refl -E- B -E- F)
      [semiDecEqB] -R- T -R- F = Nothing -E- (Eq -E- B -E- T -E- F)
      [semiDecEqB] -R- F -R- T = Nothing -E- (Eq -E- B -E- F -E- T)
    semiDecEq :R: (xs :R: List) -> (ys :R: List) -> Maybe -E- (Eq -E- List -E- xs -E- ys) 
      b :E: B ys :E: List
        [semiDecEq] -R- Nil -R- (Cons -R- b -R- ys) = Nothing -E- (Eq -E- List -E- Nil -E- (Cons -R- b -R- ys))
      b :E: B xs :E: List
        [semiDecEq] -R- (Cons -R- b -R- xs) -R- Nil = Nothing -E- (Eq -E- List -E- (Cons -R- b -R- xs) -E- Nil)
      [semiDecEq] -R- Nil -R- Nil = Just -E- (Eq -E- List -E- Nil -E- Nil) -R- (Refl -E- List -E- Nil)
      x :R: B y :R: B xs :R: List ys :R: List
        [semiDecEq] -R- (Cons -R- x -R- xs) -R- (Cons -R- y -R- ys) = 
          let semiDecEq' :R: (x :E: B) -> (y :E: B) -> (xs :E: List) -> (ys :E: List) -> (pfH :R: Maybe -E- (Eq -E- B -E- x -E- y)) -> (pfT :R: Maybe -E- (Eq -E- List -E- xs -E- ys)) -> Maybe -E- (Eq -E- List -E- (Cons -R- x -R- xs) -E- (Cons -R- y -R- ys)) 
            x :E: B y :E: B xs :E: List ys :E: List pfT :E: Maybe -E- (Eq -E- List -E- xs -E- ys)
              [semiDecEq'] -E- x -E- y -E- xs -E- ys -R- (Nothing -E- [Eq -E- B -E- x -E- y]) -R- pfT = Nothing -E- (Eq -E- List -E- (Cons -R- x -R- xs) -E- (Cons -R- y -R- ys))
            x :E: B y :E: B xs :E: List ys :E: List pfH :E: Maybe -E- (Eq -E- B -E- x -E- y)
              [semiDecEq'] -E- x -E- y -E- xs -E- ys -R- pfH -R- (Nothing -E- [Eq -E- List -E- xs -E- ys]) = Nothing -E- (Eq -E- List -E- (Cons -R- x -R- xs) -E- (Cons -R- y -R- ys))
            x :E: B xs :E: List
              [semiDecEq'] -E- x -E- [x] -E- xs -E- [xs] -R- (Just -E- [Eq -E- B -E- x -E- x] -R- [Refl -E- B -E- x]) -R- (Just -E- [Eq -E- List -E- xs -E- xs] -R- [Refl -E- List -E- xs]) = Just -E- (Eq -E- List -E- (Cons -R- x -R- xs) -E- (Cons -R- x -R- xs)) -R- (Refl -E- List -E- (Cons -R- x -R- xs))
          in semiDecEq' -E- x -E- y -E- xs -E- ys -R- (semiDecEqB -R- x -R- y) -R- (semiDecEq -R- xs -R- ys)
    sampleList :R: List = genList -R- T -R- input
    main :R: Maybe -E- (Eq -E- List -E- sampleList -E- sampleList) 
      [main] = semiDecEq -R- sampleList -R- sampleList
  in main

### Final annotation ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (x :R: N) -> N
    postulate B :E: Type
    postulate T :R: B
    postulate F :R: B
    postulate List :E: Type
    postulate Cons :R: (_x0 :R: B) -> (_x1 :R: List) -> List
    postulate Nil :R: List
    not :R: (_x2 :R: B) -> B 
      [not] -R- T = F
      [not] -R- F = T
    foreign input :R: N
    genList :R: (_x3 :R: B) -> (_x4 :R: N) -> List 
      b :E: B
        [genList] -R- b -R- Z = Nil
      b :R: B n :R: N
        [genList] -R- b -R- (S -R- n) = Cons -R- b -R- (genList -R- (not -R- b) -R- n)
    postulate Eq :E: (a :E: Type) -> (_x5 :E: a) -> (_x6 :E: a) -> Type
    postulate Refl :R: (a :E: Type) -> (x :E: a) -> Eq -E- a -E- x -E- x
    postulate Maybe :E: (_x7 :E: Type) -> Type
    postulate Nothing :R: (a :E: Type) -> Maybe -E- a
    postulate Just :R: (a :E: Type) -> (x :R: a) -> Maybe -E- a
    semiDecEqB :R: (x :R: B) -> (y :R: B) -> Maybe -E- (Eq -E- B -E- x -E- y) 
      [semiDecEqB] -R- T -R- T = Just -E- (Eq -E- B -E- T -E- T) -R- (Refl -E- B -E- T)
      [semiDecEqB] -R- F -R- F = Just -E- (Eq -E- B -E- F -E- F) -R- (Refl -E- B -E- F)
      [semiDecEqB] -R- T -R- F = Nothing -E- (Eq -E- B -E- T -E- F)
      [semiDecEqB] -R- F -R- T = Nothing -E- (Eq -E- B -E- F -E- T)
    semiDecEq :R: (xs :R: List) -> (ys :R: List) -> Maybe -E- (Eq -E- List -E- xs -E- ys) 
      b :E: B ys :E: List
        [semiDecEq] -R- Nil -R- (Cons -R- b -R- ys) = Nothing -E- (Eq -E- List -E- Nil -E- (Cons -R- b -R- ys))
      b :E: B xs :E: List
        [semiDecEq] -R- (Cons -R- b -R- xs) -R- Nil = Nothing -E- (Eq -E- List -E- (Cons -R- b -R- xs) -E- Nil)
      [semiDecEq] -R- Nil -R- Nil = Just -E- (Eq -E- List -E- Nil -E- Nil) -R- (Refl -E- List -E- Nil)
      x :R: B y :R: B xs :R: List ys :R: List
        [semiDecEq] -R- (Cons -R- x -R- xs) -R- (Cons -R- y -R- ys) = 
          let semiDecEq' :R: (x :E: B) -> (y :E: B) -> (xs :E: List) -> (ys :E: List) -> (pfH :R: Maybe -E- (Eq -E- B -E- x -E- y)) -> (pfT :R: Maybe -E- (Eq -E- List -E- xs -E- ys)) -> Maybe -E- (Eq -E- List -E- (Cons -R- x -R- xs) -E- (Cons -R- y -R- ys)) 
            x :E: B y :E: B xs :E: List ys :E: List pfT :E: Maybe -E- (Eq -E- List -E- xs -E- ys)
              [semiDecEq'] -E- x -E- y -E- xs -E- ys -R- (Nothing -E- [Eq -E- B -E- x -E- y]) -R- pfT = Nothing -E- (Eq -E- List -E- (Cons -R- x -R- xs) -E- (Cons -R- y -R- ys))
            x :E: B y :E: B xs :E: List ys :E: List pfH :E: Maybe -E- (Eq -E- B -E- x -E- y)
              [semiDecEq'] -E- x -E- y -E- xs -E- ys -R- pfH -R- (Nothing -E- [Eq -E- List -E- xs -E- ys]) = Nothing -E- (Eq -E- List -E- (Cons -R- x -R- xs) -E- (Cons -R- y -R- ys))
            x :E: B xs :E: List
              [semiDecEq'] -E- x -E- [x] -E- xs -E- [xs] -R- (Just -E- [Eq -E- B -E- x -E- x] -R- [Refl -E- B -E- x]) -R- (Just -E- [Eq -E- List -E- xs -E- xs] -R- [Refl -E- List -E- xs]) = Just -E- (Eq -E- List -E- (Cons -R- x -R- xs) -E- (Cons -R- x -R- xs)) -R- (Refl -E- List -E- (Cons -R- x -R- xs))
          in semiDecEq' -E- x -E- y -E- xs -E- ys -R- (semiDecEqB -R- x -R- y) -R- (semiDecEq -R- xs -R- ys)
    sampleList :R: List = genList -R- T -R- input
    main :R: Maybe -E- (Eq -E- List -E- sampleList -E- sampleList) 
      [main] = semiDecEq -R- sampleList -R- sampleList
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Z : N
    postulate S : (x) -> N
    postulate T : B
    postulate F : B
    postulate Cons : (_x0) -> (_x1) -> List
    postulate Nil : List
    not 
      [_] T = F
      [_] F = T
    foreign input
    genList 
      [_] _ Z = Nil
      [_] b (S n) = Cons b (genList (not b) n)
    postulate Refl : Eq
    postulate Nothing : Maybe
    postulate Just : (x) -> Maybe
    semiDecEqB 
      [_] T T = Just Refl
      [_] F F = Just Refl
      [_] T F = Nothing
      [_] F T = Nothing
    semiDecEq 
      [_] Nil (Cons _ _) = Nothing
      [_] (Cons _ _) Nil = Nothing
      [_] Nil Nil = Just Refl
      [_] (Cons x xs) (Cons y ys) = 
        let semiDecEq' 
          [_] Nothing _ = Nothing
          [_] _ Nothing = Nothing
          [_] (Just [_]) (Just [_]) = Just Refl
        in semiDecEq' (semiDecEqB x y) (semiDecEq xs ys)
    sampleList = genList T input
    main 
      [_] = semiDecEq sampleList sampleList
  in main

### Normal forms ###

unerased:
  
  let
    postulate N : Type
    postulate Z : N
    postulate S : (x :R: N) -> N
    postulate B : Type
    postulate T : B
    postulate F : B
    postulate List : Type
    postulate Cons : (_x0 : B) -> (_x1 : List) -> List
    postulate Nil : List
    not : (_x2 : B) -> B 
      [not] T = F
      [not] F = T
    foreign input : N
    genList : (_x3 : B) -> (_x4 : N) -> List 
      b : B
        [genList] b Z = Nil
      b : B n : N
        [genList] b (S n) = Cons b (genList (not b) n)
    postulate Eq : (a : Type) -> (_x5 : a) -> (_x6 : a) -> Type
    postulate Refl : (a : Type) -> (x : a) -> Eq a x x
    postulate Maybe : (_x7 : Type) -> Type
    postulate Nothing : (a : Type) -> Maybe a
    postulate Just : (a : Type) -> (x :R: a) -> Maybe a
    semiDecEqB : (x : B) -> (y : B) -> Maybe (Eq B x y) 
      [semiDecEqB] T T = Just (Eq B T T) (Refl B T)
      [semiDecEqB] F F = Just (Eq B F F) (Refl B F)
      [semiDecEqB] T F = Nothing (Eq B T F)
      [semiDecEqB] F T = Nothing (Eq B F T)
    semiDecEq : (xs : List) -> (ys : List) -> Maybe (Eq List xs ys) 
      b : B ys : List
        [semiDecEq] Nil (Cons b ys) = Nothing (Eq List Nil (Cons b ys))
      b : B xs : List
        [semiDecEq] (Cons b xs) Nil = Nothing (Eq List (Cons b xs) Nil)
      [semiDecEq] Nil Nil = Just (Eq List Nil Nil) (Refl List Nil)
      x : B y : B xs : List ys : List
        [semiDecEq] (Cons x xs) (Cons y ys) = 
          let semiDecEq' : (x : B) -> (y : B) -> (xs : List) -> (ys : List) -> (pfH : Maybe (Eq B x y)) -> (pfT : Maybe (Eq List xs ys)) -> Maybe (Eq List (Cons x xs) (Cons y ys)) 
            x : B y : B xs : List ys : List pfT : Maybe (Eq List xs ys)
              [semiDecEq'] x y xs ys (Nothing [Eq B x y]) pfT = Nothing (Eq List (Cons x xs) (Cons y ys))
            x : B y : B xs : List ys : List pfH : Maybe (Eq B x y)
              [semiDecEq'] x y xs ys pfH (Nothing [Eq List xs ys]) = Nothing (Eq List (Cons x xs) (Cons y ys))
            x : B xs : List
              [semiDecEq'] x [x] xs [xs] (Just [Eq B x x] [Refl B x]) (Just [Eq List xs xs] [Refl List xs]) = Just (Eq List (Cons x xs) (Cons x xs)) (Refl List (Cons x xs))
          in semiDecEq' x y xs ys (semiDecEqB x y) (semiDecEq xs ys)
    sampleList : List = genList T input
    main : Maybe (Eq List sampleList sampleList) 
      [main] = semiDecEq sampleList sampleList
  in main

erased:
  
  let
    postulate Z : N
    postulate S : (x) -> N
    postulate T : B
    postulate F : B
    postulate Cons : (_x0) -> (_x1) -> List
    postulate Nil : List
    not 
      [_] T = F
      [_] F = T
    foreign input
    genList 
      [_] _ Z = Nil
      [_] b (S n) = Cons b (genList (not b) n)
    postulate Refl : Eq
    postulate Nothing : Maybe
    postulate Just : (x) -> Maybe
    semiDecEqB 
      [_] T T = Just Refl
      [_] F F = Just Refl
      [_] T F = Nothing
      [_] F T = Nothing
    semiDecEq 
      [_] Nil (Cons _ _) = Nothing
      [_] (Cons _ _) Nil = Nothing
      [_] Nil Nil = Just Refl
      [_] (Cons x xs) (Cons y ys) = 
        let semiDecEq' 
          [_] Nothing _ = Nothing
          [_] _ Nothing = Nothing
          [_] (Just [_]) (Just [_]) = Just Refl
        in semiDecEq' (semiDecEqB x y) (semiDecEq xs ys)
    sampleList = genList T input
    main 
      [_] = semiDecEq sampleList sampleList
  in main

