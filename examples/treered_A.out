-- vim: ft=idris

### Desugared ###

  let
    postulate N : Type
    postulate Z : N
    postulate S : (x :R: N) -> N
    postulate Vec : (_x0 : N) -> (_x1 : Type) -> Type
    postulate Nil : (a : Type) -> Vec Z a
    postulate Cons : (a : Type) -> (n : N) -> (x :R: a) -> (xs :R: Vec n a) -> Vec (S n) a
    vlen : (n : N) -> (xs : Vec n N) -> N = \(n : N) (xs : Vec n N).
      case xs of
        Nil (a : Type) =>
          case a of [N] =>
            case n of [Z] =>
              Z
        Cons (a : Type) (m : N) (y : N) (ys : Vec m N) =>
          case a of [N] =>
            case n of [S m] =>
              S (vlen m ys)
    main : N = vlen 1 (Cons N Z 3 (Nil N))
  in main

### Metaified ###

  let
    postulate N :1: Type
    postulate Z :2: N
    postulate S :3: (x :R: N) -> N
    postulate Vec :4: (_x0 :5: N) -> (_x1 :6: Type) -> Type
    postulate Nil :7: (a :8: Type) -> Vec -10- Z -9- a
    postulate Cons :11: (a :12: Type) -> (n :13: N) -> (x :R: a) -> (xs :R: Vec -15- n -14- a) -> Vec -17- (S -18- n) -16- a
    vlen :19: (n :20: N) -> (xs :21: Vec -23- n -22- N) -> N = \(n :24: N) (xs :25: Vec -27- n -26- N).
      case -28- xs of
        Nil/29 (a :30: Type) =>
          case -31- a of [N] =>
            case -32- n of [Z] =>
              Z
        Cons/33 (a :34: Type) (m :35: N) (y :36: N) (ys :37: Vec -39- m -38- N) =>
          case -40- a of [N] =>
            case -41- n of [S -42- m] =>
              S -43- (vlen -45- m -44- ys)
    main :46: N = vlen -48- 1 -47- (Cons -53- N -52- Z -51- 3 -50- (Nil -57- N))
  in main

### Constraints ###

[] -> [2,3,7,11,19,21,25,28,29,33,37,43,44,47,50,51,54,55,56,R]
[8] -> [1,30,57]
[9] -> [14,22]
[10] -> [15,23]
[12] -> [1,34,53]
[13] -> [35,52]
[14] -> [9,38]
[15] -> [10,39]
[16] -> [22]
[17] -> [23]
[18] -> [42,49]
[20] -> [24,35,45,48,49]
[22] -> [9,16,38]
[23] -> [10,17,39]
[24] -> [20]
[30] -> [8]
[31] -> [30]
[32] -> [24]
[34] -> [12]
[35] -> [13]
[38] -> [14,22]
[39] -> [15,23]
[40] -> [34]
[41] -> [24]
[42] -> [18]
[45] -> [20]
[48] -> [20]
[49] -> [18]
[52] -> [13]
[53] -> [12]
[57] -> [8]
[R] -> [46]

### Solution ###

[2,3,7,11,19,21,25,28,29,33,37,43,44,46,47,50,51,54,55,56,R]

### Annotated ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (x :R: N) -> N
    postulate Vec :E: (_x0 :E: N) -> (_x1 :E: Type) -> Type
    postulate Nil :R: (a :E: Type) -> Vec -E- Z -E- a
    postulate Cons :R: (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
    vlen :R: (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N = \(n :E: N) (xs :R: Vec -E- n -E- N).
      case -R- xs of
        Nil/R (a :E: Type) =>
          case -E- a of [N] =>
            case -E- n of [Z] =>
              Z
        Cons/R (a :E: Type) (m :E: N) (y :E: N) (ys :R: Vec -E- m -E- N) =>
          case -E- a of [N] =>
            case -E- n of [S -E- m] =>
              S -R- (vlen -E- m -R- ys)
    main :R: N = vlen -E- 1 -R- (Cons -E- N -E- Z -R- 3 -R- (Nil -E- N))
  in main

### Specialised ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (x :R: N) -> N
    postulate Vec :E: (_x0 :E: N) -> (_x1 :E: Type) -> Type
    postulate Nil :R: (a :E: Type) -> Vec -E- Z -E- a
    postulate Cons :R: (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
    vlen :R: (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N = \(n :E: N) (xs :R: Vec -E- n -E- N).
      case -R- xs of
        Nil/R (a :E: Type) =>
          case -E- a of [N] =>
            case -E- n of [Z] =>
              Z
        Cons/R (a :E: Type) (m :E: N) (y :E: N) (ys :R: Vec -E- m -E- N) =>
          case -E- a of [N] =>
            case -E- n of [S -E- m] =>
              S -R- (vlen -E- m -R- ys)
    main :R: N = vlen -E- 1 -R- (Cons -E- N -E- Z -R- 3 -R- (Nil -E- N))
  in main

### Final annotation ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (x :R: N) -> N
    postulate Vec :E: (_x0 :E: N) -> (_x1 :E: Type) -> Type
    postulate Nil :R: (a :E: Type) -> Vec -E- Z -E- a
    postulate Cons :R: (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
    vlen :R: (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N = \(n :E: N) (xs :R: Vec -E- n -E- N).
      case -R- xs of
        Nil/R (a :E: Type) =>
          case -E- a of [N] =>
            case -E- n of [Z] =>
              Z
        Cons/R (a :E: Type) (m :E: N) (y :E: N) (ys :R: Vec -E- m -E- N) =>
          case -E- a of [N] =>
            case -E- n of [S -E- m] =>
              S -R- (vlen -E- m -R- ys)
    main :R: N = vlen -E- 1 -R- (Cons -E- N -E- Z -R- 3 -R- (Nil -E- N))
  in main

### Verification ###

ttstar: !! verification failed: Traceback:
1. In context:
  Type : Type

("LET",R,[postulate N :E: Type,postulate Z :R: N,postulate S :R: (x :R: N) -> N,postulate Vec :E: (_x0 :E: N) -> (_x1 :E: Type) -> Type,postulate Nil :R: (a :E: Type) -> Vec -E- Z -E- a,postulate Cons :R: (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a,vlen :R: (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N = \(n :E: N) (xs :R: Vec -E- n -E- N).
  case -R- xs of
    Nil/R (a :E: Type) =>
      case -E- a of [N] =>
        case -E- n of [Z] =>
          Z
    Cons/R (a :E: Type) (m :E: N) (y :E: N) (ys :R: Vec -E- m -E- N) =>
      case -E- a of [N] =>
        case -E- n of [S -E- m] =>
          S -R- (vlen -E- m -R- ys),main :R: N = vlen -E- 1 -R- (Cons -E- N -E- Z -R- 3 -R- (Nil -E- N))])

2. In context:
  Cons : (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
  N : Type
  Nil : (a :E: Type) -> Vec -E- Z -E- a
  S : (x :R: N) -> N
  Type : Type
  Vec : (_x0 :E: N) -> (_x1 :E: Type) -> Type
  Z : N
  vlen : (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N

("DEF-TERM",vlen)

3. In context:
  Cons : (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
  N : Type
  Nil : (a :E: Type) -> Vec -E- Z -E- a
  S : (x :R: N) -> N
  Type : Type
  Vec : (_x0 :E: N) -> (_x1 :E: Type) -> Type
  Z : N
  vlen : (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N

("CASEFUN",vlen)

4. In context:
  Cons : (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
  N : Type
  Nil : (a :E: Type) -> Vec -E- Z -E- a
  S : (x :R: N) -> N
  Type : Type
  Vec : (_x0 :E: N) -> (_x1 :E: Type) -> Type
  Z : N
  vlen : (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N

("CASE-MULTI",xs,R,R,vlen -E- n -R- xs)

5. In context:
  Cons : (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
  N : Type
  Nil : (a :E: Type) -> Vec -E- Z -E- a
  S : (x :R: N) -> N
  Type : Type
  Vec : (_x0 :E: N) -> (_x1 :E: Type) -> Type
  Z : N
  vlen : (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N

("ALT-MATCH",Cons,case -E- a of [N] =>
  case -E- n of [S -E- m] =>
    S -R- (vlen -E- m -R- ys))

6. In context:
  Cons : (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
  N : Type
  Nil : (a :E: Type) -> Vec -E- Z -E- a
  S : (x :R: N) -> N
  Type : Type
  Vec : (_x0 :E: N) -> (_x1 :E: Type) -> Type
  Z : N
  vlen : (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N

("ALT-MATCH-INT",Cons,case -E- a of [N] =>
  case -E- n of [S -E- m] =>
    S -R- (vlen -E- m -R- ys))

7. In context:
  Cons : (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
  N : Type
  Nil : (a :E: Type) -> Vec -E- Z -E- a
  S : (x :R: N) -> N
  Type : Type
  Vec : (_x0 :E: N) -> (_x1 :E: Type) -> Type
  Z : N
  vlen : (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N

("ALT-MATCH-INT2",R,R,Cons -E- a -E- m -E- y -R- ys,Vec -E- n -E- N)

8. In context:
  Cons : (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
  N : Type
  Nil : (a :E: Type) -> Vec -E- Z -E- a
  S : (x :R: N) -> N
  Type : Type
  Vec : (_x0 :E: N) -> (_x1 :E: Type) -> Type
  Z : N
  vlen : (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N

("CASE-MULTI",a,R,E,vlen -E- n -R- (Cons -E- a -E- m -E- y -R- ys))

9. In context:
  Cons : (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
  N : Type
  Nil : (a :E: Type) -> Vec -E- Z -E- a
  S : (x :R: N) -> N
  Type : Type
  Vec : (_x0 :E: N) -> (_x1 :E: Type) -> Type
  Z : N
  vlen : (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N

("ALT-FORCED",N)

10. In context:
  Cons : (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
  N : Type
  Nil : (a :E: Type) -> Vec -E- Z -E- a
  S : (x :R: N) -> N
  Type : Type
  Vec : (_x0 :E: N) -> (_x1 :E: Type) -> Type
  Z : N
  vlen : (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N

("CASE-MULTI",n,R,E,vlen -E- n -R- (Cons -E- [N] -E- m -E- y -R- ys))

11. In context:
  Cons : (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
  N : Type
  Nil : (a :E: Type) -> Vec -E- Z -E- a
  S : (x :R: N) -> N
  Type : Type
  Vec : (_x0 :E: N) -> (_x1 :E: Type) -> Type
  Z : N
  vlen : (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N

("ALT-FORCED",S -E- m)

12. In context:
  Cons : (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
  N : Type
  Nil : (a :E: Type) -> Vec -E- Z -E- a
  S : (x :R: N) -> N
  Type : Type
  Vec : (_x0 :E: N) -> (_x1 :E: Type) -> Type
  Z : N
  vlen : (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N

("CASE-LEAF",vlen -E- [S -E- m] -R- (Cons -E- [N] -E- m -E- y -R- ys),S -R- (vlen -E- m -R- ys))

13. In context:
  Cons : (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
  N : Type
  Nil : (a :E: Type) -> Vec -E- Z -E- a
  S : (x :R: N) -> N
  Type : Type
  Vec : (_x0 :E: N) -> (_x1 :E: Type) -> Type
  Z : N
  m : N
  vlen : (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N
  y : N
  ys : Vec -E- m -E- N

("APP",R,vlen -E- [S -E- m],R,Cons -E- [N] -E- m -E- y -R- ys)

14. In context:
  Cons : (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
  N : Type
  Nil : (a :E: Type) -> Vec -E- Z -E- a
  S : (x :R: N) -> N
  Type : Type
  Vec : (_x0 :E: N) -> (_x1 :E: Type) -> Type
  Z : N
  m : N
  vlen : (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N
  y : N
  ys : Vec -E- m -E- N

("APP",R,Cons -E- [N] -E- m -E- y,R,ys)

15. In context:
  Cons : (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
  N : Type
  Nil : (a :E: Type) -> Vec -E- Z -E- a
  S : (x :R: N) -> N
  Type : Type
  Vec : (_x0 :E: N) -> (_x1 :E: Type) -> Type
  Z : N
  m : N
  vlen : (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N
  y : N
  ys : Vec -E- m -E- N

("APP",R,Cons -E- [N] -E- m,E,y)

16. In context:
  Cons : (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
  N : Type
  Nil : (a :E: Type) -> Vec -E- Z -E- a
  S : (x :R: N) -> N
  Type : Type
  Vec : (_x0 :E: N) -> (_x1 :E: Type) -> Type
  Z : N
  m : N
  vlen : (n :E: N) -> (xs :R: Vec -E- n -E- N) -> N
  y : N
  ys : Vec -E- m -E- N

("VAR-R",y)

Error: RelevanceMismatch E R

CallStack (from HasCallStack):
  error, called at Main.hs:175:29 in main:Main
