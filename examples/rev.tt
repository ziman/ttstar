-- vim: ft=idris

data Id : (a : Type) -> (x : a) -> (y : a) -> Type.
  Refl : (a : Type) -> (x : a) -> Id a x x.

id (a : Type) : a -> a
  = \x : a. x.

subst (a : Type) (P : a -> Type) (x : a) (y : a) (eq : Id a x y)
  : (P x) -> P y
  = case eq of
      Refl (a' : Type) (x' : a)
        | a' = a
        | x' = x
        | y  = x
        => \w : P x'. w.  -- `x'` instead of `x` just to be mean to the typechecker

cong (a : Type) (b : Type) (f : a -> b) (x : a) (y : a) (eq : Id a x y)
  : Id b (f x) (f y)
  = case eq of
      Refl (a' : Type) (x' : a)
        | a' = a
        | x' = x
        | y  = x
        => Refl b (f y).  -- again, `y` instead of `x`

data Bool : Type.
  T : Bool,
  F : Bool.

-- We annotate this type manually to emulate usage caused by I/O actions.
data List : Type.
  Nil : List,
  Cons : (x :R: Bool) -> (xs :R: List) -> List.

one (x : Bool) : List
  = Cons x Nil.

app (xs : List) (ys : List) : List
  = case xs of
      Nil => ys,
      Cons (x : Bool) (xs' : List) => Cons x (app xs' ys).

appRightNeutral (ys : List) : Id List ys (app ys Nil)
  = case ys of
      Nil
        => Refl List Nil,
      Cons (x : Bool) (xs : List)
        => cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs).

{-
appAssoc (xs : List) (ys : List) (zs : List)
  : Id List (app (app xs ys) zs) (app xs (app ys zs))
  = case xs of
      Nil
        => Refl List (app ys zs),

      Cons (x : Bool) (xs' : List)
        => cong List List (Cons x) (app (app xs' ys) zs) (app xs' (app ys zs)) (appAssoc xs' ys zs).

-}
{-
-----------
appAssoc (Cons x xs') ys zs
  cong List List (Cons x) (app (app xs' ys) zs) (app xs' (app ys zs)) (appAssoc xs' ys zs)

app (app xs' zs) zs,
app (app xs' ys) zs

Id List (app (app (Cons x xs') ys) zs),

----------
---}

{-
data Rev : List -> Type.
  RNil : Rev Nil,
  RSnoc : (xs : List) -> (x : Bool) -> (rxs : Rev xs)
    -> Rev (app xs (one x)).

rev' (xs : List) (rxs : Rev xs) (ys : List) : Rev (app xs ys)
  = case ys of
      Nil
        => subst List Rev xs (app xs Nil) (appRightNeutral xs) rxs,
      Cons (y : Bool) (ys' : List)
        => subst List Rev
            (app (app xs (one y)) ys')
            (app xs (Cons y ys'))
            (appAssoc xs (one y) ys')
            (rev' (app xs (one y)) (RSnoc xs y rxs) ys').
-}

{-
rev (xs : List) : Rev xs
  = rev' Nil RNil xs.

reverse' (xs : List) (rxs : Rev xs) : List
  = case rxs of
      RNil
        | xs = Nil
        => Nil,

      RSnoc (xs' : List) (x : Bool) (rxs' : Rev xs')
        | xs = app xs' (one x)
        => Cons x (reverse' xs' rxs').

reverse (xs : List) : List
  = reverse' xs (rev xs).

main :R: List
  = reverse (Cons T (Cons F (Cons T (Cons F Nil)))).
-}

xs' : List
  = Cons T (Cons F Nil).

main (x : Bool) (xs' : List) (ys : List) (zs : List) :R: List
  = (app (app (Cons x xs') ys) zs).
