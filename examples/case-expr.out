-- vim: ft=agda

### Desugared ###

  let
    postulate Bool : Type
    postulate T : Bool
    postulate F : Bool
    postulate Unit : Type
    postulate MkUnit : Unit
    not : (x : Bool) -> Bool = \(x : Bool).
      case x of
        T
          => F
        F
          => T
    retTy : (x : Bool) -> Type = \(x : Bool).
      case x of
        T
          => Bool
        F
          => Unit
    main : Bool = not (
      let casefun#0 : (x : Bool) -> retTy x = \(x : Bool).
        case x of
          F
            => MkUnit
          T
            => F
      in casefun#0 (not F))
  in main

### Metaified ###

  let
    postulate Bool :1: Type
    postulate T :2: Bool
    postulate F :3: Bool
    postulate Unit :4: Type
    postulate MkUnit :5: Unit
    not :6: (x :7: Bool) -> Bool = \(x :8: Bool).
      case -9- x of
        T/10
          => F
        F/11
          => T
    retTy :12: (x :13: Bool) -> Type = \(x :14: Bool).
      case -15- x of
        T/16
          => Bool
        F/17
          => Unit
    main :18: Bool = not -19- (
      let casefun#0 :21: (x :22: Bool) -> retTy -23- x = \(x :24: Bool).
        case -25- x of
          F/26
            => MkUnit
          T/27
            => F
      in casefun#0 -20- (not -28- F))
  in main

### Constraints ###

[] -> [2,3,5,6,7,8,9,10,11,19,20,21,22,24,25,26,27,28,R]
[R] -> [18]

### Solution ###

[2,3,5,6,7,8,9,10,11,18,19,20,21,22,24,25,26,27,28,R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate Unit :E: Type
    postulate MkUnit :R: Unit
    not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
      case -R- x of
        T/R
          => F
        F/R
          => T
    retTy :E: (x :E: Bool) -> Type = \(x :E: Bool).
      case -E- x of
        T/E
          => Bool
        F/E
          => Unit
    main :R: Bool = not -R- (
      let casefun#0 :R: (x :R: Bool) -> retTy -E- x = \(x :R: Bool).
        case -R- x of
          F/R
            => MkUnit
          T/R
            => F
      in casefun#0 -R- (not -R- F))
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate Unit :E: Type
    postulate MkUnit :R: Unit
    not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
      case -R- x of
        T/R
          => F
        F/R
          => T
    retTy :E: (x :E: Bool) -> Type = \(x :E: Bool).
      case -E- x of
        T/E
          => Bool
        F/E
          => Unit
    main :R: Bool = not -R- (
      let casefun#0 :R: (x :R: Bool) -> retTy -E- x = \(x :R: Bool).
        case -R- x of
          F/R
            => MkUnit
          T/R
            => F
      in casefun#0 -R- (not -R- F))
  in main

### Constraints ###

[R] -> [R]

### Solution ###

[R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate Unit :E: Type
    postulate MkUnit :R: Unit
    not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
      case -R- x of
        T/R
          => F
        F/R
          => T
    retTy :E: (x :E: Bool) -> Type = \(x :E: Bool).
      case -E- x of
        T/E
          => Bool
        F/E
          => Unit
    main :R: Bool = not -R- (
      let casefun#0 :R: (x :R: Bool) -> retTy -E- x = \(x :R: Bool).
        case -R- x of
          F/R
            => MkUnit
          T/R
            => F
      in casefun#0 -R- (not -R- F))
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate Unit :E: Type
    postulate MkUnit :R: Unit
    not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
      case -R- x of
        T/R
          => F
        F/R
          => T
    retTy :E: (x :E: Bool) -> Type = \(x :E: Bool).
      case -E- x of
        T/E
          => Bool
        F/E
          => Unit
    main :R: Bool = not -R- (
      let casefun#0 :R: (x :R: Bool) -> retTy -E- x = \(x :R: Bool).
        case -R- x of
          F/R
            => MkUnit
          T/R
            => F
      in casefun#0 -R- (not -R- F))
  in main

### Final annotation ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate Unit :E: Type
    postulate MkUnit :R: Unit
    not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
      case -R- x of
        T/R
          => F
        F/R
          => T
    retTy :E: (x :E: Bool) -> Type = \(x :E: Bool).
      case -E- x of
        T/E
          => Bool
        F/E
          => Unit
    main :R: Bool = not -R- (
      let casefun#0 :R: (x :R: Bool) -> retTy -E- x = \(x :R: Bool).
        case -R- x of
          F/R
            => MkUnit
          T/R
            => F
      in casefun#0 -R- (not -R- F))
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate T : Bool
    postulate F : Bool
    postulate MkUnit : Unit
    not = \x.
      case x of
        T
          => F
        F
          => T
    main = not (
      let casefun#0 = \x.
        case x of
          F
            => MkUnit
          T
            => F
      in casefun#0 (not F))
  in main

### Normal forms ###

unerased:
  
  let postulate T : Bool
  in T

erased:
  
  let postulate T : Bool
  in T

