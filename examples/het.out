-- vim: ft=idris

### Desugared ###

  let
    postulate Tuple : (x :R: Type) -> (y :R: Type) -> (z :R: Type) -> (w :R: Type) -> Type
    postulate Bool : Type
    postulate T : Bool
    postulate F : Bool
    postulate Mool : Type
    postulate Q : Mool
    postulate W : Mool
    postulate U : Type
    postulate B : U
    postulate M : U
    ty : (u : U) -> Type = \(u : U).
      case u of
        B =>
          Bool
        M =>
          Mool
    f : (u : U) -> (x : ty u) -> Type = \(u : U) (x : ty u).
      case x of
        T =>
          case u of [B] =>
            Bool
        F =>
          case u of [B] =>
            Bool
        Q =>
          case u of [M] =>
            Mool
        W =>
          case u of [M] =>
            Mool
    main : Type = Tuple (f B T) (f B F) (f M Q) (f M W)
  in main

### Metaified ###

  let
    postulate Tuple :1: (x :R: Type) -> (y :R: Type) -> (z :R: Type) -> (w :R: Type) -> Type
    postulate Bool :2: Type
    postulate T :3: Bool
    postulate F :4: Bool
    postulate Mool :5: Type
    postulate Q :6: Mool
    postulate W :7: Mool
    postulate U :8: Type
    postulate B :9: U
    postulate M :10: U
    ty :11: (u :12: U) -> Type = \(u :13: U).
      case -14- u of
        B/15 =>
          Bool
        M/16 =>
          Mool
    f :17: (u :18: U) -> (x :19: ty -20- u) -> Type = \(u :21: U) (x :22: ty -23- u).
      case -24- x of
        T/25 =>
          case -26- u of [B] =>
            Bool
        F/27 =>
          case -28- u of [B] =>
            Bool
        Q/29 =>
          case -30- u of [M] =>
            Mool
        W/31 =>
          case -32- u of [M] =>
            Mool
    main :33: Type = Tuple -37- (f -39- B -38- T) -36- (f -41- B -40- F) -35- (f -43- M -42- Q) -34- (f -45- M -44- W)
  in main

### Constraints ###

[] -> [1,2,3,4,5,6,7,17,19,22,24,25,27,29,31,34,35,36,37,38,40,42,44,R]
[18] -> [9,10,21,39,41,43,45]
[21] -> [18]
[26] -> [21]
[28] -> [21]
[30] -> [21]
[32] -> [21]
[39] -> [18]
[41] -> [18]
[43] -> [18]
[45] -> [18]
[R] -> [33]

### Solution ###

[1,2,3,4,5,6,7,17,19,22,24,25,27,29,31,33,34,35,36,37,38,40,42,44,R]

### Annotated ###

  let
    postulate Tuple :R: (x :R: Type) -> (y :R: Type) -> (z :R: Type) -> (w :R: Type) -> Type
    postulate Bool :R: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate Mool :R: Type
    postulate Q :R: Mool
    postulate W :R: Mool
    postulate U :E: Type
    postulate B :E: U
    postulate M :E: U
    ty :E: (u :E: U) -> Type = \(u :E: U).
      case -E- u of
        B/E =>
          Bool
        M/E =>
          Mool
    f :R: (u :E: U) -> (x :R: ty -E- u) -> Type = \(u :E: U) (x :R: ty -E- u).
      case -R- x of
        T/R =>
          case -E- u of [B] =>
            Bool
        F/R =>
          case -E- u of [B] =>
            Bool
        Q/R =>
          case -E- u of [M] =>
            Mool
        W/R =>
          case -E- u of [M] =>
            Mool
    main :R: Type = Tuple -R- (f -E- B -R- T) -R- (f -E- B -R- F) -R- (f -E- M -R- Q) -R- (f -E- M -R- W)
  in main

### Specialised ###

  let
    postulate Tuple :R: (x :R: Type) -> (y :R: Type) -> (z :R: Type) -> (w :R: Type) -> Type
    postulate Bool :R: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate Mool :R: Type
    postulate Q :R: Mool
    postulate W :R: Mool
    postulate U :E: Type
    postulate B :E: U
    postulate M :E: U
    ty :E: (u :E: U) -> Type = \(u :E: U).
      case -E- u of
        B/E =>
          Bool
        M/E =>
          Mool
    f :R: (u :E: U) -> (x :R: ty -E- u) -> Type = \(u :E: U) (x :R: ty -E- u).
      case -R- x of
        T/R =>
          case -E- u of [B] =>
            Bool
        F/R =>
          case -E- u of [B] =>
            Bool
        Q/R =>
          case -E- u of [M] =>
            Mool
        W/R =>
          case -E- u of [M] =>
            Mool
    main :R: Type = Tuple -R- (f -E- B -R- T) -R- (f -E- B -R- F) -R- (f -E- M -R- Q) -R- (f -E- M -R- W)
  in main

### Final annotation ###

  let
    postulate Tuple :R: (x :R: Type) -> (y :R: Type) -> (z :R: Type) -> (w :R: Type) -> Type
    postulate Bool :R: Type
    postulate T :R: Bool
    postulate F :R: Bool
    postulate Mool :R: Type
    postulate Q :R: Mool
    postulate W :R: Mool
    postulate U :E: Type
    postulate B :E: U
    postulate M :E: U
    ty :E: (u :E: U) -> Type = \(u :E: U).
      case -E- u of
        B/E =>
          Bool
        M/E =>
          Mool
    f :R: (u :E: U) -> (x :R: ty -E- u) -> Type = \(u :E: U) (x :R: ty -E- u).
      case -R- x of
        T/R =>
          case -E- u of [B] =>
            Bool
        F/R =>
          case -E- u of [B] =>
            Bool
        Q/R =>
          case -E- u of [M] =>
            Mool
        W/R =>
          case -E- u of [M] =>
            Mool
    main :R: Type = Tuple -R- (f -E- B -R- T) -R- (f -E- B -R- F) -R- (f -E- M -R- Q) -R- (f -E- M -R- W)
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Tuple : (x) -> (y) -> (z) -> (w) -> Type
    postulate Bool : Type
    postulate T : Bool
    postulate F : Bool
    postulate Mool : Type
    postulate Q : Mool
    postulate W : Mool
    f = \x.
      case x of
        T =>
          Bool
        F =>
          Bool
        Q =>
          Mool
        W =>
          Mool
    main = Tuple (f T) (f F) (f Q) (f W)
  in main

### Normal forms ###

unerased:
  
  let
    postulate Tuple : (x :R: Type) -> (y :R: Type) -> (z :R: Type) -> (w :R: Type) -> Type
    postulate Bool : Type
    postulate Mool : Type
  in Tuple Bool Bool Mool Mool

erased:
  
  let
    postulate Tuple : (x) -> (y) -> (z) -> (w) -> Type
    postulate Bool : Type
    postulate Mool : Type
  in Tuple Bool Bool Mool Mool

