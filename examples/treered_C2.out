-- vim: ft=agda

### Desugared ###

  let
    postulate N : Type
    postulate Z : N
    postulate S : (x : N) -> N
    postulate Vec : (_ : N) -> Type
    postulate Nil : Vec Z
    vlen : (n : N) -> (xs : Vec n) -> N = \(n : N) (xs : Vec n).
      case xs of
        Nil
          | n = Z
          => n
    main : N = vlen Z Nil
  in main

### Metaified ###

  let
    postulate N :1: Type
    postulate Z :2: N
    postulate S :3: (x :4: N) -> N
    postulate Vec :5: (_ :6: N) -> Type
    postulate Nil :7: Vec -8- Z
    vlen :9: (n :10: N) -> (xs :11: Vec -12- n) -> N = \(n :13: N) (xs :14: Vec -15- n).
      case -16- xs of
        Nil/17
          | n = Z
          => n
    main :18: N = vlen -20- Z -19- Nil
  in main

### Constraints ###

[] -> [2,9,10,13,20,R]
[7] -> [17]
[8] -> [11,12]
[8,11] -> [12]
[11] -> [7,14,19]
[11,12] -> [8]
[12] -> [8,11]
[14] -> [11]
[16] -> [14]
[17] -> [7]
[19] -> [11]
[R] -> [18]

### Solution ###

[2,9,10,13,18,20,R]

### Annotated ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :E: (x :E: N) -> N
    postulate Vec :E: (_ :E: N) -> Type
    postulate Nil :E: Vec -E- Z
    vlen :R: (n :R: N) -> (xs :E: Vec -E- n) -> N = \(n :R: N) (xs :E: Vec -E- n).
      case -E- xs of
        Nil/E
          | n = Z
          => n
    main :R: N = vlen -R- Z -E- Nil
  in main

### Specialised ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :E: (x :E: N) -> N
    postulate Vec :E: (_ :E: N) -> Type
    postulate Nil :E: Vec -E- Z
    vlen :R: (n :R: N) -> (xs :E: Vec -E- n) -> N = \(n :R: N) (xs :E: Vec -E- n).
      case -E- xs of
        Nil/E
          | n = Z
          => n
    main :R: N = vlen -R- Z -E- Nil
  in main

### Constraints ###

[E] -> [E]
[R] -> [R]

### Solution ###

[R]

### Annotated ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :E: (x :E: N) -> N
    postulate Vec :E: (_ :E: N) -> Type
    postulate Nil :E: Vec -E- Z
    vlen :R: (n :R: N) -> (xs :E: Vec -E- n) -> N = \(n :R: N) (xs :E: Vec -E- n).
      case -E- xs of
        Nil/E
          | n = Z
          => n
    main :R: N = vlen -R- Z -E- Nil
  in main

### Specialised ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :E: (x :E: N) -> N
    postulate Vec :E: (_ :E: N) -> Type
    postulate Nil :E: Vec -E- Z
    vlen :R: (n :R: N) -> (xs :E: Vec -E- n) -> N = \(n :R: N) (xs :E: Vec -E- n).
      case -E- xs of
        Nil/E
          | n = Z
          => n
    main :R: N = vlen -R- Z -E- Nil
  in main

### Final annotation ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :E: (x :E: N) -> N
    postulate Vec :E: (_ :E: N) -> Type
    postulate Nil :E: Vec -E- Z
    vlen :R: (n :R: N) -> (xs :E: Vec -E- n) -> N = \(n :R: N) (xs :E: Vec -E- n).
      case -E- xs of
        Nil/E
          | n = Z
          => n
    main :R: N = vlen -R- Z -E- Nil
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Z : N
    vlen = \n.
      n
    main = vlen Z
  in main

### Normal forms ###

unerased:
  
  let postulate Z : N
  in Z

erased:
  
  let postulate Z : N
  in Z

