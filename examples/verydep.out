-- vim: ft=idris

### Desugared ###

  let
    postulate Void : Type
    postulate Maybe : (_x0 : Type) -> Type
    postulate Just : (a : Type) -> (x : a) -> Maybe a
    postulate Nothing : (a : Type) -> Maybe a
    postulate Bool : Type
    postulate True : Bool
    postulate False : Bool
    retTy : (x : Maybe Bool) -> Type = \(x : Maybe Bool).
      case x of
        Just (a : Type) (t : Bool) =>
          case a of [Bool] =>
            Bool
        Nothing (a : Type) =>
          case a of [Bool] =>
            Type
    f : (x : Maybe Bool) -> retTy x = \(x : Maybe Bool).
      case x of
        Just (a : Type) (b : Bool) =>
          case a of [Bool] =>
            b
        Nothing (a : Type) =>
          case a of [Bool] =>
            Bool
    main : Bool = f (Just Bool False)
  in main

### Metaified ###

  let
    postulate Void :1: Type
    postulate Maybe :2: (_x0 :3: Type) -> Type
    postulate Just :4: (a :5: Type) -> (x :6: a) -> Maybe -7- a
    postulate Nothing :8: (a :9: Type) -> Maybe -10- a
    postulate Bool :11: Type
    postulate True :12: Bool
    postulate False :13: Bool
    retTy :14: (x :15: Maybe -16- Bool) -> Type = \(x :17: Maybe -18- Bool).
      case -19- x of
        Just/20 (a :21: Type) (t :22: Bool) =>
          case -23- a of [Bool] =>
            Bool
        Nothing/24 (a :25: Type) =>
          case -26- a of [Bool] =>
            Type
    f :27: (x :28: Maybe -29- Bool) -> retTy -30- x = \(x :31: Maybe -32- Bool).
      case -33- x of
        Just/34 (a :35: Type) (b :36: Bool) =>
          case -37- a of [Bool] =>
            b
        Nothing/38 (a :39: Type) =>
          case -40- a of [Bool] =>
            Bool
    main :41: Bool = f -42- (Just -44- Bool -43- False)
  in main

### Constraints ###

[] -> [4,6,11,13,27,28,31,33,34,36,42,43,R]
[5] -> [35,44]
[7] -> [29]
[8] -> [38]
[9] -> [39]
[10] -> [29]
[29] -> [7,10]
[35] -> [5]
[37] -> [35]
[38] -> [8]
[39] -> [9]
[40] -> [39]
[44] -> [5]
[R] -> [41]

### Solution ###

[4,6,11,13,27,28,31,33,34,36,41,42,43,R]

### Annotated ###

  let
    postulate Void :E: Type
    postulate Maybe :E: (_x0 :E: Type) -> Type
    postulate Just :R: (a :E: Type) -> (x :R: a) -> Maybe -E- a
    postulate Nothing :E: (a :E: Type) -> Maybe -E- a
    postulate Bool :R: Type
    postulate True :E: Bool
    postulate False :R: Bool
    retTy :E: (x :E: Maybe -E- Bool) -> Type = \(x :E: Maybe -E- Bool).
      case -E- x of
        Just/E (a :E: Type) (t :E: Bool) =>
          case -E- a of [Bool] =>
            Bool
        Nothing/E (a :E: Type) =>
          case -E- a of [Bool] =>
            Type
    f :R: (x :R: Maybe -E- Bool) -> retTy -E- x = \(x :R: Maybe -E- Bool).
      case -R- x of
        Just/R (a :E: Type) (b :R: Bool) =>
          case -E- a of [Bool] =>
            b
        Nothing/E (a :E: Type) =>
          case -E- a of [Bool] =>
            Bool
    main :R: Bool = f -R- (Just -E- Bool -R- False)
  in main

### Specialised ###

  let
    postulate Void :E: Type
    postulate Maybe :E: (_x0 :E: Type) -> Type
    postulate Just :R: (a :E: Type) -> (x :R: a) -> Maybe -E- a
    postulate Nothing :E: (a :E: Type) -> Maybe -E- a
    postulate Bool :R: Type
    postulate True :E: Bool
    postulate False :R: Bool
    retTy :E: (x :E: Maybe -E- Bool) -> Type = \(x :E: Maybe -E- Bool).
      case -E- x of
        Just/E (a :E: Type) (t :E: Bool) =>
          case -E- a of [Bool] =>
            Bool
        Nothing/E (a :E: Type) =>
          case -E- a of [Bool] =>
            Type
    f :R: (x :R: Maybe -E- Bool) -> retTy -E- x = \(x :R: Maybe -E- Bool).
      case -R- x of
        Just/R (a :E: Type) (b :R: Bool) =>
          case -E- a of [Bool] =>
            b
        Nothing/E (a :E: Type) =>
          case -E- a of [Bool] =>
            Bool
    main :R: Bool = f -R- (Just -E- Bool -R- False)
  in main

### Final annotation ###

  let
    postulate Void :E: Type
    postulate Maybe :E: (_x0 :E: Type) -> Type
    postulate Just :R: (a :E: Type) -> (x :R: a) -> Maybe -E- a
    postulate Nothing :E: (a :E: Type) -> Maybe -E- a
    postulate Bool :R: Type
    postulate True :E: Bool
    postulate False :R: Bool
    retTy :E: (x :E: Maybe -E- Bool) -> Type = \(x :E: Maybe -E- Bool).
      case -E- x of
        Just/E (a :E: Type) (t :E: Bool) =>
          case -E- a of [Bool] =>
            Bool
        Nothing/E (a :E: Type) =>
          case -E- a of [Bool] =>
            Type
    f :R: (x :R: Maybe -E- Bool) -> retTy -E- x = \(x :R: Maybe -E- Bool).
      case -R- x of
        Just/R (a :E: Type) (b :R: Bool) =>
          case -E- a of [Bool] =>
            b
        Nothing/E (a :E: Type) =>
          case -E- a of [Bool] =>
            Bool
    main :R: Bool = f -R- (Just -E- Bool -R- False)
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Just : (x) -> Maybe
    postulate Bool : Type
    postulate False : Bool
    f = \x.
      case x of
        Just b =>
          b
    main = f (Just False)
  in main

### Normal forms ###

unerased:
  
  let postulate False : Bool
  in False

erased:
  
  let postulate False : Bool
  in False

