-- vim: ft=agda

### Desugared ###

postulate Void : Type

postulate Maybe : (_ : Type) -> Type

postulate Just : (a : Type) -> (x : a) -> Maybe a

postulate Nothing : (a : Type) -> Maybe a

postulate Bool : Type

postulate True : Bool

postulate False : Bool

retTy : (x : Maybe Bool) -> Type = \(x : Maybe Bool).
  case x of
    Just (a : Type) (t : a)
      | a = Bool
      => Bool
    Nothing (a : Type)
      | a = Bool
      => Type

f : (x : Maybe Bool) -> retTy x = \(x : Maybe Bool).
  case x of
    Just (a : Type) (b : a)
      | a = Bool
      => b
    Nothing (a : Type)
      | a = Bool
      => Bool

main :ᴿ Bool = f (Just Bool False)

### Metaified ###

postulate Void :¹ Type

postulate Maybe :² (_ :³ Type) -> Type

postulate Just :⁴ (a :⁵ Type) -> (x :⁶ a) -> Maybe ⁷ a

postulate Nothing :⁸ (a :⁹ Type) -> Maybe ¹⁰ a

postulate Bool :¹¹ Type

postulate True :¹² Bool

postulate False :¹³ Bool

retTy :¹⁴ (x :¹⁵ Maybe ¹⁶ Bool) -> Type = \(x :¹⁷ Maybe ¹⁸ Bool).
  case ¹⁹ x of
    Just (a :²⁰ Type) (t :²¹ a)
      | a = Bool
      => Bool
    Nothing (a :²² Type)
      | a = Bool
      => Type

f :²³ (x :²⁴ Maybe ²⁵ Bool) -> retTy ²⁶ x = \(x :²⁷ Maybe ²⁸ Bool).
  case ²⁹ x of
    Just (a :³⁰ Type) (b :³¹ a)
      | a = Bool
      => b
    Nothing (a :³² Type)
      | a = Bool
      => Bool

main :ᴿ Bool = f ³³ (Just ³⁵ Bool ³⁴ False)

### Inferred definitions ###

postulate Bool :¹¹ Type

postulate False :¹³ Bool

postulate Just :⁴ (a :⁵ Type) -> (x :⁶ a) -> Maybe ⁷ a

postulate Maybe :² (_ :³ Type) -> Type

postulate Nothing :⁸ (a :⁹ Type) -> Maybe ¹⁰ a

postulate True :¹² Bool

postulate Type :ᴿ Type

postulate Void :¹ Type

f :²³ (x :²⁴ Maybe ²⁵ Bool) -> retTy ²⁶ x = \(x :²⁷ Maybe ²⁸ Bool).
  case ²⁹ x of
    Just (a :³⁰ Type) (b :³¹ a)
      | a = Bool
      => b
    Nothing (a :³² Type)
      | a = Bool
      => Bool
  [4,23] -> [24]
  [5,23] -> [24,30]
  [6,23] -> [24,31]
  [7,23] -> [25]
  [8,23] -> [24]
  [9,23] -> [24,32]
  [10,23] -> [25]
  [23] -> [11,29,31]
  [23,24] -> [27]
  [23,25] -> [7,10]
  [23,27] -> [24]
  [23,29] -> [27]
  [23,30] -> [5,24,29]
  [23,31] -> [6,24,29]
  [23,32] -> [9,24,29]

main :ᴿ Bool = f ³³ (Just ³⁵ Bool ³⁴ False)
  [] -> [23,R]
  [5,24] -> [11,35]
  [6,24] -> [13,34]
  [7] -> [25]
  [24] -> [4,33]
  [24,34] -> [6]
  [24,35] -> [5]
  [25] -> [7]
  [33] -> [24]

retTy :¹⁴ (x :¹⁵ Maybe ¹⁶ Bool) -> Type = \(x :¹⁷ Maybe ¹⁸ Bool).
  case ¹⁹ x of
    Just (a :²⁰ Type) (t :²¹ a)
      | a = Bool
      => Bool
    Nothing (a :²² Type)
      | a = Bool
      => Type
  [4,14] -> [15]
  [5,14] -> [15,20]
  [6,14] -> [15,21]
  [7,14] -> [16]
  [8,14] -> [15]
  [9,14] -> [15,22]
  [10,14] -> [16]
  [14] -> [11,19]
  [14,15] -> [17]
  [14,16] -> [7,10]
  [14,17] -> [15]
  [14,19] -> [17]
  [14,20] -> [5,15,19]
  [14,21] -> [6,15,19]
  [14,22] -> [9,15,19]


### Constraints ###

[] -> [23,R]
[4,14] -> [15]
[4,23] -> [24]
[5,14] -> [15,20]
[5,23] -> [24,30]
[5,24] -> [11,35]
[6,14] -> [15,21]
[6,23] -> [24,31]
[6,24] -> [13,34]
[7] -> [25]
[7,14] -> [16]
[7,23] -> [25]
[8,14] -> [15]
[8,23] -> [24]
[9,14] -> [15,22]
[9,23] -> [24,32]
[10,14] -> [16]
[10,23] -> [25]
[14] -> [11,19]
[14,15] -> [17]
[14,16] -> [7,10]
[14,17] -> [15]
[14,19] -> [17]
[14,20] -> [5,15,19]
[14,21] -> [6,15,19]
[14,22] -> [9,15,19]
[23] -> [11,29,31]
[23,24] -> [27]
[23,25] -> [7,10]
[23,27] -> [24]
[23,29] -> [27]
[23,30] -> [5,24,29]
[23,31] -> [6,24,29]
[23,32] -> [9,24,29]
[24] -> [4,33]
[24,34] -> [6]
[24,35] -> [5]
[25] -> [7]
[33] -> [24]

### Solution ###

[4,6,11,13,23,24,27,29,31,33,34,R]

### Annotated ###

postulate Void :ᴱ Type

postulate Maybe :ᴱ (_ :ᴱ Type) -> Type

postulate Just :ᴿ (a :ᴱ Type) -> (x :ᴿ a) -> Maybe ᴱ a

postulate Nothing :ᴱ (a :ᴱ Type) -> Maybe ᴱ a

postulate Bool :ᴿ Type

postulate True :ᴱ Bool

postulate False :ᴿ Bool

retTy :ᴱ (x :ᴱ Maybe ᴱ Bool) -> Type = \(x :ᴱ Maybe ᴱ Bool).
  case ᴱ x of
    Just (a :ᴱ Type) (t :ᴱ a)
      | a = Bool
      => Bool
    Nothing (a :ᴱ Type)
      | a = Bool
      => Type

f :ᴿ (x :ᴿ Maybe ᴱ Bool) -> retTy ᴱ x = \(x :ᴿ Maybe ᴱ Bool).
  case ᴿ x of
    Just (a :ᴱ Type) (b :ᴿ a)
      | a = Bool
      => b
    Nothing (a :ᴱ Type)
      | a = Bool
      => Bool

main :ᴿ Bool = f ᴿ (Just ᴱ Bool ᴿ False)

### Specialised ###

postulate Void :ᴱ Type

postulate Maybe :ᴱ (_ :ᴱ Type) -> Type

postulate Just :ᴿ (a :ᴱ Type) -> (x :ᴿ a) -> Maybe ᴱ a

postulate Nothing :ᴱ (a :ᴱ Type) -> Maybe ᴱ a

postulate Bool :ᴿ Type

postulate True :ᴱ Bool

postulate False :ᴿ Bool

retTy :ᴱ (x :ᴱ Maybe ᴱ Bool) -> Type = \(x :ᴱ Maybe ᴱ Bool).
  case ᴱ x of
    Just (a :ᴱ Type) (t :ᴱ a)
      | a = Bool
      => Bool
    Nothing (a :ᴱ Type)
      | a = Bool
      => Type

f :ᴿ (x :ᴿ Maybe ᴱ Bool) -> retTy ᴱ x = \(x :ᴿ Maybe ᴱ Bool).
  case ᴿ x of
    Just (a :ᴱ Type) (b :ᴿ a)
      | a = Bool
      => b
    Nothing (a :ᴱ Type)
      | a = Bool
      => Bool

main :ᴿ Bool = f ᴿ (Just ᴱ Bool ᴿ False)

### Final annotation ###

postulate Void :ᴱ Type

postulate Maybe :ᴱ (_ :ᴱ Type) -> Type

postulate Just :ᴿ (a :ᴱ Type) -> (x :ᴿ a) -> Maybe ᴱ a

postulate Nothing :ᴱ (a :ᴱ Type) -> Maybe ᴱ a

postulate Bool :ᴿ Type

postulate True :ᴱ Bool

postulate False :ᴿ Bool

retTy :ᴱ (x :ᴱ Maybe ᴱ Bool) -> Type = \(x :ᴱ Maybe ᴱ Bool).
  case ᴱ x of
    Just (a :ᴱ Type) (t :ᴱ a)
      | a = Bool
      => Bool
    Nothing (a :ᴱ Type)
      | a = Bool
      => Type

f :ᴿ (x :ᴿ Maybe ᴱ Bool) -> retTy ᴱ x = \(x :ᴿ Maybe ᴱ Bool).
  case ᴿ x of
    Just (a :ᴱ Type) (b :ᴿ a)
      | a = Bool
      => b
    Nothing (a :ᴱ Type)
      | a = Bool
      => Bool

main :ᴿ Bool = f ᴿ (Just ᴱ Bool ᴿ False)

### Verification ###

Verification successful.

### Pruned ###

postulate Just

postulate Bool

postulate False

f = \x.
  case x of
    Just b
      => b
    Nothing
      => Bool

main = f (Just False)

### Normal forms ###

unerased:
  False
erased:
  False
