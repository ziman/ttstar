-- vim: ft=agda

### Desugared ###

postulate Void : Type

postulate Maybe : (_ : Type) -> Type

postulate Just : (a : Type) -> (x : a) -> Maybe a

postulate Nothing : (a : Type) -> Maybe a

postulate Bool : Type

postulate True : Bool

postulate False : Bool

retTy : (x : Maybe Bool) -> Type = \(x : Maybe Bool).
  case x of
    Just (a : Type) (t : a)
      | a = Bool
      => Bool
    Nothing (a : Type)
      | a = Bool
      => Type

f : (x : Maybe Bool) -> retTy x = \(x : Maybe Bool).
  case x of
    Just (a : Type) (b : a)
      | a = Bool
      => b
    Nothing (a : Type)
      | a = Bool
      => Bool

main :R: Bool = f (Just Bool False)

### Metaified ###

postulate Void :1: Type

postulate Maybe :2: (_ :3: Type) -> Type

postulate Just :4: (a :5: Type) -> (x :6: a) -> Maybe -7- a

postulate Nothing :8: (a :9: Type) -> Maybe -10- a

postulate Bool :11: Type

postulate True :12: Bool

postulate False :13: Bool

retTy :14: (x :15: Maybe -16- Bool) -> Type = \(x :17: Maybe -18- Bool).
  case -19- x of
    Just (a :20: Type) (t :21: a)
      | a = Bool
      => Bool
    Nothing (a :22: Type)
      | a = Bool
      => Type

f :23: (x :24: Maybe -25- Bool) -> retTy -26- x = \(x :27: Maybe -28- Bool).
  case -29- x of
    Just (a :30: Type) (b :31: a)
      | a = Bool
      => b
    Nothing (a :32: Type)
      | a = Bool
      => Bool

main :R: Bool = f -33- (Just -35- Bool -34- False)

### Inferred definitions ###

postulate Bool :11: Type {- constraints apply -}
  [] -> [11,R]

postulate False :13: Bool {- constraints apply -}
  [] -> [11,13,R]

postulate Just :4: (a :5: Type) -> (x :6: a) -> Maybe -7- a {- constraints apply -}
  [] -> [2,4,R]
  [3] -> [5,7]
  [7] -> [3]

postulate Maybe :2: (_ :3: Type) -> Type {- constraints apply -}
  [] -> [2,R]

postulate Nothing :8: (a :9: Type) -> Maybe -10- a {- constraints apply -}
  [] -> [2,8,R]
  [3] -> [9,10]
  [10] -> [3]

postulate True :12: Bool {- constraints apply -}
  [] -> [11,12,R]

postulate Type :R: Type

postulate Void :1: Type {- constraints apply -}
  [] -> [1,R]

f :23: (x :24: Maybe -25- Bool) -> retTy -26- x = \(x :27: Maybe -28- Bool).
  case -29- x of
    Just (a :30: Type) (b :31: a)
      | a = Bool
      => b
    Nothing (a :32: Type)
      | a = Bool
      => Bool {- constraints apply -}
  [] -> [2,3,5,6,7,10,11,14,15,16,17,19,20,21,23,24,25,26,27,29,30,31,R]
  [9] -> [22,32]
  [22] -> [9]
  [32] -> [9]

main :R: Bool = f -33- (Just -35- Bool -34- False) {- constraints apply -}
  [] -> [2,3,4,5,6,7,10,11,13,14,15,16,17,19,20,21,23,24,25,26,27,29,30,31,33,34,35,R]
  [9] -> [22,32]
  [22] -> [9]
  [32] -> [9]

retTy :14: (x :15: Maybe -16- Bool) -> Type = \(x :17: Maybe -18- Bool).
  case -19- x of
    Just (a :20: Type) (t :21: a)
      | a = Bool
      => Bool
    Nothing (a :22: Type)
      | a = Bool
      => Type {- constraints apply -}
  [] -> [6,11,14,15,17,19,21,R]
  [3] -> [7,10]
  [5] -> [3,20]
  [7] -> [3,16]
  [9] -> [3,22]
  [10] -> [3,16]
  [16] -> [7,10]
  [20] -> [5]
  [22] -> [9]


### Constraints ###

[] -> [2,3,4,5,6,7,10,11,13,14,15,16,17,19,20,21,23,24,25,26,27,29,30,31,33,34,35,R]
[9] -> [22,32]
[22] -> [9]
[32] -> [9]

### Solution ###

[2,3,4,5,6,7,10,11,13,14,15,16,17,19,20,21,23,24,25,26,27,29,30,31,33,34,35,R]

### Annotated ###

postulate Void :E: Type

postulate Maybe :R: (_ :R: Type) -> Type

postulate Just :R: (a :R: Type) -> (x :R: a) -> Maybe -R- a

postulate Nothing :E: (a :E: Type) -> Maybe -R- a

postulate Bool :R: Type

postulate True :E: Bool

postulate False :R: Bool

retTy :R: (x :R: Maybe -R- Bool) -> Type = \(x :R: Maybe -E- Bool).
  case -R- x of
    Just (a :R: Type) (t :R: a)
      | a = Bool
      => Bool
    Nothing (a :E: Type)
      | a = Bool
      => Type

f :R: (x :R: Maybe -R- Bool) -> retTy -R- x = \(x :R: Maybe -E- Bool).
  case -R- x of
    Just (a :R: Type) (b :R: a)
      | a = Bool
      => b
    Nothing (a :E: Type)
      | a = Bool
      => Bool

main :R: Bool = f -R- (Just -R- Bool -R- False)

### Specialised ###

postulate Void :E: Type

postulate Maybe :R: (_ :R: Type) -> Type

postulate Just :R: (a :R: Type) -> (x :R: a) -> Maybe -R- a

postulate Nothing :E: (a :E: Type) -> Maybe -R- a

postulate Bool :R: Type

postulate True :E: Bool

postulate False :R: Bool

retTy :R: (x :R: Maybe -R- Bool) -> Type = \(x :R: Maybe -E- Bool).
  case -R- x of
    Just (a :R: Type) (t :R: a)
      | a = Bool
      => Bool
    Nothing (a :E: Type)
      | a = Bool
      => Type

f :R: (x :R: Maybe -R- Bool) -> retTy -R- x = \(x :R: Maybe -E- Bool).
  case -R- x of
    Just (a :R: Type) (b :R: a)
      | a = Bool
      => b
    Nothing (a :E: Type)
      | a = Bool
      => Bool

main :R: Bool = f -R- (Just -R- Bool -R- False)

### Final annotation ###

postulate Void :E: Type

postulate Maybe :R: (_ :R: Type) -> Type

postulate Just :R: (a :R: Type) -> (x :R: a) -> Maybe -R- a

postulate Nothing :E: (a :E: Type) -> Maybe -R- a

postulate Bool :R: Type

postulate True :E: Bool

postulate False :R: Bool

retTy :R: (x :R: Maybe -R- Bool) -> Type = \(x :R: Maybe -E- Bool).
  case -R- x of
    Just (a :R: Type) (t :R: a)
      | a = Bool
      => Bool
    Nothing (a :E: Type)
      | a = Bool
      => Type

f :R: (x :R: Maybe -R- Bool) -> retTy -R- x = \(x :R: Maybe -E- Bool).
  case -R- x of
    Just (a :R: Type) (b :R: a)
      | a = Bool
      => b
    Nothing (a :E: Type)
      | a = Bool
      => Bool

main :R: Bool = f -R- (Just -R- Bool -R- False)

### Verification ###

Verification successful.

### Pruned ###

postulate Maybe

postulate Just

postulate Bool

postulate False

retTy = \x.
  case x of
    Just a t
      => Bool
    Nothing
      => Type

f = \x.
  case x of
    Just a b
      => b
    Nothing
      => Bool

main = f (Just Bool False)

### Normal forms ###

unerased:
  False
erased:
  False
