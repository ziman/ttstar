-- vim: ft=agda

### Desugared ###

  let
    postulate T : Type
    postulate A : T
    postulate B : T
    postulate Op : (x :R: T) -> (y :R: T) -> T
    id : (y : T) -> T = (\y : T. y)
    constA : (_ : T) -> T = (\_ : T. A)
    apply : (f : (_ : T) -> T) -> (x : T) -> T = (\f : (_ : T) -> T. (\x : T. f x))
    test1 : T = [apply : (_ : (_ : T) -> T) -> (_ : T) -> T] id B
    test2 : T = [apply : (_ : (_ : T) -> T) -> (_ : T) -> T] constA B
    main :R: T = Op test1 test2
  in main

### Metaified ###

  let
    postulate T :1: Type
    postulate A :2: T
    postulate B :3: T
    postulate Op :4: (x :R: T) -> (y :R: T) -> T
    id :5: (y :6: T) -> T = (\y :7: T. y)
    constA :8: (_ :9: T) -> T = (\_ :10: T. A)
    apply :11: (f :12: (_ :13: T) -> T) -> (x :14: T) -> T = (\f :15: (_ :16: T) -> T. (\x :17: T. f -18- x))
    test1 :19: T = [apply : (_ :22: (_ :23: T) -> T) -> (_ :24: T) -> T] -21- id -20- B
    test2 :25: T = [apply : (_ :28: (_ :29: T) -> T) -> (_ :30: T) -> T] -27- constA -26- B
    main :R: T = Op -32- test1 -31- test2
  in main

### Constraints ###

[] -> [2,3,4,5,6,7,8,19,20,21,22,23,24,25,27,28,31,32,33,34,35,36,37,38,39,40,41,42,45,R]
[9] -> [10,29]
[10] -> [9]
[26] -> [30]
[29] -> [9,43]
[30] -> [26,44]
[43] -> [29,46]
[44] -> [30,47]
[46] -> [43,47,48]
[47] -> [44]
[48] -> [46]
[R] -> [R]

### Solution ###

[2,3,4,5,6,7,8,19,20,21,22,23,24,25,27,28,31,32,33,34,35,36,37,38,39,40,41,42,45,R]

### Annotated ###

  let
    postulate T :E: Type
    postulate A :R: T
    postulate B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (y :R: T) -> T = (\y :R: T. y)
    constA :R: (_ :E: T) -> T = (\_ :E: T. A)
    apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))
    test1 :R: T = [apply : (_ :R: (_ :R: T) -> T) -> (_ :R: T) -> T] -R- id -R- B
    test2 :R: T = [apply : (_ :R: (_ :E: T) -> T) -> (_ :E: T) -> T] -R- constA -E- B
    main :R: T = Op -R- test1 -R- test2
  in main

### Specialised ###

  let
    postulate T :E: Type
    postulate A :R: T
    postulate B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (y :R: T) -> T = (\y :R: T. y)
    constA :R: (_ :E: T) -> T = (\_ :E: T. A)
    apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))
    apply_REE :33: (f :R: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :34: (_ :35: T) -> T. (\x :36: T. f -37- x))
    apply_RRR :38: (f :R: (_ :R: T) -> T) -> (x :R: T) -> T = (\f :39: (_ :40: T) -> T. (\x :41: T. f -42- x))
    test1 :R: T = apply_RRR -R- id -R- B
    test2 :R: T = apply_REE -R- constA -E- B
    main :R: T = Op -R- test1 -R- test2
  in main

### Constraints ###

[] -> [33,34,38,39,40,41,42,R]
[35] -> [36,37,E]
[36] -> [E]
[37] -> [35]
[E] -> [35,36,E]
[R] -> [R]

### Solution ###

[33,34,38,39,40,41,42,R]

### Annotated ###

  let
    postulate T :E: Type
    postulate A :R: T
    postulate B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (y :R: T) -> T = (\y :R: T. y)
    constA :R: (_ :E: T) -> T = (\_ :E: T. A)
    apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))
    apply_REE :R: (f :R: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :R: (_ :E: T) -> T. (\x :E: T. f -E- x))
    apply_RRR :R: (f :R: (_ :R: T) -> T) -> (x :R: T) -> T = (\f :R: (_ :R: T) -> T. (\x :R: T. f -R- x))
    test1 :R: T = apply_RRR -R- id -R- B
    test2 :R: T = apply_REE -R- constA -E- B
    main :R: T = Op -R- test1 -R- test2
  in main

### Specialised ###

  let
    postulate T :E: Type
    postulate A :R: T
    postulate B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (y :R: T) -> T = (\y :R: T. y)
    constA :R: (_ :E: T) -> T = (\_ :E: T. A)
    apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))
    apply_REE :R: (f :R: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :R: (_ :E: T) -> T. (\x :E: T. f -E- x))
    apply_RRR :R: (f :R: (_ :R: T) -> T) -> (x :R: T) -> T = (\f :R: (_ :R: T) -> T. (\x :R: T. f -R- x))
    test1 :R: T = apply_RRR -R- id -R- B
    test2 :R: T = apply_REE -R- constA -E- B
    main :R: T = Op -R- test1 -R- test2
  in main

### Constraints ###

[E] -> [E]
[R] -> [R]

### Solution ###

[R]

### Annotated ###

  let
    postulate T :E: Type
    postulate A :R: T
    postulate B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (y :R: T) -> T = (\y :R: T. y)
    constA :R: (_ :E: T) -> T = (\_ :E: T. A)
    apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))
    apply_REE :R: (f :R: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :R: (_ :E: T) -> T. (\x :E: T. f -E- x))
    apply_RRR :R: (f :R: (_ :R: T) -> T) -> (x :R: T) -> T = (\f :R: (_ :R: T) -> T. (\x :R: T. f -R- x))
    test1 :R: T = apply_RRR -R- id -R- B
    test2 :R: T = apply_REE -R- constA -E- B
    main :R: T = Op -R- test1 -R- test2
  in main

### Specialised ###

  let
    postulate T :E: Type
    postulate A :R: T
    postulate B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (y :R: T) -> T = (\y :R: T. y)
    constA :R: (_ :E: T) -> T = (\_ :E: T. A)
    apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))
    apply_REE :R: (f :R: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :R: (_ :E: T) -> T. (\x :E: T. f -E- x))
    apply_RRR :R: (f :R: (_ :R: T) -> T) -> (x :R: T) -> T = (\f :R: (_ :R: T) -> T. (\x :R: T. f -R- x))
    test1 :R: T = apply_RRR -R- id -R- B
    test2 :R: T = apply_REE -R- constA -E- B
    main :R: T = Op -R- test1 -R- test2
  in main

### Final annotation ###

  let
    postulate T :E: Type
    postulate A :R: T
    postulate B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (y :R: T) -> T = (\y :R: T. y)
    constA :R: (_ :E: T) -> T = (\_ :E: T. A)
    apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))
    apply_REE :R: (f :R: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :R: (_ :E: T) -> T. (\x :E: T. f -E- x))
    apply_RRR :R: (f :R: (_ :R: T) -> T) -> (x :R: T) -> T = (\f :R: (_ :R: T) -> T. (\x :R: T. f -R- x))
    test1 :R: T = apply_RRR -R- id -R- B
    test2 :R: T = apply_REE -R- constA -E- B
    main :R: T = Op -R- test1 -R- test2
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate A : T
    postulate B : T
    postulate Op : (x) -> (y) -> T
    id = (\y. y)
    constA = A
    apply_REE = (\f. f)
    apply_RRR = (\f. (\x. f x))
    test1 = apply_RRR id B
    test2 = apply_REE constA
    main = Op test1 test2
  in main

### Normal forms ###

unerased:
  
  let
    postulate A : T
    postulate B : T
    postulate Op : (x :R: T) -> (y :R: T) -> T
  in Op B A

erased:
  
  let
    postulate A : T
    postulate B : T
    postulate Op : (x) -> (y) -> T
  in Op B A

