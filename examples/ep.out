-- vim: ft=agda

### Desugared ###

postulate T : Type

postulate A : T

postulate B : T

postulate Op : (x :R: T) -> (y :R: T) -> T

id : (y : T) -> T = (\y : T. y)

constA : (_ : T) -> T = (\_ : T. A)

apply : (f : (_ : T) -> T) -> (x : T) -> T = (\f : (_ : T) -> T. (\x : T. f x))

test1 : T = [apply : (_ : (_ : T) -> T) -> (_ : T) -> T] id B

test2 : T = [apply : (_ : (_ : T) -> T) -> (_ : T) -> T] constA B

main :R: T = Op test1 test2

### Metaified ###

postulate T :1: Type

postulate A :2: T

postulate B :3: T

postulate Op :4: (x :R: T) -> (y :R: T) -> T

id :5: (y :6: T) -> T = (\y :7: T. y)

constA :8: (_ :9: T) -> T = (\_ :10: T. A)

apply :11: (f :12: (_ :13: T) -> T) -> (x :14: T) -> T = (\f :15: (_ :16: T) -> T. (\x :17: T. f -18- x))

test1 :19: T = [apply : (_ :22: (_ :23: T) -> T) -> (_ :24: T) -> T] -21- id -20- B

test2 :25: T = [apply : (_ :28: (_ :29: T) -> T) -> (_ :30: T) -> T] -27- constA -26- B

main :R: T = Op -32- test1 -31- test2

### Inferred definitions ###

postulate A :2: T {- constraints apply -}
  [] -> [2,R]

postulate B :3: T {- constraints apply -}
  [] -> [3,R]

postulate Op :4: (x :R: T) -> (y :R: T) -> T {- constraints apply -}
  [] -> [4,R]

postulate T :1: Type {- constraints apply -}
  [] -> [1,R]

postulate Type :E: Type

apply :11: (f :12: (_ :13: T) -> T) -> (x :14: T) -> T = (\f :15: (_ :16: T) -> T. (\x :17: T. f -18- x)) {- constraints apply -}
  [] -> [11,12,15,R]
  [13] -> [16]
  [14] -> [17]
  [16] -> [13,17,18]
  [17] -> [14]
  [18] -> [16]

constA :8: (_ :9: T) -> T = (\_ :10: T. A) {- constraints apply -}
  [] -> [2,8,R]
  [9] -> [10]
  [10] -> [9]

id :5: (y :6: T) -> T = (\y :7: T. y) {- constraints apply -}
  [] -> [5,6,7,R]

main :R: T = Op -32- test1 -31- test2 {- constraints apply -}
  [] -> [2,3,4,5,6,7,8,19,20,21,22,23,24,25,27,28,31,32,33,34,35,36,37,38,39,40,41,42,45,R]
  [9] -> [10,29]
  [10] -> [9]
  [26] -> [30]
  [29] -> [9,43]
  [30] -> [26,44]
  [43] -> [29,46]
  [44] -> [30,47]
  [46] -> [43,47,48]
  [47] -> [44]
  [48] -> [46]

test1 :19: T = [apply : (_ :22: (_ :23: T) -> T) -> (_ :24: T) -> T] -21- id -20- B {- constraints apply -}
  [] -> [3,5,6,7,19,20,21,22,23,24,33,34,35,36,37,38,39,40,R]

test2 :25: T = [apply : (_ :28: (_ :29: T) -> T) -> (_ :30: T) -> T] -27- constA -26- B {- constraints apply -}
  [] -> [2,8,25,27,28,41,42,45,R]
  [9] -> [10,29]
  [10] -> [9]
  [26] -> [30]
  [29] -> [9,43]
  [30] -> [3,26,44]
  [43] -> [29,46]
  [44] -> [30,47]
  [46] -> [43,47,48]
  [47] -> [44]
  [48] -> [46]


### Constraints ###

[] -> [2,3,4,5,6,7,8,19,20,21,22,23,24,25,27,28,31,32,33,34,35,36,37,38,39,40,41,42,45,R]
[9] -> [10,29]
[10] -> [9]
[26] -> [30]
[29] -> [9,43]
[30] -> [26,44]
[43] -> [29,46]
[44] -> [30,47]
[46] -> [43,47,48]
[47] -> [44]
[48] -> [46]

### Solution ###

[2,3,4,5,6,7,8,19,20,21,22,23,24,25,27,28,31,32,33,34,35,36,37,38,39,40,41,42,45,R]

### Annotated ###

postulate T :E: Type

postulate A :R: T

postulate B :R: T

postulate Op :R: (x :R: T) -> (y :R: T) -> T

id :R: (y :R: T) -> T = (\y :R: T. y)

constA :R: (_ :E: T) -> T = (\_ :E: T. A)

apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))

test1 :R: T = [apply : (_ :R: (_ :R: T) -> T) -> (_ :R: T) -> T] -R- id -R- B

test2 :R: T = [apply : (_ :R: (_ :E: T) -> T) -> (_ :E: T) -> T] -R- constA -E- B

main :R: T = Op -R- test1 -R- test2

### Specialised ###

postulate T :E: Type

postulate A :R: T

postulate B :R: T

postulate Op :R: (x :R: T) -> (y :R: T) -> T

id :R: (y :R: T) -> T = (\y :R: T. y)

constA :R: (_ :E: T) -> T = (\_ :E: T. A)

apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))

apply_REE :1: (f :R: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :2: (_ :3: T) -> T. (\x :4: T. f -5- x))

apply_RRR :6: (f :R: (_ :R: T) -> T) -> (x :R: T) -> T = (\f :7: (_ :8: T) -> T. (\x :9: T. f -10- x))

test1 :R: T = apply_RRR -R- id -R- B

test2 :R: T = apply_REE -R- constA -E- B

main :R: T = Op -R- test1 -R- test2

### Inferred definitions ###

postulate A :R: T

postulate B :R: T

postulate Op :R: (x :R: T) -> (y :R: T) -> T

postulate T :E: Type {- constraints apply -}
  [] -> [E,R]

postulate Type :E: Type

apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x)) {- constraints apply -}
  [] -> [E,R]

constA :R: (_ :E: T) -> T = (\_ :E: T. A) {- constraints apply -}
  [E] -> [E]

id :R: (y :R: T) -> T = (\y :R: T. y)

main :R: T = Op -R- test1 -R- test2 {- constraints apply -}
  [] -> [1,2,6,7,8,9,10,R]
  [3] -> [4,5,E]
  [4] -> [E]
  [5] -> [3]
  [E] -> [3,4,E]

test1 :R: T = apply_RRR -R- id -R- B {- constraints apply -}
  [] -> [6,7,8,9,10,R]

test2 :R: T = apply_REE -R- constA -E- B {- constraints apply -}
  [] -> [1,2,R]
  [3] -> [4,5,E]
  [4] -> [E]
  [5] -> [3]
  [E] -> [3,4,E]

apply_REE :1: (f :R: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :2: (_ :3: T) -> T. (\x :4: T. f -5- x)) {- constraints apply -}
  [] -> [1,2,R]
  [3] -> [4,5,E]
  [4] -> [E]
  [5] -> [3]
  [E] -> [3,4]

apply_RRR :6: (f :R: (_ :R: T) -> T) -> (x :R: T) -> T = (\f :7: (_ :8: T) -> T. (\x :9: T. f -10- x)) {- constraints apply -}
  [] -> [6,7,8,9,10,R]


### Constraints ###

[] -> [1,2,6,7,8,9,10,R]
[3] -> [4,5,E]
[4] -> [E]
[5] -> [3]
[E] -> [3,4,E]

### Solution ###

[1,2,6,7,8,9,10,R]

### Annotated ###

postulate T :E: Type

postulate A :R: T

postulate B :R: T

postulate Op :R: (x :R: T) -> (y :R: T) -> T

id :R: (y :R: T) -> T = (\y :R: T. y)

constA :R: (_ :E: T) -> T = (\_ :E: T. A)

apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))

apply_REE :R: (f :R: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :R: (_ :E: T) -> T. (\x :E: T. f -E- x))

apply_RRR :R: (f :R: (_ :R: T) -> T) -> (x :R: T) -> T = (\f :R: (_ :R: T) -> T. (\x :R: T. f -R- x))

test1 :R: T = apply_RRR -R- id -R- B

test2 :R: T = apply_REE -R- constA -E- B

main :R: T = Op -R- test1 -R- test2

### Specialised ###

postulate T :E: Type

postulate A :R: T

postulate B :R: T

postulate Op :R: (x :R: T) -> (y :R: T) -> T

id :R: (y :R: T) -> T = (\y :R: T. y)

constA :R: (_ :E: T) -> T = (\_ :E: T. A)

apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))

apply_REE :R: (f :R: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :R: (_ :E: T) -> T. (\x :E: T. f -E- x))

apply_RRR :R: (f :R: (_ :R: T) -> T) -> (x :R: T) -> T = (\f :R: (_ :R: T) -> T. (\x :R: T. f -R- x))

test1 :R: T = apply_RRR -R- id -R- B

test2 :R: T = apply_REE -R- constA -E- B

main :R: T = Op -R- test1 -R- test2

### Final annotation ###

postulate T :E: Type

postulate A :R: T

postulate B :R: T

postulate Op :R: (x :R: T) -> (y :R: T) -> T

id :R: (y :R: T) -> T = (\y :R: T. y)

constA :R: (_ :E: T) -> T = (\_ :E: T. A)

apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))

apply_REE :R: (f :R: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :R: (_ :E: T) -> T. (\x :E: T. f -E- x))

apply_RRR :R: (f :R: (_ :R: T) -> T) -> (x :R: T) -> T = (\f :R: (_ :R: T) -> T. (\x :R: T. f -R- x))

test1 :R: T = apply_RRR -R- id -R- B

test2 :R: T = apply_REE -R- constA -E- B

main :R: T = Op -R- test1 -R- test2

### Verification ###

Verification successful.

### Pruned ###

postulate A : T

postulate B : T

postulate Op : (x) -> (y) -> T

id = (\y. y)

constA = A

apply_REE = (\f. f)

apply_RRR = (\f. (\x. f x))

test1 = apply_RRR id B

test2 = apply_REE constA

main = Op test1 test2

### Normal forms ###

unerased:
  Op B A
erased:
  Op B A
