-- vim: ft=agda

### Desugared ###

  let
    postulate T : Type
    postulate A : T
    postulate B : T
    postulate Op : (x :R: T) -> (y :R: T) -> T
    id : (y : T) -> T = (\y : T. y)
    constA : (_ : T) -> T = (\_ : T. A)
    apply : (f : (x#0 : T) -> T) -> (x : T) -> T = (\f : (x#0 : T) -> T. (\x : T. f x))
    test1 : T = [apply : (x#1 : (x#2 : T) -> T) -> (x#3 : T) -> T] id B
    test2 : T = [apply : (x#4 : (x#5 : T) -> T) -> (x#6 : T) -> T] constA B
    main : T = Op test1 test2
  in main

### Metaified ###

  let
    postulate T :1: Type
    postulate A :2: T
    postulate B :3: T
    postulate Op :4: (x :R: T) -> (y :R: T) -> T
    id :5: (y :6: T) -> T = (\y :7: T. y)
    constA :8: (_ :9: T) -> T = (\_ :10: T. A)
    apply :11: (f :12: (x#0 :13: T) -> T) -> (x :14: T) -> T = (\f :15: (x#0 :16: T) -> T. (\x :17: T. f -18- x))
    test1 :19: T = [apply : (x#1 :22: (x#2 :23: T) -> T) -> (x#3 :24: T) -> T] -21- id -20- B
    test2 :25: T = [apply : (x#4 :28: (x#5 :29: T) -> T) -> (x#6 :30: T) -> T] -27- constA -26- B
    main :31: T = Op -33- test1 -32- test2
  in main

### Constraints ###

[] -> [2,3,4,5,6,7,8,19,20,21,22,23,24,25,27,28,32,33,34,35,36,37,38,39,40,41,42,43,46,R]
[9] -> [10,29]
[10] -> [9]
[26] -> [30]
[29] -> [9,44]
[30] -> [26,45]
[44] -> [29,47]
[45] -> [30,48]
[47] -> [44,48,49]
[48] -> [45]
[49] -> [47]
[R] -> [31]

### Solution ###

[2,3,4,5,6,7,8,19,20,21,22,23,24,25,27,28,31,32,33,34,35,36,37,38,39,40,41,42,43,46,R]

### Annotated ###

  let
    postulate T :E: Type
    postulate A :R: T
    postulate B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (y :R: T) -> T = (\y :R: T. y)
    constA :R: (_ :E: T) -> T = (\_ :E: T. A)
    apply :E: (f :E: (x#0 :E: T) -> T) -> (x :E: T) -> T = (\f :E: (x#0 :E: T) -> T. (\x :E: T. f -E- x))
    test1 :R: T = [apply : (x#1 :R: (x#2 :R: T) -> T) -> (x#3 :R: T) -> T] -R- id -R- B
    test2 :R: T = [apply : (x#4 :R: (x#5 :E: T) -> T) -> (x#6 :E: T) -> T] -R- constA -E- B
    main :R: T = Op -R- test1 -R- test2
  in main

### Specialised ###

  let
    postulate T :E: Type
    postulate A :R: T
    postulate B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (y :R: T) -> T = (\y :R: T. y)
    constA :R: (_ :E: T) -> T = (\_ :E: T. A)
    apply :E: (f :E: (x#0 :E: T) -> T) -> (x :E: T) -> T = (\f :E: (x#0 :E: T) -> T. (\x :E: T. f -E- x))
    apply_REE :34: (f :R: (x#0 :E: T) -> T) -> (x :E: T) -> T = (\f :35: (x#0 :36: T) -> T. (\x :37: T. f -38- x))
    apply_RRR :39: (f :R: (x#0 :R: T) -> T) -> (x :R: T) -> T = (\f :40: (x#0 :41: T) -> T. (\x :42: T. f -43- x))
    test1 :R: T = apply_RRR -R- id -R- B
    test2 :R: T = apply_REE -R- constA -E- B
    main :R: T = Op -R- test1 -R- test2
  in main

### Constraints ###

[] -> [34,35,39,40,41,42,43,R]
[36] -> [37,38,E]
[37] -> [E]
[38] -> [36]
[E] -> [36,37,E]
[R] -> [R]

### Solution ###

[34,35,39,40,41,42,43,R]

### Annotated ###

  let
    postulate T :E: Type
    postulate A :R: T
    postulate B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (y :R: T) -> T = (\y :R: T. y)
    constA :R: (_ :E: T) -> T = (\_ :E: T. A)
    apply :E: (f :E: (x#0 :E: T) -> T) -> (x :E: T) -> T = (\f :E: (x#0 :E: T) -> T. (\x :E: T. f -E- x))
    apply_REE :R: (f :R: (x#0 :E: T) -> T) -> (x :E: T) -> T = (\f :R: (x#0 :E: T) -> T. (\x :E: T. f -E- x))
    apply_RRR :R: (f :R: (x#0 :R: T) -> T) -> (x :R: T) -> T = (\f :R: (x#0 :R: T) -> T. (\x :R: T. f -R- x))
    test1 :R: T = apply_RRR -R- id -R- B
    test2 :R: T = apply_REE -R- constA -E- B
    main :R: T = Op -R- test1 -R- test2
  in main

### Specialised ###

  let
    postulate T :E: Type
    postulate A :R: T
    postulate B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (y :R: T) -> T = (\y :R: T. y)
    constA :R: (_ :E: T) -> T = (\_ :E: T. A)
    apply :E: (f :E: (x#0 :E: T) -> T) -> (x :E: T) -> T = (\f :E: (x#0 :E: T) -> T. (\x :E: T. f -E- x))
    apply_REE :R: (f :R: (x#0 :E: T) -> T) -> (x :E: T) -> T = (\f :R: (x#0 :E: T) -> T. (\x :E: T. f -E- x))
    apply_RRR :R: (f :R: (x#0 :R: T) -> T) -> (x :R: T) -> T = (\f :R: (x#0 :R: T) -> T. (\x :R: T. f -R- x))
    test1 :R: T = apply_RRR -R- id -R- B
    test2 :R: T = apply_REE -R- constA -E- B
    main :R: T = Op -R- test1 -R- test2
  in main

### Final annotation ###

  let
    postulate T :E: Type
    postulate A :R: T
    postulate B :R: T
    postulate Op :R: (x :R: T) -> (y :R: T) -> T
    id :R: (y :R: T) -> T = (\y :R: T. y)
    constA :R: (_ :E: T) -> T = (\_ :E: T. A)
    apply :E: (f :E: (x#0 :E: T) -> T) -> (x :E: T) -> T = (\f :E: (x#0 :E: T) -> T. (\x :E: T. f -E- x))
    apply_REE :R: (f :R: (x#0 :E: T) -> T) -> (x :E: T) -> T = (\f :R: (x#0 :E: T) -> T. (\x :E: T. f -E- x))
    apply_RRR :R: (f :R: (x#0 :R: T) -> T) -> (x :R: T) -> T = (\f :R: (x#0 :R: T) -> T. (\x :R: T. f -R- x))
    test1 :R: T = apply_RRR -R- id -R- B
    test2 :R: T = apply_REE -R- constA -E- B
    main :R: T = Op -R- test1 -R- test2
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate A : T
    postulate B : T
    postulate Op : (x) -> (y) -> T
    id = (\y. y)
    constA = A
    apply_REE = (\f. f)
    apply_RRR = (\f. (\x. f x))
    test1 = apply_RRR id B
    test2 = apply_REE constA
    main = Op test1 test2
  in main

### Normal forms ###

unerased:
  
  let
    postulate A : T
    postulate B : T
    postulate Op : (x :R: T) -> (y :R: T) -> T
  in Op B A

erased:
  
  let
    postulate A : T
    postulate B : T
    postulate Op : (x) -> (y) -> T
  in Op B A

