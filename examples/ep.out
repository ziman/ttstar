-- vim: ft=agda

### Desugared ###

postulate T : Type

postulate A : T

postulate B : T

postulate Op : (x :R: T) -> (y :R: T) -> T

id : (y : T) -> T = (\y : T. y)

constA : (_ : T) -> T = (\_ : T. A)

apply : (f : (_ : T) -> T) -> (x : T) -> T = (\f : (_ : T) -> T. (\x : T. f x))

test1 : T = [apply : (_ : (_ : T) -> T) -> (_ : T) -> T] id B

test2 : T = [apply : (_ : (_ : T) -> T) -> (_ : T) -> T] constA B

main :R: T = Op test1 test2

### Metaified ###

postulate T :1: Type

postulate A :2: T

postulate B :3: T

postulate Op :4: (x :R: T) -> (y :R: T) -> T

id :5: (y :6: T) -> T = (\y :7: T. y)

constA :8: (_ :9: T) -> T = (\_ :10: T. A)

apply :11: (f :12: (_ :13: T) -> T) -> (x :14: T) -> T = (\f :15: (_ :16: T) -> T. (\x :17: T. f -18- x))

test1 :19: T = [apply : (_ :22: (_ :23: T) -> T) -> (_ :24: T) -> T] -21- id -20- B

test2 :25: T = [apply : (_ :28: (_ :29: T) -> T) -> (_ :30: T) -> T] -27- constA -26- B

main :R: T = Op -32- test1 -31- test2

### Inferred definitions ###

postulate A :2: T

postulate B :3: T

postulate Op :4: (x :R: T) -> (y :R: T) -> T

postulate T :1: Type

postulate Type :R: Type

apply :11: (f :12: (_ :13: T) -> T) -> (x :14: T) -> T = (\f :15: (_ :16: T) -> T. (\x :17: T. f -18- x))
  [11] -> [15]
  [11,12] -> [15]
  [11,13] -> [16]
  [11,14] -> [17]
  [11,15] -> [12]
  [11,16] -> [13,17,18]
  [11,17] -> [14]
  [11,18] -> [16]

constA :8: (_ :9: T) -> T = (\_ :10: T. A)
  [8] -> [2]
  [8,9] -> [10]
  [8,10] -> [9]

id :5: (y :6: T) -> T = (\y :7: T. y)
  [5] -> [7]
  [5,6] -> [7]
  [5,7] -> [6]

main :R: T = Op -32- test1 -31- test2
  [] -> [4,19,25,31,32,R]

test1 :19: T = [apply : (_ :22: (_ :23: T) -> T) -> (_ :24: T) -> T] -21- id -20- B
  [6,19] -> [35]
  [19] -> [33]
  [19,20] -> [36]
  [19,21] -> [34]
  [19,22] -> [34]
  [19,23] -> [35]
  [19,24] -> [36]
  [19,33] -> [37]
  [19,33,34] -> [37]
  [19,33,35] -> [38]
  [19,33,36] -> [39]
  [19,33,37] -> [34]
  [19,33,38] -> [35,39,40]
  [19,33,39] -> [36]
  [19,33,40] -> [38]
  [19,34] -> [5,21,22]
  [19,35] -> [6,23]
  [19,36] -> [3,20,24]

test2 :25: T = [apply : (_ :28: (_ :29: T) -> T) -> (_ :30: T) -> T] -27- constA -26- B
  [9,25] -> [43]
  [25] -> [41]
  [25,26] -> [44]
  [25,27] -> [42]
  [25,28] -> [42]
  [25,29] -> [43]
  [25,30] -> [44]
  [25,41] -> [45]
  [25,41,42] -> [45]
  [25,41,43] -> [46]
  [25,41,44] -> [47]
  [25,41,45] -> [42]
  [25,41,46] -> [43,47,48]
  [25,41,47] -> [44]
  [25,41,48] -> [46]
  [25,42] -> [8,27,28]
  [25,43] -> [9,29]
  [25,44] -> [3,26,30]


### Constraints ###

[] -> [4,19,25,31,32,R]
[5] -> [7]
[5,6] -> [7]
[5,7] -> [6]
[6,19] -> [35]
[8] -> [2]
[8,9] -> [10]
[8,10] -> [9]
[9,25] -> [43]
[11] -> [15]
[11,12] -> [15]
[11,13] -> [16]
[11,14] -> [17]
[11,15] -> [12]
[11,16] -> [13,17,18]
[11,17] -> [14]
[11,18] -> [16]
[19] -> [33]
[19,20] -> [36]
[19,21] -> [34]
[19,22] -> [34]
[19,23] -> [35]
[19,24] -> [36]
[19,33] -> [37]
[19,33,34] -> [37]
[19,33,35] -> [38]
[19,33,36] -> [39]
[19,33,37] -> [34]
[19,33,38] -> [35,39,40]
[19,33,39] -> [36]
[19,33,40] -> [38]
[19,34] -> [5,21,22]
[19,35] -> [6,23]
[19,36] -> [3,20,24]
[25] -> [41]
[25,26] -> [44]
[25,27] -> [42]
[25,28] -> [42]
[25,29] -> [43]
[25,30] -> [44]
[25,41] -> [45]
[25,41,42] -> [45]
[25,41,43] -> [46]
[25,41,44] -> [47]
[25,41,45] -> [42]
[25,41,46] -> [43,47,48]
[25,41,47] -> [44]
[25,41,48] -> [46]
[25,42] -> [8,27,28]
[25,43] -> [9,29]
[25,44] -> [3,26,30]

### Solution ###

[2,3,4,5,6,7,8,19,20,21,22,23,24,25,27,28,31,32,33,34,35,36,37,38,39,40,41,42,45,R]

### Annotated ###

postulate T :E: Type

postulate A :R: T

postulate B :R: T

postulate Op :R: (x :R: T) -> (y :R: T) -> T

id :R: (y :R: T) -> T = (\y :R: T. y)

constA :R: (_ :E: T) -> T = (\_ :E: T. A)

apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))

test1 :R: T = [apply : (_ :R: (_ :R: T) -> T) -> (_ :R: T) -> T] -R- id -R- B

test2 :R: T = [apply : (_ :R: (_ :E: T) -> T) -> (_ :E: T) -> T] -R- constA -E- B

main :R: T = Op -R- test1 -R- test2

### Specialised ###

postulate T :E: Type

postulate A :R: T

postulate B :R: T

postulate Op :R: (x :R: T) -> (y :R: T) -> T

id :R: (y :R: T) -> T = (\y :R: T. y)

constA :R: (_ :E: T) -> T = (\_ :E: T. A)

apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))

apply_REE :1: (f :R: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :2: (_ :3: T) -> T. (\x :4: T. f -5- x))

apply_RRR :6: (f :R: (_ :R: T) -> T) -> (x :R: T) -> T = (\f :7: (_ :8: T) -> T. (\x :9: T. f -10- x))

test1 :R: T = apply_RRR -R- id -R- B

test2 :R: T = apply_REE -R- constA -E- B

main :R: T = Op -R- test1 -R- test2

### Inferred definitions ###

postulate A :R: T

postulate B :R: T

postulate Op :R: (x :R: T) -> (y :R: T) -> T

postulate T :E: Type

postulate Type :R: Type

apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))
  [E] -> [E]

constA :R: (_ :E: T) -> T = (\_ :E: T. A)
  [E] -> [E]

id :R: (y :R: T) -> T = (\y :R: T. y)

main :R: T = Op -R- test1 -R- test2

test1 :R: T = apply_RRR -R- id -R- B
  [] -> [6,R]

test2 :R: T = apply_REE -R- constA -E- B
  [] -> [1,R]
  [E] -> [E]

apply_REE :1: (f :R: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :2: (_ :3: T) -> T. (\x :4: T. f -5- x))
  [1] -> [2]
  [1,3] -> [4,5,E]
  [1,4] -> [E]
  [1,5] -> [3]
  [1,E] -> [3,4]

apply_RRR :6: (f :R: (_ :R: T) -> T) -> (x :R: T) -> T = (\f :7: (_ :8: T) -> T. (\x :9: T. f -10- x))
  [6] -> [7,8,9]
  [6,8] -> [9,10]
  [6,10] -> [8]


### Constraints ###

[] -> [1,6,R]
[1] -> [2]
[1,3] -> [4,5,E]
[1,4] -> [E]
[1,5] -> [3]
[1,E] -> [3,4]
[6] -> [7,8,9]
[6,8] -> [9,10]
[6,10] -> [8]
[E] -> [E]

### Solution ###

[1,2,6,7,8,9,10,R]

### Annotated ###

postulate T :E: Type

postulate A :R: T

postulate B :R: T

postulate Op :R: (x :R: T) -> (y :R: T) -> T

id :R: (y :R: T) -> T = (\y :R: T. y)

constA :R: (_ :E: T) -> T = (\_ :E: T. A)

apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))

apply_REE :R: (f :R: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :R: (_ :E: T) -> T. (\x :E: T. f -E- x))

apply_RRR :R: (f :R: (_ :R: T) -> T) -> (x :R: T) -> T = (\f :R: (_ :R: T) -> T. (\x :R: T. f -R- x))

test1 :R: T = apply_RRR -R- id -R- B

test2 :R: T = apply_REE -R- constA -E- B

main :R: T = Op -R- test1 -R- test2

### Specialised ###

postulate T :E: Type

postulate A :R: T

postulate B :R: T

postulate Op :R: (x :R: T) -> (y :R: T) -> T

id :R: (y :R: T) -> T = (\y :R: T. y)

constA :R: (_ :E: T) -> T = (\_ :E: T. A)

apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))

apply_REE :R: (f :R: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :R: (_ :E: T) -> T. (\x :E: T. f -E- x))

apply_RRR :R: (f :R: (_ :R: T) -> T) -> (x :R: T) -> T = (\f :R: (_ :R: T) -> T. (\x :R: T. f -R- x))

test1 :R: T = apply_RRR -R- id -R- B

test2 :R: T = apply_REE -R- constA -E- B

main :R: T = Op -R- test1 -R- test2

### Final annotation ###

postulate T :E: Type

postulate A :R: T

postulate B :R: T

postulate Op :R: (x :R: T) -> (y :R: T) -> T

id :R: (y :R: T) -> T = (\y :R: T. y)

constA :R: (_ :E: T) -> T = (\_ :E: T. A)

apply :E: (f :E: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :E: (_ :E: T) -> T. (\x :E: T. f -E- x))

apply_REE :R: (f :R: (_ :E: T) -> T) -> (x :E: T) -> T = (\f :R: (_ :E: T) -> T. (\x :E: T. f -E- x))

apply_RRR :R: (f :R: (_ :R: T) -> T) -> (x :R: T) -> T = (\f :R: (_ :R: T) -> T. (\x :R: T. f -R- x))

test1 :R: T = apply_RRR -R- id -R- B

test2 :R: T = apply_REE -R- constA -E- B

main :R: T = Op -R- test1 -R- test2

### Verification ###

Verification successful.

### Pruned ###

postulate A

postulate B

postulate Op

id = (\y. y)

constA = A

apply_REE = (\f. f)

apply_RRR = (\f. (\x. f x))

test1 = apply_RRR id B

test2 = apply_REE constA

main = Op test1 test2

### Normal forms ###

unerased:
  Op B A
erased:
  Op B A
