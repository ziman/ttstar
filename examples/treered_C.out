-- vim: ft=idris

### Desugared ###

  let
    postulate N : Type
    postulate Z :R: N
    postulate S : (x :R: N) -> N
    postulate Vec : (_x0 : N) -> (_x1 : Type) -> Type
    postulate Nil : (a : Type) -> Vec Z a
    postulate Cons : (a : Type) -> (n : N) -> (x : a) -> (xs : Vec n a) -> Vec (S n) a
    vlen : (n : N) -> (xs : Vec n N) -> N = \(n : N) (xs : Vec n N).
      case xs of
        Nil (a : Type)
          | a = N
          | n = Z
          => n
        Cons (a : Type) (m : N) (y : N) (ys : Vec m N)
          | a = N
          | n = S m
          => S (vlen m ys)
    main : N = vlen 1 (Cons N Z 3 (Nil N))
  in main

### Metaified ###

  let
    postulate N :1: Type
    postulate Z :R: N
    postulate S :2: (x :R: N) -> N
    postulate Vec :3: (_x0 :4: N) -> (_x1 :5: Type) -> Type
    postulate Nil :6: (a :7: Type) -> Vec -9- Z -8- a
    postulate Cons :10: (a :11: Type) -> (n :12: N) -> (x :13: a) -> (xs :14: Vec -16- n -15- a) -> Vec -18- (S -19- n) -17- a
    vlen :20: (n :21: N) -> (xs :22: Vec -24- n -23- N) -> N = \(n :25: N) (xs :26: Vec -28- n -27- N).
      case -29- xs of
        Nil/30 (a :31: Type)
          | a = N
          | n = Z
          => n
        Cons/32 (a :33: Type) (m :34: N) (y :35: N) (ys :36: Vec -38- m -37- N)
          | a = N
          | n = S -39- m
          => S -40- (vlen -42- m -41- ys)
    main :43: N = vlen -45- 1 -44- (Cons -50- N -49- Z -48- 3 -47- (Nil -54- N))
  in main

### Constraints ###

[] -> [2,6,10,12,14,19,20,21,22,25,26,29,30,32,34,36,39,40,41,42,44,45,46,47,49,R]
[7] -> [1,31,54]
[8] -> [15,23]
[9] -> [16,24]
[11] -> [1,33,50]
[13] -> [35,48,51,52,53]
[15] -> [8,37]
[16] -> [9,38]
[17] -> [23]
[18] -> [24]
[23] -> [8,17,37]
[24] -> [9,18,38]
[31] -> [7]
[33] -> [11]
[35] -> [13]
[37] -> [15,23]
[38] -> [16,24]
[48] -> [13]
[50] -> [11]
[54] -> [7]
[R] -> [43]

### Solution ###

[2,6,10,12,14,19,20,21,22,25,26,29,30,32,34,36,39,40,41,42,43,44,45,46,47,49,R]

### Annotated ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (x :R: N) -> N
    postulate Vec :E: (_x0 :E: N) -> (_x1 :E: Type) -> Type
    postulate Nil :R: (a :E: Type) -> Vec -E- Z -E- a
    postulate Cons :R: (a :E: Type) -> (n :R: N) -> (x :E: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -R- n) -E- a
    vlen :R: (n :R: N) -> (xs :R: Vec -E- n -E- N) -> N = \(n :R: N) (xs :R: Vec -E- n -E- N).
      case -R- xs of
        Nil/R (a :E: Type)
          | a = N
          | n = Z
          => n
        Cons/R (a :E: Type) (m :R: N) (y :E: N) (ys :R: Vec -E- m -E- N)
          | a = N
          | n = S -R- m
          => S -R- (vlen -R- m -R- ys)
    main :R: N = vlen -R- 1 -R- (Cons -E- N -R- Z -E- 3 -R- (Nil -E- N))
  in main

### Specialised ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (x :R: N) -> N
    postulate Vec :E: (_x0 :E: N) -> (_x1 :E: Type) -> Type
    postulate Nil :R: (a :E: Type) -> Vec -E- Z -E- a
    postulate Cons :R: (a :E: Type) -> (n :R: N) -> (x :E: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -R- n) -E- a
    vlen :R: (n :R: N) -> (xs :R: Vec -E- n -E- N) -> N = \(n :R: N) (xs :R: Vec -E- n -E- N).
      case -R- xs of
        Nil/R (a :E: Type)
          | a = N
          | n = Z
          => n
        Cons/R (a :E: Type) (m :R: N) (y :E: N) (ys :R: Vec -E- m -E- N)
          | a = N
          | n = S -R- m
          => S -R- (vlen -R- m -R- ys)
    main :R: N = vlen -R- 1 -R- (Cons -E- N -R- Z -E- 3 -R- (Nil -E- N))
  in main

### Final annotation ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (x :R: N) -> N
    postulate Vec :E: (_x0 :E: N) -> (_x1 :E: Type) -> Type
    postulate Nil :R: (a :E: Type) -> Vec -E- Z -E- a
    postulate Cons :R: (a :E: Type) -> (n :R: N) -> (x :E: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -R- n) -E- a
    vlen :R: (n :R: N) -> (xs :R: Vec -E- n -E- N) -> N = \(n :R: N) (xs :R: Vec -E- n -E- N).
      case -R- xs of
        Nil/R (a :E: Type)
          | a = N
          | n = Z
          => n
        Cons/R (a :E: Type) (m :R: N) (y :E: N) (ys :R: Vec -E- m -E- N)
          | a = N
          | n = S -R- m
          => S -R- (vlen -R- m -R- ys)
    main :R: N = vlen -R- 1 -R- (Cons -E- N -R- Z -E- 3 -R- (Nil -E- N))
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Z : N
    postulate S : (x) -> N
    postulate Nil : Vec
    postulate Cons : (n) -> (xs) -> Vec
    vlen = \n xs.
      case xs of
        Nil
          => n
        Cons m ys
          => S (vlen m ys)
    main = vlen 1 (Cons Z Nil)
  in main

### Normal forms ###

unerased:
  
  let
    postulate Z :R: N
    postulate S : (x :R: N) -> N
  in 1

erased:
  
  let
    postulate Z : N
    postulate S : (x) -> N
  in 1

