-- vim: ft=agda

### Desugared ###

postulate Bool : Type

postulate True : Bool

postulate False : Bool

postulate Maybe : (_ : Type) -> Type

postulate Just : (a : Type) -> (_ : a) -> Type

postulate Nothing : (a : Type) -> Type

postulate Nat : Type

postulate Z : Nat

postulate S : (n :R: Nat) -> Nat

postulate Plus : (x :R: Nat) -> (y :R: Nat) -> Nat

id : (x : Nat) -> Nat = (\x : Nat. 
  case  x returns Nat.
    Z
      => Z
    S (y : Nat)
      => 
        let result : Nat = S y
        in result)

const_3 : (_ : Nat) -> Nat = (\_ : Nat. 3)

two : Nat = 2

f : (g : (_ : Nat) -> Nat) -> (z : Nat) -> (h : (_ : Nat) -> Nat) -> (w : Nat) -> Nat = (\g : (_ : Nat) -> Nat. (\z : Nat. (\h : (_ : Nat) -> Nat. (\w : Nat. Plus (g z) (h w)))))

apply : (f : (_ : Nat) -> Nat) -> (x : Nat) -> Nat = (\f : (_ : Nat) -> Nat. (\x : Nat. f x))

test_1 : Nat = Plus (apply id 2) (apply const_3 two)

test_2 : Nat = f id 2 const_3 1

main :R: Nat = Plus test_1 test_2

### Metaified ###

postulate Bool :1: Type

postulate True :2: Bool

postulate False :3: Bool

postulate Maybe :4: (_ :5: Type) -> Type

postulate Just :6: (a :7: Type) -> (_ :8: a) -> Type

postulate Nothing :9: (a :10: Type) -> Type

postulate Nat :11: Type

postulate Z :12: Nat

postulate S :13: (n :R: Nat) -> Nat

postulate Plus :14: (x :R: Nat) -> (y :R: Nat) -> Nat

id :15: (x :16: Nat) -> Nat = (\x :17: Nat. 
  case -18-  x returns Nat.
    Z
      => Z
    S (y :19: Nat)
      => 
        let result :20: Nat = S -21- y
        in result)

const_3 :22: (_ :23: Nat) -> Nat = (\_ :24: Nat. 3)

two :28: Nat = 2

f :31: (g :32: (_ :33: Nat) -> Nat) -> (z :34: Nat) -> (h :35: (_ :36: Nat) -> Nat) -> (w :37: Nat) -> Nat = (\g :38: (_ :39: Nat) -> Nat. (\z :40: Nat. (\h :41: (_ :42: Nat) -> Nat. (\w :43: Nat. Plus -45- (g -46- z) -44- (h -47- w)))))

apply :48: (f :49: (_ :50: Nat) -> Nat) -> (x :51: Nat) -> Nat = (\f :52: (_ :53: Nat) -> Nat. (\x :54: Nat. f -55- x))

test_1 :56: Nat = Plus -58- (apply -60- id -59- 2) -57- (apply -64- const_3 -63- two)

test_2 :65: Nat = f -69- id -68- 2 -67- const_3 -66- 1

main :R: Nat = Plus -74- test_1 -73- test_2

### Inferred definitions ###

postulate Bool :1: Type {- constraints apply -}
  [] -> [1,R]

postulate False :3: Bool {- constraints apply -}
  [] -> [3,R]

postulate Just :6: (a :7: Type) -> (_ :8: a) -> Type {- constraints apply -}
  [] -> [6,R]

postulate Maybe :4: (_ :5: Type) -> Type {- constraints apply -}
  [] -> [4,R]

postulate Nat :11: Type {- constraints apply -}
  [] -> [11,R]

postulate Nothing :9: (a :10: Type) -> Type {- constraints apply -}
  [] -> [9,R]

postulate Plus :14: (x :R: Nat) -> (y :R: Nat) -> Nat {- constraints apply -}
  [] -> [14,R]

postulate S :13: (n :R: Nat) -> Nat {- constraints apply -}
  [] -> [13,R]

postulate True :2: Bool {- constraints apply -}
  [] -> [2,R]

postulate Type :R: Type

postulate Z :12: Nat {- constraints apply -}
  [] -> [12,R]

apply :48: (f :49: (_ :50: Nat) -> Nat) -> (x :51: Nat) -> Nat = (\f :52: (_ :53: Nat) -> Nat. (\x :54: Nat. f -55- x)) {- constraints apply -}
  [] -> [48,49,52,R]
  [50] -> [53]
  [51] -> [54]
  [53] -> [50,54,55]
  [54] -> [51]
  [55] -> [53]

const_3 :22: (_ :23: Nat) -> Nat = (\_ :24: Nat. 3) {- constraints apply -}
  [] -> [12,13,22,25,26,27,R]
  [23] -> [24]
  [24] -> [23]

f :31: (g :32: (_ :33: Nat) -> Nat) -> (z :34: Nat) -> (h :35: (_ :36: Nat) -> Nat) -> (w :37: Nat) -> Nat = (\g :38: (_ :39: Nat) -> Nat. (\z :40: Nat. (\h :41: (_ :42: Nat) -> Nat. (\w :43: Nat. Plus -45- (g -46- z) -44- (h -47- w))))) {- constraints apply -}
  [] -> [14,31,32,35,38,41,44,45,R]
  [33] -> [39]
  [34] -> [40]
  [36] -> [42]
  [37] -> [43]
  [39] -> [33,40,46]
  [40] -> [34]
  [42] -> [36,43,47]
  [43] -> [37]
  [46] -> [39]
  [47] -> [42]

id :15: (x :16: Nat) -> Nat = (\x :17: Nat. 
  case -18-  x returns Nat.
    Z
      => Z
    S (y :19: Nat)
      => 
        let result :20: Nat = S -21- y
        in result) {- constraints apply -}
  [] -> [12,13,15,16,17,18,19,20,21,R]

main :R: Nat = Plus -74- test_1 -73- test_2 {- constraints apply -}
  [] -> [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,R]

test_1 :56: Nat = Plus -58- (apply -60- id -59- 2) -57- (apply -64- const_3 -63- two) {- constraints apply -}
  [] -> [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,R]

test_2 :65: Nat = f -69- id -68- 2 -67- const_3 -66- 1 {- constraints apply -}
  [] -> [12,13,14,15,16,17,18,19,20,21,22,25,26,27,31,32,33,34,35,38,39,40,41,44,45,46,65,67,68,69,70,71,R]
  [23] -> [24,36]
  [24] -> [23]
  [36] -> [23,42]
  [37] -> [43,66,72]
  [42] -> [36,43,47]
  [43] -> [37]
  [47] -> [42]
  [66] -> [37]

two :28: Nat = 2 {- constraints apply -}
  [] -> [12,13,28,29,30,R]


### Constraints ###

[] -> [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,R]

### Solution ###

[12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,R]

### Annotated ###

postulate Bool :E: Type

postulate True :E: Bool

postulate False :E: Bool

postulate Maybe :E: (_ :E: Type) -> Type

postulate Just :E: (a :E: Type) -> (_ :E: a) -> Type

postulate Nothing :E: (a :E: Type) -> Type

postulate Nat :E: Type

postulate Z :R: Nat

postulate S :R: (n :R: Nat) -> Nat

postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat

id :R: (x :R: Nat) -> Nat = (\x :R: Nat. 
  case -R-  x returns Nat.
    Z
      => Z
    S (y :R: Nat)
      => 
        let result :R: Nat = S -R- y
        in result)

const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)

two :R: Nat = 2

f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))

apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))

test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)

test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1

main :R: Nat = Plus -R- test_1 -R- test_2

### Specialised ###

postulate Bool :E: Type

postulate True :E: Bool

postulate False :E: Bool

postulate Maybe :E: (_ :E: Type) -> Type

postulate Just :E: (a :E: Type) -> (_ :E: a) -> Type

postulate Nothing :E: (a :E: Type) -> Type

postulate Nat :E: Type

postulate Z :R: Nat

postulate S :R: (n :R: Nat) -> Nat

postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat

id :R: (x :R: Nat) -> Nat = (\x :R: Nat. 
  case -R-  x returns Nat.
    Z
      => Z
    S (y :R: Nat)
      => 
        let result :R: Nat = S -R- y
        in result)

const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)

two :R: Nat = 2

f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))

apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))

test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)

test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1

main :R: Nat = Plus -R- test_1 -R- test_2

### Final annotation ###

postulate Bool :E: Type

postulate True :E: Bool

postulate False :E: Bool

postulate Maybe :E: (_ :E: Type) -> Type

postulate Just :E: (a :E: Type) -> (_ :E: a) -> Type

postulate Nothing :E: (a :E: Type) -> Type

postulate Nat :E: Type

postulate Z :R: Nat

postulate S :R: (n :R: Nat) -> Nat

postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat

id :R: (x :R: Nat) -> Nat = (\x :R: Nat. 
  case -R-  x returns Nat.
    Z
      => Z
    S (y :R: Nat)
      => 
        let result :R: Nat = S -R- y
        in result)

const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)

two :R: Nat = 2

f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))

apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))

test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)

test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1

main :R: Nat = Plus -R- test_1 -R- test_2

### Verification ###

Verification successful.

### Pruned ###

postulate Z

postulate S

postulate Plus

id = (\x. 
  case x of
    Z
      => Z
    S y
      => 
        let result = S y
        in result)

const_3 = (\_. 3)

two = 2

f = (\g. (\z. (\h. (\w. Plus (g z) (h w)))))

apply = (\f. (\x. f x))

test_1 = Plus (apply id 2) (apply const_3 two)

test_2 = f id 2 const_3 1

main = Plus test_1 test_2

### Normal forms ###

unerased:
  Plus (Plus 2 3) (Plus 2 3)
erased:
  Plus (Plus 2 3) (Plus 2 3)
