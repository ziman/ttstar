-- vim: ft=agda

### Desugared ###

postulate Bool : Type

postulate True : Bool

postulate False : Bool

postulate Maybe : (_ : Type) -> Type

postulate Just : (a : Type) -> (_ : a) -> Type

postulate Nothing : (a : Type) -> Type

postulate Nat : Type

postulate Z : Nat

postulate S : (n  -R-  Nat) -> Nat

postulate Plus : (x  -R-  Nat) -> (y  -R-  Nat) -> Nat

id : (x : Nat) -> Nat = \(x : Nat).
  case x of
    Z
      => Z
    S (y : Nat)
      => 
        let result : Nat = S y
        in result

const_3 : (_ : Nat) -> Nat = (\_ : Nat. 3)

two : Nat = 2

f : (g : (_ : Nat) -> Nat) -> (z : Nat) -> (h : (_ : Nat) -> Nat) -> (w : Nat) -> Nat = (\g : (_ : Nat) -> Nat. (\z : Nat. (\h : (_ : Nat) -> Nat. (\w : Nat. Plus (g z) (h w)))))

apply : (f : (_ : Nat) -> Nat) -> (x : Nat) -> Nat = (\f : (_ : Nat) -> Nat. (\x : Nat. f x))

test_1 : Nat = Plus (apply id 2) (apply const_3 two)

test_2 : Nat = f id 2 const_3 1

main  -R-  Nat = Plus test_1 test_2

### Metaified ###

postulate Bool :?1: Type

postulate True :?2: Bool

postulate False :?3: Bool

postulate Maybe :?4: (_ :?5: Type) -> Type

postulate Just :?6: (a :?7: Type) -> (_ :?8: a) -> Type

postulate Nothing :?9: (a :?10: Type) -> Type

postulate Nat :?11: Type

postulate Z :?12: Nat

postulate S :?13: (n :!R: Nat) -> Nat

postulate Plus :?14: (x :!R: Nat) -> (y :!R: Nat) -> Nat

id :?15: (x :?16: Nat) -> Nat = \(x :?17: Nat).
  case -?18- x of
    Z
      => Z
    S (y :?19: Nat)
      => 
        let result :?20: Nat = S -?21- y
        in result

const_3 :?22: (_ :?23: Nat) -> Nat = (\_ :?24: Nat. 3)

two :?28: Nat = 2

f :?31: (g :?32: (_ :?33: Nat) -> Nat) -> (z :?34: Nat) -> (h :?35: (_ :?36: Nat) -> Nat) -> (w :?37: Nat) -> Nat = (\g :?38: (_ :?39: Nat) -> Nat. (\z :?40: Nat. (\h :?41: (_ :?42: Nat) -> Nat. (\w :?43: Nat. Plus -?45- (g -?46- z) -?44- (h -?47- w)))))

apply :?48: (f :?49: (_ :?50: Nat) -> Nat) -> (x :?51: Nat) -> Nat = (\f :?52: (_ :?53: Nat) -> Nat. (\x :?54: Nat. f -?55- x))

test_1 :?56: Nat = Plus -?58- (apply -?60- id -?59- 2) -?57- (apply -?64- const_3 -?63- two)

test_2 :?65: Nat = f -?69- id -?68- 2 -?67- const_3 -?66- 1

main :!R: Nat = Plus -?74- test_1 -?73- test_2

### Inferred definitions ###

postulate Bool :?1: Type

postulate False :?3: Bool

postulate Just :?6: (a :?7: Type) -> (_ :?8: a) -> Type

postulate Maybe :?4: (_ :?5: Type) -> Type

postulate Nat :?11: Type

postulate Nothing :?9: (a :?10: Type) -> Type

postulate Plus :?14: (x :!R: Nat) -> (y :!R: Nat) -> Nat

postulate S :?13: (n :!R: Nat) -> Nat

postulate True :?2: Bool

postulate Type :!R: Type

postulate Z :?12: Nat

apply :?48: (f :?49: (_ :?50: Nat) -> Nat) -> (x :?51: Nat) -> Nat = (\f :?52: (_ :?53: Nat) -> Nat. (\x :?54: Nat. f -?55- x))
  [] -> [?49,?52,!R]
  [?50] -> [?53]
  [?51] -> [?54]
  [?53] -> [?50,?54,?55]
  [?54] -> [?51]
  [?55] -> [?53]

const_3 :?22: (_ :?23: Nat) -> Nat = (\_ :?24: Nat. 3)
  [] -> [?12,?13,?25,?26,?27,!R]
  [?23] -> [?24]
  [?24] -> [?23]

f :?31: (g :?32: (_ :?33: Nat) -> Nat) -> (z :?34: Nat) -> (h :?35: (_ :?36: Nat) -> Nat) -> (w :?37: Nat) -> Nat = (\g :?38: (_ :?39: Nat) -> Nat. (\z :?40: Nat. (\h :?41: (_ :?42: Nat) -> Nat. (\w :?43: Nat. Plus -?45- (g -?46- z) -?44- (h -?47- w)))))
  [] -> [?14,?32,?35,?38,?41,?44,?45,!R]
  [?33] -> [?39]
  [?34] -> [?40]
  [?36] -> [?42]
  [?37] -> [?43]
  [?39] -> [?33,?40,?46]
  [?40] -> [?34]
  [?42] -> [?36,?43,?47]
  [?43] -> [?37]
  [?46] -> [?39]
  [?47] -> [?42]

id :?15: (x :?16: Nat) -> Nat = \(x :?17: Nat).
  case -?18- x of
    Z
      => Z
    S (y :?19: Nat)
      => 
        let result :?20: Nat = S -?21- y
        in result
  [] -> [?12,?13,?16,?17,?18,?19,?20,?21,!R]

main :!R: Nat = Plus -?74- test_1 -?73- test_2
  [] -> [?14,?56,?65,?73,?74,!R]

test_1 :?56: Nat = Plus -?58- (apply -?60- id -?59- 2) -?57- (apply -?64- const_3 -?63- two)
  [] -> [?14,?48,?57,?58,!R]
  [?16] -> [?50]
  [?23] -> [?50]
  [?49] -> [?15,?22,?60,?64]
  [?50] -> [?16,?23]
  [?51] -> [?12,?13,?28,?59,?61,?62,?63]
  [?59] -> [?51]
  [?60] -> [?49]
  [?63] -> [?51]
  [?64] -> [?49]

test_2 :?65: Nat = f -?69- id -?68- 2 -?67- const_3 -?66- 1
  [] -> [?31,!R]
  [?16] -> [?33]
  [?23] -> [?36]
  [?32] -> [?15,?69]
  [?33] -> [?16]
  [?34] -> [?12,?13,?68,?70,?71]
  [?35] -> [?22,?67]
  [?36] -> [?23]
  [?37] -> [?12,?13,?66,?72]
  [?66] -> [?37]
  [?67] -> [?35]
  [?68] -> [?34]
  [?69] -> [?32]

two :?28: Nat = 2
  [] -> [?12,?13,?29,?30,!R]


### Constraints ###

[] -> [?12,?13,?14,?16,?17,?18,?19,?20,?21,?25,?26,?27,?29,?30,?31,?32,?35,?38,?41,?44,?45,?48,?49,?52,?56,?57,?58,?65,?73,?74,!R]
[?16] -> [?33,?50]
[?23] -> [?24,?36,?50]
[?24] -> [?23]
[?32] -> [?15,?69]
[?33] -> [?16,?39]
[?34] -> [?12,?13,?40,?68,?70,?71]
[?35] -> [?22,?67]
[?36] -> [?23,?42]
[?37] -> [?12,?13,?43,?66,?72]
[?39] -> [?33,?40,?46]
[?40] -> [?34]
[?42] -> [?36,?43,?47]
[?43] -> [?37]
[?46] -> [?39]
[?47] -> [?42]
[?49] -> [?15,?22,?60,?64]
[?50] -> [?16,?23,?53]
[?51] -> [?12,?13,?28,?54,?59,?61,?62,?63]
[?53] -> [?50,?54,?55]
[?54] -> [?51]
[?55] -> [?53]
[?59] -> [?51]
[?60] -> [?49]
[?63] -> [?51]
[?64] -> [?49]
[?66] -> [?37]
[?67] -> [?35]
[?68] -> [?34]
[?69] -> [?32]

### Solution ###

[?12,?13,?14,?15,?16,?17,?18,?19,?20,?21,?22,?23,?24,?25,?26,?27,?28,?29,?30,?31,?32,?33,?34,?35,?36,?37,?38,?39,?40,?41,?42,?43,?44,?45,?46,?47,?48,?49,?50,?51,?52,?53,?54,?55,?56,?57,?58,?59,?60,?61,?62,?63,?64,?65,?66,?67,?68,?69,?70,?71,?72,?73,?74,!R]

### Annotated ###

postulate Bool :E: Type

postulate True :E: Bool

postulate False :E: Bool

postulate Maybe :E: (_ :E: Type) -> Type

postulate Just :E: (a :E: Type) -> (_ :E: a) -> Type

postulate Nothing :E: (a :E: Type) -> Type

postulate Nat :E: Type

postulate Z :R: Nat

postulate S :R: (n :R: Nat) -> Nat

postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat

id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
  case -R- x of
    Z
      => Z
    S (y :R: Nat)
      => 
        let result :R: Nat = S -R- y
        in result

const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)

two :R: Nat = 2

f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))

apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))

test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)

test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1

main :R: Nat = Plus -R- test_1 -R- test_2

### Specialised ###

postulate Bool :!E: Type

postulate True :!E: Bool

postulate False :!E: Bool

postulate Maybe :!E: (_ :!E: Type) -> Type

postulate Just :!E: (a :!E: Type) -> (_ :!E: a) -> Type

postulate Nothing :!E: (a :!E: Type) -> Type

postulate Nat :!E: Type

postulate Z :!R: Nat

postulate S :!R: (n :!R: Nat) -> Nat

postulate Plus :!R: (x :!R: Nat) -> (y :!R: Nat) -> Nat

id :!R: (x :!R: Nat) -> Nat = \(x :!R: Nat).
  case -!R- x of
    Z
      => Z
    S (y :!R: Nat)
      => 
        let result :!R: Nat = S -!R- y
        in result

const_3 :!R: (_ :!R: Nat) -> Nat = (\_ :!R: Nat. 3)

two :!R: Nat = 2

f :!R: (g :!R: (_ :!R: Nat) -> Nat) -> (z :!R: Nat) -> (h :!R: (_ :!R: Nat) -> Nat) -> (w :!R: Nat) -> Nat = (\g :!R: (_ :!R: Nat) -> Nat. (\z :!R: Nat. (\h :!R: (_ :!R: Nat) -> Nat. (\w :!R: Nat. Plus -!R- (g -!R- z) -!R- (h -!R- w)))))

apply :!R: (f :!R: (_ :!R: Nat) -> Nat) -> (x :!R: Nat) -> Nat = (\f :!R: (_ :!R: Nat) -> Nat. (\x :!R: Nat. f -!R- x))

test_1 :!R: Nat = Plus -!R- (apply -!R- id -!R- 2) -!R- (apply -!R- const_3 -!R- two)

test_2 :!R: Nat = f -!R- id -!R- 2 -!R- const_3 -!R- 1

main :!R: Nat = Plus -!R- test_1 -!R- test_2

### Final annotation ###

postulate Bool :E: Type

postulate True :E: Bool

postulate False :E: Bool

postulate Maybe :E: (_ :E: Type) -> Type

postulate Just :E: (a :E: Type) -> (_ :E: a) -> Type

postulate Nothing :E: (a :E: Type) -> Type

postulate Nat :E: Type

postulate Z :R: Nat

postulate S :R: (n :R: Nat) -> Nat

postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat

id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
  case -R- x of
    Z
      => Z
    S (y :R: Nat)
      => 
        let result :R: Nat = S -R- y
        in result

const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)

two :R: Nat = 2

f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))

apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))

test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)

test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1

main :R: Nat = Plus -R- test_1 -R- test_2

### Verification ###

Verification successful.

### Pruned ###

postulate Z

postulate S

postulate Plus

id = \x.
  case x of
    Z
      => Z
    S y
      => 
        let result = S y
        in result

const_3 = (\_. 3)

two = 2

f = (\g. (\z. (\h. (\w. Plus (g z) (h w)))))

apply = (\f. (\x. f x))

test_1 = Plus (apply id 2) (apply const_3 two)

test_2 = f id 2 const_3 1

main = Plus test_1 test_2

### Normal forms ###

unerased:
  Plus (Plus 2 3) (Plus 2 3)
erased:
  Plus (Plus 2 3) (Plus 2 3)
