-- vim: ft=agda

### Desugared ###

  let
    postulate Bool : Type
    postulate True : Bool
    postulate False : Bool
    postulate Nat : Type
    postulate Z : Nat
    postulate S : (n :R: Nat) -> Nat
    postulate Plus : (x :R: Nat) -> (y :R: Nat) -> Nat
    id : (x : Nat) -> Nat = \(x : Nat).
      case x of
        Z
          => Z
        S (y : Nat)
          => 
            let result : Nat = S y
            in result
    const_3 : (_ : Nat) -> Nat = (\_ : Nat. 3)
    two : Nat = 2
    f : (g : (_ : Nat) -> Nat) -> (z : Nat) -> (h : (_ : Nat) -> Nat) -> (w : Nat) -> Nat = (\g : (_ : Nat) -> Nat. (\z : Nat. (\h : (_ : Nat) -> Nat. (\w : Nat. Plus (g z) (h w)))))
    apply : (f : (_ : Nat) -> Nat) -> (x : Nat) -> Nat = (\f : (_ : Nat) -> Nat. (\x : Nat. f x))
    test_1 : Nat = Plus (apply id 2) (apply const_3 two)
    test_2 : Nat = f id 2 const_3 1
    main : Nat = Plus test_1 test_2
  in main

### Metaified ###

  let
    postulate Bool :1: Type
    postulate True :2: Bool
    postulate False :3: Bool
    postulate Nat :4: Type
    postulate Z :5: Nat
    postulate S :6: (n :R: Nat) -> Nat
    postulate Plus :7: (x :R: Nat) -> (y :R: Nat) -> Nat
    id :8: (x :9: Nat) -> Nat = \(x :10: Nat).
      case -11- x of
        Z/12
          => Z
        S/13 (y :14: Nat)
          => 
            let result :15: Nat = S -16- y
            in result
    const_3 :17: (_ :18: Nat) -> Nat = (\_ :19: Nat. 3)
    two :23: Nat = 2
    f :26: (g :27: (_ :28: Nat) -> Nat) -> (z :29: Nat) -> (h :30: (_ :31: Nat) -> Nat) -> (w :32: Nat) -> Nat = (\g :33: (_ :34: Nat) -> Nat. (\z :35: Nat. (\h :36: (_ :37: Nat) -> Nat. (\w :38: Nat. Plus -40- (g -41- z) -39- (h -42- w)))))
    apply :43: (f :44: (_ :45: Nat) -> Nat) -> (x :46: Nat) -> Nat = (\f :47: (_ :48: Nat) -> Nat. (\x :49: Nat. f -50- x))
    test_1 :51: Nat = Plus -53- (apply -55- id -54- 2) -52- (apply -59- const_3 -58- two)
    test_2 :60: Nat = f -64- id -63- 2 -62- const_3 -61- 1
    main :68: Nat = Plus -70- test_1 -69- test_2
  in main

### Constraints ###

[] -> [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,69,70,R]
[R] -> [68]

### Solution ###

[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat
    id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
      case -R- x of
        Z/R
          => Z
        S/R (y :R: Nat)
          => 
            let result :R: Nat = S -R- y
            in result
    const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)
    two :R: Nat = 2
    f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))
    apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))
    test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)
    test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1
    main :R: Nat = Plus -R- test_1 -R- test_2
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat
    id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
      case -R- x of
        Z/R
          => Z
        S/R (y :R: Nat)
          => 
            let result :R: Nat = S -R- y
            in result
    const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)
    two :R: Nat = 2
    f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))
    apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))
    test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)
    test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1
    main :R: Nat = Plus -R- test_1 -R- test_2
  in main

### Constraints ###

[R] -> [R]

### Solution ###

[R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat
    id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
      case -R- x of
        Z/R
          => Z
        S/R (y :R: Nat)
          => 
            let result :R: Nat = S -R- y
            in result
    const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)
    two :R: Nat = 2
    f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))
    apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))
    test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)
    test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1
    main :R: Nat = Plus -R- test_1 -R- test_2
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat
    id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
      case -R- x of
        Z/R
          => Z
        S/R (y :R: Nat)
          => 
            let result :R: Nat = S -R- y
            in result
    const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)
    two :R: Nat = 2
    f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))
    apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))
    test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)
    test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1
    main :R: Nat = Plus -R- test_1 -R- test_2
  in main

### Final annotation ###

  let
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat
    id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
      case -R- x of
        Z/R
          => Z
        S/R (y :R: Nat)
          => 
            let result :R: Nat = S -R- y
            in result
    const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)
    two :R: Nat = 2
    f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))
    apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))
    test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)
    test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1
    main :R: Nat = Plus -R- test_1 -R- test_2
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Z : Nat
    postulate S : (n) -> Nat
    postulate Plus : (x) -> (y) -> Nat
    id = \x.
      case x of
        Z
          => Z
        S y
          => 
            let result = S y
            in result
    const_3 = (\_. 3)
    two = 2
    f = (\g. (\z. (\h. (\w. Plus (g z) (h w)))))
    apply = (\f. (\x. f x))
    test_1 = Plus (apply id 2) (apply const_3 two)
    test_2 = f id 2 const_3 1
    main = Plus test_1 test_2
  in main

### Normal forms ###

unerased:
  
  let
    postulate Z : Nat
    postulate S : (n :R: Nat) -> Nat
    postulate Plus : (x :R: Nat) -> (y :R: Nat) -> Nat
  in Plus (Plus 2 3) (Plus 2 3)

erased:
  
  let
    postulate Z : Nat
    postulate S : (n) -> Nat
    postulate Plus : (x) -> (y) -> Nat
  in Plus (Plus 2 3) (Plus 2 3)

