-- vim: ft=agda

### Desugared ###

postulate Bool : Type

postulate True : Bool

postulate False : Bool

postulate Maybe : (_ : Type) -> Type

postulate Just : (a : Type) -> (_ : a) -> Type

postulate Nothing : (a : Type) -> Type

postulate Nat : Type

postulate Z : Nat

postulate S : (n :ᴿ Nat) -> Nat

postulate Plus : (x :ᴿ Nat) -> (y :ᴿ Nat) -> Nat

id : (x : Nat) -> Nat = \(x : Nat).
  case x of
    Z
      => Z
    S (y : Nat)
      => 
        let result : Nat = S y
        in result

const_3 : (_ : Nat) -> Nat = (\_ : Nat. 3)

two : Nat = 2

f : (g : (_ : Nat) -> Nat) -> (z : Nat) -> (h : (_ : Nat) -> Nat) -> (w : Nat) -> Nat = (\g : (_ : Nat) -> Nat. (\z : Nat. (\h : (_ : Nat) -> Nat. (\w : Nat. Plus (g z) (h w)))))

apply : (f : (_ : Nat) -> Nat) -> (x : Nat) -> Nat = (\f : (_ : Nat) -> Nat. (\x : Nat. f x))

test_1 : Nat = Plus (apply id 2) (apply const_3 two)

test_2 : Nat = f id 2 const_3 1

main :ᴿ Nat = Plus test_1 test_2

### Metaified ###

postulate Bool :¹ Type

postulate True :² Bool

postulate False :³ Bool

postulate Maybe :⁴ (_ :⁵ Type) -> Type

postulate Just :⁶ (a :⁷ Type) -> (_ :⁸ a) -> Type

postulate Nothing :⁹ (a :¹⁰ Type) -> Type

postulate Nat :¹¹ Type

postulate Z :¹² Nat

postulate S :¹³ (n :ᴿ Nat) -> Nat

postulate Plus :¹⁴ (x :ᴿ Nat) -> (y :ᴿ Nat) -> Nat

id :¹⁵ (x :¹⁶ Nat) -> Nat = \(x :¹⁷ Nat).
  case ¹⁸ x of
    Z
      => Z
    S (y :¹⁹ Nat)
      => 
        let result :²⁰ Nat = S ²¹ y
        in result

const_3 :²² (_ :²³ Nat) -> Nat = (\_ :²⁴ Nat. 3)

two :²⁸ Nat = 2

f :³¹ (g :³² (_ :³³ Nat) -> Nat) -> (z :³⁴ Nat) -> (h :³⁵ (_ :³⁶ Nat) -> Nat) -> (w :³⁷ Nat) -> Nat = (\g :³⁸ (_ :³⁹ Nat) -> Nat. (\z :⁴⁰ Nat. (\h :⁴¹ (_ :⁴² Nat) -> Nat. (\w :⁴³ Nat. Plus ⁴⁵ (g ⁴⁶ z) ⁴⁴ (h ⁴⁷ w)))))

apply :⁴⁸ (f :⁴⁹ (_ :⁵⁰ Nat) -> Nat) -> (x :⁵¹ Nat) -> Nat = (\f :⁵² (_ :⁵³ Nat) -> Nat. (\x :⁵⁴ Nat. f ⁵⁵ x))

test_1 :⁵⁶ Nat = Plus ⁵⁸ (apply ⁶⁰ id ⁵⁹ 2) ⁵⁷ (apply ⁶⁴ const_3 ⁶³ two)

test_2 :⁶⁵ Nat = f ⁶⁹ id ⁶⁸ 2 ⁶⁷ const_3 ⁶⁶ 1

main :ᴿ Nat = Plus ⁷⁴ test_1 ⁷³ test_2

### Inferred definitions ###

postulate Bool :¹ Type

postulate False :³ Bool

postulate Just :⁶ (a :⁷ Type) -> (_ :⁸ a) -> Type

postulate Maybe :⁴ (_ :⁵ Type) -> Type

postulate Nat :¹¹ Type

postulate Nothing :⁹ (a :¹⁰ Type) -> Type

postulate Plus :¹⁴ (x :ᴿ Nat) -> (y :ᴿ Nat) -> Nat

postulate S :¹³ (n :ᴿ Nat) -> Nat

postulate True :² Bool

postulate Type :ᴿ Type

postulate Z :¹² Nat

apply :⁴⁸ (f :⁴⁹ (_ :⁵⁰ Nat) -> Nat) -> (x :⁵¹ Nat) -> Nat = (\f :⁵² (_ :⁵³ Nat) -> Nat. (\x :⁵⁴ Nat. f ⁵⁵ x))
  [48] -> [52]
  [48,49] -> [52]
  [48,50] -> [53]
  [48,51] -> [54]
  [48,52] -> [49]
  [48,53] -> [50,54,55]
  [48,54] -> [51]
  [48,55] -> [53]

const_3 :²² (_ :²³ Nat) -> Nat = (\_ :²⁴ Nat. 3)
  [22] -> [12,13,25,26,27]
  [22,23] -> [24]
  [22,24] -> [23]

f :³¹ (g :³² (_ :³³ Nat) -> Nat) -> (z :³⁴ Nat) -> (h :³⁵ (_ :³⁶ Nat) -> Nat) -> (w :³⁷ Nat) -> Nat = (\g :³⁸ (_ :³⁹ Nat) -> Nat. (\z :⁴⁰ Nat. (\h :⁴¹ (_ :⁴² Nat) -> Nat. (\w :⁴³ Nat. Plus ⁴⁵ (g ⁴⁶ z) ⁴⁴ (h ⁴⁷ w)))))
  [31] -> [14,38,41,44,45]
  [31,32] -> [38]
  [31,33] -> [39]
  [31,34] -> [40]
  [31,35] -> [41]
  [31,36] -> [42]
  [31,37] -> [43]
  [31,38] -> [32]
  [31,39] -> [33,40,46]
  [31,40] -> [34]
  [31,41] -> [35]
  [31,42] -> [36,43,47]
  [31,43] -> [37]
  [31,46] -> [39]
  [31,47] -> [42]

id :¹⁵ (x :¹⁶ Nat) -> Nat = \(x :¹⁷ Nat).
  case ¹⁸ x of
    Z
      => Z
    S (y :¹⁹ Nat)
      => 
        let result :²⁰ Nat = S ²¹ y
        in result
  [12,15] -> [16]
  [13,15] -> [16]
  [15] -> [12,16,18,19,20]
  [15,16] -> [17]
  [15,17] -> [16]
  [15,18] -> [17]
  [15,19] -> [16,18]
  [15,20] -> [13,19,21]

main :ᴿ Nat = Plus ⁷⁴ test_1 ⁷³ test_2
  [] -> [14,56,65,73,74,R]

test_1 :⁵⁶ Nat = Plus ⁵⁸ (apply ⁶⁰ id ⁵⁹ 2) ⁵⁷ (apply ⁶⁴ const_3 ⁶³ two)
  [16,56] -> [50]
  [23,56] -> [50]
  [49,56] -> [15,22,60,64]
  [50,56] -> [16,23]
  [51,56] -> [12,13,28,59,61,62,63]
  [56] -> [14,48,57,58]
  [56,59] -> [51]
  [56,60] -> [49]
  [56,63] -> [51]
  [56,64] -> [49]

test_2 :⁶⁵ Nat = f ⁶⁹ id ⁶⁸ 2 ⁶⁷ const_3 ⁶⁶ 1
  [16,65] -> [33]
  [23,65] -> [36]
  [32,65] -> [15,69]
  [33,65] -> [16]
  [34,65] -> [12,13,68,70,71]
  [35,65] -> [22,67]
  [36,65] -> [23]
  [37,65] -> [12,13,66,72]
  [65] -> [31]
  [65,66] -> [37]
  [65,67] -> [35]
  [65,68] -> [34]
  [65,69] -> [32]

two :²⁸ Nat = 2
  [28] -> [12,13,29,30]


### Constraints ###

[] -> [14,56,65,73,74,R]
[12,15] -> [16]
[13,15] -> [16]
[15] -> [12,16,18,19,20]
[15,16] -> [17]
[15,17] -> [16]
[15,18] -> [17]
[15,19] -> [16,18]
[15,20] -> [13,19,21]
[16,56] -> [50]
[16,65] -> [33]
[22] -> [12,13,25,26,27]
[22,23] -> [24]
[22,24] -> [23]
[23,56] -> [50]
[23,65] -> [36]
[28] -> [12,13,29,30]
[31] -> [14,38,41,44,45]
[31,32] -> [38]
[31,33] -> [39]
[31,34] -> [40]
[31,35] -> [41]
[31,36] -> [42]
[31,37] -> [43]
[31,38] -> [32]
[31,39] -> [33,40,46]
[31,40] -> [34]
[31,41] -> [35]
[31,42] -> [36,43,47]
[31,43] -> [37]
[31,46] -> [39]
[31,47] -> [42]
[32,65] -> [15,69]
[33,65] -> [16]
[34,65] -> [12,13,68,70,71]
[35,65] -> [22,67]
[36,65] -> [23]
[37,65] -> [12,13,66,72]
[48] -> [52]
[48,49] -> [52]
[48,50] -> [53]
[48,51] -> [54]
[48,52] -> [49]
[48,53] -> [50,54,55]
[48,54] -> [51]
[48,55] -> [53]
[49,56] -> [15,22,60,64]
[50,56] -> [16,23]
[51,56] -> [12,13,28,59,61,62,63]
[56] -> [14,48,57,58]
[56,59] -> [51]
[56,60] -> [49]
[56,63] -> [51]
[56,64] -> [49]
[65] -> [31]
[65,66] -> [37]
[65,67] -> [35]
[65,68] -> [34]
[65,69] -> [32]

### Solution ###

[12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,R]

### Annotated ###

postulate Bool :ᴱ Type

postulate True :ᴱ Bool

postulate False :ᴱ Bool

postulate Maybe :ᴱ (_ :ᴱ Type) -> Type

postulate Just :ᴱ (a :ᴱ Type) -> (_ :ᴱ a) -> Type

postulate Nothing :ᴱ (a :ᴱ Type) -> Type

postulate Nat :ᴱ Type

postulate Z :ᴿ Nat

postulate S :ᴿ (n :ᴿ Nat) -> Nat

postulate Plus :ᴿ (x :ᴿ Nat) -> (y :ᴿ Nat) -> Nat

id :ᴿ (x :ᴿ Nat) -> Nat = \(x :ᴿ Nat).
  case ᴿ x of
    Z
      => Z
    S (y :ᴿ Nat)
      => 
        let result :ᴿ Nat = S ᴿ y
        in result

const_3 :ᴿ (_ :ᴿ Nat) -> Nat = (\_ :ᴿ Nat. 3)

two :ᴿ Nat = 2

f :ᴿ (g :ᴿ (_ :ᴿ Nat) -> Nat) -> (z :ᴿ Nat) -> (h :ᴿ (_ :ᴿ Nat) -> Nat) -> (w :ᴿ Nat) -> Nat = (\g :ᴿ (_ :ᴿ Nat) -> Nat. (\z :ᴿ Nat. (\h :ᴿ (_ :ᴿ Nat) -> Nat. (\w :ᴿ Nat. Plus ᴿ (g ᴿ z) ᴿ (h ᴿ w)))))

apply :ᴿ (f :ᴿ (_ :ᴿ Nat) -> Nat) -> (x :ᴿ Nat) -> Nat = (\f :ᴿ (_ :ᴿ Nat) -> Nat. (\x :ᴿ Nat. f ᴿ x))

test_1 :ᴿ Nat = Plus ᴿ (apply ᴿ id ᴿ 2) ᴿ (apply ᴿ const_3 ᴿ two)

test_2 :ᴿ Nat = f ᴿ id ᴿ 2 ᴿ const_3 ᴿ 1

main :ᴿ Nat = Plus ᴿ test_1 ᴿ test_2

### Specialised ###

postulate Bool :ᴱ Type

postulate True :ᴱ Bool

postulate False :ᴱ Bool

postulate Maybe :ᴱ (_ :ᴱ Type) -> Type

postulate Just :ᴱ (a :ᴱ Type) -> (_ :ᴱ a) -> Type

postulate Nothing :ᴱ (a :ᴱ Type) -> Type

postulate Nat :ᴱ Type

postulate Z :ᴿ Nat

postulate S :ᴿ (n :ᴿ Nat) -> Nat

postulate Plus :ᴿ (x :ᴿ Nat) -> (y :ᴿ Nat) -> Nat

id :ᴿ (x :ᴿ Nat) -> Nat = \(x :ᴿ Nat).
  case ᴿ x of
    Z
      => Z
    S (y :ᴿ Nat)
      => 
        let result :ᴿ Nat = S ᴿ y
        in result

const_3 :ᴿ (_ :ᴿ Nat) -> Nat = (\_ :ᴿ Nat. 3)

two :ᴿ Nat = 2

f :ᴿ (g :ᴿ (_ :ᴿ Nat) -> Nat) -> (z :ᴿ Nat) -> (h :ᴿ (_ :ᴿ Nat) -> Nat) -> (w :ᴿ Nat) -> Nat = (\g :ᴿ (_ :ᴿ Nat) -> Nat. (\z :ᴿ Nat. (\h :ᴿ (_ :ᴿ Nat) -> Nat. (\w :ᴿ Nat. Plus ᴿ (g ᴿ z) ᴿ (h ᴿ w)))))

apply :ᴿ (f :ᴿ (_ :ᴿ Nat) -> Nat) -> (x :ᴿ Nat) -> Nat = (\f :ᴿ (_ :ᴿ Nat) -> Nat. (\x :ᴿ Nat. f ᴿ x))

test_1 :ᴿ Nat = Plus ᴿ (apply ᴿ id ᴿ 2) ᴿ (apply ᴿ const_3 ᴿ two)

test_2 :ᴿ Nat = f ᴿ id ᴿ 2 ᴿ const_3 ᴿ 1

main :ᴿ Nat = Plus ᴿ test_1 ᴿ test_2

### Final annotation ###

postulate Bool :ᴱ Type

postulate True :ᴱ Bool

postulate False :ᴱ Bool

postulate Maybe :ᴱ (_ :ᴱ Type) -> Type

postulate Just :ᴱ (a :ᴱ Type) -> (_ :ᴱ a) -> Type

postulate Nothing :ᴱ (a :ᴱ Type) -> Type

postulate Nat :ᴱ Type

postulate Z :ᴿ Nat

postulate S :ᴿ (n :ᴿ Nat) -> Nat

postulate Plus :ᴿ (x :ᴿ Nat) -> (y :ᴿ Nat) -> Nat

id :ᴿ (x :ᴿ Nat) -> Nat = \(x :ᴿ Nat).
  case ᴿ x of
    Z
      => Z
    S (y :ᴿ Nat)
      => 
        let result :ᴿ Nat = S ᴿ y
        in result

const_3 :ᴿ (_ :ᴿ Nat) -> Nat = (\_ :ᴿ Nat. 3)

two :ᴿ Nat = 2

f :ᴿ (g :ᴿ (_ :ᴿ Nat) -> Nat) -> (z :ᴿ Nat) -> (h :ᴿ (_ :ᴿ Nat) -> Nat) -> (w :ᴿ Nat) -> Nat = (\g :ᴿ (_ :ᴿ Nat) -> Nat. (\z :ᴿ Nat. (\h :ᴿ (_ :ᴿ Nat) -> Nat. (\w :ᴿ Nat. Plus ᴿ (g ᴿ z) ᴿ (h ᴿ w)))))

apply :ᴿ (f :ᴿ (_ :ᴿ Nat) -> Nat) -> (x :ᴿ Nat) -> Nat = (\f :ᴿ (_ :ᴿ Nat) -> Nat. (\x :ᴿ Nat. f ᴿ x))

test_1 :ᴿ Nat = Plus ᴿ (apply ᴿ id ᴿ 2) ᴿ (apply ᴿ const_3 ᴿ two)

test_2 :ᴿ Nat = f ᴿ id ᴿ 2 ᴿ const_3 ᴿ 1

main :ᴿ Nat = Plus ᴿ test_1 ᴿ test_2

### Verification ###

Verification successful.

### Pruned ###

postulate Z

postulate S

postulate Plus

id = \x.
  case x of
    Z
      => Z
    S y
      => 
        let result = S y
        in result

const_3 = (\_. 3)

two = 2

f = (\g. (\z. (\h. (\w. Plus (g z) (h w)))))

apply = (\f. (\x. f x))

test_1 = Plus (apply id 2) (apply const_3 two)

test_2 = f id 2 const_3 1

main = Plus test_1 test_2

### Normal forms ###

unerased:
  Plus (Plus 2 3) (Plus 2 3)
erased:
  Plus (Plus 2 3) (Plus 2 3)
