-- vim: ft=agda

### Desugared ###

  let
    postulate Bool : Type
    postulate True : Bool
    postulate False : Bool
    postulate Maybe : (_ : Type) -> Type
    postulate Just : (a : Type) -> (_ : a) -> Type
    postulate Nothing : (a : Type) -> Type
    postulate Nat : Type
    postulate Z : Nat
    postulate S : (n :R: Nat) -> Nat
    postulate Plus : (x :R: Nat) -> (y :R: Nat) -> Nat
    id : (x : Nat) -> Nat = \(x : Nat).
      case x of
        Z
          => Z
        S (y : Nat)
          => 
            let result : Nat = S y
            in result
    const_3 : (_ : Nat) -> Nat = (\_ : Nat. 3)
    two : Nat = 2
    f : (g : (_ : Nat) -> Nat) -> (z : Nat) -> (h : (_ : Nat) -> Nat) -> (w : Nat) -> Nat = (\g : (_ : Nat) -> Nat. (\z : Nat. (\h : (_ : Nat) -> Nat. (\w : Nat. Plus (g z) (h w)))))
    apply : (f : (_ : Nat) -> Nat) -> (x : Nat) -> Nat = (\f : (_ : Nat) -> Nat. (\x : Nat. f x))
    test_1 : Nat = Plus (apply id 2) (apply const_3 two)
    test_2 : Nat = f id 2 const_3 1
    main :R: Nat = Plus test_1 test_2
  in main

### Metaified ###

  let
    postulate Bool :1: Type
    postulate True :2: Bool
    postulate False :3: Bool
    postulate Maybe :4: (_ :5: Type) -> Type
    postulate Just :6: (a :7: Type) -> (_ :8: a) -> Type
    postulate Nothing :9: (a :10: Type) -> Type
    postulate Nat :11: Type
    postulate Z :12: Nat
    postulate S :13: (n :R: Nat) -> Nat
    postulate Plus :14: (x :R: Nat) -> (y :R: Nat) -> Nat
    id :15: (x :16: Nat) -> Nat = \(x :17: Nat).
      case -18- x of
        Z/19
          => Z
        S/20 (y :21: Nat)
          => 
            let result :22: Nat = S -23- y
            in result
    const_3 :24: (_ :25: Nat) -> Nat = (\_ :26: Nat. 3)
    two :30: Nat = 2
    f :33: (g :34: (_ :35: Nat) -> Nat) -> (z :36: Nat) -> (h :37: (_ :38: Nat) -> Nat) -> (w :39: Nat) -> Nat = (\g :40: (_ :41: Nat) -> Nat. (\z :42: Nat. (\h :43: (_ :44: Nat) -> Nat. (\w :45: Nat. Plus -47- (g -48- z) -46- (h -49- w)))))
    apply :50: (f :51: (_ :52: Nat) -> Nat) -> (x :53: Nat) -> Nat = (\f :54: (_ :55: Nat) -> Nat. (\x :56: Nat. f -57- x))
    test_1 :58: Nat = Plus -60- (apply -62- id -61- 2) -59- (apply -66- const_3 -65- two)
    test_2 :67: Nat = f -71- id -70- 2 -69- const_3 -68- 1
    main :R: Nat = Plus -76- test_1 -75- test_2
  in main

### Constraints ###

[] -> [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,R]
[R] -> [R]

### Solution ###

[12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    postulate Maybe :E: (_ :E: Type) -> Type
    postulate Just :E: (a :E: Type) -> (_ :E: a) -> Type
    postulate Nothing :E: (a :E: Type) -> Type
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat
    id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
      case -R- x of
        Z/R
          => Z
        S/R (y :R: Nat)
          => 
            let result :R: Nat = S -R- y
            in result
    const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)
    two :R: Nat = 2
    f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))
    apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))
    test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)
    test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1
    main :R: Nat = Plus -R- test_1 -R- test_2
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    postulate Maybe :E: (_ :E: Type) -> Type
    postulate Just :E: (a :E: Type) -> (_ :E: a) -> Type
    postulate Nothing :E: (a :E: Type) -> Type
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat
    id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
      case -R- x of
        Z/R
          => Z
        S/R (y :R: Nat)
          => 
            let result :R: Nat = S -R- y
            in result
    const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)
    two :R: Nat = 2
    f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))
    apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))
    test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)
    test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1
    main :R: Nat = Plus -R- test_1 -R- test_2
  in main

### Constraints ###

[R] -> [R]

### Solution ###

[R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    postulate Maybe :E: (_ :E: Type) -> Type
    postulate Just :E: (a :E: Type) -> (_ :E: a) -> Type
    postulate Nothing :E: (a :E: Type) -> Type
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat
    id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
      case -R- x of
        Z/R
          => Z
        S/R (y :R: Nat)
          => 
            let result :R: Nat = S -R- y
            in result
    const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)
    two :R: Nat = 2
    f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))
    apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))
    test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)
    test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1
    main :R: Nat = Plus -R- test_1 -R- test_2
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    postulate Maybe :E: (_ :E: Type) -> Type
    postulate Just :E: (a :E: Type) -> (_ :E: a) -> Type
    postulate Nothing :E: (a :E: Type) -> Type
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat
    id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
      case -R- x of
        Z/R
          => Z
        S/R (y :R: Nat)
          => 
            let result :R: Nat = S -R- y
            in result
    const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)
    two :R: Nat = 2
    f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))
    apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))
    test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)
    test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1
    main :R: Nat = Plus -R- test_1 -R- test_2
  in main

### Final annotation ###

  let
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    postulate Maybe :E: (_ :E: Type) -> Type
    postulate Just :E: (a :E: Type) -> (_ :E: a) -> Type
    postulate Nothing :E: (a :E: Type) -> Type
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat
    id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
      case -R- x of
        Z/R
          => Z
        S/R (y :R: Nat)
          => 
            let result :R: Nat = S -R- y
            in result
    const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)
    two :R: Nat = 2
    f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))
    apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))
    test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)
    test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1
    main :R: Nat = Plus -R- test_1 -R- test_2
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Z : Nat
    postulate S : (n) -> Nat
    postulate Plus : (x) -> (y) -> Nat
    id = \x.
      case x of
        Z
          => Z
        S y
          => 
            let result = S y
            in result
    const_3 = (\_. 3)
    two = 2
    f = (\g. (\z. (\h. (\w. Plus (g z) (h w)))))
    apply = (\f. (\x. f x))
    test_1 = Plus (apply id 2) (apply const_3 two)
    test_2 = f id 2 const_3 1
    main = Plus test_1 test_2
  in main

### Normal forms ###

unerased:
  
  let
    postulate Z : Nat
    postulate S : (n :R: Nat) -> Nat
    postulate Plus : (x :R: Nat) -> (y :R: Nat) -> Nat
  in Plus (Plus 2 3) (Plus 2 3)

erased:
  
  let
    postulate Z : Nat
    postulate S : (n) -> Nat
    postulate Plus : (x) -> (y) -> Nat
  in Plus (Plus 2 3) (Plus 2 3)

