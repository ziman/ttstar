-- vim: ft=agda

### Desugared ###

postulate Bool : Type

postulate True : Bool

postulate False : Bool

postulate Maybe : (_ : Type) -> Type

postulate Just : (a : Type) -> (_ : a) -> Type

postulate Nothing : (a : Type) -> Type

postulate Nat : Type

postulate Z : Nat

postulate S : (n :R: Nat) -> Nat

postulate Plus : (x :R: Nat) -> (y :R: Nat) -> Nat

id : (x : Nat) -> Nat = \(x : Nat).
  case x of
    Z
      => Z
    S (y : Nat)
      => 
        let result : Nat = S y
        in result

const_3 : (_ : Nat) -> Nat = (\_ : Nat. 3)

two : Nat = 2

f : (g : (_ : Nat) -> Nat) -> (z : Nat) -> (h : (_ : Nat) -> Nat) -> (w : Nat) -> Nat = (\g : (_ : Nat) -> Nat. (\z : Nat. (\h : (_ : Nat) -> Nat. (\w : Nat. Plus (g z) (h w)))))

apply : (f : (_ : Nat) -> Nat) -> (x : Nat) -> Nat = (\f : (_ : Nat) -> Nat. (\x : Nat. f x))

test_1 : Nat = Plus (apply id 2) (apply const_3 two)

test_2 : Nat = f id 2 const_3 1

main :R: Nat = Plus test_1 test_2

### Metaified ###

postulate Bool :1: Type

postulate True :2: Bool

postulate False :3: Bool

postulate Maybe :4: (_ :5: Type) -> Type

postulate Just :6: (a :7: Type) -> (_ :8: a) -> Type

postulate Nothing :9: (a :10: Type) -> Type

postulate Nat :11: Type

postulate Z :12: Nat

postulate S :13: (n :R: Nat) -> Nat

postulate Plus :14: (x :R: Nat) -> (y :R: Nat) -> Nat

id :15: (x :16: Nat) -> Nat = \(x :17: Nat).
  case -18- x of
    Z
      => Z
    S (y :19: Nat)
      => 
        let result :20: Nat = S -21- y
        in result

const_3 :22: (_ :23: Nat) -> Nat = (\_ :24: Nat. 3)

two :28: Nat = 2

f :31: (g :32: (_ :33: Nat) -> Nat) -> (z :34: Nat) -> (h :35: (_ :36: Nat) -> Nat) -> (w :37: Nat) -> Nat = (\g :38: (_ :39: Nat) -> Nat. (\z :40: Nat. (\h :41: (_ :42: Nat) -> Nat. (\w :43: Nat. Plus -45- (g -46- z) -44- (h -47- w)))))

apply :48: (f :49: (_ :50: Nat) -> Nat) -> (x :51: Nat) -> Nat = (\f :52: (_ :53: Nat) -> Nat. (\x :54: Nat. f -55- x))

test_1 :56: Nat = Plus -58- (apply -60- id -59- 2) -57- (apply -64- const_3 -63- two)

test_2 :65: Nat = f -69- id -68- 2 -67- const_3 -66- 1

main :R: Nat = Plus -74- test_1 -73- test_2

### Inferred definitions ###

postulate Bool :1: Type

postulate False :3: Bool

postulate Just :6: (a :7: Type) -> (_ :8: a) -> Type

postulate Maybe :4: (_ :5: Type) -> Type

postulate Nat :11: Type

postulate Nothing :9: (a :10: Type) -> Type

postulate Plus :14: (x :R: Nat) -> (y :R: Nat) -> Nat

postulate S :13: (n :R: Nat) -> Nat

postulate True :2: Bool

postulate Type :R: Type

postulate Z :12: Nat

apply :48: (f :49: (_ :50: Nat) -> Nat) -> (x :51: Nat) -> Nat = (\f :52: (_ :53: Nat) -> Nat. (\x :54: Nat. f -55- x))
  [48] -> [52]
  [48,49] -> [52]
  [48,50] -> [53]
  [48,51] -> [54]
  [48,52] -> [49]
  [48,53] -> [50,54,55]
  [48,54] -> [51]
  [48,55] -> [53]

const_3 :22: (_ :23: Nat) -> Nat = (\_ :24: Nat. 3)
  [22] -> [12,13,25,26,27]
  [22,23] -> [24]
  [22,24] -> [23]

f :31: (g :32: (_ :33: Nat) -> Nat) -> (z :34: Nat) -> (h :35: (_ :36: Nat) -> Nat) -> (w :37: Nat) -> Nat = (\g :38: (_ :39: Nat) -> Nat. (\z :40: Nat. (\h :41: (_ :42: Nat) -> Nat. (\w :43: Nat. Plus -45- (g -46- z) -44- (h -47- w)))))
  [31] -> [14,38,41,44,45]
  [31,32] -> [38]
  [31,33] -> [39]
  [31,34] -> [40]
  [31,35] -> [41]
  [31,36] -> [42]
  [31,37] -> [43]
  [31,38] -> [32]
  [31,39] -> [33,40,46]
  [31,40] -> [34]
  [31,41] -> [35]
  [31,42] -> [36,43,47]
  [31,43] -> [37]
  [31,46] -> [39]
  [31,47] -> [42]

id :15: (x :16: Nat) -> Nat = \(x :17: Nat).
  case -18- x of
    Z
      => Z
    S (y :19: Nat)
      => 
        let result :20: Nat = S -21- y
        in result
  [12,15] -> [16]
  [13,15] -> [16]
  [15] -> [12,16,18,19,20]
  [15,16] -> [17]
  [15,17] -> [16]
  [15,18] -> [17]
  [15,19] -> [16,18]
  [15,20] -> [13,19,21]

main :R: Nat = Plus -74- test_1 -73- test_2
  [] -> [14,56,65,73,74,R]

test_1 :56: Nat = Plus -58- (apply -60- id -59- 2) -57- (apply -64- const_3 -63- two)
  [16,56] -> [50]
  [23,56] -> [50]
  [49,56] -> [15,22,60,64]
  [50,56] -> [16,23]
  [51,56] -> [12,13,28,59,61,62,63]
  [56] -> [14,48,57,58]
  [56,59] -> [51]
  [56,60] -> [49]
  [56,63] -> [51]
  [56,64] -> [49]

test_2 :65: Nat = f -69- id -68- 2 -67- const_3 -66- 1
  [16,65] -> [33]
  [23,65] -> [36]
  [32,65] -> [15,69]
  [33,65] -> [16]
  [34,65] -> [12,13,68,70,71]
  [35,65] -> [22,67]
  [36,65] -> [23]
  [37,65] -> [12,13,66,72]
  [65] -> [31]
  [65,66] -> [37]
  [65,67] -> [35]
  [65,68] -> [34]
  [65,69] -> [32]

two :28: Nat = 2
  [28] -> [12,13,29,30]


### Constraints ###

[] -> [14,56,65,73,74,R]
[12,15] -> [16]
[13,15] -> [16]
[15] -> [12,16,18,19,20]
[15,16] -> [17]
[15,17] -> [16]
[15,18] -> [17]
[15,19] -> [16,18]
[15,20] -> [13,19,21]
[16,56] -> [50]
[16,65] -> [33]
[22] -> [12,13,25,26,27]
[22,23] -> [24]
[22,24] -> [23]
[23,56] -> [50]
[23,65] -> [36]
[28] -> [12,13,29,30]
[31] -> [14,38,41,44,45]
[31,32] -> [38]
[31,33] -> [39]
[31,34] -> [40]
[31,35] -> [41]
[31,36] -> [42]
[31,37] -> [43]
[31,38] -> [32]
[31,39] -> [33,40,46]
[31,40] -> [34]
[31,41] -> [35]
[31,42] -> [36,43,47]
[31,43] -> [37]
[31,46] -> [39]
[31,47] -> [42]
[32,65] -> [15,69]
[33,65] -> [16]
[34,65] -> [12,13,68,70,71]
[35,65] -> [22,67]
[36,65] -> [23]
[37,65] -> [12,13,66,72]
[48] -> [52]
[48,49] -> [52]
[48,50] -> [53]
[48,51] -> [54]
[48,52] -> [49]
[48,53] -> [50,54,55]
[48,54] -> [51]
[48,55] -> [53]
[49,56] -> [15,22,60,64]
[50,56] -> [16,23]
[51,56] -> [12,13,28,59,61,62,63]
[56] -> [14,48,57,58]
[56,59] -> [51]
[56,60] -> [49]
[56,63] -> [51]
[56,64] -> [49]
[65] -> [31]
[65,66] -> [37]
[65,67] -> [35]
[65,68] -> [34]
[65,69] -> [32]

### Solution ###

[12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,R]

### Annotated ###

postulate Bool :E: Type

postulate True :E: Bool

postulate False :E: Bool

postulate Maybe :E: (_ :E: Type) -> Type

postulate Just :E: (a :E: Type) -> (_ :E: a) -> Type

postulate Nothing :E: (a :E: Type) -> Type

postulate Nat :E: Type

postulate Z :R: Nat

postulate S :R: (n :R: Nat) -> Nat

postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat

id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
  case -R- x of
    Z
      => Z
    S (y :R: Nat)
      => 
        let result :R: Nat = S -R- y
        in result

const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)

two :R: Nat = 2

f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))

apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))

test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)

test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1

main :R: Nat = Plus -R- test_1 -R- test_2

### Specialised ###

postulate Bool :E: Type

postulate True :E: Bool

postulate False :E: Bool

postulate Maybe :E: (_ :E: Type) -> Type

postulate Just :E: (a :E: Type) -> (_ :E: a) -> Type

postulate Nothing :E: (a :E: Type) -> Type

postulate Nat :E: Type

postulate Z :R: Nat

postulate S :R: (n :R: Nat) -> Nat

postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat

id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
  case -R- x of
    Z
      => Z
    S (y :R: Nat)
      => 
        let result :R: Nat = S -R- y
        in result

const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)

two :R: Nat = 2

f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))

apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))

test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)

test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1

main :R: Nat = Plus -R- test_1 -R- test_2

### Final annotation ###

postulate Bool :E: Type

postulate True :E: Bool

postulate False :E: Bool

postulate Maybe :E: (_ :E: Type) -> Type

postulate Just :E: (a :E: Type) -> (_ :E: a) -> Type

postulate Nothing :E: (a :E: Type) -> Type

postulate Nat :E: Type

postulate Z :R: Nat

postulate S :R: (n :R: Nat) -> Nat

postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat

id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
  case -R- x of
    Z
      => Z
    S (y :R: Nat)
      => 
        let result :R: Nat = S -R- y
        in result

const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)

two :R: Nat = 2

f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))

apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))

test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)

test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1

main :R: Nat = Plus -R- test_1 -R- test_2

### Verification ###

Verification successful.

### Pruned ###

postulate Z

postulate S

postulate Plus

id = \x.
  case x of
    Z
      => Z
    S y
      => 
        let result = S y
        in result

const_3 = (\_. 3)

two = 2

f = (\g. (\z. (\h. (\w. Plus (g z) (h w)))))

apply = (\f. (\x. f x))

test_1 = Plus (apply id 2) (apply const_3 two)

test_2 = f id 2 const_3 1

main = Plus test_1 test_2

### Normal forms ###

unerased:
  Plus (Plus 2 3) (Plus 2 3)
erased:
  Plus (Plus 2 3) (Plus 2 3)
