-- vim: ft=agda

### Desugared ###

postulate Bool : Type

postulate True : Bool

postulate False : Bool

postulate Maybe : (_ : Type) -> Type

postulate Just : (a : Type) -> (_ : a) -> Type

postulate Nothing : (a : Type) -> Type

postulate Nat : Type

postulate Z : Nat

postulate S : (n :R: Nat) -> Nat

postulate Plus : (x :R: Nat) -> (y :R: Nat) -> Nat

id : (x : Nat) -> Nat = \(x : Nat).
  case x of
    Z
      => Z
    S (y : Nat)
      => 
        let result : Nat = S y
        in result

const_3 : (_ : Nat) -> Nat = (\_ : Nat. 3)

two : Nat = 2

f : (g : (_ : Nat) -> Nat) -> (z : Nat) -> (h : (_ : Nat) -> Nat) -> (w : Nat) -> Nat = (\g : (_ : Nat) -> Nat. (\z : Nat. (\h : (_ : Nat) -> Nat. (\w : Nat. Plus (g z) (h w)))))

apply : (f : (_ : Nat) -> Nat) -> (x : Nat) -> Nat = (\f : (_ : Nat) -> Nat. (\x : Nat. f x))

test_1 : Nat = Plus (apply id 2) (apply const_3 two)

test_2 : Nat = f id 2 const_3 1

main :R: Nat = Plus test_1 test_2

### Metaified ###

postulate Bool :1: Type

postulate True :2: Bool

postulate False :3: Bool

postulate Maybe :4: (_ :5: Type) -> Type

postulate Just :6: (a :7: Type) -> (_ :8: a) -> Type

postulate Nothing :9: (a :10: Type) -> Type

postulate Nat :11: Type

postulate Z :12: Nat

postulate S :13: (n :R: Nat) -> Nat

postulate Plus :14: (x :R: Nat) -> (y :R: Nat) -> Nat

id :15: (x :16: Nat) -> Nat = \(x :17: Nat).
  case -18- x of
    Z
      => Z
    S (y :21: Nat)
      => 
        let result :22: Nat = S -23- y
        in result

const_3 :24: (_ :25: Nat) -> Nat = (\_ :26: Nat. 3)

two :30: Nat = 2

f :33: (g :34: (_ :35: Nat) -> Nat) -> (z :36: Nat) -> (h :37: (_ :38: Nat) -> Nat) -> (w :39: Nat) -> Nat = (\g :40: (_ :41: Nat) -> Nat. (\z :42: Nat. (\h :43: (_ :44: Nat) -> Nat. (\w :45: Nat. Plus -47- (g -48- z) -46- (h -49- w)))))

apply :50: (f :51: (_ :52: Nat) -> Nat) -> (x :53: Nat) -> Nat = (\f :54: (_ :55: Nat) -> Nat. (\x :56: Nat. f -57- x))

test_1 :58: Nat = Plus -60- (apply -62- id -61- 2) -59- (apply -66- const_3 -65- two)

test_2 :67: Nat = f -71- id -70- 2 -69- const_3 -68- 1

main :R: Nat = Plus -76- test_1 -75- test_2

### Inferred definitions ###

postulate Bool :1: Type {- constraints apply -}
  [] -> [1,R]

postulate False :3: Bool {- constraints apply -}
  [] -> [3,R]

postulate Just :6: (a :7: Type) -> (_ :8: a) -> Type {- constraints apply -}
  [] -> [6,R]

postulate Maybe :4: (_ :5: Type) -> Type {- constraints apply -}
  [] -> [4,R]

postulate Nat :11: Type {- constraints apply -}
  [] -> [11,R]

postulate Nothing :9: (a :10: Type) -> Type {- constraints apply -}
  [] -> [9,R]

postulate Plus :14: (x :R: Nat) -> (y :R: Nat) -> Nat {- constraints apply -}
  [] -> [14,R]

postulate S :13: (n :R: Nat) -> Nat {- constraints apply -}
  [] -> [13,R]

postulate True :2: Bool {- constraints apply -}
  [] -> [2,R]

postulate Type :E: Type

postulate Z :12: Nat {- constraints apply -}
  [] -> [12,R]

apply :50: (f :51: (_ :52: Nat) -> Nat) -> (x :53: Nat) -> Nat = (\f :54: (_ :55: Nat) -> Nat. (\x :56: Nat. f -57- x)) {- constraints apply -}
  [] -> [50,51,54,R]
  [52] -> [55]
  [53] -> [56]
  [55] -> [52,56,57]
  [56] -> [53]
  [57] -> [55]

const_3 :24: (_ :25: Nat) -> Nat = (\_ :26: Nat. 3) {- constraints apply -}
  [] -> [12,13,24,27,28,29,R]
  [25] -> [26]
  [26] -> [25]

f :33: (g :34: (_ :35: Nat) -> Nat) -> (z :36: Nat) -> (h :37: (_ :38: Nat) -> Nat) -> (w :39: Nat) -> Nat = (\g :40: (_ :41: Nat) -> Nat. (\z :42: Nat. (\h :43: (_ :44: Nat) -> Nat. (\w :45: Nat. Plus -47- (g -48- z) -46- (h -49- w))))) {- constraints apply -}
  [] -> [14,33,34,37,40,43,46,47,R]
  [35] -> [41]
  [36] -> [42]
  [38] -> [44]
  [39] -> [45]
  [41] -> [35,42,48]
  [42] -> [36]
  [44] -> [38,45,49]
  [45] -> [39]
  [48] -> [41]
  [49] -> [44]

id :15: (x :16: Nat) -> Nat = \(x :17: Nat).
  case -18- x of
    Z
      => Z
    S (y :21: Nat)
      => 
        let result :22: Nat = S -23- y
        in result {- constraints apply -}
  [] -> [12,13,15,16,17,18,19,20,21,22,23,R]

main :R: Nat = Plus -76- test_1 -75- test_2 {- constraints apply -}
  [] -> [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,R]

test_1 :58: Nat = Plus -60- (apply -62- id -61- 2) -59- (apply -66- const_3 -65- two) {- constraints apply -}
  [] -> [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,R]

test_2 :67: Nat = f -71- id -70- 2 -69- const_3 -68- 1 {- constraints apply -}
  [] -> [12,13,14,15,16,17,18,19,20,21,22,23,24,27,28,29,33,34,35,36,37,40,41,42,43,46,47,48,67,69,70,71,72,73,R]
  [25] -> [26,38]
  [26] -> [25]
  [38] -> [25,44]
  [39] -> [45,68,74]
  [44] -> [38,45,49]
  [45] -> [39]
  [49] -> [44]
  [68] -> [39]

two :30: Nat = 2 {- constraints apply -}
  [] -> [12,13,30,31,32,R]


### Constraints ###

[] -> [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,R]

### Solution ###

[12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,R]

### Annotated ###

postulate Bool :E: Type

postulate True :E: Bool

postulate False :E: Bool

postulate Maybe :E: (_ :E: Type) -> Type

postulate Just :E: (a :E: Type) -> (_ :E: a) -> Type

postulate Nothing :E: (a :E: Type) -> Type

postulate Nat :E: Type

postulate Z :R: Nat

postulate S :R: (n :R: Nat) -> Nat

postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat

id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
  case -R- x of
    Z
      => Z
    S (y :R: Nat)
      => 
        let result :R: Nat = S -R- y
        in result

const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)

two :R: Nat = 2

f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))

apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))

test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)

test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1

main :R: Nat = Plus -R- test_1 -R- test_2

### Specialised ###

postulate Bool :E: Type

postulate True :E: Bool

postulate False :E: Bool

postulate Maybe :E: (_ :E: Type) -> Type

postulate Just :E: (a :E: Type) -> (_ :E: a) -> Type

postulate Nothing :E: (a :E: Type) -> Type

postulate Nat :E: Type

postulate Z :R: Nat

postulate S :R: (n :R: Nat) -> Nat

postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat

id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
  case -R- x of
    Z
      => Z
    S (y :R: Nat)
      => 
        let result :R: Nat = S -R- y
        in result

const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)

two :R: Nat = 2

f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))

apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))

test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)

test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1

main :R: Nat = Plus -R- test_1 -R- test_2

### Final annotation ###

postulate Bool :E: Type

postulate True :E: Bool

postulate False :E: Bool

postulate Maybe :E: (_ :E: Type) -> Type

postulate Just :E: (a :E: Type) -> (_ :E: a) -> Type

postulate Nothing :E: (a :E: Type) -> Type

postulate Nat :E: Type

postulate Z :R: Nat

postulate S :R: (n :R: Nat) -> Nat

postulate Plus :R: (x :R: Nat) -> (y :R: Nat) -> Nat

id :R: (x :R: Nat) -> Nat = \(x :R: Nat).
  case -R- x of
    Z
      => Z
    S (y :R: Nat)
      => 
        let result :R: Nat = S -R- y
        in result

const_3 :R: (_ :R: Nat) -> Nat = (\_ :R: Nat. 3)

two :R: Nat = 2

f :R: (g :R: (_ :R: Nat) -> Nat) -> (z :R: Nat) -> (h :R: (_ :R: Nat) -> Nat) -> (w :R: Nat) -> Nat = (\g :R: (_ :R: Nat) -> Nat. (\z :R: Nat. (\h :R: (_ :R: Nat) -> Nat. (\w :R: Nat. Plus -R- (g -R- z) -R- (h -R- w)))))

apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))

test_1 :R: Nat = Plus -R- (apply -R- id -R- 2) -R- (apply -R- const_3 -R- two)

test_2 :R: Nat = f -R- id -R- 2 -R- const_3 -R- 1

main :R: Nat = Plus -R- test_1 -R- test_2

### Verification ###

Verification successful.

### Pruned ###

postulate Z

postulate S

postulate Plus

id = \x.
  case x of
    Z
      => Z
    S y
      => 
        let result = S y
        in result

const_3 = (\_. 3)

two = 2

f = (\g. (\z. (\h. (\w. Plus (g z) (h w)))))

apply = (\f. (\x. f x))

test_1 = Plus (apply id 2) (apply const_3 two)

test_2 = f id 2 const_3 1

main = Plus test_1 test_2

### Normal forms ###

unerased:
  Plus (Plus 2 3) (Plus 2 3)
erased:
  Plus (Plus 2 3) (Plus 2 3)
