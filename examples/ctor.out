-- vim: ft=agda

### Desugared ###

postulate Bool : Type

postulate T : Bool

postulate F : Bool

postulate Unit : Type

postulate MkUnit : Unit

not : (x : Bool) -> Unit = \(x : Bool).
  case x of
    T
      => MkUnit
    F
      => MkUnit

main :R: Unit = not T

### Metaified ###

postulate Bool :1: Type

postulate T :2: Bool

postulate F :3: Bool

postulate Unit :4: Type

postulate MkUnit :5: Unit

not :6: (x :7: Bool) -> Unit = \(x :8: Bool).
  case -9- x of
    T
      => MkUnit
    F
      => MkUnit

main :R: Unit = not -12- T

### Inferred definitions ###

postulate Bool :1: Type {- constraints apply -}
  [] -> [1,R]

postulate F :3: Bool {- constraints apply -}
  [] -> [3,R]

postulate MkUnit :5: Unit {- constraints apply -}
  [] -> [5,R]

postulate T :2: Bool {- constraints apply -}
  [] -> [2,R]

postulate Type :E: Type

postulate Unit :4: Type {- constraints apply -}
  [] -> [4,R]

main :R: Unit = not -12- T {- constraints apply -}
  [] -> [2,5,6,7,8,9,10,12,R]
  [3] -> [11]
  [11] -> [3]

not :6: (x :7: Bool) -> Unit = \(x :8: Bool).
  case -9- x of
    T
      => MkUnit
    F
      => MkUnit {- constraints apply -}
  [] -> [5,6,7,8,9,R]
  [2] -> [10]
  [3] -> [11]
  [10] -> [2]
  [11] -> [3]


### Constraints ###

[] -> [2,5,6,7,8,9,10,12,R]
[3] -> [11]
[11] -> [3]

### Solution ###

[2,5,6,7,8,9,10,12,R]

### Annotated ###

postulate Bool :E: Type

postulate T :R: Bool

postulate F :E: Bool

postulate Unit :E: Type

postulate MkUnit :R: Unit

not :R: (x :R: Bool) -> Unit = \(x :R: Bool).
  case -R- x of
    T
      => MkUnit
    {ERASED} F
      => MkUnit

main :R: Unit = not -R- T

### Specialised ###

postulate Bool :E: Type

postulate T :R: Bool

postulate F :E: Bool

postulate Unit :E: Type

postulate MkUnit :R: Unit

not :R: (x :R: Bool) -> Unit = \(x :R: Bool).
  case -R- x of
    T
      => MkUnit
    {ERASED} F
      => MkUnit

main :R: Unit = not -R- T

### Final annotation ###

postulate Bool :E: Type

postulate T :R: Bool

postulate F :E: Bool

postulate Unit :E: Type

postulate MkUnit :R: Unit

not :R: (x :R: Bool) -> Unit = \(x :R: Bool).
  case -R- x of
    T
      => MkUnit
    {ERASED} F
      => MkUnit

main :R: Unit = not -R- T

### Verification ###

Verification successful.

### Pruned ###

postulate T

postulate MkUnit

not = \x.
  case x of
    T
      => MkUnit

main = not T

### Normal forms ###

unerased:
  MkUnit
erased:
  MkUnit
