-- vim: ft=agda

### Desugared ###

postulate Bool : Type

postulate T : Bool

postulate F : Bool

postulate Unit : Type

postulate MkUnit : Unit

not : (x : Bool) -> Unit = \(x : Bool).
  case x of
    T
      => MkUnit
    F
      => MkUnit

main :R: Unit = not T

### Metaified ###

postulate Bool :1: Type

postulate T :2: Bool

postulate F :3: Bool

postulate Unit :4: Type

postulate MkUnit :5: Unit

not :6: (x :7: Bool) -> Unit = \(x :8: Bool).
  case -9- x of
    T/10
      => MkUnit
    F/11
      => MkUnit

main :R: Unit = not -12- T

### Inferred definitions ###

postulate Bool :1: Type

postulate F :3: Bool

postulate MkUnit :5: Unit

postulate T :2: Bool

postulate Type :E: Type

postulate Unit :4: Type

main :R: Unit = not -12- T {- constraints apply -}
  [] -> [2,5,6,7,8,9,10,12,R]
  [3] -> [11]
  [11] -> [3]

not :6: (x :7: Bool) -> Unit = \(x :8: Bool).
  case -9- x of
    T/10
      => MkUnit
    F/11
      => MkUnit {- constraints apply -}
  [] -> [5,7,8,9,R]
  [2] -> [10]
  [3] -> [11]
  [10] -> [2]
  [11] -> [3]


### Constraints ###

[] -> [2,5,6,7,8,9,10,12,R]
[3] -> [11]
[11] -> [3]

### Solution ###

[2,5,6,7,8,9,10,12,R]

### Annotated ###

postulate Bool :E: Type

postulate T :R: Bool

postulate F :E: Bool

postulate Unit :E: Type

postulate MkUnit :R: Unit

not :R: (x :R: Bool) -> Unit = \(x :R: Bool).
  case -R- x of
    T/R
      => MkUnit
    F/E
      => MkUnit

main :R: Unit = not -R- T

### Specialised ###

postulate Bool :E: Type

postulate T :R: Bool

postulate F :E: Bool

postulate Unit :E: Type

postulate MkUnit :R: Unit

not :R: (x :R: Bool) -> Unit = \(x :R: Bool).
  case -R- x of
    T/R
      => MkUnit
    F/E
      => MkUnit

main :R: Unit = not -R- T

### Final annotation ###

postulate Bool :E: Type

postulate T :R: Bool

postulate F :E: Bool

postulate Unit :E: Type

postulate MkUnit :R: Unit

not :R: (x :R: Bool) -> Unit = \(x :R: Bool).
  case -R- x of
    T/R
      => MkUnit
    F/E
      => MkUnit

main :R: Unit = not -R- T

### Verification ###

Verification successful.

### Pruned ###

postulate T : Bool

postulate MkUnit : Unit

not = \x.
  case x of
    T
      => MkUnit

main = not T

### Normal forms ###

unerased:
  
  let postulate Unit : Type
  in 
    let postulate MkUnit : Unit
    in MkUnit
erased:
  
  let postulate MkUnit : Unit
  in MkUnit
