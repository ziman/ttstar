-- vim: ft=agda

### Desugared ###

  let
    postulate Bool : Type
    postulate T : Bool
    postulate F : Bool
    postulate Unit : Type
    postulate MkUnit : Unit
    not : (x : Bool) -> Unit = \(x : Bool).
      case x of
        T
          => MkUnit
        F
          => MkUnit
    main :R: Unit = not T
  in main

### Metaified ###

  let
    postulate Bool :1: Type
    postulate T :2: Bool
    postulate F :3: Bool
    postulate Unit :4: Type
    postulate MkUnit :5: Unit
    not :6: (x :7: Bool) -> Unit = \(x :8: Bool).
      case -9- x of
        T/10
          => MkUnit
        F/11
          => MkUnit
    main :R: Unit = not -12- T
  in main

### Constraints ###

[] -> [2,5,6,7,8,9,10,12,R]
[3] -> [11]
[11] -> [3]
[R] -> [R]

### Solution ###

[2,5,6,7,8,9,10,12,R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :E: Bool
    postulate Unit :E: Type
    postulate MkUnit :R: Unit
    not :R: (x :R: Bool) -> Unit = \(x :R: Bool).
      case -R- x of
        T/R
          => MkUnit
        F/E
          => MkUnit
    main :R: Unit = not -R- T
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :E: Bool
    postulate Unit :E: Type
    postulate MkUnit :R: Unit
    not :R: (x :R: Bool) -> Unit = \(x :R: Bool).
      case -R- x of
        T/R
          => MkUnit
        F/E
          => MkUnit
    main :R: Unit = not -R- T
  in main

### Constraints ###

[E] -> [E]
[R] -> [R]

### Solution ###

[R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :E: Bool
    postulate Unit :E: Type
    postulate MkUnit :R: Unit
    not :R: (x :R: Bool) -> Unit = \(x :R: Bool).
      case -R- x of
        T/R
          => MkUnit
        F/E
          => MkUnit
    main :R: Unit = not -R- T
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :E: Bool
    postulate Unit :E: Type
    postulate MkUnit :R: Unit
    not :R: (x :R: Bool) -> Unit = \(x :R: Bool).
      case -R- x of
        T/R
          => MkUnit
        F/E
          => MkUnit
    main :R: Unit = not -R- T
  in main

### Final annotation ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :E: Bool
    postulate Unit :E: Type
    postulate MkUnit :R: Unit
    not :R: (x :R: Bool) -> Unit = \(x :R: Bool).
      case -R- x of
        T/R
          => MkUnit
        F/E
          => MkUnit
    main :R: Unit = not -R- T
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate T : Bool
    postulate MkUnit : Unit
    not = \x.
      case x of
        T
          => MkUnit
    main = not T
  in main

### Normal forms ###

unerased:
  
  let postulate MkUnit : Unit
  in MkUnit

erased:
  
  let postulate MkUnit : Unit
  in MkUnit

