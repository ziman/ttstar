-- vim: ft=agda

### Desugared ###

postulate Mool : Type

postulate Q : Mool

postulate W : Mool

postulate Bool : Type

postulate T : Bool

postulate F : Bool

postulate Id : (a : Type) -> (x : a) -> (y : a) -> Type

postulate Refl : (a : Type) -> (x : a) -> Id a x x

not : (x : Bool) -> Bool = \(x : Bool).
  case x of
    T
      => F
    F
      => T

notnot : (x : Bool) -> Id Bool x (not (not x)) = \(x : Bool).
  case x of
    T
      => Refl Bool T
    F
      => Refl Bool F

retTy : (x : Bool) -> Type = \(x : Bool).
  case x of
    T
      => Bool
    F
      => Mool

mot : (m : Mool) -> Mool = \(m : Mool).
  case m of
    Q
      => W
    W
      => Q

invert : (t : Bool) -> (x : retTy t) -> retTy t = \(t : Bool) (x : retTy t).
  case t of
    T
      => not x
    F
      => mot x

main :R: Mool = invert F Q

### Metaified ###

postulate Mool :1: Type

postulate Q :2: Mool

postulate W :3: Mool

postulate Bool :4: Type

postulate T :5: Bool

postulate F :6: Bool

postulate Id :7: (a :8: Type) -> (x :9: a) -> (y :10: a) -> Type

postulate Refl :11: (a :12: Type) -> (x :13: a) -> Id -16- a -15- x -14- x

not :17: (x :18: Bool) -> Bool = \(x :19: Bool).
  case -20- x of
    T/21
      => F
    F/22
      => T

notnot :23: (x :24: Bool) -> Id -27- Bool -26- x -25- (not -28- (not -29- x)) = \(x :30: Bool).
  case -31- x of
    T/32
      => Refl -34- Bool -33- T
    F/35
      => Refl -37- Bool -36- F

retTy :38: (x :39: Bool) -> Type = \(x :40: Bool).
  case -41- x of
    T/42
      => Bool
    F/43
      => Mool

mot :44: (m :45: Mool) -> Mool = \(m :46: Mool).
  case -47- m of
    Q/48
      => W
    W/49
      => Q

invert :50: (t :51: Bool) -> (x :52: retTy -53- t) -> retTy -54- t = \(t :55: Bool) (x :56: retTy -57- t).
  case -58- t of
    T/59
      => not -60- x
    F/61
      => mot -62- x

main :R: Mool = invert -64- F -63- Q

### Inferred definitions ###

postulate Bool :4: Type {- constraints apply -}
  [] -> [4,R]

postulate F :6: Bool {- constraints apply -}
  [] -> [6,R]

postulate Id :7: (a :8: Type) -> (x :9: a) -> (y :10: a) -> Type {- constraints apply -}
  [] -> [7,R]

postulate Mool :1: Type {- constraints apply -}
  [] -> [1,R]

postulate Q :2: Mool {- constraints apply -}
  [] -> [2,R]

postulate Refl :11: (a :12: Type) -> (x :13: a) -> Id -16- a -15- x -14- x {- constraints apply -}
  [] -> [11,R]

postulate T :5: Bool {- constraints apply -}
  [] -> [5,R]

postulate Type :E: Type

postulate W :3: Mool {- constraints apply -}
  [] -> [3,R]

invert :50: (t :51: Bool) -> (x :52: retTy -53- t) -> retTy -54- t = \(t :55: Bool) (x :56: retTy -57- t).
  case -58- t of
    T/59
      => not -60- x
    F/61
      => mot -62- x {- constraints apply -}
  [] -> [2,3,5,6,17,18,19,20,21,22,44,45,46,47,48,49,50,51,52,55,56,58,59,60,61,62,R]

main :R: Mool = invert -64- F -63- Q {- constraints apply -}
  [] -> [2,3,5,6,17,18,19,20,21,22,44,45,46,47,48,49,50,51,52,55,56,58,59,60,61,62,63,64,R]

mot :44: (m :45: Mool) -> Mool = \(m :46: Mool).
  case -47- m of
    Q/48
      => W
    W/49
      => Q {- constraints apply -}
  [] -> [2,3,44,45,46,47,48,49,R]

not :17: (x :18: Bool) -> Bool = \(x :19: Bool).
  case -20- x of
    T/21
      => F
    F/22
      => T {- constraints apply -}
  [] -> [5,6,17,18,19,20,21,22,R]

notnot :23: (x :24: Bool) -> Id -27- Bool -26- x -25- (not -28- (not -29- x)) = \(x :30: Bool).
  case -31- x of
    T/32
      => Refl -34- Bool -33- T
    F/35
      => Refl -37- Bool -36- F {- constraints apply -}
  [] -> [11,23,24,30,31,R]
  [5] -> [32]
  [6] -> [35]
  [12] -> [4,34,37]
  [13] -> [5,6,33,36]
  [14] -> [25]
  [15] -> [26]
  [16] -> [27]
  [25] -> [14]
  [26] -> [15]
  [27] -> [16]
  [32] -> [5]
  [33] -> [13]
  [34] -> [12]
  [35] -> [6]
  [36] -> [13]
  [37] -> [12]

retTy :38: (x :39: Bool) -> Type = \(x :40: Bool).
  case -41- x of
    T/42
      => Bool
    F/43
      => Mool {- constraints apply -}
  [] -> [1,4,38,39,40,41,R]
  [5] -> [42]
  [6] -> [43]
  [42] -> [5]
  [43] -> [6]


### Constraints ###

[] -> [2,3,5,6,17,18,19,20,21,22,44,45,46,47,48,49,50,51,52,55,56,58,59,60,61,62,63,64,R]

### Solution ###

[2,3,5,6,17,18,19,20,21,22,44,45,46,47,48,49,50,51,52,55,56,58,59,60,61,62,63,64,R]

### Annotated ###

postulate Mool :E: Type

postulate Q :R: Mool

postulate W :R: Mool

postulate Bool :E: Type

postulate T :R: Bool

postulate F :R: Bool

postulate Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type

postulate Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x

not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
  case -R- x of
    T/R
      => F
    F/R
      => T

notnot :E: (x :E: Bool) -> Id -E- Bool -E- x -E- (not -E- (not -E- x)) = \(x :E: Bool).
  case -E- x of
    T/E
      => Refl -E- Bool -E- T
    F/E
      => Refl -E- Bool -E- F

retTy :E: (x :E: Bool) -> Type = \(x :E: Bool).
  case -E- x of
    T/E
      => Bool
    F/E
      => Mool

mot :R: (m :R: Mool) -> Mool = \(m :R: Mool).
  case -R- m of
    Q/R
      => W
    W/R
      => Q

invert :R: (t :R: Bool) -> (x :R: retTy -E- t) -> retTy -E- t = \(t :R: Bool) (x :R: retTy -E- t).
  case -R- t of
    T/R
      => not -R- x
    F/R
      => mot -R- x

main :R: Mool = invert -R- F -R- Q

### Specialised ###

postulate Mool :E: Type

postulate Q :R: Mool

postulate W :R: Mool

postulate Bool :E: Type

postulate T :R: Bool

postulate F :R: Bool

postulate Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type

postulate Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x

not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
  case -R- x of
    T/R
      => F
    F/R
      => T

notnot :E: (x :E: Bool) -> Id -E- Bool -E- x -E- (not -E- (not -E- x)) = \(x :E: Bool).
  case -E- x of
    T/E
      => Refl -E- Bool -E- T
    F/E
      => Refl -E- Bool -E- F

retTy :E: (x :E: Bool) -> Type = \(x :E: Bool).
  case -E- x of
    T/E
      => Bool
    F/E
      => Mool

mot :R: (m :R: Mool) -> Mool = \(m :R: Mool).
  case -R- m of
    Q/R
      => W
    W/R
      => Q

invert :R: (t :R: Bool) -> (x :R: retTy -E- t) -> retTy -E- t = \(t :R: Bool) (x :R: retTy -E- t).
  case -R- t of
    T/R
      => not -R- x
    F/R
      => mot -R- x

main :R: Mool = invert -R- F -R- Q

### Final annotation ###

postulate Mool :E: Type

postulate Q :R: Mool

postulate W :R: Mool

postulate Bool :E: Type

postulate T :R: Bool

postulate F :R: Bool

postulate Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type

postulate Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x

not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
  case -R- x of
    T/R
      => F
    F/R
      => T

notnot :E: (x :E: Bool) -> Id -E- Bool -E- x -E- (not -E- (not -E- x)) = \(x :E: Bool).
  case -E- x of
    T/E
      => Refl -E- Bool -E- T
    F/E
      => Refl -E- Bool -E- F

retTy :E: (x :E: Bool) -> Type = \(x :E: Bool).
  case -E- x of
    T/E
      => Bool
    F/E
      => Mool

mot :R: (m :R: Mool) -> Mool = \(m :R: Mool).
  case -R- m of
    Q/R
      => W
    W/R
      => Q

invert :R: (t :R: Bool) -> (x :R: retTy -E- t) -> retTy -E- t = \(t :R: Bool) (x :R: retTy -E- t).
  case -R- t of
    T/R
      => not -R- x
    F/R
      => mot -R- x

main :R: Mool = invert -R- F -R- Q

### Verification ###

Verification successful.

### Pruned ###

postulate Q

postulate W

postulate T

postulate F

not = \x.
  case x of
    T
      => F
    F
      => T

mot = \m.
  case m of
    Q
      => W
    W
      => Q

invert = \t x.
  case t of
    T
      => not x
    F
      => mot x

main = invert F Q

### Normal forms ###

unerased:
  W
erased:
  W
