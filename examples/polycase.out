-- vim: ft=agda

### Desugared ###

postulate Mool : Type

postulate Q : Mool

postulate W : Mool

postulate Bool : Type

postulate T : Bool

postulate F : Bool

postulate Id : (a : Type) -> (x : a) -> (y : a) -> Type

postulate Refl : (a : Type) -> (x : a) -> Id a x x

not : (x : Bool) -> Bool = \(x : Bool).
  case x of
    T
      => F
    F
      => T

notnot : (x : Bool) -> Id Bool x (not (not x)) = \(x : Bool).
  case x of
    T
      => Refl Bool T
    F
      => Refl Bool F

retTy : (x : Bool) -> Type = \(x : Bool).
  case x of
    T
      => Bool
    F
      => Mool

mot : (m : Mool) -> Mool = \(m : Mool).
  case m of
    Q
      => W
    W
      => Q

invert : (t : Bool) -> (x : retTy t) -> retTy t = \(t : Bool) (x : retTy t).
  case t of
    T
      => not x
    F
      => mot x

main :R: Mool = invert F Q

### Metaified ###

postulate Mool :1: Type

postulate Q :2: Mool

postulate W :3: Mool

postulate Bool :4: Type

postulate T :5: Bool

postulate F :6: Bool

postulate Id :7: (a :8: Type) -> (x :9: a) -> (y :10: a) -> Type

postulate Refl :11: (a :12: Type) -> (x :13: a) -> Id -16- a -15- x -14- x

not :17: (x :18: Bool) -> Bool = \(x :19: Bool).
  case -20- x of
    T
      => F
    F
      => T

notnot :21: (x :22: Bool) -> Id -25- Bool -24- x -23- (not -26- (not -27- x)) = \(x :28: Bool).
  case -29- x of
    T
      => Refl -31- Bool -30- T
    F
      => Refl -33- Bool -32- F

retTy :34: (x :35: Bool) -> Type = \(x :36: Bool).
  case -37- x of
    T
      => Bool
    F
      => Mool

mot :38: (m :39: Mool) -> Mool = \(m :40: Mool).
  case -41- m of
    Q
      => W
    W
      => Q

invert :42: (t :43: Bool) -> (x :44: retTy -45- t) -> retTy -46- t = \(t :47: Bool) (x :48: retTy -49- t).
  case -50- t of
    T
      => not -51- x
    F
      => mot -52- x

main :R: Mool = invert -54- F -53- Q

### Inferred definitions ###

postulate Bool :4: Type {- constraints apply -}
  [] -> [4,R]

postulate F :6: Bool {- constraints apply -}
  [] -> [4,6,R]

postulate Id :7: (a :8: Type) -> (x :9: a) -> (y :10: a) -> Type {- constraints apply -}
  [] -> [7,R]

postulate Mool :1: Type {- constraints apply -}
  [] -> [1,R]

postulate Q :2: Mool {- constraints apply -}
  [] -> [1,2,R]

postulate Refl :11: (a :12: Type) -> (x :13: a) -> Id -16- a -15- x -14- x {- constraints apply -}
  [] -> [7,11,R]
  [8] -> [12,16]
  [9] -> [12,13,15]
  [10] -> [12,13,14]
  [14] -> [10]
  [15] -> [9]
  [16] -> [8]

postulate T :5: Bool {- constraints apply -}
  [] -> [4,5,R]

postulate Type :R: Type

postulate W :3: Mool {- constraints apply -}
  [] -> [1,3,R]

invert :42: (t :43: Bool) -> (x :44: retTy -45- t) -> retTy -46- t = \(t :47: Bool) (x :48: retTy -49- t).
  case -50- t of
    T
      => not -51- x
    F
      => mot -52- x {- constraints apply -}
  [] -> [1,2,3,4,5,6,17,18,19,20,34,35,36,37,38,39,40,41,42,43,44,46,47,48,49,50,51,52,R]

main :R: Mool = invert -54- F -53- Q {- constraints apply -}
  [] -> [1,2,3,4,5,6,17,18,19,20,34,35,36,37,38,39,40,41,42,43,44,46,47,48,49,50,51,52,53,54,R]

mot :38: (m :39: Mool) -> Mool = \(m :40: Mool).
  case -41- m of
    Q
      => W
    W
      => Q {- constraints apply -}
  [] -> [1,2,3,38,39,40,41,R]

not :17: (x :18: Bool) -> Bool = \(x :19: Bool).
  case -20- x of
    T
      => F
    F
      => T {- constraints apply -}
  [] -> [4,5,6,17,18,19,20,R]

notnot :21: (x :22: Bool) -> Id -25- Bool -24- x -23- (not -26- (not -27- x)) = \(x :28: Bool).
  case -29- x of
    T
      => Refl -31- Bool -30- T
    F
      => Refl -33- Bool -32- F {- constraints apply -}
  [] -> [7,11,21,22,28,29,R]
  [8] -> [4,12,16,25]
  [9] -> [4,12,13,15,24]
  [10] -> [4,5,6,12,13,14,17,18,19,20,23]
  [10,18] -> [4,5,6,17,18,19,20,26,27]
  [10,18,27] -> [18]
  [10,26] -> [18]
  [12] -> [4,31,33]
  [13] -> [4,5,6,30,32]
  [14] -> [10,23]
  [15] -> [9,24]
  [16] -> [8,25]
  [23] -> [10,14]
  [24] -> [9,15]
  [25] -> [8,16]
  [30] -> [13]
  [31] -> [12]
  [32] -> [13]
  [33] -> [12]

retTy :34: (x :35: Bool) -> Type = \(x :36: Bool).
  case -37- x of
    T
      => Bool
    F
      => Mool {- constraints apply -}
  [] -> [1,4,34,35,36,37,R]


### Constraints ###

[] -> [1,2,3,4,5,6,17,18,19,20,34,35,36,37,38,39,40,41,42,43,44,46,47,48,49,50,51,52,53,54,R]

### Solution ###

[1,2,3,4,5,6,17,18,19,20,34,35,36,37,38,39,40,41,42,43,44,46,47,48,49,50,51,52,53,54,R]

### Annotated ###

postulate Mool :R: Type

postulate Q :R: Mool

postulate W :R: Mool

postulate Bool :R: Type

postulate T :R: Bool

postulate F :R: Bool

postulate Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type

postulate Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x

not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
  case -R- x of
    T
      => F
    F
      => T

notnot :E: (x :E: Bool) -> Id -E- Bool -E- x -E- (not -E- (not -E- x)) = \(x :E: Bool).
  case -E- x of
    T
      => Refl -E- Bool -E- T
    F
      => Refl -E- Bool -E- F

retTy :R: (x :R: Bool) -> Type = \(x :R: Bool).
  case -R- x of
    T
      => Bool
    F
      => Mool

mot :R: (m :R: Mool) -> Mool = \(m :R: Mool).
  case -R- m of
    Q
      => W
    W
      => Q

invert :R: (t :R: Bool) -> (x :R: retTy -E- t) -> retTy -R- t = \(t :R: Bool) (x :R: retTy -R- t).
  case -R- t of
    T
      => not -R- x
    F
      => mot -R- x

main :R: Mool = invert -R- F -R- Q

### Specialised ###

postulate Mool :R: Type

postulate Q :R: Mool

postulate W :R: Mool

postulate Bool :R: Type

postulate T :R: Bool

postulate F :R: Bool

postulate Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type

postulate Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x

not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
  case -R- x of
    T
      => F
    F
      => T

notnot :E: (x :E: Bool) -> Id -E- Bool -E- x -E- (not -E- (not -E- x)) = \(x :E: Bool).
  case -E- x of
    T
      => Refl -E- Bool -E- T
    F
      => Refl -E- Bool -E- F

retTy :R: (x :R: Bool) -> Type = \(x :R: Bool).
  case -R- x of
    T
      => Bool
    F
      => Mool

mot :R: (m :R: Mool) -> Mool = \(m :R: Mool).
  case -R- m of
    Q
      => W
    W
      => Q

invert :R: (t :R: Bool) -> (x :R: retTy -E- t) -> retTy -R- t = \(t :R: Bool) (x :R: retTy -R- t).
  case -R- t of
    T
      => not -R- x
    F
      => mot -R- x

main :R: Mool = invert -R- F -R- Q

### Final annotation ###

postulate Mool :R: Type

postulate Q :R: Mool

postulate W :R: Mool

postulate Bool :R: Type

postulate T :R: Bool

postulate F :R: Bool

postulate Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type

postulate Refl :E: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x

not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
  case -R- x of
    T
      => F
    F
      => T

notnot :E: (x :E: Bool) -> Id -E- Bool -E- x -E- (not -E- (not -E- x)) = \(x :E: Bool).
  case -E- x of
    T
      => Refl -E- Bool -E- T
    F
      => Refl -E- Bool -E- F

retTy :R: (x :R: Bool) -> Type = \(x :R: Bool).
  case -R- x of
    T
      => Bool
    F
      => Mool

mot :R: (m :R: Mool) -> Mool = \(m :R: Mool).
  case -R- m of
    Q
      => W
    W
      => Q

invert :R: (t :R: Bool) -> (x :R: retTy -E- t) -> retTy -R- t = \(t :R: Bool) (x :R: retTy -R- t).
  case -R- t of
    T
      => not -R- x
    F
      => mot -R- x

main :R: Mool = invert -R- F -R- Q

### Verification ###

Verification successful.

### Pruned ###

postulate Mool

postulate Q

postulate W

postulate Bool

postulate T

postulate F

not = \x.
  case x of
    T
      => F
    F
      => T

retTy = \x.
  case x of
    T
      => Bool
    F
      => Mool

mot = \m.
  case m of
    Q
      => W
    W
      => Q

invert = \t x.
  case t of
    T
      => not x
    F
      => mot x

main = invert F Q

### Normal forms ###

unerased:
  W
erased:
  W
