-- vim: ft=agda

### Desugared ###

postulate Nat : Type

postulate Z : Nat

postulate S : (_ :R: Nat) -> Nat

plus : (n : Nat) -> (m : Nat) -> Nat = \(n : Nat) (m : Nat).
  case n of
    Z
      => m
    S (n' : Nat)
      => S (plus n' m)

id : (x : Nat) -> Nat = (\x : Nat. x)

const : (x : Nat) -> (y : Nat) -> Nat = (\x : Nat. (\y : Nat. x))

main :R: Nat = 
  let apply : (f : (_ : Nat) -> Nat) -> (x : Nat) -> Nat = \(f : (_ : Nat) -> Nat) (x : Nat).
    case x of
      Z
        => f Z
      S (x' : Nat)
        => f (S x')
  in 
    let postulate Q : Nat
    in 
      let three : Nat = 3
      in plus (apply id 2) (apply (const Q) three)

### Metaified ###

postulate Nat :1: Type

postulate Z :2: Nat

postulate S :3: (_ :R: Nat) -> Nat

plus :4: (n :5: Nat) -> (m :6: Nat) -> Nat = \(n :7: Nat) (m :8: Nat).
  case -9- n of
    Z
      => m
    S (n' :10: Nat)
      => S -11- (plus -13- n' -12- m)

id :14: (x :15: Nat) -> Nat = (\x :16: Nat. x)

const :17: (x :18: Nat) -> (y :19: Nat) -> Nat = (\x :20: Nat. (\y :21: Nat. x))

main :R: Nat = 
  let apply :22: (f :23: (_ :24: Nat) -> Nat) -> (x :25: Nat) -> Nat = \(f :26: (_ :27: Nat) -> Nat) (x :28: Nat).
    case -29- x of
      Z
        => f -30- Z
      S (x' :31: Nat)
        => f -32- (S -33- x')
  in 
    let postulate Q :34: Nat
    in 
      let three :35: Nat = 3
      in plus -40- (apply -42- id -41- 2) -39- (apply -46- (const -47- Q) -45- three)

### Inferred definitions ###

postulate Nat :1: Type

postulate S :3: (_ :R: Nat) -> Nat

postulate Type :R: Type

postulate Z :2: Nat

const :17: (x :18: Nat) -> (y :19: Nat) -> Nat = (\x :20: Nat. (\y :21: Nat. x))
  [17] -> [20]
  [17,18] -> [20]
  [17,19] -> [21]
  [17,20] -> [18]
  [17,21] -> [19]

id :14: (x :15: Nat) -> Nat = (\x :16: Nat. x)
  [14] -> [16]
  [14,15] -> [16]
  [14,16] -> [15]

main :R: Nat = 
  let apply :22: (f :23: (_ :24: Nat) -> Nat) -> (x :25: Nat) -> Nat = \(f :26: (_ :27: Nat) -> Nat) (x :28: Nat).
    case -29- x of
      Z
        => f -30- Z
      S (x' :31: Nat)
        => f -32- (S -33- x')
  in 
    let postulate Q :34: Nat
    in 
      let three :35: Nat = 3
      in plus -40- (apply -42- id -41- 2) -39- (apply -46- (const -47- Q) -45- three)
  [] -> [4,R]
  [2,22] -> [25]
  [3,22] -> [25]
  [5] -> [22,40]
  [5,15] -> [24]
  [5,23] -> [14,42]
  [5,24] -> [15]
  [5,25] -> [2,3,41,43,44]
  [5,41] -> [25]
  [5,42] -> [23]
  [6] -> [22,39]
  [6,18,23] -> [34,47]
  [6,19] -> [24]
  [6,23] -> [17,46]
  [6,23,47] -> [18]
  [6,24] -> [19]
  [6,25] -> [35,45]
  [6,45] -> [25]
  [6,46] -> [23]
  [22] -> [25,26,29,31]
  [22,23] -> [26]
  [22,24] -> [27]
  [22,25] -> [28]
  [22,26] -> [23]
  [22,27] -> [2,3,24,30,31,32,33]
  [22,28] -> [25]
  [22,29] -> [28]
  [22,30] -> [27]
  [22,31] -> [25,29]
  [22,32] -> [27]
  [35] -> [2,3,36,37,38]
  [39] -> [6]
  [40] -> [5]

plus :4: (n :5: Nat) -> (m :6: Nat) -> Nat = \(n :7: Nat) (m :8: Nat).
  case -9- n of
    Z
      => m
    S (n' :10: Nat)
      => S -11- (plus -13- n' -12- m)
  [2,4] -> [5]
  [3,4] -> [5]
  [4] -> [3,4,5,8,9,10,11]
  [4,5] -> [7,10,13]
  [4,6] -> [8,12]
  [4,7] -> [5]
  [4,8] -> [6]
  [4,9] -> [7]
  [4,10] -> [5,9]
  [4,12] -> [6]
  [4,13] -> [5]


### Constraints ###

[] -> [4,R]
[2,4] -> [5]
[2,22] -> [25]
[3,4] -> [5]
[3,22] -> [25]
[4] -> [3,4,5,8,9,10,11]
[4,5] -> [7,10,13]
[4,6] -> [8,12]
[4,7] -> [5]
[4,8] -> [6]
[4,9] -> [7]
[4,10] -> [5,9]
[4,12] -> [6]
[4,13] -> [5]
[5] -> [22,40]
[5,15] -> [24]
[5,23] -> [14,42]
[5,24] -> [15]
[5,25] -> [2,3,41,43,44]
[5,41] -> [25]
[5,42] -> [23]
[6] -> [22,39]
[6,18,23] -> [34,47]
[6,19] -> [24]
[6,23] -> [17,46]
[6,23,47] -> [18]
[6,24] -> [19]
[6,25] -> [35,45]
[6,45] -> [25]
[6,46] -> [23]
[14] -> [16]
[14,15] -> [16]
[14,16] -> [15]
[17] -> [20]
[17,18] -> [20]
[17,19] -> [21]
[17,20] -> [18]
[17,21] -> [19]
[22] -> [25,26,29,31]
[22,23] -> [26]
[22,24] -> [27]
[22,25] -> [28]
[22,26] -> [23]
[22,27] -> [2,3,24,30,31,32,33]
[22,28] -> [25]
[22,29] -> [28]
[22,30] -> [27]
[22,31] -> [25,29]
[22,32] -> [27]
[35] -> [2,3,36,37,38]
[39] -> [6]
[40] -> [5]

### Solution ###

[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,R]

### Annotated ###

postulate Nat :E: Type

postulate Z :R: Nat

postulate S :R: (_ :R: Nat) -> Nat

plus :R: (n :R: Nat) -> (m :R: Nat) -> Nat = \(n :R: Nat) (m :R: Nat).
  case -R- n of
    Z
      => m
    S (n' :R: Nat)
      => S -R- (plus -R- n' -R- m)

id :R: (x :R: Nat) -> Nat = (\x :R: Nat. x)

const :R: (x :R: Nat) -> (y :R: Nat) -> Nat = (\x :R: Nat. (\y :R: Nat. x))

main :R: Nat = 
  let apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = \(f :R: (_ :R: Nat) -> Nat) (x :R: Nat).
    case -R- x of
      Z
        => f -R- Z
      S (x' :R: Nat)
        => f -R- (S -R- x')
  in 
    let postulate Q :R: Nat
    in 
      let three :R: Nat = 3
      in plus -R- (apply -R- id -R- 2) -R- (apply -R- (const -R- Q) -R- three)

### Specialised ###

postulate Nat :E: Type

postulate Z :R: Nat

postulate S :R: (_ :R: Nat) -> Nat

plus :R: (n :R: Nat) -> (m :R: Nat) -> Nat = \(n :R: Nat) (m :R: Nat).
  case -R- n of
    Z
      => m
    S (n' :R: Nat)
      => S -R- (plus -R- n' -R- m)

id :R: (x :R: Nat) -> Nat = (\x :R: Nat. x)

const :R: (x :R: Nat) -> (y :R: Nat) -> Nat = (\x :R: Nat. (\y :R: Nat. x))

main :R: Nat = 
  let apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = \(f :R: (_ :R: Nat) -> Nat) (x :R: Nat).
    case -R- x of
      Z
        => f -R- Z
      S (x' :R: Nat)
        => f -R- (S -R- x')
  in 
    let postulate Q :R: Nat
    in 
      let three :R: Nat = 3
      in plus -R- (apply -R- id -R- 2) -R- (apply -R- (const -R- Q) -R- three)

### Final annotation ###

postulate Nat :E: Type

postulate Z :R: Nat

postulate S :R: (_ :R: Nat) -> Nat

plus :R: (n :R: Nat) -> (m :R: Nat) -> Nat = \(n :R: Nat) (m :R: Nat).
  case -R- n of
    Z
      => m
    S (n' :R: Nat)
      => S -R- (plus -R- n' -R- m)

id :R: (x :R: Nat) -> Nat = (\x :R: Nat. x)

const :R: (x :R: Nat) -> (y :R: Nat) -> Nat = (\x :R: Nat. (\y :R: Nat. x))

main :R: Nat = 
  let apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = \(f :R: (_ :R: Nat) -> Nat) (x :R: Nat).
    case -R- x of
      Z
        => f -R- Z
      S (x' :R: Nat)
        => f -R- (S -R- x')
  in 
    let postulate Q :R: Nat
    in 
      let three :R: Nat = 3
      in plus -R- (apply -R- id -R- 2) -R- (apply -R- (const -R- Q) -R- three)

### Verification ###

Verification successful.

### Pruned ###

postulate Z

postulate S

plus = \n m.
  case n of
    Z
      => m
    S n'
      => S (plus n' m)

id = (\x. x)

const = (\x. (\y. x))

main = 
  let apply = \f x.
    case x of
      Z
        => f Z
      S x'
        => f (S x')
  in 
    let postulate Q
    in 
      let three = 3
      in plus (apply id 2) (apply (const Q) three)

### Normal forms ###

unerased:
  S (S Q)
erased:
  S (S Q)
