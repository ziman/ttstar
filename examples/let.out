-- vim: ft=agda

### Desugared ###

postulate Nat : Type

postulate Z : Nat

postulate S : (_ :ᴿ Nat) -> Nat

plus : (n : Nat) -> (m : Nat) -> Nat = \(n : Nat) (m : Nat).
  case n of
    Z
      => m
    S (n' : Nat)
      => S (plus n' m)

id : (x : Nat) -> Nat = (\x : Nat. x)

const : (x : Nat) -> (y : Nat) -> Nat = (\x : Nat. (\y : Nat. x))

main :ᴿ Nat = 
  let apply : (f : (_ : Nat) -> Nat) -> (x : Nat) -> Nat = \(f : (_ : Nat) -> Nat) (x : Nat).
    case x of
      Z
        => f Z
      S (x' : Nat)
        => f (S x')
  in 
    let postulate Q : Nat
    in 
      let three : Nat = 3
      in plus (apply id 2) (apply (const Q) three)

### Metaified ###

postulate Nat :¹ Type

postulate Z :² Nat

postulate S :³ (_ :ᴿ Nat) -> Nat

plus :⁴ (n :⁵ Nat) -> (m :⁶ Nat) -> Nat = \(n :⁷ Nat) (m :⁸ Nat).
  case ⁹ n of
    Z
      => m
    S (n' :¹⁰ Nat)
      => S ¹¹ (plus ¹³ n' ¹² m)

id :¹⁴ (x :¹⁵ Nat) -> Nat = (\x :¹⁶ Nat. x)

const :¹⁷ (x :¹⁸ Nat) -> (y :¹⁹ Nat) -> Nat = (\x :²⁰ Nat. (\y :²¹ Nat. x))

main :ᴿ Nat = 
  let apply :²² (f :²³ (_ :²⁴ Nat) -> Nat) -> (x :²⁵ Nat) -> Nat = \(f :²⁶ (_ :²⁷ Nat) -> Nat) (x :²⁸ Nat).
    case ²⁹ x of
      Z
        => f ³⁰ Z
      S (x' :³¹ Nat)
        => f ³² (S ³³ x')
  in 
    let postulate Q :³⁴ Nat
    in 
      let three :³⁵ Nat = 3
      in plus ⁴⁰ (apply ⁴² id ⁴¹ 2) ³⁹ (apply ⁴⁶ (const ⁴⁷ Q) ⁴⁵ three)

### Inferred definitions ###

postulate Nat :¹ Type

postulate S :³ (_ :ᴿ Nat) -> Nat

postulate Type :ᴿ Type

postulate Z :² Nat

const :¹⁷ (x :¹⁸ Nat) -> (y :¹⁹ Nat) -> Nat = (\x :²⁰ Nat. (\y :²¹ Nat. x))
  [17] -> [20]
  [17,18] -> [20]
  [17,19] -> [21]
  [17,20] -> [18]
  [17,21] -> [19]

id :¹⁴ (x :¹⁵ Nat) -> Nat = (\x :¹⁶ Nat. x)
  [14] -> [16]
  [14,15] -> [16]
  [14,16] -> [15]

main :ᴿ Nat = 
  let apply :²² (f :²³ (_ :²⁴ Nat) -> Nat) -> (x :²⁵ Nat) -> Nat = \(f :²⁶ (_ :²⁷ Nat) -> Nat) (x :²⁸ Nat).
    case ²⁹ x of
      Z
        => f ³⁰ Z
      S (x' :³¹ Nat)
        => f ³² (S ³³ x')
  in 
    let postulate Q :³⁴ Nat
    in 
      let three :³⁵ Nat = 3
      in plus ⁴⁰ (apply ⁴² id ⁴¹ 2) ³⁹ (apply ⁴⁶ (const ⁴⁷ Q) ⁴⁵ three)
  [] -> [4,R]
  [2,22] -> [25]
  [3,22] -> [25]
  [5] -> [22,40]
  [5,15] -> [24]
  [5,23] -> [14,42]
  [5,24] -> [15]
  [5,25] -> [2,3,41,43,44]
  [5,41] -> [25]
  [5,42] -> [23]
  [6] -> [22,39]
  [6,18,23] -> [34,47]
  [6,19] -> [24]
  [6,23] -> [17,46]
  [6,23,47] -> [18]
  [6,24] -> [19]
  [6,25] -> [35,45]
  [6,45] -> [25]
  [6,46] -> [23]
  [22] -> [25,26,29,31]
  [22,23] -> [26]
  [22,24] -> [27]
  [22,25] -> [28]
  [22,26] -> [23]
  [22,27] -> [2,3,24,30,31,32,33]
  [22,28] -> [25]
  [22,29] -> [28]
  [22,30] -> [27]
  [22,31] -> [25,29]
  [22,32] -> [27]
  [35] -> [2,3,36,37,38]
  [39] -> [6]
  [40] -> [5]

plus :⁴ (n :⁵ Nat) -> (m :⁶ Nat) -> Nat = \(n :⁷ Nat) (m :⁸ Nat).
  case ⁹ n of
    Z
      => m
    S (n' :¹⁰ Nat)
      => S ¹¹ (plus ¹³ n' ¹² m)
  [2,4] -> [5]
  [3,4] -> [5]
  [4] -> [3,4,5,8,9,10,11]
  [4,5] -> [7,10,13]
  [4,6] -> [8,12]
  [4,7] -> [5]
  [4,8] -> [6]
  [4,9] -> [7]
  [4,10] -> [5,9]
  [4,12] -> [6]
  [4,13] -> [5]


### Constraints ###

[] -> [4,R]
[2,4] -> [5]
[2,22] -> [25]
[3,4] -> [5]
[3,22] -> [25]
[4] -> [3,4,5,8,9,10,11]
[4,5] -> [7,10,13]
[4,6] -> [8,12]
[4,7] -> [5]
[4,8] -> [6]
[4,9] -> [7]
[4,10] -> [5,9]
[4,12] -> [6]
[4,13] -> [5]
[5] -> [22,40]
[5,15] -> [24]
[5,23] -> [14,42]
[5,24] -> [15]
[5,25] -> [2,3,41,43,44]
[5,41] -> [25]
[5,42] -> [23]
[6] -> [22,39]
[6,18,23] -> [34,47]
[6,19] -> [24]
[6,23] -> [17,46]
[6,23,47] -> [18]
[6,24] -> [19]
[6,25] -> [35,45]
[6,45] -> [25]
[6,46] -> [23]
[14] -> [16]
[14,15] -> [16]
[14,16] -> [15]
[17] -> [20]
[17,18] -> [20]
[17,19] -> [21]
[17,20] -> [18]
[17,21] -> [19]
[22] -> [25,26,29,31]
[22,23] -> [26]
[22,24] -> [27]
[22,25] -> [28]
[22,26] -> [23]
[22,27] -> [2,3,24,30,31,32,33]
[22,28] -> [25]
[22,29] -> [28]
[22,30] -> [27]
[22,31] -> [25,29]
[22,32] -> [27]
[35] -> [2,3,36,37,38]
[39] -> [6]
[40] -> [5]

### Solution ###

[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,R]

### Annotated ###

postulate Nat :ᴱ Type

postulate Z :ᴿ Nat

postulate S :ᴿ (_ :ᴿ Nat) -> Nat

plus :ᴿ (n :ᴿ Nat) -> (m :ᴿ Nat) -> Nat = \(n :ᴿ Nat) (m :ᴿ Nat).
  case ᴿ n of
    Z
      => m
    S (n' :ᴿ Nat)
      => S ᴿ (plus ᴿ n' ᴿ m)

id :ᴿ (x :ᴿ Nat) -> Nat = (\x :ᴿ Nat. x)

const :ᴿ (x :ᴿ Nat) -> (y :ᴿ Nat) -> Nat = (\x :ᴿ Nat. (\y :ᴿ Nat. x))

main :ᴿ Nat = 
  let apply :ᴿ (f :ᴿ (_ :ᴿ Nat) -> Nat) -> (x :ᴿ Nat) -> Nat = \(f :ᴿ (_ :ᴿ Nat) -> Nat) (x :ᴿ Nat).
    case ᴿ x of
      Z
        => f ᴿ Z
      S (x' :ᴿ Nat)
        => f ᴿ (S ᴿ x')
  in 
    let postulate Q :ᴿ Nat
    in 
      let three :ᴿ Nat = 3
      in plus ᴿ (apply ᴿ id ᴿ 2) ᴿ (apply ᴿ (const ᴿ Q) ᴿ three)

### Specialised ###

postulate Nat :ᴱ Type

postulate Z :ᴿ Nat

postulate S :ᴿ (_ :ᴿ Nat) -> Nat

plus :ᴿ (n :ᴿ Nat) -> (m :ᴿ Nat) -> Nat = \(n :ᴿ Nat) (m :ᴿ Nat).
  case ᴿ n of
    Z
      => m
    S (n' :ᴿ Nat)
      => S ᴿ (plus ᴿ n' ᴿ m)

id :ᴿ (x :ᴿ Nat) -> Nat = (\x :ᴿ Nat. x)

const :ᴿ (x :ᴿ Nat) -> (y :ᴿ Nat) -> Nat = (\x :ᴿ Nat. (\y :ᴿ Nat. x))

main :ᴿ Nat = 
  let apply :ᴿ (f :ᴿ (_ :ᴿ Nat) -> Nat) -> (x :ᴿ Nat) -> Nat = \(f :ᴿ (_ :ᴿ Nat) -> Nat) (x :ᴿ Nat).
    case ᴿ x of
      Z
        => f ᴿ Z
      S (x' :ᴿ Nat)
        => f ᴿ (S ᴿ x')
  in 
    let postulate Q :ᴿ Nat
    in 
      let three :ᴿ Nat = 3
      in plus ᴿ (apply ᴿ id ᴿ 2) ᴿ (apply ᴿ (const ᴿ Q) ᴿ three)

### Final annotation ###

postulate Nat :ᴱ Type

postulate Z :ᴿ Nat

postulate S :ᴿ (_ :ᴿ Nat) -> Nat

plus :ᴿ (n :ᴿ Nat) -> (m :ᴿ Nat) -> Nat = \(n :ᴿ Nat) (m :ᴿ Nat).
  case ᴿ n of
    Z
      => m
    S (n' :ᴿ Nat)
      => S ᴿ (plus ᴿ n' ᴿ m)

id :ᴿ (x :ᴿ Nat) -> Nat = (\x :ᴿ Nat. x)

const :ᴿ (x :ᴿ Nat) -> (y :ᴿ Nat) -> Nat = (\x :ᴿ Nat. (\y :ᴿ Nat. x))

main :ᴿ Nat = 
  let apply :ᴿ (f :ᴿ (_ :ᴿ Nat) -> Nat) -> (x :ᴿ Nat) -> Nat = \(f :ᴿ (_ :ᴿ Nat) -> Nat) (x :ᴿ Nat).
    case ᴿ x of
      Z
        => f ᴿ Z
      S (x' :ᴿ Nat)
        => f ᴿ (S ᴿ x')
  in 
    let postulate Q :ᴿ Nat
    in 
      let three :ᴿ Nat = 3
      in plus ᴿ (apply ᴿ id ᴿ 2) ᴿ (apply ᴿ (const ᴿ Q) ᴿ three)

### Verification ###

Verification successful.

### Pruned ###

postulate Z

postulate S

plus = \n m.
  case n of
    Z
      => m
    S n'
      => S (plus n' m)

id = (\x. x)

const = (\x. (\y. x))

main = 
  let apply = \f x.
    case x of
      Z
        => f Z
      S x'
        => f (S x')
  in 
    let postulate Q
    in 
      let three = 3
      in plus (apply id 2) (apply (const Q) three)

### Normal forms ###

unerased:
  S (S Q)
erased:
  S (S Q)
