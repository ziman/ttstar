-- vim: ft=agda

### Desugared ###

postulate Nat : *

postulate Z : Nat

postulate S : (n  -R-  Nat) -> Nat

plus : (_ : Nat) -> (_ : Nat) -> Nat
  pat (n : Nat).
    plus Z n  =  n
  pat (m : Nat) (n : Nat).
    plus (S m) n  =  S (plus m n)

id : (_ : Nat) -> Nat
  id  =  (\x : Nat. x)

const : (x : Nat) -> (y : Nat) -> Nat
  = (\x : Nat. (\y : Nat. x))

main  -R-  Nat
  = 
    let apply : (f : (_ : Nat) -> Nat) -> (x : Nat) -> Nat = (\f : (_ : Nat) -> Nat. (\x : Nat. f x))
    in 
      let Q : Nat
      in 
        let three : Nat = 3
        in plus (apply id 2) (apply (const Q) three)

### Metaified ###

postulate Nat :?1: *

postulate Z :?2: Nat

postulate S :?3: (n :!R: Nat) -> Nat

plus :?4: (_ :?5: Nat) -> (_ :?6: Nat) -> Nat
  pat (n :?7: Nat).
    plus -?9- Z -?8- n  =  n
  pat (m :?10: Nat) (n :?11: Nat).
    plus -?13- (S -?14- m) -?12- n  =  S -?15- (plus -?17- m -?16- n)

id :?18: (_ :?19: Nat) -> Nat
  id  =  (\x :?20: Nat. x)

const :?21: (x :?22: Nat) -> (y :?23: Nat) -> Nat
  = (\x :?24: Nat. (\y :?25: Nat. x))

main :!R: Nat
  = 
    let apply :?26: (f :?27: (_ :?28: Nat) -> Nat) -> (x :?29: Nat) -> Nat = (\f :?30: (_ :?31: Nat) -> Nat. (\x :?32: Nat. f -?33- x))
    in 
      let Q :?34: Nat
      in 
        let three :?35: Nat = 3
        in plus -?40- (apply -?42- id -?41- 2) -?39- (apply -?46- (const -?47- Q) -?45- three)

### Inferred definitions ###

Nat :?1: *

S :?3: (n :!R: Nat) -> Nat

Z :?2: Nat

const :?21: (x :?22: Nat) -> (y :?23: Nat) -> Nat = (\x :?24: Nat. (\y :?25: Nat. x))
  [] -> [?22,?24,!R]
  [?23] -> [?25]
  [?25] -> [?23]

id :?18: (_ :?19: Nat) -> Nat 
  id  =  (\x :?20: Nat. x)
  [] -> [?19,?20,!R]

main :!R: Nat = 
  let apply :?26: (f :?27: (_ :?28: Nat) -> Nat) -> (x :?29: Nat) -> Nat = (\f :?30: (_ :?31: Nat) -> Nat. (\x :?32: Nat. f -?33- x))
  in 
    let Q :?34: Nat
    in 
      let three :?35: Nat = 3
      in plus -?40- (apply -?42- id -?41- 2) -?39- (apply -?46- (const -?47- Q) -?45- three)
  [] -> [?2,?3,?4,?27,?30,?36,?37,?38,!R]
  [?5] -> [?18,?26,?40,?42]
  [?5,?19] -> [?28]
  [?5,?28] -> [?19]
  [?5,?29] -> [?41,?43,?44]
  [?5,?41] -> [?29]
  [?6] -> [?21,?26,?39,?46]
  [?6,?22] -> [?34,?47]
  [?6,?23] -> [?28]
  [?6,?28] -> [?23]
  [?6,?29] -> [?35,?45]
  [?6,?45] -> [?29]
  [?6,?47] -> [?22]
  [?28] -> [?31]
  [?29] -> [?32]
  [?31] -> [?28,?32,?33]
  [?32] -> [?29]
  [?33] -> [?31]
  [?39] -> [?6]
  [?40] -> [?5]

plus :?4: (_ :?5: Nat) -> (_ :?6: Nat) -> Nat 
  pat (n :?7: Nat).
    plus -?9- Z -?8- n  =  n
  pat (m :?10: Nat) (n :?11: Nat).
    plus -?13- (S -?14- m) -?12- n  =  S -?15- (plus -?17- m -?16- n)
  [] -> [?3,?4,?5,?6,?7,?8,?9,?10,?11,?12,?13,?14,?15,?16,?17,!R]


### Constraints ###

[] -> [?2,?3,?4,?5,?6,?7,?8,?9,?10,?11,?12,?13,?14,?15,?16,?17,?19,?20,?22,?24,?27,?30,?36,?37,?38,!R]
[?5] -> [?18,?26,?40,?42]
[?5,?19] -> [?28]
[?5,?28] -> [?19]
[?5,?29] -> [?41,?43,?44]
[?5,?41] -> [?29]
[?6] -> [?21,?26,?39,?46]
[?6,?22] -> [?34,?47]
[?6,?23] -> [?28]
[?6,?28] -> [?23]
[?6,?29] -> [?35,?45]
[?6,?45] -> [?29]
[?6,?47] -> [?22]
[?23] -> [?25]
[?25] -> [?23]
[?28] -> [?31]
[?29] -> [?32]
[?31] -> [?28,?32,?33]
[?32] -> [?29]
[?33] -> [?31]
[?39] -> [?6]
[?40] -> [?5]

### Solution ###

[?2,?3,?4,?5,?6,?7,?8,?9,?10,?11,?12,?13,?14,?15,?16,?17,?18,?19,?20,?21,?22,?23,?24,?25,?26,?27,?28,?29,?30,?31,?32,?33,?34,?35,?36,?37,?38,?39,?40,?41,?42,?43,?44,?45,?46,?47,!R]

### Annotated ###

postulate Nat :E: *

postulate Z :R: Nat

postulate S :R: (n :R: Nat) -> Nat

plus :R: (_ :R: Nat) -> (_ :R: Nat) -> Nat
  pat (n :R: Nat).
    plus -R- Z -R- n  =  n
  pat (m :R: Nat) (n :R: Nat).
    plus -R- (S -R- m) -R- n  =  S -R- (plus -R- m -R- n)

id :R: (_ :R: Nat) -> Nat
  id  =  (\x :R: Nat. x)

const :R: (x :R: Nat) -> (y :R: Nat) -> Nat
  = (\x :R: Nat. (\y :R: Nat. x))

main :R: Nat
  = 
    let apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))
    in 
      let Q :R: Nat
      in 
        let three :R: Nat = 3
        in plus -R- (apply -R- id -R- 2) -R- (apply -R- (const -R- Q) -R- three)

### Specialised ###

postulate Nat :!E: *

postulate Z :!R: Nat

postulate S :!R: (n :!R: Nat) -> Nat

plus :!R: (_ :!R: Nat) -> (_ :!R: Nat) -> Nat
  pat (n :!R: Nat).
    plus -!R- Z -!R- n  =  n
  pat (m :!R: Nat) (n :!R: Nat).
    plus -!R- (S -!R- m) -!R- n  =  S -!R- (plus -!R- m -!R- n)

id :!R: (_ :!R: Nat) -> Nat
  id  =  (\x :!R: Nat. x)

const :!R: (x :!R: Nat) -> (y :!R: Nat) -> Nat
  = (\x :!R: Nat. (\y :!R: Nat. x))

main :!R: Nat
  = 
    let apply :!R: (f :!R: (_ :!R: Nat) -> Nat) -> (x :!R: Nat) -> Nat = (\f :!R: (_ :!R: Nat) -> Nat. (\x :!R: Nat. f -!R- x))
    in 
      let Q :!R: Nat
      in 
        let three :!R: Nat = 3
        in plus -!R- (apply -!R- id -!R- 2) -!R- (apply -!R- (const -!R- Q) -!R- three)

### Final annotation ###

postulate Nat :E: *

postulate Z :R: Nat

postulate S :R: (n :R: Nat) -> Nat

plus :R: (_ :R: Nat) -> (_ :R: Nat) -> Nat
  pat (n :R: Nat).
    plus -R- Z -R- n  =  n
  pat (m :R: Nat) (n :R: Nat).
    plus -R- (S -R- m) -R- n  =  S -R- (plus -R- m -R- n)

id :R: (_ :R: Nat) -> Nat
  id  =  (\x :R: Nat. x)

const :R: (x :R: Nat) -> (y :R: Nat) -> Nat
  = (\x :R: Nat. (\y :R: Nat. x))

main :R: Nat
  = 
    let apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = (\f :R: (_ :R: Nat) -> Nat. (\x :R: Nat. f -R- x))
    in 
      let Q :R: Nat
      in 
        let three :R: Nat = 3
        in plus -R- (apply -R- id -R- 2) -R- (apply -R- (const -R- Q) -R- three)

### Verification ###

Verification successful.

### Pruned ###

postulate Z

postulate S

  pat (n).
    plus Z n  =  n
  pat (m) (n).
    plus (S m) n  =  S (plus m n)

  id  =  (\x. x)

  = (\x. (\y. x))

  = 
    let apply = (\f. (\x. f x))
    in 
      let Q
      in 
        let three = 3
        in plus (apply id 2) (apply (const Q) three)

### Normal forms ###

unerased:
  S (S Q)
erased:
  S (S Q)
