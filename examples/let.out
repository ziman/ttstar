-- vim: ft=agda

### Desugared ###

  let
    postulate Nat : Type
    postulate Z : Nat
    postulate S : (_ :R: Nat) -> Nat
    plus : (n : Nat) -> (m : Nat) -> Nat = \(n : Nat) (m : Nat).
      case n of
        Z
          => m
        S (n' : Nat)
          => S (plus n' m)
    id : (x : Nat) -> Nat = (\x : Nat. x)
    const : (x : Nat) -> (y : Nat) -> Nat = (\x : Nat. (\y : Nat. x))
    main : Nat = 
      let apply : (f : (_ : Nat) -> Nat) -> (x : Nat) -> Nat = \(f : (_ : Nat) -> Nat) (x : Nat).
        case x of
          Z
            => f Z
          S (x' : Nat)
            => f (S x')
      in 
        let
          postulate Q : Nat
          three : Nat = 3
        in plus (apply id 2) (apply (const Q) three)
  in main

### Metaified ###

  let
    postulate Nat :1: Type
    postulate Z :2: Nat
    postulate S :3: (_ :R: Nat) -> Nat
    plus :4: (n :5: Nat) -> (m :6: Nat) -> Nat = \(n :7: Nat) (m :8: Nat).
      case -9- n of
        Z/10
          => m
        S/11 (n' :12: Nat)
          => S -13- (plus -15- n' -14- m)
    id :16: (x :17: Nat) -> Nat = (\x :18: Nat. x)
    const :19: (x :20: Nat) -> (y :21: Nat) -> Nat = (\x :22: Nat. (\y :23: Nat. x))
    main :24: Nat = 
      let apply :25: (f :26: (_ :27: Nat) -> Nat) -> (x :28: Nat) -> Nat = \(f :29: (_ :30: Nat) -> Nat) (x :31: Nat).
        case -32- x of
          Z/33
            => f -34- Z
          S/35 (x' :36: Nat)
            => f -37- (S -38- x')
      in 
        let
          postulate Q :39: Nat
          three :40: Nat = 3
        in plus -45- (apply -47- id -46- 2) -44- (apply -51- (const -52- Q) -50- three)
  in main

### Constraints ###

[] -> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,R]
[R] -> [24]

### Solution ###

[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,R]

### Annotated ###

  let
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (_ :R: Nat) -> Nat
    plus :R: (n :R: Nat) -> (m :R: Nat) -> Nat = \(n :R: Nat) (m :R: Nat).
      case -R- n of
        Z/R
          => m
        S/R (n' :R: Nat)
          => S -R- (plus -R- n' -R- m)
    id :R: (x :R: Nat) -> Nat = (\x :R: Nat. x)
    const :R: (x :R: Nat) -> (y :R: Nat) -> Nat = (\x :R: Nat. (\y :R: Nat. x))
    main :R: Nat = 
      let apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = \(f :R: (_ :R: Nat) -> Nat) (x :R: Nat).
        case -R- x of
          Z/R
            => f -R- Z
          S/R (x' :R: Nat)
            => f -R- (S -R- x')
      in 
        let
          postulate Q :R: Nat
          three :R: Nat = 3
        in plus -R- (apply -R- id -R- 2) -R- (apply -R- (const -R- Q) -R- three)
  in main

### Specialised ###

  let
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (_ :R: Nat) -> Nat
    plus :R: (n :R: Nat) -> (m :R: Nat) -> Nat = \(n :R: Nat) (m :R: Nat).
      case -R- n of
        Z/R
          => m
        S/R (n' :R: Nat)
          => S -R- (plus -R- n' -R- m)
    id :R: (x :R: Nat) -> Nat = (\x :R: Nat. x)
    const :R: (x :R: Nat) -> (y :R: Nat) -> Nat = (\x :R: Nat. (\y :R: Nat. x))
    main :R: Nat = 
      let apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = \(f :R: (_ :R: Nat) -> Nat) (x :R: Nat).
        case -R- x of
          Z/R
            => f -R- Z
          S/R (x' :R: Nat)
            => f -R- (S -R- x')
      in 
        let
          postulate Q :R: Nat
          three :R: Nat = 3
        in plus -R- (apply -R- id -R- 2) -R- (apply -R- (const -R- Q) -R- three)
  in main

### Final annotation ###

  let
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (_ :R: Nat) -> Nat
    plus :R: (n :R: Nat) -> (m :R: Nat) -> Nat = \(n :R: Nat) (m :R: Nat).
      case -R- n of
        Z/R
          => m
        S/R (n' :R: Nat)
          => S -R- (plus -R- n' -R- m)
    id :R: (x :R: Nat) -> Nat = (\x :R: Nat. x)
    const :R: (x :R: Nat) -> (y :R: Nat) -> Nat = (\x :R: Nat. (\y :R: Nat. x))
    main :R: Nat = 
      let apply :R: (f :R: (_ :R: Nat) -> Nat) -> (x :R: Nat) -> Nat = \(f :R: (_ :R: Nat) -> Nat) (x :R: Nat).
        case -R- x of
          Z/R
            => f -R- Z
          S/R (x' :R: Nat)
            => f -R- (S -R- x')
      in 
        let
          postulate Q :R: Nat
          three :R: Nat = 3
        in plus -R- (apply -R- id -R- 2) -R- (apply -R- (const -R- Q) -R- three)
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Z : Nat
    postulate S : (_) -> Nat
    plus = \n m.
      case n of
        Z
          => m
        S n'
          => S (plus n' m)
    id = (\x. x)
    const = (\x. (\y. x))
    main = 
      let apply = \f x.
        case x of
          Z
            => f Z
          S x'
            => f (S x')
      in 
        let
          postulate Q : Nat
          three = 3
        in plus (apply id 2) (apply (const Q) three)
  in main

### Normal forms ###

unerased:
  
  let
    postulate Nat : Type
    postulate S : (_ :R: Nat) -> Nat
  in 
    let postulate Q : Nat
    in S (S Q)

erased:
  
  let postulate S : (_) -> Nat
  in 
    let postulate Q : Nat
    in S (S Q)

