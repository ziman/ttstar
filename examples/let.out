-- vim: ft=agda

### Desugared ###

postulate Nat : Type

postulate Z : Nat

postulate S : (_ :R: Nat) -> Nat

plus : (n : Nat) -> (m : Nat) -> Nat = \(n : Nat) (m : Nat).
  case n of
    Z
      => m
    S (n' : Nat)
      => S (plus n' m)

id : (x : Nat) -> Nat = (\x : Nat. x)

const : (x : Nat) -> (y : Nat) -> Nat = (\x : Nat. (\y : Nat. x))

main :R: Nat = 
  let apply : (f : (_ : Nat) -> Nat) -> (x : Nat) -> Nat = \(f : (_ : Nat) -> Nat) (x : Nat).
    case x of
      Z
        => f Z
      S (x' : Nat)
        => f (S x')
  in 
    let postulate Q : Nat
    in 
      let three : Nat = 3
      in plus (apply id 2) (apply (const Q) three)

### Metaified ###

postulate Nat :1: Type

postulate Z :2: Nat

postulate S :3: (_ :R: Nat) -> Nat

plus :4: (n :5: Nat) -> (m :6: Nat) -> Nat = \(n :7: Nat) (m :8: Nat).
  case -9- n of
    Z
      => m
    S (n' :10: Nat)
      => S -11- (plus -13- n' -12- m)

id :14: (x :15: Nat) -> Nat = (\x :16: Nat. x)

const :17: (x :18: Nat) -> (y :19: Nat) -> Nat = (\x :20: Nat. (\y :21: Nat. x))

main :R: Nat = 
  let apply :22: (f :23: (_ :24: Nat) -> Nat) -> (x :25: Nat) -> Nat = \(f :26: (_ :27: Nat) -> Nat) (x :28: Nat).
    case -29- x of
      Z
        => f -30- Z
      S (x' :31: Nat)
        => f -32- (S -33- x')
  in 
    let postulate Q :34: Nat
    in 
      let three :35: Nat = 3
      in plus -40- (apply -42- id -41- 2) -39- (apply -46- (const -47- Q) -45- three)

### Inferred definitions ###

