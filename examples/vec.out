-- vim: ft=agda

### Desugared ###

postulate N : Type

postulate Z : N

postulate S : (x :R: N) -> N

postulate Vec : (_ : N) -> (_ : Type) -> Type

postulate Nil : (a : Type) -> Vec Z a

postulate Cons : (a : Type) -> (n : N) -> (x :R: a) -> (xs :R: Vec n a) -> Vec (S n) a

plus : (m : N) -> (n : N) -> N = \(m : N) (n : N).
  case m of
    Z
      => n
    S (m' : N)
      => S (plus m' n)

append : (a : Type) -> (m : N) -> (n : N) -> (xs : Vec m a) -> (ys : Vec n a) -> Vec (plus m n) a = \(a : Type) (m : N) (n : N) (xs : Vec m a) (ys : Vec n a).
  case xs of
    Nil (a' : Type)
      | a = a'
      | m = Z
      => ys
    Cons (a' : Type) (m' : N) (x : a') (xs' : Vec m' a')
      | a = a'
      | m = S m'
      => Cons a (plus m' n) x (append a m' n xs' ys)

main :R: Vec 1 N = append N Z 1 (Nil N) (Cons N Z 42 (Nil N))

### Metaified ###

postulate N :1: Type

postulate Z :2: N

postulate S :3: (x :R: N) -> N

postulate Vec :4: (_ :5: N) -> (_ :6: Type) -> Type

postulate Nil :7: (a :8: Type) -> Vec -10- Z -9- a

postulate Cons :11: (a :12: Type) -> (n :13: N) -> (x :R: a) -> (xs :R: Vec -15- n -14- a) -> Vec -17- (S -18- n) -16- a

plus :19: (m :20: N) -> (n :21: N) -> N = \(m :22: N) (n :23: N).
  case -24- m of
    Z
      => n
    S (m' :25: N)
      => S -26- (plus -28- m' -27- n)

append :29: (a :30: Type) -> (m :31: N) -> (n :32: N) -> (xs :33: Vec -35- m -34- a) -> (ys :36: Vec -38- n -37- a) -> Vec -40- (plus -42- m -41- n) -39- a = \(a :43: Type) (m :44: N) (n :45: N) (xs :46: Vec -48- m -47- a) (ys :49: Vec -51- n -50- a).
  case -52- xs of
    Nil (a' :53: Type)
      | a = a'
      | m = Z
      => ys
    Cons (a' :54: Type) (m' :55: N) (x :56: a') (xs' :57: Vec -59- m' -58- a')
      | a = a'
      | m = S -60- m'
      => Cons -64- a -63- (plus -66- m' -65- n) -62- x -61- (append -71- a -70- m' -69- n -68- xs' -67- ys)

main :R: Vec -73- 1 -72- N = append -79- N -78- Z -77- 1 -76- (Nil -81- N) -75- (Cons -85- N -84- Z -83- 42 -82- (Nil -128- N))

### Inferred definitions ###

postulate Cons :11: (a :12: Type) -> (n :13: N) -> (x :R: a) -> (xs :R: Vec -15- n -14- a) -> Vec -17- (S -18- n) -16- a {- constraints apply -}
  [] -> [11,R]

postulate N :1: Type {- constraints apply -}
  [] -> [1,R]

postulate Nil :7: (a :8: Type) -> Vec -10- Z -9- a {- constraints apply -}
  [] -> [7,R]

postulate S :3: (x :R: N) -> N {- constraints apply -}
  [] -> [3,R]

postulate Type :R: Type

postulate Vec :4: (_ :5: N) -> (_ :6: Type) -> Type {- constraints apply -}
  [] -> [4,R]

postulate Z :2: N {- constraints apply -}
  [] -> [2,R]

append :29: (a :30: Type) -> (m :31: N) -> (n :32: N) -> (xs :33: Vec -35- m -34- a) -> (ys :36: Vec -38- n -37- a) -> Vec -40- (plus -42- m -41- n) -39- a = \(a :43: Type) (m :44: N) (n :45: N) (xs :46: Vec -48- m -47- a) (ys :49: Vec -51- n -50- a).
  case -52- xs of
    Nil (a' :53: Type)
      | a = a'
      | m = Z
      => ys
    Cons (a' :54: Type) (m' :55: N) (x :56: a') (xs' :57: Vec -59- m' -58- a')
      | a = a'
      | m = S -60- m'
      => Cons -64- a -63- (plus -66- m' -65- n) -62- x -61- (append -71- a -70- m' -69- n -68- xs' -67- ys) {- constraints apply -}
  [] -> [3,8,11,12,13,18,19,20,21,22,23,24,25,26,27,28,29,32,33,36,41,42,45,46,49,52,53,54,55,56,57,60,61,62,63,64,65,66,67,68,69,R]
  [9] -> [34]
  [10] -> [35]
  [14] -> [39,58]
  [15] -> [40,59]
  [16] -> [34,39]
  [17] -> [35,40]
  [30] -> [43,71]
  [31] -> [44,70]
  [34] -> [9,16,58]
  [35] -> [10,17,59]
  [37] -> [50]
  [38] -> [51]
  [39] -> [14,16,50]
  [40] -> [15,17,51]
  [43] -> [30]
  [44] -> [31]
  [50] -> [37,39]
  [51] -> [38,40]
  [58] -> [14,34]
  [59] -> [15,35]
  [70] -> [31]
  [71] -> [30]

main :R: Vec -73- 1 -72- N = append -79- N -78- Z -77- 1 -76- (Nil -81- N) -75- (Cons -85- N -84- Z -83- 42 -82- (Nil -128- N)) {- constraints apply -}
  [] -> [1,2,3,7,8,11,12,13,18,19,20,21,22,23,24,25,26,27,28,29,32,33,36,41,42,45,46,49,52,53,54,55,56,57,60,61,62,63,64,65,66,67,68,69,74,75,76,77,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,R]
  [9] -> [14,34]
  [10] -> [15,35]
  [14] -> [9,39,58]
  [15] -> [10,40,59]
  [16] -> [34,37,39]
  [17] -> [35,38,40]
  [30] -> [43,71,79]
  [31] -> [44,70,78]
  [34] -> [9,16,58]
  [35] -> [10,17,59]
  [37] -> [16,50]
  [38] -> [17,51]
  [39] -> [14,16,50,72]
  [40] -> [15,17,51,73]
  [43] -> [30]
  [44] -> [31]
  [50] -> [37,39]
  [51] -> [38,40]
  [58] -> [14,34]
  [59] -> [15,35]
  [70] -> [31]
  [71] -> [30]
  [72] -> [39]
  [73] -> [40]
  [78] -> [31]
  [79] -> [30]

plus :19: (m :20: N) -> (n :21: N) -> N = \(m :22: N) (n :23: N).
  case -24- m of
    Z
      => n
    S (m' :25: N)
      => S -26- (plus -28- m' -27- n) {- constraints apply -}
  [] -> [3,19,20,21,22,23,24,25,26,27,28,R]


### Constraints ###

[] -> [1,2,3,7,8,11,12,13,18,19,20,21,22,23,24,25,26,27,28,29,32,33,36,41,42,45,46,49,52,53,54,55,56,57,60,61,62,63,64,65,66,67,68,69,74,75,76,77,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,R]
[9] -> [14,34]
[10] -> [15,35]
[14] -> [9,39,58]
[15] -> [10,40,59]
[16] -> [34,37,39]
[17] -> [35,38,40]
[30] -> [43,71,79]
[31] -> [44,70,78]
[34] -> [9,16,58]
[35] -> [10,17,59]
[37] -> [16,50]
[38] -> [17,51]
[39] -> [14,16,50,72]
[40] -> [15,17,51,73]
[43] -> [30]
[44] -> [31]
[50] -> [37,39]
[51] -> [38,40]
[58] -> [14,34]
[59] -> [15,35]
[70] -> [31]
[71] -> [30]
[72] -> [39]
[73] -> [40]
[78] -> [31]
[79] -> [30]

### Solution ###

[1,2,3,7,8,11,12,13,18,19,20,21,22,23,24,25,26,27,28,29,32,33,36,41,42,45,46,49,52,53,54,55,56,57,60,61,62,63,64,65,66,67,68,69,74,75,76,77,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,R]

### Annotated ###

postulate N :R: Type

postulate Z :R: N

postulate S :R: (x :R: N) -> N

postulate Vec :E: (_ :E: N) -> (_ :E: Type) -> Type

postulate Nil :R: (a :R: Type) -> Vec -E- Z -E- a

postulate Cons :R: (a :R: Type) -> (n :R: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -R- n) -E- a

plus :R: (m :R: N) -> (n :R: N) -> N = \(m :R: N) (n :R: N).
  case -R- m of
    Z
      => n
    S (m' :R: N)
      => S -R- (plus -R- m' -R- n)

append :R: (a :E: Type) -> (m :E: N) -> (n :R: N) -> (xs :R: Vec -E- m -E- a) -> (ys :R: Vec -E- n -E- a) -> Vec -E- (plus -R- m -R- n) -E- a = \(a :E: Type) (m :E: N) (n :R: N) (xs :R: Vec -E- m -E- a) (ys :R: Vec -E- n -E- a).
  case -R- xs of
    Nil (a' :R: Type)
      | a = a'
      | m = Z
      => ys
    Cons (a' :R: Type) (m' :R: N) (x :R: a') (xs' :R: Vec -E- m' -E- a')
      | a = a'
      | m = S -R- m'
      => Cons -R- a -R- (plus -R- m' -R- n) -R- x -R- (append -E- a -E- m' -R- n -R- xs' -R- ys)

main :R: Vec -E- 1 -E- N = append -E- N -E- Z -R- 1 -R- (Nil -R- N) -R- (Cons -R- N -R- Z -R- 42 -R- (Nil -R- N))

### Specialised ###

postulate N :R: Type

postulate Z :R: N

postulate S :R: (x :R: N) -> N

postulate Vec :E: (_ :E: N) -> (_ :E: Type) -> Type

postulate Nil :R: (a :R: Type) -> Vec -E- Z -E- a

postulate Cons :R: (a :R: Type) -> (n :R: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -R- n) -E- a

plus :R: (m :R: N) -> (n :R: N) -> N = \(m :R: N) (n :R: N).
  case -R- m of
    Z
      => n
    S (m' :R: N)
      => S -R- (plus -R- m' -R- n)

append :R: (a :E: Type) -> (m :E: N) -> (n :R: N) -> (xs :R: Vec -E- m -E- a) -> (ys :R: Vec -E- n -E- a) -> Vec -E- (plus -R- m -R- n) -E- a = \(a :E: Type) (m :E: N) (n :R: N) (xs :R: Vec -E- m -E- a) (ys :R: Vec -E- n -E- a).
  case -R- xs of
    Nil (a' :R: Type)
      | a = a'
      | m = Z
      => ys
    Cons (a' :R: Type) (m' :R: N) (x :R: a') (xs' :R: Vec -E- m' -E- a')
      | a = a'
      | m = S -R- m'
      => Cons -R- a -R- (plus -R- m' -R- n) -R- x -R- (append -E- a -E- m' -R- n -R- xs' -R- ys)

main :R: Vec -E- 1 -E- N = append -E- N -E- Z -R- 1 -R- (Nil -R- N) -R- (Cons -R- N -R- Z -R- 42 -R- (Nil -R- N))

### Final annotation ###

postulate N :R: Type

postulate Z :R: N

postulate S :R: (x :R: N) -> N

postulate Vec :E: (_ :E: N) -> (_ :E: Type) -> Type

postulate Nil :R: (a :R: Type) -> Vec -E- Z -E- a

postulate Cons :R: (a :R: Type) -> (n :R: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -R- n) -E- a

plus :R: (m :R: N) -> (n :R: N) -> N = \(m :R: N) (n :R: N).
  case -R- m of
    Z
      => n
    S (m' :R: N)
      => S -R- (plus -R- m' -R- n)

append :R: (a :E: Type) -> (m :E: N) -> (n :R: N) -> (xs :R: Vec -E- m -E- a) -> (ys :R: Vec -E- n -E- a) -> Vec -E- (plus -R- m -R- n) -E- a = \(a :E: Type) (m :E: N) (n :R: N) (xs :R: Vec -E- m -E- a) (ys :R: Vec -E- n -E- a).
  case -R- xs of
    Nil (a' :R: Type)
      | a = a'
      | m = Z
      => ys
    Cons (a' :R: Type) (m' :R: N) (x :R: a') (xs' :R: Vec -E- m' -E- a')
      | a = a'
      | m = S -R- m'
      => Cons -R- a -R- (plus -R- m' -R- n) -R- x -R- (append -E- a -E- m' -R- n -R- xs' -R- ys)

main :R: Vec -E- 1 -E- N = append -E- N -E- Z -R- 1 -R- (Nil -R- N) -R- (Cons -R- N -R- Z -R- 42 -R- (Nil -R- N))

### Verification ###

