-- vim: ft=idris

### Desugared ###

  let
    postulate N : Type
    postulate Z : N
    postulate S : (x :R: N) -> N
    postulate Vec : (_x0 : N) -> (_x1 : Type) -> Type
    postulate Nil : (a : Type) -> Vec Z a
    postulate Cons : (a : Type) -> (n : N) -> (x :R: a) -> (xs :R: Vec n a) -> Vec (S n) a
    plus : (m : N) -> (n : N) -> N = \(m : N) (n : N).
      case m of
        Z
          => n
        S (m' : N)
          => S (plus m' n)
    append : (a : Type) -> (m : N) -> (n : N) -> (xs : Vec m a) -> (ys : Vec n a) -> Vec (plus m n) a = \(a : Type) (m : N) (n : N) (xs : Vec m a) (ys : Vec n a).
      case xs of
        Nil (a' : Type)
          => case a of [a'] =>
            case m of [Z] =>
              ys
        Cons (a' : Type) (m' : N) (x : a') (xs' : Vec m' a')
          => case a' of [a] =>
            case m of [S m'] =>
              Cons a (plus m' n) x (append a m' n xs' ys)
    main : Vec 1 N = append N Z 1 (Nil N) (Cons N Z 4 (Nil N))
  in main

### Metaified ###

  let
    postulate N :1: Type
    postulate Z :2: N
    postulate S :3: (x :R: N) -> N
    postulate Vec :4: (_x0 :5: N) -> (_x1 :6: Type) -> Type
    postulate Nil :7: (a :8: Type) -> Vec -10- Z -9- a
    postulate Cons :11: (a :12: Type) -> (n :13: N) -> (x :R: a) -> (xs :R: Vec -15- n -14- a) -> Vec -17- (S -18- n) -16- a
    plus :19: (m :20: N) -> (n :21: N) -> N = \(m :22: N) (n :23: N).
      case -24- m of
        Z/25
          => n
        S/26 (m' :27: N)
          => S -28- (plus -30- m' -29- n)
    append :31: (a :32: Type) -> (m :33: N) -> (n :34: N) -> (xs :35: Vec -37- m -36- a) -> (ys :38: Vec -40- n -39- a) -> Vec -42- (plus -44- m -43- n) -41- a = \(a :45: Type) (m :46: N) (n :47: N) (xs :48: Vec -50- m -49- a) (ys :51: Vec -53- n -52- a).
      case -54- xs of
        Nil/55 (a' :56: Type)
          => case -57- a of [a'] =>
            case -58- m of [Z] =>
              ys
        Cons/59 (a' :60: Type) (m' :61: N) (x :62: a') (xs' :63: Vec -65- m' -64- a')
          => case -66- a' of [a] =>
            case -67- m of [S -68- m'] =>
              Cons -72- a -71- (plus -74- m' -73- n) -70- x -69- (append -79- a -78- m' -77- n -76- xs' -75- ys)
    main :80: Vec -82- 1 -81- N = append -88- N -87- Z -86- 1 -85- (Nil -90- N) -84- (Cons -94- N -93- Z -92- 4 -91- (Nil -99- N))
  in main

### Constraints ###

[] -> [2,3,7,11,31,35,38,48,51,54,55,59,62,63,69,70,75,76,84,85,91,92,95,96,97,98,R]
[8] -> [1,56,90,99]
[9] -> [14,36]
[10] -> [15,37]
[12] -> [1,45,60,72,94]
[13] -> [19,20,21,22,23,24,25,26,27,28,29,30,61,71,93]
[13,20] -> [61,74]
[13,21] -> [47,73]
[13,73] -> [21]
[13,74] -> [20]
[14] -> [9,41,64]
[15] -> [10,42,65]
[16] -> [36,39,41]
[17] -> [37,40,42]
[18] -> [28,68,89]
[28] -> [18]
[29] -> [73]
[30] -> [74]
[32] -> [1,45,79,88]
[33] -> [46,61,78,87]
[34] -> [47,77,86,89]
[36] -> [9,16,64]
[37] -> [10,17,65]
[39] -> [16,52]
[40] -> [17,53]
[41] -> [14,16,52,81]
[42] -> [15,17,53,82]
[43] -> [73]
[44] -> [74]
[45] -> [32]
[46] -> [33]
[47] -> [34]
[52] -> [39,41]
[53] -> [40,42]
[56] -> [8]
[57] -> [45]
[58] -> [46]
[60] -> [12]
[61] -> [13]
[64] -> [14,36]
[65] -> [15,37]
[66] -> [60]
[67] -> [46]
[68] -> [18]
[71] -> [13]
[72] -> [12]
[73] -> [29,43]
[74] -> [30,44]
[77] -> [34]
[78] -> [33]
[79] -> [32]
[81] -> [41]
[82] -> [42]
[83] -> [89]
[86] -> [34]
[87] -> [33]
[88] -> [32]
[89] -> [18,83]
[90] -> [8]
[93] -> [13]
[94] -> [12]
[99] -> [8]
[R] -> [80]

### Solution ###

[2,3,7,11,31,35,38,48,51,54,55,59,62,63,69,70,75,76,80,84,85,91,92,95,96,97,98,R]

### Annotated ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (x :R: N) -> N
    postulate Vec :E: (_x0 :E: N) -> (_x1 :E: Type) -> Type
    postulate Nil :R: (a :E: Type) -> Vec -E- Z -E- a
    postulate Cons :R: (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
    plus :E: (m :E: N) -> (n :E: N) -> N = \(m :E: N) (n :E: N).
      case -E- m of
        Z/E
          => n
        S/E (m' :E: N)
          => S -E- (plus -E- m' -E- n)
    append :R: (a :E: Type) -> (m :E: N) -> (n :E: N) -> (xs :R: Vec -E- m -E- a) -> (ys :R: Vec -E- n -E- a) -> Vec -E- (plus -E- m -E- n) -E- a = \(a :E: Type) (m :E: N) (n :E: N) (xs :R: Vec -E- m -E- a) (ys :R: Vec -E- n -E- a).
      case -R- xs of
        Nil/R (a' :E: Type)
          => case -E- a of [a'] =>
            case -E- m of [Z] =>
              ys
        Cons/R (a' :E: Type) (m' :E: N) (x :R: a') (xs' :R: Vec -E- m' -E- a')
          => case -E- a' of [a] =>
            case -E- m of [S -E- m'] =>
              Cons -E- a -E- (plus -E- m' -E- n) -R- x -R- (append -E- a -E- m' -E- n -R- xs' -R- ys)
    main :R: Vec -E- 1 -E- N = append -E- N -E- Z -E- 1 -R- (Nil -E- N) -R- (Cons -E- N -E- Z -R- 4 -R- (Nil -E- N))
  in main

### Specialised ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (x :R: N) -> N
    postulate Vec :E: (_x0 :E: N) -> (_x1 :E: Type) -> Type
    postulate Nil :R: (a :E: Type) -> Vec -E- Z -E- a
    postulate Cons :R: (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
    plus :E: (m :E: N) -> (n :E: N) -> N = \(m :E: N) (n :E: N).
      case -E- m of
        Z/E
          => n
        S/E (m' :E: N)
          => S -E- (plus -E- m' -E- n)
    append :R: (a :E: Type) -> (m :E: N) -> (n :E: N) -> (xs :R: Vec -E- m -E- a) -> (ys :R: Vec -E- n -E- a) -> Vec -E- (plus -E- m -E- n) -E- a = \(a :E: Type) (m :E: N) (n :E: N) (xs :R: Vec -E- m -E- a) (ys :R: Vec -E- n -E- a).
      case -R- xs of
        Nil/R (a' :E: Type)
          => case -E- a of [a'] =>
            case -E- m of [Z] =>
              ys
        Cons/R (a' :E: Type) (m' :E: N) (x :R: a') (xs' :R: Vec -E- m' -E- a')
          => case -E- a' of [a] =>
            case -E- m of [S -E- m'] =>
              Cons -E- a -E- (plus -E- m' -E- n) -R- x -R- (append -E- a -E- m' -E- n -R- xs' -R- ys)
    main :R: Vec -E- 1 -E- N = append -E- N -E- Z -E- 1 -R- (Nil -E- N) -R- (Cons -E- N -E- Z -R- 4 -R- (Nil -E- N))
  in main

### Final annotation ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (x :R: N) -> N
    postulate Vec :E: (_x0 :E: N) -> (_x1 :E: Type) -> Type
    postulate Nil :R: (a :E: Type) -> Vec -E- Z -E- a
    postulate Cons :R: (a :E: Type) -> (n :E: N) -> (x :R: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
    plus :E: (m :E: N) -> (n :E: N) -> N = \(m :E: N) (n :E: N).
      case -E- m of
        Z/E
          => n
        S/E (m' :E: N)
          => S -E- (plus -E- m' -E- n)
    append :R: (a :E: Type) -> (m :E: N) -> (n :E: N) -> (xs :R: Vec -E- m -E- a) -> (ys :R: Vec -E- n -E- a) -> Vec -E- (plus -E- m -E- n) -E- a = \(a :E: Type) (m :E: N) (n :E: N) (xs :R: Vec -E- m -E- a) (ys :R: Vec -E- n -E- a).
      case -R- xs of
        Nil/R (a' :E: Type)
          => case -E- a of [a'] =>
            case -E- m of [Z] =>
              ys
        Cons/R (a' :E: Type) (m' :E: N) (x :R: a') (xs' :R: Vec -E- m' -E- a')
          => case -E- a' of [a] =>
            case -E- m of [S -E- m'] =>
              Cons -E- a -E- (plus -E- m' -E- n) -R- x -R- (append -E- a -E- m' -E- n -R- xs' -R- ys)
    main :R: Vec -E- 1 -E- N = append -E- N -E- Z -E- 1 -R- (Nil -E- N) -R- (Cons -E- N -E- Z -R- 4 -R- (Nil -E- N))
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Z : N
    postulate S : (x) -> N
    postulate Nil : Vec
    postulate Cons : (x) -> (xs) -> Vec
    append = \xs ys.
      case xs of
        Nil
          => ys
        Cons x xs'
          => Cons x (append xs' ys)
    main = append Nil (Cons 4 Nil)
  in main

### Normal forms ###

unerased:
  
  let
    postulate N : Type
    postulate Z : N
    postulate S : (x :R: N) -> N
    postulate Nil : (a : Type) -> Vec Z a
    postulate Cons : (a : Type) -> (n : N) -> (x :R: a) -> (xs :R: Vec n a) -> Vec (S n) a
  in Cons N Z 4 (Nil N)

erased:
  
  let
    postulate Z : N
    postulate S : (x) -> N
    postulate Nil : Vec
    postulate Cons : (x) -> (xs) -> Vec
  in Cons 4 Nil

