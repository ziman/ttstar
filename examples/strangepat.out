-- vim: ft=agda

### Desugared ###

  let
    postulate Bool : Type
    postulate T : Bool
    postulate F : Bool
    postulate Pair : Type
    postulate P : (_ : Bool) -> (_ : Bool) -> Pair
    fst : (x : (_ : Bool) -> Pair) -> Bool = \(x : (_ : Bool) -> Pair).
      case x of
        P (y : Bool)
          => y
    main : Bool = fst (P T)
  in main

### Metaified ###

  let
    postulate Bool :1: Type
    postulate T :2: Bool
    postulate F :3: Bool
    postulate Pair :4: Type
    postulate P :5: (_ :6: Bool) -> (_ :7: Bool) -> Pair
    fst :8: (x :9: (_ :10: Bool) -> Pair) -> Bool = \(x :11: (_ :12: Bool) -> Pair).
      case -13- x of
        P/14 (y :15: Bool)
          => y
    main :16: Bool = fst -17- (P -18- T)
  in main

### Constraints ###

[] -> [2,5,6,8,9,11,13,14,15,17,18,R]
[7] -> [10]
[10] -> [7]
[R] -> [16]

### Solution ###

[2,5,6,8,9,11,13,14,15,16,17,18,R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :E: Bool
    postulate Pair :E: Type
    postulate P :R: (_ :R: Bool) -> (_ :E: Bool) -> Pair
    fst :R: (x :R: (_ :E: Bool) -> Pair) -> Bool = \(x :R: (_ :E: Bool) -> Pair).
      case -R- x of
        P/R (y :R: Bool)
          => y
    main :R: Bool = fst -R- (P -R- T)
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :E: Bool
    postulate Pair :E: Type
    postulate P :R: (_ :R: Bool) -> (_ :E: Bool) -> Pair
    fst :R: (x :R: (_ :E: Bool) -> Pair) -> Bool = \(x :R: (_ :E: Bool) -> Pair).
      case -R- x of
        P/R (y :R: Bool)
          => y
    main :R: Bool = fst -R- (P -R- T)
  in main

### Constraints ###

[E] -> [E]
[R] -> [R]

### Solution ###

[R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :E: Bool
    postulate Pair :E: Type
    postulate P :R: (_ :R: Bool) -> (_ :E: Bool) -> Pair
    fst :R: (x :R: (_ :E: Bool) -> Pair) -> Bool = \(x :R: (_ :E: Bool) -> Pair).
      case -R- x of
        P/R (y :R: Bool)
          => y
    main :R: Bool = fst -R- (P -R- T)
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :E: Bool
    postulate Pair :E: Type
    postulate P :R: (_ :R: Bool) -> (_ :E: Bool) -> Pair
    fst :R: (x :R: (_ :E: Bool) -> Pair) -> Bool = \(x :R: (_ :E: Bool) -> Pair).
      case -R- x of
        P/R (y :R: Bool)
          => y
    main :R: Bool = fst -R- (P -R- T)
  in main

### Final annotation ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :E: Bool
    postulate Pair :E: Type
    postulate P :R: (_ :R: Bool) -> (_ :E: Bool) -> Pair
    fst :R: (x :R: (_ :E: Bool) -> Pair) -> Bool = \(x :R: (_ :E: Bool) -> Pair).
      case -R- x of
        P/R (y :R: Bool)
          => y
    main :R: Bool = fst -R- (P -R- T)
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate T : Bool
    postulate P : (_) -> Pair
    fst = \x.
      case x of
        P y
          => y
    main = fst (P T)
  in main

### Normal forms ###

unerased:
  
  let postulate T : Bool
  in T

erased:
  
  let postulate T : Bool
  in T

