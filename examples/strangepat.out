-- vim: ft=agda

### Desugared ###

postulate Bool : Type

postulate T : Bool

postulate F : Bool

postulate Pair : Type

postulate P : (_ : Bool) -> (_ : Bool) -> Pair

fst : (x : (_ : Bool) -> Pair) -> Bool = \(x : (_ : Bool) -> Pair).
  case x of
    P (y : Bool)
      => y

main :R: Bool = fst (P T)

### Metaified ###

postulate Bool :1: Type

postulate T :2: Bool

postulate F :3: Bool

postulate Pair :4: Type

postulate P :5: (_ :6: Bool) -> (_ :7: Bool) -> Pair

fst :8: (x :9: (_ :10: Bool) -> Pair) -> Bool = \(x :11: (_ :12: Bool) -> Pair).
  case -13- x of
    P/14 (y :15: Bool)
      => y

main :R: Bool = fst -16- (P -17- T)

### Inferred definitions ###

postulate Bool :1: Type {- constraints apply -}
  [] -> [1,R]

postulate F :3: Bool {- constraints apply -}
  [] -> [3,R]

postulate P :5: (_ :6: Bool) -> (_ :7: Bool) -> Pair {- constraints apply -}
  [] -> [5,R]

postulate Pair :4: Type {- constraints apply -}
  [] -> [4,R]

postulate T :2: Bool {- constraints apply -}
  [] -> [2,R]

postulate Type :E: Type

fst :8: (x :9: (_ :10: Bool) -> Pair) -> Bool = \(x :11: (_ :12: Bool) -> Pair).
  case -13- x of
    P/14 (y :15: Bool)
      => y {- constraints apply -}
  [] -> [6,8,9,11,13,15,R]
  [5] -> [14]
  [7] -> [10]
  [10] -> [7]
  [14] -> [5]

main :R: Bool = fst -16- (P -17- T) {- constraints apply -}
  [] -> [2,5,6,8,9,11,13,14,15,16,17,R]
  [7] -> [10]
  [10] -> [7]


### Constraints ###

[] -> [2,5,6,8,9,11,13,14,15,16,17,R]
[7] -> [10]
[10] -> [7]

### Solution ###

[2,5,6,8,9,11,13,14,15,16,17,R]

### Annotated ###

postulate Bool :E: Type

postulate T :R: Bool

postulate F :E: Bool

postulate Pair :E: Type

postulate P :R: (_ :R: Bool) -> (_ :E: Bool) -> Pair

fst :R: (x :R: (_ :E: Bool) -> Pair) -> Bool = \(x :R: (_ :E: Bool) -> Pair).
  case -R- x of
    P/R (y :R: Bool)
      => y

main :R: Bool = fst -R- (P -R- T)

### Specialised ###

postulate Bool :E: Type

postulate T :R: Bool

postulate F :E: Bool

postulate Pair :E: Type

postulate P :R: (_ :R: Bool) -> (_ :E: Bool) -> Pair

fst :R: (x :R: (_ :E: Bool) -> Pair) -> Bool = \(x :R: (_ :E: Bool) -> Pair).
  case -R- x of
    P/R (y :R: Bool)
      => y

main :R: Bool = fst -R- (P -R- T)

### Final annotation ###

postulate Bool :E: Type

postulate T :R: Bool

postulate F :E: Bool

postulate Pair :E: Type

postulate P :R: (_ :R: Bool) -> (_ :E: Bool) -> Pair

fst :R: (x :R: (_ :E: Bool) -> Pair) -> Bool = \(x :R: (_ :E: Bool) -> Pair).
  case -R- x of
    P/R (y :R: Bool)
      => y

main :R: Bool = fst -R- (P -R- T)

### Verification ###

Verification successful.

### Pruned ###

postulate T : Bool

postulate P : (_) -> Pair

fst = \x.
  case x of
    P y
      => y

main = fst (P T)

### Normal forms ###

unerased:
  T
erased:
  T
