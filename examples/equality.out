-- vim: ft=idris

### Desugared ###

  let
    postulate Bool : Type
    postulate T : Bool
    postulate F : Bool
    postulate Id : (a : Type) -> (x : a) -> (y : a) -> Type
    postulate Refl : (a : Type) -> (x : a) -> Id a x x
    not : (x : Bool) -> Bool = \(x : Bool).
      case x of
        T =>
          F
        F =>
          T
    notnot : (x : Bool) -> Id Bool x (not (not x)) = \(x : Bool).
      case x of
        T =>
          Refl Bool T
        F =>
          Refl Bool F
    main : Id Bool F (not (not F)) = notnot F
  in main

### Metaified ###

  let
    postulate Bool :1: Type
    postulate T :2: Bool
    postulate F :3: Bool
    postulate Id :4: (a :5: Type) -> (x :6: a) -> (y :7: a) -> Type
    postulate Refl :8: (a :9: Type) -> (x :10: a) -> Id -13- a -12- x -11- x
    not :14: (x :15: Bool) -> Bool = \(x :16: Bool).
      case -17- x of
        T/18 =>
          F
        F/19 =>
          T
    notnot :20: (x :21: Bool) -> Id -24- Bool -23- x -22- (not -25- (not -26- x)) = \(x :27: Bool).
      case -28- x of
        T/29 =>
          Refl -31- Bool -30- T
        F/32 =>
          Refl -34- Bool -33- F
    main :35: Id -38- Bool -37- F -36- (not -39- (not -40- F)) = notnot -41- F
  in main

### Constraints ###

[] -> [3,8,20,21,27,28,32,41,R]
[2] -> [29]
[9] -> [1,31,34]
[10] -> [2,30,33]
[11] -> [22]
[12] -> [23]
[13] -> [24]
[22] -> [11,36]
[23] -> [12,37]
[24] -> [13,38]
[29] -> [2]
[30] -> [10]
[31] -> [9]
[33] -> [10]
[34] -> [9]
[36] -> [22]
[37] -> [23]
[38] -> [24]
[R] -> [35]

### Solution ###

[3,8,20,21,27,28,32,35,41,R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate T :E: Bool
    postulate F :R: Bool
    postulate Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    postulate Refl :R: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    not :E: (x :E: Bool) -> Bool = \(x :E: Bool).
      case -E- x of
        T/E =>
          F
        F/E =>
          T
    notnot :R: (x :R: Bool) -> Id -E- Bool -E- x -E- (not -E- (not -E- x)) = \(x :R: Bool).
      case -R- x of
        T/E =>
          Refl -E- Bool -E- T
        F/R =>
          Refl -E- Bool -E- F
    main :R: Id -E- Bool -E- F -E- (not -E- (not -E- F)) = notnot -R- F
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate T :E: Bool
    postulate F :R: Bool
    postulate Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    postulate Refl :R: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    not :E: (x :E: Bool) -> Bool = \(x :E: Bool).
      case -E- x of
        T/E =>
          F
        F/E =>
          T
    notnot :R: (x :R: Bool) -> Id -E- Bool -E- x -E- (not -E- (not -E- x)) = \(x :R: Bool).
      case -R- x of
        T/E =>
          Refl -E- Bool -E- T
        F/R =>
          Refl -E- Bool -E- F
    main :R: Id -E- Bool -E- F -E- (not -E- (not -E- F)) = notnot -R- F
  in main

### Final annotation ###

  let
    postulate Bool :E: Type
    postulate T :E: Bool
    postulate F :R: Bool
    postulate Id :E: (a :E: Type) -> (x :E: a) -> (y :E: a) -> Type
    postulate Refl :R: (a :E: Type) -> (x :E: a) -> Id -E- a -E- x -E- x
    not :E: (x :E: Bool) -> Bool = \(x :E: Bool).
      case -E- x of
        T/E =>
          F
        F/E =>
          T
    notnot :R: (x :R: Bool) -> Id -E- Bool -E- x -E- (not -E- (not -E- x)) = \(x :R: Bool).
      case -R- x of
        T/E =>
          Refl -E- Bool -E- T
        F/R =>
          Refl -E- Bool -E- F
    main :R: Id -E- Bool -E- F -E- (not -E- (not -E- F)) = notnot -R- F
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate F : Bool
    postulate Refl : Id
    notnot = \x.
      case x of
        F =>
          Refl
    main = notnot F
  in main

### Normal forms ###

unerased:
  
  let
    postulate Bool : Type
    postulate F : Bool
    postulate Refl : (a : Type) -> (x : a) -> Id a x x
  in Refl Bool F

erased:
  
  let postulate Refl : Id
  in Refl

