-- vim: ft=idris

### Desugared ###

  let
    postulate N : Type
    postulate Z : N
    postulate S : (x :R: N) -> N
    postulate Vec : (_x0 : N) -> (_x1 : Type) -> Type
    postulate Nil : (a : Type) -> Vec Z a
    postulate Cons : (a : Type) -> (n : N) -> (x : a) -> (xs : Vec n a) -> Vec (S n) a
    vlen : (n : N) -> (xs : Vec n N) -> N = \(n : N) (xs : Vec n N).
      case xs of
        Nil (a : Type)
          | a = N
          | n = Z
          => n
        Cons (a : Type) (m : N) (y : N) (ys : Vec m N)
          | a = N
          | n = S m
          => S (vlen m ys)
    main : N = vlen 1 (Cons N Z 3 (Nil N))
  in main

### Metaified ###

  let
    postulate N :1: Type
    postulate Z :2: N
    postulate S :3: (x :R: N) -> N
    postulate Vec :4: (_x0 :5: N) -> (_x1 :6: Type) -> Type
    postulate Nil :7: (a :8: Type) -> Vec -10- Z -9- a
    postulate Cons :11: (a :12: Type) -> (n :13: N) -> (x :14: a) -> (xs :15: Vec -17- n -16- a) -> Vec -19- (S -20- n) -18- a
    vlen :21: (n :22: N) -> (xs :23: Vec -25- n -24- N) -> N = \(n :26: N) (xs :27: Vec -29- n -28- N).
      case -30- xs of
        Nil/31 (a :32: Type)
          | a = N
          | n = Z
          => n
        Cons/33 (a :34: Type) (m :35: N) (y :36: N) (ys :37: Vec -39- m -38- N)
          | a = N
          | n = S -40- m
          => S -41- (vlen -43- m -42- ys)
    main :44: N = vlen -46- 1 -45- (Cons -51- N -50- Z -49- 3 -48- (Nil -55- N))
  in main

### Constraints ###

[] -> [2,3,7,11,13,15,20,21,22,23,26,27,30,31,33,35,37,40,41,42,43,45,46,47,48,50,R]
[8] -> [1,32,55]
[9] -> [16,24]
[10] -> [17,25]
[12] -> [1,34,51]
[14] -> [36,49,52,53,54]
[16] -> [9,38]
[17] -> [10,39]
[18] -> [24]
[19] -> [25]
[24] -> [9,18,38]
[25] -> [10,19,39]
[32] -> [8]
[34] -> [12]
[36] -> [14]
[38] -> [16,24]
[39] -> [17,25]
[49] -> [14]
[51] -> [12]
[55] -> [8]
[R] -> [44]

### Solution ###

[2,3,7,11,13,15,20,21,22,23,26,27,30,31,33,35,37,40,41,42,43,44,45,46,47,48,50,R]

### Annotated ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (x :R: N) -> N
    postulate Vec :E: (_x0 :E: N) -> (_x1 :E: Type) -> Type
    postulate Nil :R: (a :E: Type) -> Vec -E- Z -E- a
    postulate Cons :R: (a :E: Type) -> (n :R: N) -> (x :E: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -R- n) -E- a
    vlen :R: (n :R: N) -> (xs :R: Vec -E- n -E- N) -> N = \(n :R: N) (xs :R: Vec -E- n -E- N).
      case -R- xs of
        Nil/R (a :E: Type)
          | a = N
          | n = Z
          => n
        Cons/R (a :E: Type) (m :R: N) (y :E: N) (ys :R: Vec -E- m -E- N)
          | a = N
          | n = S -R- m
          => S -R- (vlen -R- m -R- ys)
    main :R: N = vlen -R- 1 -R- (Cons -E- N -R- Z -E- 3 -R- (Nil -E- N))
  in main

### Specialised ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (x :R: N) -> N
    postulate Vec :E: (_x0 :E: N) -> (_x1 :E: Type) -> Type
    postulate Nil :R: (a :E: Type) -> Vec -E- Z -E- a
    postulate Cons :R: (a :E: Type) -> (n :R: N) -> (x :E: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -R- n) -E- a
    vlen :R: (n :R: N) -> (xs :R: Vec -E- n -E- N) -> N = \(n :R: N) (xs :R: Vec -E- n -E- N).
      case -R- xs of
        Nil/R (a :E: Type)
          | a = N
          | n = Z
          => n
        Cons/R (a :E: Type) (m :R: N) (y :E: N) (ys :R: Vec -E- m -E- N)
          | a = N
          | n = S -R- m
          => S -R- (vlen -R- m -R- ys)
    main :R: N = vlen -R- 1 -R- (Cons -E- N -R- Z -E- 3 -R- (Nil -E- N))
  in main

### Final annotation ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (x :R: N) -> N
    postulate Vec :E: (_x0 :E: N) -> (_x1 :E: Type) -> Type
    postulate Nil :R: (a :E: Type) -> Vec -E- Z -E- a
    postulate Cons :R: (a :E: Type) -> (n :R: N) -> (x :E: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -R- n) -E- a
    vlen :R: (n :R: N) -> (xs :R: Vec -E- n -E- N) -> N = \(n :R: N) (xs :R: Vec -E- n -E- N).
      case -R- xs of
        Nil/R (a :E: Type)
          | a = N
          | n = Z
          => n
        Cons/R (a :E: Type) (m :R: N) (y :E: N) (ys :R: Vec -E- m -E- N)
          | a = N
          | n = S -R- m
          => S -R- (vlen -R- m -R- ys)
    main :R: N = vlen -R- 1 -R- (Cons -E- N -R- Z -E- 3 -R- (Nil -E- N))
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Z : N
    postulate S : (x) -> N
    postulate Nil : Vec
    postulate Cons : (n) -> (xs) -> Vec
    vlen = \n xs.
      case xs of
        Nil
          => n
        Cons m ys
          => S (vlen m ys)
    main = vlen 1 (Cons Z Nil)
  in main

### Normal forms ###

unerased:
  
  let
    postulate Z : N
    postulate S : (x :R: N) -> N
  in 1

erased:
  
  let
    postulate Z : N
    postulate S : (x) -> N
  in 1

