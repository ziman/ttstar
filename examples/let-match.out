-- vim: ft=agda

### Desugared ###

  let
    postulate Bool : Type
    postulate T : Bool
    postulate F : Bool
    main : Bool = 
      let not : (x : Bool) -> Bool = \(x : Bool).
        case x of
          T
            => F
          F
            => T
      in not F
  in main

### Metaified ###

  let
    postulate Bool :1: Type
    postulate T :2: Bool
    postulate F :3: Bool
    main :4: Bool = 
      let not :6: (x :7: Bool) -> Bool = \(x :8: Bool).
        case -9- x of
          T/10
            => F
          F/11
            => T
      in not -5- F
  in main

### Constraints ###

[] -> [2,3,5,6,7,8,9,10,11,R]
[R] -> [4]

### Solution ###

[2,3,4,5,6,7,8,9,10,11,R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    main :R: Bool = 
      let not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
        case -R- x of
          T/R
            => F
          F/R
            => T
      in not -R- F
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    main :R: Bool = 
      let not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
        case -R- x of
          T/R
            => F
          F/R
            => T
      in not -R- F
  in main

### Constraints ###

[R] -> [R]

### Solution ###

[R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    main :R: Bool = 
      let not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
        case -R- x of
          T/R
            => F
          F/R
            => T
      in not -R- F
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    main :R: Bool = 
      let not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
        case -R- x of
          T/R
            => F
          F/R
            => T
      in not -R- F
  in main

### Final annotation ###

  let
    postulate Bool :E: Type
    postulate T :R: Bool
    postulate F :R: Bool
    main :R: Bool = 
      let not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
        case -R- x of
          T/R
            => F
          F/R
            => T
      in not -R- F
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate T : Bool
    postulate F : Bool
    main = 
      let not = \x.
        case x of
          T
            => F
          F
            => T
      in not F
  in main

### Normal forms ###

unerased:
  
  let postulate T : Bool
  in T

erased:
  
  let postulate T : Bool
  in T

