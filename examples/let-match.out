-- vim: ft=agda

### Desugared ###

postulate Bool : Type

postulate T : Bool

postulate F : Bool

main :R: Bool = 
  let not : (x : Bool) -> Bool = \(x : Bool).
    case x of
      T
        => F
      F
        => T
  in not F

### Metaified ###

postulate Bool :1: Type

postulate T :2: Bool

postulate F :3: Bool

main :R: Bool = 
  let not :5: (x :6: Bool) -> Bool = \(x :7: Bool).
    case -8- x of
      T/9
        => F
      F/10
        => T
  in not -4- F

### Inferred definitions ###

postulate Bool :1: Type

postulate F :3: Bool

postulate T :2: Bool

postulate Type :E: Type

main :R: Bool = 
  let not :5: (x :6: Bool) -> Bool = \(x :7: Bool).
    case -8- x of
      T/9
        => F
      F/10
        => T
  in not -4- F {- constraints apply -}
  [] -> [2,3,4,5,6,7,8,9,10,R]


### Constraints ###

[] -> [2,3,4,5,6,7,8,9,10,R]

### Solution ###

[2,3,4,5,6,7,8,9,10,R]

### Annotated ###

postulate Bool :E: Type

postulate T :R: Bool

postulate F :R: Bool

main :R: Bool = 
  let not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
    case -R- x of
      T/R
        => F
      F/R
        => T
  in not -R- F

### Specialised ###

postulate Bool :E: Type

postulate T :R: Bool

postulate F :R: Bool

main :R: Bool = 
  let not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
    case -R- x of
      T/R
        => F
      F/R
        => T
  in not -R- F

### Final annotation ###

postulate Bool :E: Type

postulate T :R: Bool

postulate F :R: Bool

main :R: Bool = 
  let not :R: (x :R: Bool) -> Bool = \(x :R: Bool).
    case -R- x of
      T/R
        => F
      F/R
        => T
  in not -R- F

### Verification ###

Verification successful.

### Pruned ###

postulate T : Bool

postulate F : Bool

main = 
  let not = \x.
    case x of
      T
        => F
      F
        => T
  in not F

### Normal forms ###

unerased:
  
  let postulate Bool : Type
  in 
    let postulate T : Bool
    in T
erased:
  
  let postulate T : Bool
  in T
