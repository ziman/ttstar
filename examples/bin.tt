-- vim: ft=idris

import "../stdlib/prelude.tt"
import "../stdlib/equality.tt"

data Bit : Nat -> Type where
  I : Bit 1,
  O : Bit 0.

double : Nat -> Nat.
  double Z = Z,
  (n : Nat)
    double (S n) = S (S (double n)).

data Bin : (width : Nat) -> (value : Nat) -> Type where
  N : Bin Z Z,
  C : (width : Nat)
    -> (lsbVal : Nat) -> (lsb : Bit lsbVal)
    -> (restVal : Nat) -> (rest :R: Bin width restVal)
    -> Bin (S width) (plus lsbVal (double restVal)).

-- TwoBits is a pair of bits (highBit, lowBit)
-- which is provably equivalent to the sum (c + x + y).
-- However, c, x, and y live on the type level,
-- while only lowBit and highBit are meant to be relevant.
data TwoBits : Nat -> Nat -> Nat -> Type where
  TB :
    (c : Nat) -> (x : Nat) -> (y : Nat)
    -> (hi' : Nat) -> (hi : Bit hi')
    -> (lo' : Nat) -> (lo : Bit lo')
    -> (pf : Id Nat (plus c (plus x y)) (plus lo' (double hi')))
    -> TwoBits c x y.

adb : (c : Nat) -> (x : Nat) -> (y : Nat)
    -> Bit c -> Bit x -> Bit y -> TwoBits c x y.
adb [0] [0] [0] O O O = TB  0 0 0  0 O 0 O  (Refl Nat 0),
adb [1] [0] [0] I O O = TB  1 0 0  0 O 1 I  (Refl Nat 1),
adb [0] [1] [0] O I O = TB  0 1 0  0 O 1 I  (Refl Nat 1),
adb [0] [0] [1] O O I = TB  0 0 1  0 O 1 I  (Refl Nat 1),
adb [1] [1] [0] I I O = TB  1 1 0  1 I 0 O  (Refl Nat 2),
adb [1] [0] [1] I O I = TB  1 0 1  1 I 0 O  (Refl Nat 2),
adb [0] [1] [1] O I I = TB  0 1 1  1 I 0 O  (Refl Nat 2),
adb [1] [1] [1] I I I = TB  1 1 1  1 I 1 I  (Refl Nat 3).

add' : (w : Nat)
    -> (c : Nat) -> (x : Nat) -> (y : Nat)
    -> Bit c  -> Bin w x -> Bin w y
    -> Bin (S w) (plus c (plus x y)).

  (c : Nat) (cb : Bit c)
    add' [Z] c [Z] [Z] cb N N = C Z c cb Z N,

  (w : Nat)
  (c : Nat) (cb : Bit c)
  (xb' : Nat) (xb : Bit xb')
  (xn' : Nat) (xn : Bin w xn')
  (yb' : Nat) (yb : Bit yb')
  (yn' : Nat) (yn : Bin w yn')
    add' ([S] w) c [plus xb' (double xn')] [plus yb' (double yn')] cb
      (C [w] xb' xb xn' xn) (C [w] yb' yb yn' yn)
        = case adb c xb' yb' cb xb yb with
            f : (TwoBits c xb' yb')
              -> Bin (S (S w)) (plus c (plus (plus xb' (double xn')) (plus yb' (double yn')))).
            (hi' : Nat) (hi : Bit hi')
            (lo' : Nat) (lo : Bit lo')
            (pf : Id Nat (plus c (plus xb' yb')) (plus lo' (double hi')))
              f (TB [c] [xb'] [yb'] hi' hi lo' lo pf)
                = let
                    -- cheat our way out of the boring proof stuff
                    -- this should be normally proven as a consequence of `pf`
                    postulate eq : Id Nat
                      (plus lo' (double (plus hi' (plus xn' yn'))))
                      (plus c (plus (plus xb' (double xn')) (plus yb' (double yn'))))
                  in
                    subst Nat
                      (Bin (S (S w)))
                      (plus lo' (double (plus hi' (plus xn' yn'))))
                      (plus c (plus (plus xb' (double xn')) (plus yb' (double yn'))))
                      eq
                      (C (S w) lo' lo (plus hi' (plus xn' yn')) (add' w hi' xn' yn' hi xn yn))..

add \(w : Nat) (x : Nat) (y : Nat) (bx : Bin w x) (by : Bin w y) : Bin (S w) (plus x y)
  = add' w Z x y O bx by.

foreign inputSize : Nat = "(rts-arg-peano 'Z 'S 0)".

binVal : Bool -> Nat -> Nat.
  (b : Bool)
    binVal b Z = Z,
  (n : Nat)
    binVal True (S n) = S (double (binVal False n)),
  (n : Nat)
    binVal False (S n) = double (binVal True n).

mkBin : (b : Bool) -> (w : Nat) -> Bin w (binVal b w).
  (b : Bool)
    mkBin b Z = N,
  (n : Nat)
    mkBin True (S n) = C n 1 I (binVal False n) (mkBin False n),
  (n : Nat)
    mkBin False (S n) = C n 0 O (binVal True n) (mkBin True n).

main \: Bin (S inputSize) (plus (binVal True inputSize) (binVal False inputSize))
  = let
      x \: Bin inputSize (binVal True inputSize) = mkBin True inputSize,
      y \: Bin inputSize (binVal False inputSize) = mkBin False inputSize
    in
      add inputSize (binVal True inputSize) (binVal False inputSize) x y.
