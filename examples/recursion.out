-- vim: ft=agda

### Desugared ###

postulate Bool : Type

postulate True : Bool

postulate False : Bool

postulate Nat : Type

postulate Z : Nat

postulate S : (n :R: Nat) -> Nat

postulate Vec : (_ : Nat) -> (_ : Type) -> Type

postulate VNil : (a : Type) -> Vec Z a

postulate VCons : (a : Type) -> (n : Nat) -> (x : a) -> (xs : Vec n a) -> Vec (S n) a

vlen : (a : Type) -> (n : Nat) -> (xs : Vec n a) -> Nat = \(a : Type) (n : Nat) (xs : Vec n a).
  case xs of
    VNil (a' : Type)
      | a = a'
      | n = Z
      => Z
    VCons (a' : Type) (n' : Nat) (x' : a) (xs' : Vec n' a)
      | a = a'
      | n = S n'
      => S (vlen a n' xs')

testVec : Vec 2 Bool = VCons Bool 1 True (VCons Bool Z False (VNil Bool))

main :R: Nat = vlen Bool 2 testVec

### Metaified ###

postulate Bool :1: Type

postulate True :2: Bool

postulate False :3: Bool

postulate Nat :4: Type

postulate Z :5: Nat

postulate S :6: (n :R: Nat) -> Nat

postulate Vec :7: (_ :8: Nat) -> (_ :9: Type) -> Type

postulate VNil :10: (a :11: Type) -> Vec -13- Z -12- a

postulate VCons :14: (a :15: Type) -> (n :16: Nat) -> (x :17: a) -> (xs :18: Vec -20- n -19- a) -> Vec -22- (S -23- n) -21- a

vlen :24: (a :25: Type) -> (n :26: Nat) -> (xs :27: Vec -29- n -28- a) -> Nat = \(a :30: Type) (n :31: Nat) (xs :32: Vec -34- n -33- a).
  case -35- xs of
    VNil (a' :36: Type)
      | a = a'
      | n = Z
      => Z
    VCons (a' :37: Type) (n' :38: Nat) (x' :39: a) (xs' :40: Vec -42- n' -41- a)
      | a = a'
      | n = S -43- n'
      => S -44- (vlen -47- a -46- n' -45- xs')

testVec :48: Vec -50- 2 -49- Bool = VCons -56- Bool -55- 1 -54- True -53- (VCons -61- Bool -60- Z -59- False -58- (VNil -62- Bool))

main :R: Nat = vlen -65- Bool -64- 2 -63- testVec

### Inferred definitions ###

postulate Bool :1: Type {- constraints apply -}
  [] -> [1,R]

postulate False :3: Bool {- constraints apply -}
  [] -> [1,3,R]

postulate Nat :4: Type {- constraints apply -}
  [] -> [4,R]

postulate S :6: (n :R: Nat) -> Nat {- constraints apply -}
  [] -> [4,6,R]

postulate True :2: Bool {- constraints apply -}
  [] -> [1,2,R]

postulate Type :R: Type

postulate VCons :14: (a :15: Type) -> (n :16: Nat) -> (x :17: a) -> (xs :18: Vec -20- n -19- a) -> Vec -22- (S -23- n) -21- a {- constraints apply -}
  [] -> [7,14,R]
  [8] -> [4,6,16,22,23]
  [9] -> [15,21]
  [21] -> [9]
  [22] -> [8]

postulate VNil :10: (a :11: Type) -> Vec -13- Z -12- a {- constraints apply -}
  [] -> [7,10,R]
  [8] -> [4,5,13]
  [9] -> [11,12]
  [12] -> [9]
  [13] -> [8]

postulate Vec :7: (_ :8: Nat) -> (_ :9: Type) -> Type {- constraints apply -}
  [] -> [7,R]

postulate Z :5: Nat {- constraints apply -}
  [] -> [4,5,R]

main :R: Nat = vlen -65- Bool -64- 2 -63- testVec {- constraints apply -}
  [] -> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,27,28,29,30,32,35,36,37,38,39,40,41,42,43,44,45,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,65,66,67,R]
  [26] -> [31,46,64]
  [31] -> [26]
  [46] -> [26]
  [64] -> [26]

testVec :48: Vec -50- 2 -49- Bool = VCons -56- Bool -55- 1 -54- True -53- (VCons -61- Bool -60- Z -59- False -58- (VNil -62- Bool)) {- constraints apply -}
  [] -> [7,14,48,R]
  [8] -> [4,5,6,16,22,23,50,51,52]
  [8,18] -> [4,5,6,13,16,22,23]
  [9] -> [1,15,21,49]
  [9,18] -> [11,12,15,21]
  [11,18] -> [1,62]
  [12,18] -> [9,19]
  [13,18] -> [8,20]
  [15] -> [1,56]
  [15,18] -> [1,61]
  [16] -> [4,5,6,55,57]
  [16,18] -> [4,5,60]
  [17] -> [1,2,54]
  [17,18] -> [1,3,59]
  [18] -> [10,53,58]
  [18,19] -> [12]
  [18,20] -> [13]
  [18,21] -> [9]
  [18,22] -> [8]
  [18,58] -> [18]
  [18,59] -> [17]
  [18,60] -> [16]
  [18,61] -> [15]
  [18,62] -> [11]
  [19] -> [21]
  [20] -> [22]
  [21] -> [9,19,49]
  [22] -> [8,20,50]
  [23] -> [51,57]
  [49] -> [9,21]
  [50] -> [8,22]
  [51] -> [23]
  [52] -> [57]
  [53] -> [18]
  [54] -> [17]
  [55] -> [16]
  [56] -> [15]
  [57] -> [23,52]

vlen :24: (a :25: Type) -> (n :26: Nat) -> (xs :27: Vec -29- n -28- a) -> Nat = \(a :30: Type) (n :31: Nat) (xs :32: Vec -34- n -33- a).
  case -35- xs of
    VNil (a' :36: Type)
      | a = a'
      | n = Z
      => Z
    VCons (a' :37: Type) (n' :38: Nat) (x' :39: a) (xs' :40: Vec -42- n' -41- a)
      | a = a'
      | n = S -43- n'
      => S -44- (vlen -47- a -46- n' -45- xs') {- constraints apply -}
  [] -> [4,5,6,7,8,9,11,12,13,15,16,17,18,19,20,21,22,24,25,27,28,29,30,32,35,36,37,38,39,40,41,42,44,45,47,R]
  [23] -> [43]
  [26] -> [31,46]
  [31] -> [26]
  [43] -> [23]
  [46] -> [26]


### Constraints ###

[] -> [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,27,28,29,30,32,35,36,37,38,39,40,41,42,43,44,45,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,65,66,67,R]
[26] -> [31,46,64]
[31] -> [26]
[46] -> [26]
[64] -> [26]

### Solution ###

[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,27,28,29,30,32,35,36,37,38,39,40,41,42,43,44,45,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,65,66,67,R]

### Annotated ###

postulate Bool :R: Type

postulate True :R: Bool

postulate False :R: Bool

postulate Nat :R: Type

postulate Z :R: Nat

postulate S :R: (n :R: Nat) -> Nat

postulate Vec :R: (_ :R: Nat) -> (_ :R: Type) -> Type

postulate VNil :R: (a :R: Type) -> Vec -R- Z -R- a

postulate VCons :R: (a :R: Type) -> (n :R: Nat) -> (x :R: a) -> (xs :R: Vec -R- n -R- a) -> Vec -R- (S -R- n) -R- a

vlen :R: (a :R: Type) -> (n :E: Nat) -> (xs :R: Vec -R- n -R- a) -> Nat = \(a :R: Type) (n :E: Nat) (xs :R: Vec -E- n -E- a).
  case -R- xs of
    VNil (a' :R: Type)
      | a = a'
      | n = Z
      => Z
    VCons (a' :R: Type) (n' :R: Nat) (x' :R: a) (xs' :R: Vec -R- n' -R- a)
      | a = a'
      | n = S -R- n'
      => S -R- (vlen -R- a -E- n' -R- xs')

testVec :R: Vec -R- 2 -R- Bool = VCons -R- Bool -R- 1 -R- True -R- (VCons -R- Bool -R- Z -R- False -R- (VNil -R- Bool))

main :R: Nat = vlen -R- Bool -E- 2 -R- testVec

### Specialised ###

postulate Bool :R: Type

postulate True :R: Bool

postulate False :R: Bool

postulate Nat :R: Type

postulate Z :R: Nat

postulate S :R: (n :R: Nat) -> Nat

postulate Vec :R: (_ :R: Nat) -> (_ :R: Type) -> Type

postulate VNil :R: (a :R: Type) -> Vec -R- Z -R- a

postulate VCons :R: (a :R: Type) -> (n :R: Nat) -> (x :R: a) -> (xs :R: Vec -R- n -R- a) -> Vec -R- (S -R- n) -R- a

vlen :R: (a :R: Type) -> (n :E: Nat) -> (xs :R: Vec -R- n -R- a) -> Nat = \(a :R: Type) (n :E: Nat) (xs :R: Vec -E- n -E- a).
  case -R- xs of
    VNil (a' :R: Type)
      | a = a'
      | n = Z
      => Z
    VCons (a' :R: Type) (n' :R: Nat) (x' :R: a) (xs' :R: Vec -R- n' -R- a)
      | a = a'
      | n = S -R- n'
      => S -R- (vlen -R- a -E- n' -R- xs')

testVec :R: Vec -R- 2 -R- Bool = VCons -R- Bool -R- 1 -R- True -R- (VCons -R- Bool -R- Z -R- False -R- (VNil -R- Bool))

main :R: Nat = vlen -R- Bool -E- 2 -R- testVec

### Final annotation ###

postulate Bool :R: Type

postulate True :R: Bool

postulate False :R: Bool

postulate Nat :R: Type

postulate Z :R: Nat

postulate S :R: (n :R: Nat) -> Nat

postulate Vec :R: (_ :R: Nat) -> (_ :R: Type) -> Type

postulate VNil :R: (a :R: Type) -> Vec -R- Z -R- a

postulate VCons :R: (a :R: Type) -> (n :R: Nat) -> (x :R: a) -> (xs :R: Vec -R- n -R- a) -> Vec -R- (S -R- n) -R- a

vlen :R: (a :R: Type) -> (n :E: Nat) -> (xs :R: Vec -R- n -R- a) -> Nat = \(a :R: Type) (n :E: Nat) (xs :R: Vec -E- n -E- a).
  case -R- xs of
    VNil (a' :R: Type)
      | a = a'
      | n = Z
      => Z
    VCons (a' :R: Type) (n' :R: Nat) (x' :R: a) (xs' :R: Vec -R- n' -R- a)
      | a = a'
      | n = S -R- n'
      => S -R- (vlen -R- a -E- n' -R- xs')

testVec :R: Vec -R- 2 -R- Bool = VCons -R- Bool -R- 1 -R- True -R- (VCons -R- Bool -R- Z -R- False -R- (VNil -R- Bool))

main :R: Nat = vlen -R- Bool -E- 2 -R- testVec

### Verification ###

Verification successful.

### Pruned ###

postulate Bool

postulate True

postulate False

postulate Nat

postulate Z

postulate S

postulate Vec

postulate VNil

postulate VCons

vlen = \a xs.
  case xs of
    VNil a'
      => Z
    VCons a' n' x' xs'
      => S (vlen a xs')

testVec = VCons Bool 1 True (VCons Bool Z False (VNil Bool))

main = vlen Bool testVec

### Normal forms ###

unerased:
  2
erased:
  2
