-- vim: ft=agda

### Desugared ###

  let
    postulate Bool : Type
    postulate True : Bool
    postulate False : Bool
    postulate Nat : Type
    postulate Z : Nat
    postulate S : (n :R: Nat) -> Nat
    postulate Vec : (_ : Nat) -> (_ : Type) -> Type
    postulate VNil : (a : Type) -> Vec Z a
    postulate VCons : (a : Type) -> (n : Nat) -> (x : a) -> (xs : Vec n a) -> Vec (S n) a
    vlen : (a : Type) -> (n : Nat) -> (xs : Vec n a) -> Nat = \(a : Type) (n : Nat) (xs : Vec n a).
      case xs of
        VNil (a' : Type)
          | a' = a
          | n = Z
          => Z
        VCons (a' : Type) (n' : Nat) (x' : a) (xs' : Vec n' a)
          | a' = a
          | n = S n'
          => S (vlen a n' xs')
    testVec : Vec 2 Bool = VCons Bool 1 True (VCons Bool Z False (VNil Bool))
    main : Nat = vlen Bool 2 testVec
  in main

### Metaified ###

  let
    postulate Bool :1: Type
    postulate True :2: Bool
    postulate False :3: Bool
    postulate Nat :4: Type
    postulate Z :5: Nat
    postulate S :6: (n :R: Nat) -> Nat
    postulate Vec :7: (_ :8: Nat) -> (_ :9: Type) -> Type
    postulate VNil :10: (a :11: Type) -> Vec -13- Z -12- a
    postulate VCons :14: (a :15: Type) -> (n :16: Nat) -> (x :17: a) -> (xs :18: Vec -20- n -19- a) -> Vec -22- (S -23- n) -21- a
    vlen :24: (a :25: Type) -> (n :26: Nat) -> (xs :27: Vec -29- n -28- a) -> Nat = \(a :30: Type) (n :31: Nat) (xs :32: Vec -34- n -33- a).
      case -35- xs of
        VNil/36 (a' :37: Type)
          | a' = a
          | n = Z
          => Z
        VCons/38 (a' :39: Type) (n' :40: Nat) (x' :41: a) (xs' :42: Vec -44- n' -43- a)
          | a' = a
          | n = S -45- n'
          => S -46- (vlen -49- a -48- n' -47- xs')
    testVec :50: Vec -52- 2 -51- Bool = VCons -58- Bool -57- 1 -56- True -55- (VCons -63- Bool -62- Z -61- False -60- (VNil -64- Bool))
    main :65: Nat = vlen -68- Bool -67- 2 -66- testVec
  in main

### Constraints ###

[] -> [5,6,10,14,18,24,27,32,35,36,38,42,46,47,50,55,60,66,R]
[11] -> [1,37,64]
[12] -> [19,28]
[13] -> [20,29]
[15] -> [1,39,58,63]
[16] -> [40,57,59,62]
[17] -> [2,3,41,56,61]
[19] -> [12,21,43]
[20] -> [13,22,44]
[21] -> [19,28,51]
[22] -> [20,29,52]
[23] -> [45,53,59]
[25] -> [1,30,49,68]
[26] -> [31,40,48,67,69,70]
[28] -> [12,21,43,51]
[29] -> [13,22,44,52]
[30] -> [25]
[31] -> [26]
[37] -> [11]
[39] -> [15]
[40] -> [16]
[41] -> [17]
[43] -> [19,28]
[44] -> [20,29]
[45] -> [23]
[48] -> [26]
[49] -> [25]
[51] -> [21,28]
[52] -> [22,29]
[53] -> [23,69]
[54] -> [59,70]
[56] -> [17]
[57] -> [16]
[58] -> [15]
[59] -> [23,54]
[61] -> [17]
[62] -> [16]
[63] -> [15]
[64] -> [11]
[67] -> [26]
[68] -> [25]
[69] -> [53]
[70] -> [54]
[R] -> [65]

### Solution ###

[5,6,10,14,18,24,27,32,35,36,38,42,46,47,50,55,60,65,66,R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Vec :E: (_ :E: Nat) -> (_ :E: Type) -> Type
    postulate VNil :R: (a :E: Type) -> Vec -E- Z -E- a
    postulate VCons :R: (a :E: Type) -> (n :E: Nat) -> (x :E: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
    vlen :R: (a :E: Type) -> (n :E: Nat) -> (xs :R: Vec -E- n -E- a) -> Nat = \(a :E: Type) (n :E: Nat) (xs :R: Vec -E- n -E- a).
      case -R- xs of
        VNil/R (a' :E: Type)
          | a' = a
          | n = Z
          => Z
        VCons/R (a' :E: Type) (n' :E: Nat) (x' :E: a) (xs' :R: Vec -E- n' -E- a)
          | a' = a
          | n = S -E- n'
          => S -R- (vlen -E- a -E- n' -R- xs')
    testVec :R: Vec -E- 2 -E- Bool = VCons -E- Bool -E- 1 -E- True -R- (VCons -E- Bool -E- Z -E- False -R- (VNil -E- Bool))
    main :R: Nat = vlen -E- Bool -E- 2 -R- testVec
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Vec :E: (_ :E: Nat) -> (_ :E: Type) -> Type
    postulate VNil :R: (a :E: Type) -> Vec -E- Z -E- a
    postulate VCons :R: (a :E: Type) -> (n :E: Nat) -> (x :E: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
    vlen :R: (a :E: Type) -> (n :E: Nat) -> (xs :R: Vec -E- n -E- a) -> Nat = \(a :E: Type) (n :E: Nat) (xs :R: Vec -E- n -E- a).
      case -R- xs of
        VNil/R (a' :E: Type)
          | a' = a
          | n = Z
          => Z
        VCons/R (a' :E: Type) (n' :E: Nat) (x' :E: a) (xs' :R: Vec -E- n' -E- a)
          | a' = a
          | n = S -E- n'
          => S -R- (vlen -E- a -E- n' -R- xs')
    testVec :R: Vec -E- 2 -E- Bool = VCons -E- Bool -E- 1 -E- True -R- (VCons -E- Bool -E- Z -E- False -R- (VNil -E- Bool))
    main :R: Nat = vlen -E- Bool -E- 2 -R- testVec
  in main

### Constraints ###

[E] -> [E]
[R] -> [R]

### Solution ###

[R]

### Annotated ###

  let
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Vec :E: (_ :E: Nat) -> (_ :E: Type) -> Type
    postulate VNil :R: (a :E: Type) -> Vec -E- Z -E- a
    postulate VCons :R: (a :E: Type) -> (n :E: Nat) -> (x :E: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
    vlen :R: (a :E: Type) -> (n :E: Nat) -> (xs :R: Vec -E- n -E- a) -> Nat = \(a :E: Type) (n :E: Nat) (xs :R: Vec -E- n -E- a).
      case -R- xs of
        VNil/R (a' :E: Type)
          | a' = a
          | n = Z
          => Z
        VCons/R (a' :E: Type) (n' :E: Nat) (x' :E: a) (xs' :R: Vec -E- n' -E- a)
          | a' = a
          | n = S -E- n'
          => S -R- (vlen -E- a -E- n' -R- xs')
    testVec :R: Vec -E- 2 -E- Bool = VCons -E- Bool -E- 1 -E- True -R- (VCons -E- Bool -E- Z -E- False -R- (VNil -E- Bool))
    main :R: Nat = vlen -E- Bool -E- 2 -R- testVec
  in main

### Specialised ###

  let
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Vec :E: (_ :E: Nat) -> (_ :E: Type) -> Type
    postulate VNil :R: (a :E: Type) -> Vec -E- Z -E- a
    postulate VCons :R: (a :E: Type) -> (n :E: Nat) -> (x :E: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
    vlen :R: (a :E: Type) -> (n :E: Nat) -> (xs :R: Vec -E- n -E- a) -> Nat = \(a :E: Type) (n :E: Nat) (xs :R: Vec -E- n -E- a).
      case -R- xs of
        VNil/R (a' :E: Type)
          | a' = a
          | n = Z
          => Z
        VCons/R (a' :E: Type) (n' :E: Nat) (x' :E: a) (xs' :R: Vec -E- n' -E- a)
          | a' = a
          | n = S -E- n'
          => S -R- (vlen -E- a -E- n' -R- xs')
    testVec :R: Vec -E- 2 -E- Bool = VCons -E- Bool -E- 1 -E- True -R- (VCons -E- Bool -E- Z -E- False -R- (VNil -E- Bool))
    main :R: Nat = vlen -E- Bool -E- 2 -R- testVec
  in main

### Final annotation ###

  let
    postulate Bool :E: Type
    postulate True :E: Bool
    postulate False :E: Bool
    postulate Nat :E: Type
    postulate Z :R: Nat
    postulate S :R: (n :R: Nat) -> Nat
    postulate Vec :E: (_ :E: Nat) -> (_ :E: Type) -> Type
    postulate VNil :R: (a :E: Type) -> Vec -E- Z -E- a
    postulate VCons :R: (a :E: Type) -> (n :E: Nat) -> (x :E: a) -> (xs :R: Vec -E- n -E- a) -> Vec -E- (S -E- n) -E- a
    vlen :R: (a :E: Type) -> (n :E: Nat) -> (xs :R: Vec -E- n -E- a) -> Nat = \(a :E: Type) (n :E: Nat) (xs :R: Vec -E- n -E- a).
      case -R- xs of
        VNil/R (a' :E: Type)
          | a' = a
          | n = Z
          => Z
        VCons/R (a' :E: Type) (n' :E: Nat) (x' :E: a) (xs' :R: Vec -E- n' -E- a)
          | a' = a
          | n = S -E- n'
          => S -R- (vlen -E- a -E- n' -R- xs')
    testVec :R: Vec -E- 2 -E- Bool = VCons -E- Bool -E- 1 -E- True -R- (VCons -E- Bool -E- Z -E- False -R- (VNil -E- Bool))
    main :R: Nat = vlen -E- Bool -E- 2 -R- testVec
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Z : Nat
    postulate S : (n) -> Nat
    postulate VNil : Vec
    postulate VCons : (xs) -> Vec
    vlen = \xs.
      case xs of
        VNil
          => Z
        VCons xs'
          => S (vlen xs')
    testVec = VCons (VCons VNil)
    main = vlen testVec
  in main

### Normal forms ###

unerased:
  
  let
    postulate Z : Nat
    postulate S : (n :R: Nat) -> Nat
  in 2

erased:
  
  let
    postulate Z : Nat
    postulate S : (n) -> Nat
  in 2

