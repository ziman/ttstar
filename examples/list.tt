-- vim: ft=idris

data Id : (a : Type) -> (x : a) -> (y : a) -> Type.
  Refl : (a : Type) -> (x : a) -> Id a x x.

id (a : Type) : a -> a = \x : a. x.

subst : (a : Type) -> (P : a -> Type) -> (x : a) -> (y : a) -> (eq : Id a x y) -> (P x) -> (P y).
  pat (a : Type) (P : a -> Type) (x : a) (eq : Id a x x).
    subst a P x [x] (Refl [a] [x]) = \y : P x. y.

cong : (a : Type) -> (b : Type) -> (f : a -> b) -> (x : a) -> (y : a) -> (eq : Id a x y) -> Id b (f x) (f y).
  pat (a : Type) (b : Type) (f : a -> b) (x : a).
    cong a b f x [x] (Refl a [x]) = Refl b (f x).

data Bool : Type.
  T : Bool,
  F : Bool.

-- We annotate this type manually to emulate usage caused by I/O actions.
data List : Type.
  Nil : List,
  Cons : (x :R: Bool) -> (xs :R: List) -> List.

app : List -> List -> List.
  pat (ys : List).
    app Nil ys = ys,
  pat (x : Bool) (xs : List) (ys : List).
    app (Cons x xs) ys = Cons x (app xs ys).

postulate appRightNeutral : (ys : List) -> Id List ys (app ys Nil).
{-
appRightNeutral : (ys : List) -> Id List ys (app ys Nil).
  appRightNeutral Nil = Refl List Nil,
  pat (x : Bool) (xs : List).
    appRightNeutral (Cons x xs) = cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs).
-}

main (x : Bool) (xs : List)
  :R: Id List (Cons x xs) (app (Cons x xs) Nil)
  = cong List List (Cons x) xs (app xs Nil) (appRightNeutral xs).
