-- vim: ft=idris

### Desugared ###

  let
    postulate N : Type
    postulate Z : N
    postulate S : (_x0 : N) -> N
    plus : (m : N) -> (n : N) -> N = \(m : N) (n : N).
      case m of
        Z
          => n
        S (m' : N)
          => S (plus m' n)
    postulate Vect : (_x1 : N) -> Type
    postulate Nil : Vect Z
    postulate Cons : (n : N) -> (x : N) -> (xs : Vect n) -> Vect (S n)
    zipWith : (n : N) -> (f : (_x2 : N) -> (_x3 : N) -> N) -> (xs : Vect n) -> (ys : Vect n) -> Vect n = \(n : N) (f : (_x2 : N) -> (_x3 : N) -> N) (xs : Vect n) (ys : Vect n).
      case xs of
        Cons (n1 : N) (x1 : N) (xs1 : Vect n1)
          => case n of [S n1] =>
            case ys of
              Cons (n2 : N) (x2 : N) (xs2 : Vect n1)
                => case n2 of [n1] =>
                  Cons n1 (f x1 x2) (zipWith n1 f xs1 xs2)
        Nil
          => case n of [Z] =>
            case ys of
              Nil
                => Nil
    main : N = 
      let pred : (x : N) -> N = \(x : N).
        case x of
          Z
            => Z
          S (x' : N)
            => x'
      in plus (pred 4) (pred 5)
  in main

### Metaified ###

  let
    postulate N :1: Type
    postulate Z :2: N
    postulate S :3: (_x0 :4: N) -> N
    plus :5: (m :6: N) -> (n :7: N) -> N = \(m :8: N) (n :9: N).
      case -10- m of
        Z/11
          => n
        S/12 (m' :13: N)
          => S -14- (plus -16- m' -15- n)
    postulate Vect :17: (_x1 :18: N) -> Type
    postulate Nil :19: Vect -20- Z
    postulate Cons :21: (n :22: N) -> (x :23: N) -> (xs :24: Vect -25- n) -> Vect -26- (S -27- n)
    zipWith :28: (n :29: N) -> (f :30: (_x2 :31: N) -> (_x3 :32: N) -> N) -> (xs :33: Vect -34- n) -> (ys :35: Vect -36- n) -> Vect -37- n = \(n :38: N) (f :39: (_x2 :40: N) -> (_x3 :41: N) -> N) (xs :42: Vect -43- n) (ys :44: Vect -45- n).
      case -46- xs of
        Cons/47 (n1 :48: N) (x1 :49: N) (xs1 :50: Vect -51- n1)
          => case -52- n of [S -53- n1] =>
            case -54- ys of
              Cons/55 (n2 :56: N) (x2 :57: N) (xs2 :58: Vect -59- n1)
                => case -60- n2 of [n1] =>
                  Cons -63- n1 -62- (f -65- x1 -64- x2) -61- (zipWith -69- n1 -68- f -67- xs1 -66- xs2)
        Nil/70
          => case -71- n of [Z] =>
            case -72- ys of
              Nil/73
                => Nil
    main :74: N = 
      let pred :75: (x :76: N) -> N = \(x :77: N).
        case -78- x of
          Z/79
            => Z
          S/80 (x' :81: N)
            => x'
      in plus -83- (pred -84- 4) -82- (pred -89- 5)
  in main

### Constraints ###

[] -> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,R]
[R] -> [74]

### Solution ###

[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,R]

### Annotated ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (_x0 :R: N) -> N
    plus :R: (m :R: N) -> (n :R: N) -> N = \(m :R: N) (n :R: N).
      case -R- m of
        Z/R
          => n
        S/R (m' :R: N)
          => S -R- (plus -R- m' -R- n)
    postulate Vect :E: (_x1 :E: N) -> Type
    postulate Nil :E: Vect -E- Z
    postulate Cons :E: (n :E: N) -> (x :E: N) -> (xs :E: Vect -E- n) -> Vect -E- (S -E- n)
    zipWith :E: (n :E: N) -> (f :E: (_x2 :E: N) -> (_x3 :E: N) -> N) -> (xs :E: Vect -E- n) -> (ys :E: Vect -E- n) -> Vect -E- n = \(n :E: N) (f :E: (_x2 :E: N) -> (_x3 :E: N) -> N) (xs :E: Vect -E- n) (ys :E: Vect -E- n).
      case -E- xs of
        Cons/E (n1 :E: N) (x1 :E: N) (xs1 :E: Vect -E- n1)
          => case -E- n of [S -E- n1] =>
            case -E- ys of
              Cons/E (n2 :E: N) (x2 :E: N) (xs2 :E: Vect -E- n1)
                => case -E- n2 of [n1] =>
                  Cons -E- n1 -E- (f -E- x1 -E- x2) -E- (zipWith -E- n1 -E- f -E- xs1 -E- xs2)
        Nil/E
          => case -E- n of [Z] =>
            case -E- ys of
              Nil/E
                => Nil
    main :R: N = 
      let pred :R: (x :R: N) -> N = \(x :R: N).
        case -R- x of
          Z/R
            => Z
          S/R (x' :R: N)
            => x'
      in plus -R- (pred -R- 4) -R- (pred -R- 5)
  in main

### Specialised ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (_x0 :R: N) -> N
    plus :R: (m :R: N) -> (n :R: N) -> N = \(m :R: N) (n :R: N).
      case -R- m of
        Z/R
          => n
        S/R (m' :R: N)
          => S -R- (plus -R- m' -R- n)
    postulate Vect :E: (_x1 :E: N) -> Type
    postulate Nil :E: Vect -E- Z
    postulate Cons :E: (n :E: N) -> (x :E: N) -> (xs :E: Vect -E- n) -> Vect -E- (S -E- n)
    zipWith :E: (n :E: N) -> (f :E: (_x2 :E: N) -> (_x3 :E: N) -> N) -> (xs :E: Vect -E- n) -> (ys :E: Vect -E- n) -> Vect -E- n = \(n :E: N) (f :E: (_x2 :E: N) -> (_x3 :E: N) -> N) (xs :E: Vect -E- n) (ys :E: Vect -E- n).
      case -E- xs of
        Cons/E (n1 :E: N) (x1 :E: N) (xs1 :E: Vect -E- n1)
          => case -E- n of [S -E- n1] =>
            case -E- ys of
              Cons/E (n2 :E: N) (x2 :E: N) (xs2 :E: Vect -E- n1)
                => case -E- n2 of [n1] =>
                  Cons -E- n1 -E- (f -E- x1 -E- x2) -E- (zipWith -E- n1 -E- f -E- xs1 -E- xs2)
        Nil/E
          => case -E- n of [Z] =>
            case -E- ys of
              Nil/E
                => Nil
    main :R: N = 
      let pred :R: (x :R: N) -> N = \(x :R: N).
        case -R- x of
          Z/R
            => Z
          S/R (x' :R: N)
            => x'
      in plus -R- (pred -R- 4) -R- (pred -R- 5)
  in main

### Final annotation ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (_x0 :R: N) -> N
    plus :R: (m :R: N) -> (n :R: N) -> N = \(m :R: N) (n :R: N).
      case -R- m of
        Z/R
          => n
        S/R (m' :R: N)
          => S -R- (plus -R- m' -R- n)
    postulate Vect :E: (_x1 :E: N) -> Type
    postulate Nil :E: Vect -E- Z
    postulate Cons :E: (n :E: N) -> (x :E: N) -> (xs :E: Vect -E- n) -> Vect -E- (S -E- n)
    zipWith :E: (n :E: N) -> (f :E: (_x2 :E: N) -> (_x3 :E: N) -> N) -> (xs :E: Vect -E- n) -> (ys :E: Vect -E- n) -> Vect -E- n = \(n :E: N) (f :E: (_x2 :E: N) -> (_x3 :E: N) -> N) (xs :E: Vect -E- n) (ys :E: Vect -E- n).
      case -E- xs of
        Cons/E (n1 :E: N) (x1 :E: N) (xs1 :E: Vect -E- n1)
          => case -E- n of [S -E- n1] =>
            case -E- ys of
              Cons/E (n2 :E: N) (x2 :E: N) (xs2 :E: Vect -E- n1)
                => case -E- n2 of [n1] =>
                  Cons -E- n1 -E- (f -E- x1 -E- x2) -E- (zipWith -E- n1 -E- f -E- xs1 -E- xs2)
        Nil/E
          => case -E- n of [Z] =>
            case -E- ys of
              Nil/E
                => Nil
    main :R: N = 
      let pred :R: (x :R: N) -> N = \(x :R: N).
        case -R- x of
          Z/R
            => Z
          S/R (x' :R: N)
            => x'
      in plus -R- (pred -R- 4) -R- (pred -R- 5)
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Z : N
    postulate S : (_x0) -> N
    plus = \m n.
      case m of
        Z
          => n
        S m'
          => S (plus m' n)
    main = 
      let pred = \x.
        case x of
          Z
            => Z
          S x'
            => x'
      in plus (pred 4) (pred 5)
  in main

### Normal forms ###

unerased:
  
  let
    postulate Z : N
    postulate S : (_x0 : N) -> N
  in 7

erased:
  
  let
    postulate Z : N
    postulate S : (_x0) -> N
  in 7

