-- vim: ft=agda

### Desugared ###

postulate N : Type

postulate Z : N

postulate S : (_ : N) -> N

plus : (m : N) -> (n : N) -> N = \(m : N) (n : N).
  case m of
    Z
      => n
    S (m' : N)
      => S (plus m' n)

postulate Vect : (_ : N) -> Type

postulate Nil : Vect Z

postulate Cons : (n : N) -> (x : N) -> (xs : Vect n) -> Vect (S n)

zipWith : (n : N) -> (f : (_ : N) -> (_ : N) -> N) -> (xs : Vect n) -> (ys : Vect n) -> Vect n = \(n : N) (f : (_ : N) -> (_ : N) -> N) (xs : Vect n) (ys : Vect n).
  case xs of
    Cons (n1 : N) (x1 : N) (xs1 : Vect n1)
      | n = S n1
      => case ys of
        Cons (n2 : N) (x2 : N) (xs2 : Vect n1)
          | n2 = n1
          => Cons n1 (f x1 x2) (zipWith n1 f xs1 xs2)
    Nil
      | n = Z
      => case ys of
        Nil
          => Nil

main :ᴿ N = 
  let pred : (x : N) -> N = \(x : N).
    case x of
      Z
        => Z
      S (x' : N)
        => x'
  in plus (pred 4) (pred 5)

### Metaified ###

postulate N :¹ Type

postulate Z :² N

postulate S :³ (_ :⁴ N) -> N

plus :⁵ (m :⁶ N) -> (n :⁷ N) -> N = \(m :⁸ N) (n :⁹ N).
  case ¹⁰ m of
    Z
      => n
    S (m' :¹¹ N)
      => S ¹² (plus ¹⁴ m' ¹³ n)

postulate Vect :¹⁵ (_ :¹⁶ N) -> Type

postulate Nil :¹⁷ Vect ¹⁸ Z

postulate Cons :¹⁹ (n :²⁰ N) -> (x :²¹ N) -> (xs :²² Vect ²³ n) -> Vect ²⁴ (S ²⁵ n)

zipWith :²⁶ (n :²⁷ N) -> (f :²⁸ (_ :²⁹ N) -> (_ :³⁰ N) -> N) -> (xs :³¹ Vect ³² n) -> (ys :³³ Vect ³⁴ n) -> Vect ³⁵ n = \(n :³⁶ N) (f :³⁷ (_ :³⁸ N) -> (_ :³⁹ N) -> N) (xs :⁴⁰ Vect ⁴¹ n) (ys :⁴² Vect ⁴³ n).
  case ⁴⁴ xs of
    Cons (n1 :⁴⁵ N) (x1 :⁴⁶ N) (xs1 :⁴⁷ Vect ⁴⁸ n1)
      | n = S ⁴⁹ n1
      => case ⁵⁰ ys of
        Cons (n2 :⁵¹ N) (x2 :⁵² N) (xs2 :⁵³ Vect ⁵⁴ n1)
          | n2 = n1
          => Cons ⁵⁷ n1 ⁵⁶ (f ⁵⁹ x1 ⁵⁸ x2) ⁵⁵ (zipWith ⁶³ n1 ⁶² f ⁶¹ xs1 ⁶⁰ xs2)
    Nil
      | n = Z
      => case ⁶⁴ ys of
        Nil
          => Nil

main :ᴿ N = 
  let pred :⁶⁵ (x :⁶⁶ N) -> N = \(x :⁶⁷ N).
    case ⁶⁸ x of
      Z
        => Z
      S (x' :⁶⁹ N)
        => x'
  in plus ⁷¹ (pred ⁷² 4) ⁷⁰ (pred ⁷⁷ 5)

### Inferred definitions ###

postulate Cons :¹⁹ (n :²⁰ N) -> (x :²¹ N) -> (xs :²² Vect ²³ n) -> Vect ²⁴ (S ²⁵ n)

postulate N :¹ Type

postulate Nil :¹⁷ Vect ¹⁸ Z

postulate S :³ (_ :⁴ N) -> N

postulate Type :ᴿ Type

postulate Vect :¹⁵ (_ :¹⁶ N) -> Type

postulate Z :² N

main :ᴿ N = 
  let pred :⁶⁵ (x :⁶⁶ N) -> N = \(x :⁶⁷ N).
    case ⁶⁸ x of
      Z
        => Z
      S (x' :⁶⁹ N)
        => x'
  in plus ⁷¹ (pred ⁷² 4) ⁷⁰ (pred ⁷⁷ 5)
  [] -> [5,R]
  [2,65] -> [66]
  [3,65] -> [66]
  [4,6,66] -> [2,3,73,74,75,76]
  [4,6,66,74] -> [4]
  [4,6,66,75] -> [4]
  [4,6,66,76] -> [4]
  [4,7,66] -> [2,3,78,79,80,81,82]
  [4,7,66,79] -> [4]
  [4,7,66,80] -> [4]
  [4,7,66,81] -> [4]
  [4,7,66,82] -> [4]
  [4,65] -> [66,69]
  [6] -> [65,71]
  [6,66] -> [3,72]
  [6,66,73] -> [4]
  [6,72] -> [66]
  [7] -> [65,70]
  [7,66] -> [3,77]
  [7,66,78] -> [4]
  [7,77] -> [66]
  [65] -> [2,68,69]
  [65,66] -> [67]
  [65,67] -> [66]
  [65,68] -> [67]
  [65,69] -> [4,66,68]
  [70] -> [7]
  [71] -> [6]

plus :⁵ (m :⁶ N) -> (n :⁷ N) -> N = \(m :⁸ N) (n :⁹ N).
  case ¹⁰ m of
    Z
      => n
    S (m' :¹¹ N)
      => S ¹² (plus ¹⁴ m' ¹³ n)
  [2,5] -> [6]
  [3,5] -> [6]
  [4,5] -> [5,6,11,12]
  [4,5,6] -> [11,14]
  [4,5,7] -> [9,13]
  [4,5,13] -> [7]
  [4,5,14] -> [6]
  [5] -> [3,9,10]
  [5,6] -> [8]
  [5,7] -> [9]
  [5,8] -> [6]
  [5,9] -> [7]
  [5,10] -> [8]
  [5,11] -> [4,6,10]
  [5,12] -> [4]

zipWith :²⁶ (n :²⁷ N) -> (f :²⁸ (_ :²⁹ N) -> (_ :³⁰ N) -> N) -> (xs :³¹ Vect ³² n) -> (ys :³³ Vect ³⁴ n) -> Vect ³⁵ n = \(n :³⁶ N) (f :³⁷ (_ :³⁸ N) -> (_ :³⁹ N) -> N) (xs :⁴⁰ Vect ⁴¹ n) (ys :⁴² Vect ⁴³ n).
  case ⁴⁴ xs of
    Cons (n1 :⁴⁵ N) (x1 :⁴⁶ N) (xs1 :⁴⁷ Vect ⁴⁸ n1)
      | n = S ⁴⁹ n1
      => case ⁵⁰ ys of
        Cons (n2 :⁵¹ N) (x2 :⁵² N) (xs2 :⁵³ Vect ⁵⁴ n1)
          | n2 = n1
          => Cons ⁵⁷ n1 ⁵⁶ (f ⁵⁹ x1 ⁵⁸ x2) ⁵⁵ (zipWith ⁶³ n1 ⁶² f ⁶¹ xs1 ⁶⁰ xs2)
    Nil
      | n = Z
      => case ⁶⁴ ys of
        Nil
          => Nil
  [17,26] -> [31]
  [18,26] -> [32,34,35]
  [19,26] -> [31]
  [20,26] -> [31,33,45,51,57]
  [21,26] -> [31,33,37,46,52,56]
  [21,26,38] -> [46,59]
  [21,26,39] -> [52,58]
  [21,26,58] -> [39]
  [21,26,59] -> [38]
  [22,26] -> [26,31,33,47,53,55]
  [22,26,27] -> [45,63]
  [22,26,28] -> [37,62]
  [22,26,29] -> [38]
  [22,26,30] -> [39]
  [22,26,31] -> [47,61]
  [22,26,32] -> [48]
  [22,26,33] -> [53,60]
  [22,26,34] -> [54]
  [22,26,38] -> [29]
  [22,26,39] -> [30]
  [22,26,48] -> [32]
  [22,26,54] -> [34]
  [22,26,60] -> [33]
  [22,26,61] -> [31]
  [22,26,62] -> [28]
  [22,26,63] -> [27]
  [23,26] -> [31,33,35,48,54]
  [24,26] -> [32,34,35]
  [25,26] -> [49]
  [26] -> [17,19,44]
  [26,27] -> [36]
  [26,28] -> [37]
  [26,29] -> [38]
  [26,30] -> [39]
  [26,31] -> [40]
  [26,32] -> [18,24]
  [26,33] -> [42]
  [26,34] -> [18,24]
  [26,35] -> [18,23,24]
  [26,36] -> [27]
  [26,37] -> [28]
  [26,38] -> [29]
  [26,39] -> [30]
  [26,40] -> [31]
  [26,42] -> [33]
  [26,44] -> [40]
  [26,45] -> [20,31,44]
  [26,46] -> [21,31,44]
  [26,47] -> [22,31,44]
  [26,48] -> [23,31]
  [26,49] -> [25]
  [26,50] -> [42]
  [26,51] -> [20,33,50]
  [26,52] -> [21,33,50]
  [26,53] -> [22,33,50]
  [26,54] -> [23,33]
  [26,55] -> [22]
  [26,56] -> [21]
  [26,57] -> [20]
  [26,64] -> [42]


### Constraints ###

[] -> [5,R]
[2,5] -> [6]
[2,65] -> [66]
[3,5] -> [6]
[3,65] -> [66]
[4,5] -> [5,6,11,12]
[4,5,6] -> [11,14]
[4,5,7] -> [9,13]
[4,5,13] -> [7]
[4,5,14] -> [6]
[4,6,66] -> [2,3,73,74,75,76]
[4,6,66,74] -> [4]
[4,6,66,75] -> [4]
[4,6,66,76] -> [4]
[4,7,66] -> [2,3,78,79,80,81,82]
[4,7,66,79] -> [4]
[4,7,66,80] -> [4]
[4,7,66,81] -> [4]
[4,7,66,82] -> [4]
[4,65] -> [66,69]
[5] -> [3,9,10]
[5,6] -> [8]
[5,7] -> [9]
[5,8] -> [6]
[5,9] -> [7]
[5,10] -> [8]
[5,11] -> [4,6,10]
[5,12] -> [4]
[6] -> [65,71]
[6,66] -> [3,72]
[6,66,73] -> [4]
[6,72] -> [66]
[7] -> [65,70]
[7,66] -> [3,77]
[7,66,78] -> [4]
[7,77] -> [66]
[17,26] -> [31]
[18,26] -> [32,34,35]
[19,26] -> [31]
[20,26] -> [31,33,45,51,57]
[21,26] -> [31,33,37,46,52,56]
[21,26,38] -> [46,59]
[21,26,39] -> [52,58]
[21,26,58] -> [39]
[21,26,59] -> [38]
[22,26] -> [26,31,33,47,53,55]
[22,26,27] -> [45,63]
[22,26,28] -> [37,62]
[22,26,29] -> [38]
[22,26,30] -> [39]
[22,26,31] -> [47,61]
[22,26,32] -> [48]
[22,26,33] -> [53,60]
[22,26,34] -> [54]
[22,26,38] -> [29]
[22,26,39] -> [30]
[22,26,48] -> [32]
[22,26,54] -> [34]
[22,26,60] -> [33]
[22,26,61] -> [31]
[22,26,62] -> [28]
[22,26,63] -> [27]
[23,26] -> [31,33,35,48,54]
[24,26] -> [32,34,35]
[25,26] -> [49]
[26] -> [17,19,44]
[26,27] -> [36]
[26,28] -> [37]
[26,29] -> [38]
[26,30] -> [39]
[26,31] -> [40]
[26,32] -> [18,24]
[26,33] -> [42]
[26,34] -> [18,24]
[26,35] -> [18,23,24]
[26,36] -> [27]
[26,37] -> [28]
[26,38] -> [29]
[26,39] -> [30]
[26,40] -> [31]
[26,42] -> [33]
[26,44] -> [40]
[26,45] -> [20,31,44]
[26,46] -> [21,31,44]
[26,47] -> [22,31,44]
[26,48] -> [23,31]
[26,49] -> [25]
[26,50] -> [42]
[26,51] -> [20,33,50]
[26,52] -> [21,33,50]
[26,53] -> [22,33,50]
[26,54] -> [23,33]
[26,55] -> [22]
[26,56] -> [21]
[26,57] -> [20]
[26,64] -> [42]
[65] -> [2,68,69]
[65,66] -> [67]
[65,67] -> [66]
[65,68] -> [67]
[65,69] -> [4,66,68]
[70] -> [7]
[71] -> [6]

### Solution ###

[2,3,4,5,6,7,8,9,10,11,12,13,14,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,R]

### Annotated ###

postulate N :ᴱ Type

postulate Z :ᴿ N

postulate S :ᴿ (_ :ᴿ N) -> N

plus :ᴿ (m :ᴿ N) -> (n :ᴿ N) -> N = \(m :ᴿ N) (n :ᴿ N).
  case ᴿ m of
    Z
      => n
    S (m' :ᴿ N)
      => S ᴿ (plus ᴿ m' ᴿ n)

postulate Vect :ᴱ (_ :ᴱ N) -> Type

postulate Nil :ᴱ Vect ᴱ Z

postulate Cons :ᴱ (n :ᴱ N) -> (x :ᴱ N) -> (xs :ᴱ Vect ᴱ n) -> Vect ᴱ (S ᴱ n)

zipWith :ᴱ (n :ᴱ N) -> (f :ᴱ (_ :ᴱ N) -> (_ :ᴱ N) -> N) -> (xs :ᴱ Vect ᴱ n) -> (ys :ᴱ Vect ᴱ n) -> Vect ᴱ n = \(n :ᴱ N) (f :ᴱ (_ :ᴱ N) -> (_ :ᴱ N) -> N) (xs :ᴱ Vect ᴱ n) (ys :ᴱ Vect ᴱ n).
  case ᴱ xs of
    Cons (n1 :ᴱ N) (x1 :ᴱ N) (xs1 :ᴱ Vect ᴱ n1)
      | n = S ᴱ n1
      => case ᴱ ys of
        Cons (n2 :ᴱ N) (x2 :ᴱ N) (xs2 :ᴱ Vect ᴱ n1)
          | n2 = n1
          => Cons ᴱ n1 ᴱ (f ᴱ x1 ᴱ x2) ᴱ (zipWith ᴱ n1 ᴱ f ᴱ xs1 ᴱ xs2)
    Nil
      | n = Z
      => case ᴱ ys of
        Nil
          => Nil

main :ᴿ N = 
  let pred :ᴿ (x :ᴿ N) -> N = \(x :ᴿ N).
    case ᴿ x of
      Z
        => Z
      S (x' :ᴿ N)
        => x'
  in plus ᴿ (pred ᴿ 4) ᴿ (pred ᴿ 5)

### Specialised ###

postulate N :ᴱ Type

postulate Z :ᴿ N

postulate S :ᴿ (_ :ᴿ N) -> N

plus :ᴿ (m :ᴿ N) -> (n :ᴿ N) -> N = \(m :ᴿ N) (n :ᴿ N).
  case ᴿ m of
    Z
      => n
    S (m' :ᴿ N)
      => S ᴿ (plus ᴿ m' ᴿ n)

postulate Vect :ᴱ (_ :ᴱ N) -> Type

postulate Nil :ᴱ Vect ᴱ Z

postulate Cons :ᴱ (n :ᴱ N) -> (x :ᴱ N) -> (xs :ᴱ Vect ᴱ n) -> Vect ᴱ (S ᴱ n)

zipWith :ᴱ (n :ᴱ N) -> (f :ᴱ (_ :ᴱ N) -> (_ :ᴱ N) -> N) -> (xs :ᴱ Vect ᴱ n) -> (ys :ᴱ Vect ᴱ n) -> Vect ᴱ n = \(n :ᴱ N) (f :ᴱ (_ :ᴱ N) -> (_ :ᴱ N) -> N) (xs :ᴱ Vect ᴱ n) (ys :ᴱ Vect ᴱ n).
  case ᴱ xs of
    Cons (n1 :ᴱ N) (x1 :ᴱ N) (xs1 :ᴱ Vect ᴱ n1)
      | n = S ᴱ n1
      => case ᴱ ys of
        Cons (n2 :ᴱ N) (x2 :ᴱ N) (xs2 :ᴱ Vect ᴱ n1)
          | n2 = n1
          => Cons ᴱ n1 ᴱ (f ᴱ x1 ᴱ x2) ᴱ (zipWith ᴱ n1 ᴱ f ᴱ xs1 ᴱ xs2)
    Nil
      | n = Z
      => case ᴱ ys of
        Nil
          => Nil

main :ᴿ N = 
  let pred :ᴿ (x :ᴿ N) -> N = \(x :ᴿ N).
    case ᴿ x of
      Z
        => Z
      S (x' :ᴿ N)
        => x'
  in plus ᴿ (pred ᴿ 4) ᴿ (pred ᴿ 5)

### Final annotation ###

postulate N :ᴱ Type

postulate Z :ᴿ N

postulate S :ᴿ (_ :ᴿ N) -> N

plus :ᴿ (m :ᴿ N) -> (n :ᴿ N) -> N = \(m :ᴿ N) (n :ᴿ N).
  case ᴿ m of
    Z
      => n
    S (m' :ᴿ N)
      => S ᴿ (plus ᴿ m' ᴿ n)

postulate Vect :ᴱ (_ :ᴱ N) -> Type

postulate Nil :ᴱ Vect ᴱ Z

postulate Cons :ᴱ (n :ᴱ N) -> (x :ᴱ N) -> (xs :ᴱ Vect ᴱ n) -> Vect ᴱ (S ᴱ n)

zipWith :ᴱ (n :ᴱ N) -> (f :ᴱ (_ :ᴱ N) -> (_ :ᴱ N) -> N) -> (xs :ᴱ Vect ᴱ n) -> (ys :ᴱ Vect ᴱ n) -> Vect ᴱ n = \(n :ᴱ N) (f :ᴱ (_ :ᴱ N) -> (_ :ᴱ N) -> N) (xs :ᴱ Vect ᴱ n) (ys :ᴱ Vect ᴱ n).
  case ᴱ xs of
    Cons (n1 :ᴱ N) (x1 :ᴱ N) (xs1 :ᴱ Vect ᴱ n1)
      | n = S ᴱ n1
      => case ᴱ ys of
        Cons (n2 :ᴱ N) (x2 :ᴱ N) (xs2 :ᴱ Vect ᴱ n1)
          | n2 = n1
          => Cons ᴱ n1 ᴱ (f ᴱ x1 ᴱ x2) ᴱ (zipWith ᴱ n1 ᴱ f ᴱ xs1 ᴱ xs2)
    Nil
      | n = Z
      => case ᴱ ys of
        Nil
          => Nil

main :ᴿ N = 
  let pred :ᴿ (x :ᴿ N) -> N = \(x :ᴿ N).
    case ᴿ x of
      Z
        => Z
      S (x' :ᴿ N)
        => x'
  in plus ᴿ (pred ᴿ 4) ᴿ (pred ᴿ 5)

### Verification ###

Verification successful.

### Pruned ###

postulate Z

postulate S

plus = \m n.
  case m of
    Z
      => n
    S m'
      => S (plus m' n)

main = 
  let pred = \x.
    case x of
      Z
        => Z
      S x'
        => x'
  in plus (pred 4) (pred 5)

### Normal forms ###

unerased:
  7
erased:
  7
