-- vim: ft=agda

### Desugared ###

  let
    postulate N : Type
    postulate Z : N
    postulate S : (_ : N) -> N
    plus : (m : N) -> (n : N) -> N = \(m : N) (n : N).
      case m of
        Z
          => n
        S (m' : N)
          => S (plus m' n)
    postulate Vect : (_ : N) -> Type
    postulate Nil : Vect Z
    postulate Cons : (n : N) -> (x : N) -> (xs : Vect n) -> Vect (S n)
    zipWith : (n : N) -> (f : (_ : N) -> (_ : N) -> N) -> (xs : Vect n) -> (ys : Vect n) -> Vect n = \(n : N) (f : (_ : N) -> (_ : N) -> N) (xs : Vect n) (ys : Vect n).
      case xs of
        Cons (n1 : N) (x1 : N) (xs1 : Vect n1)
          | n = S n1
          => case ys of
            Cons (n2 : N) (x2 : N) (xs2 : Vect n1)
              | n2 = n1
              => Cons n1 (f x1 x2) (zipWith n1 f xs1 xs2)
        Nil
          | n = Z
          => case ys of
            Nil
              => Nil
    main : N = 
      let pred : (x : N) -> N = \(x : N).
        case x of
          Z
            => Z
          S (x' : N)
            => x'
      in plus (pred 4) (pred 5)
  in main

### Metaified ###

  let
    postulate N :1: Type
    postulate Z :2: N
    postulate S :3: (_ :4: N) -> N
    plus :5: (m :6: N) -> (n :7: N) -> N = \(m :8: N) (n :9: N).
      case -10- m of
        Z/11
          => n
        S/12 (m' :13: N)
          => S -14- (plus -16- m' -15- n)
    postulate Vect :17: (_ :18: N) -> Type
    postulate Nil :19: Vect -20- Z
    postulate Cons :21: (n :22: N) -> (x :23: N) -> (xs :24: Vect -25- n) -> Vect -26- (S -27- n)
    zipWith :28: (n :29: N) -> (f :30: (_ :31: N) -> (_ :32: N) -> N) -> (xs :33: Vect -34- n) -> (ys :35: Vect -36- n) -> Vect -37- n = \(n :38: N) (f :39: (_ :40: N) -> (_ :41: N) -> N) (xs :42: Vect -43- n) (ys :44: Vect -45- n).
      case -46- xs of
        Cons/47 (n1 :48: N) (x1 :49: N) (xs1 :50: Vect -51- n1)
          | n = S -52- n1
          => case -53- ys of
            Cons/54 (n2 :55: N) (x2 :56: N) (xs2 :57: Vect -58- n1)
              | n2 = n1
              => Cons -61- n1 -60- (f -63- x1 -62- x2) -59- (zipWith -67- n1 -66- f -65- xs1 -64- xs2)
        Nil/68
          | n = Z
          => case -69- ys of
            Nil/70
              => Nil
    main :71: N = 
      let pred :72: (x :73: N) -> N = \(x :74: N).
        case -75- x of
          Z/76
            => Z
          S/77 (x' :78: N)
            => x'
      in plus -80- (pred -81- 4) -79- (pred -86- 5)
  in main

### Constraints ###

[] -> [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,R]
[R] -> [71]

### Solution ###

[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,R]

### Annotated ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (_ :R: N) -> N
    plus :R: (m :R: N) -> (n :R: N) -> N = \(m :R: N) (n :R: N).
      case -R- m of
        Z/R
          => n
        S/R (m' :R: N)
          => S -R- (plus -R- m' -R- n)
    postulate Vect :E: (_ :E: N) -> Type
    postulate Nil :E: Vect -E- Z
    postulate Cons :E: (n :E: N) -> (x :E: N) -> (xs :E: Vect -E- n) -> Vect -E- (S -E- n)
    zipWith :E: (n :E: N) -> (f :E: (_ :E: N) -> (_ :E: N) -> N) -> (xs :E: Vect -E- n) -> (ys :E: Vect -E- n) -> Vect -E- n = \(n :E: N) (f :E: (_ :E: N) -> (_ :E: N) -> N) (xs :E: Vect -E- n) (ys :E: Vect -E- n).
      case -E- xs of
        Cons/E (n1 :E: N) (x1 :E: N) (xs1 :E: Vect -E- n1)
          | n = S -E- n1
          => case -E- ys of
            Cons/E (n2 :E: N) (x2 :E: N) (xs2 :E: Vect -E- n1)
              | n2 = n1
              => Cons -E- n1 -E- (f -E- x1 -E- x2) -E- (zipWith -E- n1 -E- f -E- xs1 -E- xs2)
        Nil/E
          | n = Z
          => case -E- ys of
            Nil/E
              => Nil
    main :R: N = 
      let pred :R: (x :R: N) -> N = \(x :R: N).
        case -R- x of
          Z/R
            => Z
          S/R (x' :R: N)
            => x'
      in plus -R- (pred -R- 4) -R- (pred -R- 5)
  in main

### Specialised ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (_ :R: N) -> N
    plus :R: (m :R: N) -> (n :R: N) -> N = \(m :R: N) (n :R: N).
      case -R- m of
        Z/R
          => n
        S/R (m' :R: N)
          => S -R- (plus -R- m' -R- n)
    postulate Vect :E: (_ :E: N) -> Type
    postulate Nil :E: Vect -E- Z
    postulate Cons :E: (n :E: N) -> (x :E: N) -> (xs :E: Vect -E- n) -> Vect -E- (S -E- n)
    zipWith :E: (n :E: N) -> (f :E: (_ :E: N) -> (_ :E: N) -> N) -> (xs :E: Vect -E- n) -> (ys :E: Vect -E- n) -> Vect -E- n = \(n :E: N) (f :E: (_ :E: N) -> (_ :E: N) -> N) (xs :E: Vect -E- n) (ys :E: Vect -E- n).
      case -E- xs of
        Cons/E (n1 :E: N) (x1 :E: N) (xs1 :E: Vect -E- n1)
          | n = S -E- n1
          => case -E- ys of
            Cons/E (n2 :E: N) (x2 :E: N) (xs2 :E: Vect -E- n1)
              | n2 = n1
              => Cons -E- n1 -E- (f -E- x1 -E- x2) -E- (zipWith -E- n1 -E- f -E- xs1 -E- xs2)
        Nil/E
          | n = Z
          => case -E- ys of
            Nil/E
              => Nil
    main :R: N = 
      let pred :R: (x :R: N) -> N = \(x :R: N).
        case -R- x of
          Z/R
            => Z
          S/R (x' :R: N)
            => x'
      in plus -R- (pred -R- 4) -R- (pred -R- 5)
  in main

### Constraints ###

[R] -> [R]

### Solution ###

[R]

### Annotated ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (_ :R: N) -> N
    plus :R: (m :R: N) -> (n :R: N) -> N = \(m :R: N) (n :R: N).
      case -R- m of
        Z/R
          => n
        S/R (m' :R: N)
          => S -R- (plus -R- m' -R- n)
    postulate Vect :E: (_ :E: N) -> Type
    postulate Nil :E: Vect -E- Z
    postulate Cons :E: (n :E: N) -> (x :E: N) -> (xs :E: Vect -E- n) -> Vect -E- (S -E- n)
    zipWith :E: (n :E: N) -> (f :E: (_ :E: N) -> (_ :E: N) -> N) -> (xs :E: Vect -E- n) -> (ys :E: Vect -E- n) -> Vect -E- n = \(n :E: N) (f :E: (_ :E: N) -> (_ :E: N) -> N) (xs :E: Vect -E- n) (ys :E: Vect -E- n).
      case -E- xs of
        Cons/E (n1 :E: N) (x1 :E: N) (xs1 :E: Vect -E- n1)
          | n = S -E- n1
          => case -E- ys of
            Cons/E (n2 :E: N) (x2 :E: N) (xs2 :E: Vect -E- n1)
              | n2 = n1
              => Cons -E- n1 -E- (f -E- x1 -E- x2) -E- (zipWith -E- n1 -E- f -E- xs1 -E- xs2)
        Nil/E
          | n = Z
          => case -E- ys of
            Nil/E
              => Nil
    main :R: N = 
      let pred :R: (x :R: N) -> N = \(x :R: N).
        case -R- x of
          Z/R
            => Z
          S/R (x' :R: N)
            => x'
      in plus -R- (pred -R- 4) -R- (pred -R- 5)
  in main

### Specialised ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (_ :R: N) -> N
    plus :R: (m :R: N) -> (n :R: N) -> N = \(m :R: N) (n :R: N).
      case -R- m of
        Z/R
          => n
        S/R (m' :R: N)
          => S -R- (plus -R- m' -R- n)
    postulate Vect :E: (_ :E: N) -> Type
    postulate Nil :E: Vect -E- Z
    postulate Cons :E: (n :E: N) -> (x :E: N) -> (xs :E: Vect -E- n) -> Vect -E- (S -E- n)
    zipWith :E: (n :E: N) -> (f :E: (_ :E: N) -> (_ :E: N) -> N) -> (xs :E: Vect -E- n) -> (ys :E: Vect -E- n) -> Vect -E- n = \(n :E: N) (f :E: (_ :E: N) -> (_ :E: N) -> N) (xs :E: Vect -E- n) (ys :E: Vect -E- n).
      case -E- xs of
        Cons/E (n1 :E: N) (x1 :E: N) (xs1 :E: Vect -E- n1)
          | n = S -E- n1
          => case -E- ys of
            Cons/E (n2 :E: N) (x2 :E: N) (xs2 :E: Vect -E- n1)
              | n2 = n1
              => Cons -E- n1 -E- (f -E- x1 -E- x2) -E- (zipWith -E- n1 -E- f -E- xs1 -E- xs2)
        Nil/E
          | n = Z
          => case -E- ys of
            Nil/E
              => Nil
    main :R: N = 
      let pred :R: (x :R: N) -> N = \(x :R: N).
        case -R- x of
          Z/R
            => Z
          S/R (x' :R: N)
            => x'
      in plus -R- (pred -R- 4) -R- (pred -R- 5)
  in main

### Final annotation ###

  let
    postulate N :E: Type
    postulate Z :R: N
    postulate S :R: (_ :R: N) -> N
    plus :R: (m :R: N) -> (n :R: N) -> N = \(m :R: N) (n :R: N).
      case -R- m of
        Z/R
          => n
        S/R (m' :R: N)
          => S -R- (plus -R- m' -R- n)
    postulate Vect :E: (_ :E: N) -> Type
    postulate Nil :E: Vect -E- Z
    postulate Cons :E: (n :E: N) -> (x :E: N) -> (xs :E: Vect -E- n) -> Vect -E- (S -E- n)
    zipWith :E: (n :E: N) -> (f :E: (_ :E: N) -> (_ :E: N) -> N) -> (xs :E: Vect -E- n) -> (ys :E: Vect -E- n) -> Vect -E- n = \(n :E: N) (f :E: (_ :E: N) -> (_ :E: N) -> N) (xs :E: Vect -E- n) (ys :E: Vect -E- n).
      case -E- xs of
        Cons/E (n1 :E: N) (x1 :E: N) (xs1 :E: Vect -E- n1)
          | n = S -E- n1
          => case -E- ys of
            Cons/E (n2 :E: N) (x2 :E: N) (xs2 :E: Vect -E- n1)
              | n2 = n1
              => Cons -E- n1 -E- (f -E- x1 -E- x2) -E- (zipWith -E- n1 -E- f -E- xs1 -E- xs2)
        Nil/E
          | n = Z
          => case -E- ys of
            Nil/E
              => Nil
    main :R: N = 
      let pred :R: (x :R: N) -> N = \(x :R: N).
        case -R- x of
          Z/R
            => Z
          S/R (x' :R: N)
            => x'
      in plus -R- (pred -R- 4) -R- (pred -R- 5)
  in main

### Verification ###

Verification successful.

### Pruned ###

  let
    postulate Z : N
    postulate S : (_) -> N
    plus = \m n.
      case m of
        Z
          => n
        S m'
          => S (plus m' n)
    main = 
      let pred = \x.
        case x of
          Z
            => Z
          S x'
            => x'
      in plus (pred 4) (pred 5)
  in main

### Normal forms ###

unerased:
  
  let
    postulate Z : N
    postulate S : (_ : N) -> N
  in 7

erased:
  
  let
    postulate Z : N
    postulate S : (_) -> N
  in 7

