-- vim: ft=agda

### Desugared ###

postulate N : Type

postulate Z : N

postulate S : (_ : N) -> N

plus : (m : N) -> (n : N) -> N = \(m : N) (n : N).
  case m of
    Z
      => n
    S (m' : N)
      => S (plus m' n)

postulate Vect : (_ : N) -> Type

postulate Nil : Vect Z

postulate Cons : (n : N) -> (x : N) -> (xs : Vect n) -> Vect (S n)

zipWith : (n : N) -> (f : (_ : N) -> (_ : N) -> N) -> (xs : Vect n) -> (ys : Vect n) -> Vect n = \(n : N) (f : (_ : N) -> (_ : N) -> N) (xs : Vect n) (ys : Vect n).
  case xs of
    Cons (n1 : N) (x1 : N) (xs1 : Vect n1)
      | n = S n1
      => case ys of
        Cons (n2 : N) (x2 : N) (xs2 : Vect n1)
          | n2 = n1
          => Cons n1 (f x1 x2) (zipWith n1 f xs1 xs2)
    Nil
      | n = Z
      => case ys of
        Nil
          => Nil

main  -R-  N = 
  let pred : (x : N) -> N = \(x : N).
    case x of
      Z
        => Z
      S (x' : N)
        => x'
  in plus (pred 4) (pred 5)

### Metaified ###

postulate N :?1: Type

postulate Z :?2: N

postulate S :?3: (_ :?4: N) -> N

plus :?5: (m :?6: N) -> (n :?7: N) -> N = \(m :?8: N) (n :?9: N).
  case -?10- m of
    Z
      => n
    S (m' :?11: N)
      => S -?12- (plus -?14- m' -?13- n)

postulate Vect :?15: (_ :?16: N) -> Type

postulate Nil :?17: Vect -?18- Z

postulate Cons :?19: (n :?20: N) -> (x :?21: N) -> (xs :?22: Vect -?23- n) -> Vect -?24- (S -?25- n)

zipWith :?26: (n :?27: N) -> (f :?28: (_ :?29: N) -> (_ :?30: N) -> N) -> (xs :?31: Vect -?32- n) -> (ys :?33: Vect -?34- n) -> Vect -?35- n = \(n :?36: N) (f :?37: (_ :?38: N) -> (_ :?39: N) -> N) (xs :?40: Vect -?41- n) (ys :?42: Vect -?43- n).
  case -?44- xs of
    Cons (n1 :?45: N) (x1 :?46: N) (xs1 :?47: Vect -?48- n1)
      | n = S -?49- n1
      => case -?50- ys of
        Cons (n2 :?51: N) (x2 :?52: N) (xs2 :?53: Vect -?54- n1)
          | n2 = n1
          => Cons -?57- n1 -?56- (f -?59- x1 -?58- x2) -?55- (zipWith -?63- n1 -?62- f -?61- xs1 -?60- xs2)
    Nil
      | n = Z
      => case -?64- ys of
        Nil
          => Nil

main :!R: N = 
  let pred :?65: (x :?66: N) -> N = \(x :?67: N).
    case -?68- x of
      Z
        => Z
      S (x' :?69: N)
        => x'
  in plus -?71- (pred -?72- 4) -?70- (pred -?77- 5)

### Inferred definitions ###

postulate Cons :?19: (n :?20: N) -> (x :?21: N) -> (xs :?22: Vect -?23- n) -> Vect -?24- (S -?25- n)

postulate N :?1: Type

postulate Nil :?17: Vect -?18- Z

postulate S :?3: (_ :?4: N) -> N

postulate Type :!R: Type

postulate Vect :?15: (_ :?16: N) -> Type

postulate Z :?2: N

main :!R: N = 
  let pred :?65: (x :?66: N) -> N = \(x :?67: N).
    case -?68- x of
      Z
        => Z
      S (x' :?69: N)
        => x'
  in plus -?71- (pred -?72- 4) -?70- (pred -?77- 5)
  [] -> [?2,?4,?5,?66,?67,?68,?69,!R]
  [?6] -> [?3,?65,?71,?72,?73,?74,?75,?76]
  [?7] -> [?3,?65,?70,?77,?78,?79,?80,?81,?82]
  [?70] -> [?7]
  [?71] -> [?6]

plus :?5: (m :?6: N) -> (n :?7: N) -> N = \(m :?8: N) (n :?9: N).
  case -?10- m of
    Z
      => n
    S (m' :?11: N)
      => S -?12- (plus -?14- m' -?13- n)
  [] -> [?3,?6,?7,?8,?9,?10,!R]
  [?4] -> [?5,?11,?12,?13,?14]
  [?11] -> [?4]
  [?12] -> [?4]

zipWith :?26: (n :?27: N) -> (f :?28: (_ :?29: N) -> (_ :?30: N) -> N) -> (xs :?31: Vect -?32- n) -> (ys :?33: Vect -?34- n) -> Vect -?35- n = \(n :?36: N) (f :?37: (_ :?38: N) -> (_ :?39: N) -> N) (xs :?40: Vect -?41- n) (ys :?42: Vect -?43- n).
  case -?44- xs of
    Cons (n1 :?45: N) (x1 :?46: N) (xs1 :?47: Vect -?48- n1)
      | n = S -?49- n1
      => case -?50- ys of
        Cons (n2 :?51: N) (x2 :?52: N) (xs2 :?53: Vect -?54- n1)
          | n2 = n1
          => Cons -?57- n1 -?56- (f -?59- x1 -?58- x2) -?55- (zipWith -?63- n1 -?62- f -?61- xs1 -?60- xs2)
    Nil
      | n = Z
      => case -?64- ys of
        Nil
          => Nil
  [] -> [?17,?19,?31,?40,?44,!R]
  [?18] -> [?32,?34,?35]
  [?20] -> [?33,?45,?51,?57]
  [?21] -> [?33,?37,?46,?52,?56]
  [?21,?38] -> [?46,?59]
  [?21,?39] -> [?52,?58]
  [?21,?58] -> [?39]
  [?21,?59] -> [?38]
  [?22] -> [?26,?33,?47,?53,?55,?61]
  [?22,?27] -> [?45,?63]
  [?22,?28] -> [?37,?62]
  [?22,?29] -> [?38]
  [?22,?30] -> [?39]
  [?22,?32] -> [?48]
  [?22,?33] -> [?53,?60]
  [?22,?34] -> [?54]
  [?22,?38] -> [?29]
  [?22,?39] -> [?30]
  [?22,?48] -> [?32]
  [?22,?54] -> [?34]
  [?22,?60] -> [?33]
  [?22,?62] -> [?28]
  [?22,?63] -> [?27]
  [?23] -> [?33,?35,?48,?54]
  [?24] -> [?32,?34,?35]
  [?25] -> [?49]
  [?27] -> [?36]
  [?28] -> [?37]
  [?29] -> [?38]
  [?30] -> [?39]
  [?32] -> [?18,?24]
  [?33] -> [?42]
  [?34] -> [?18,?24]
  [?35] -> [?18,?23,?24]
  [?36] -> [?27]
  [?37] -> [?28]
  [?38] -> [?29]
  [?39] -> [?30]
  [?42] -> [?33]
  [?45] -> [?20]
  [?46] -> [?21]
  [?47] -> [?22]
  [?48] -> [?23]
  [?49] -> [?25]
  [?50] -> [?42]
  [?51] -> [?20,?33,?50]
  [?52] -> [?21,?33,?50]
  [?53] -> [?22,?33,?50]
  [?54] -> [?23,?33]
  [?55] -> [?22]
  [?56] -> [?21]
  [?57] -> [?20]
  [?64] -> [?42]


### Constraints ###

[] -> [?2,?3,?4,?5,?6,?7,?8,?9,?10,?17,?19,?31,?40,?44,?66,?67,?68,?69,!R]
[?4] -> [?5,?11,?12,?13,?14]
[?6] -> [?3,?65,?71,?72,?73,?74,?75,?76]
[?7] -> [?3,?65,?70,?77,?78,?79,?80,?81,?82]
[?11] -> [?4]
[?12] -> [?4]
[?18] -> [?32,?34,?35]
[?20] -> [?33,?45,?51,?57]
[?21] -> [?33,?37,?46,?52,?56]
[?21,?38] -> [?46,?59]
[?21,?39] -> [?52,?58]
[?21,?58] -> [?39]
[?21,?59] -> [?38]
[?22] -> [?26,?33,?47,?53,?55,?61]
[?22,?27] -> [?45,?63]
[?22,?28] -> [?37,?62]
[?22,?29] -> [?38]
[?22,?30] -> [?39]
[?22,?32] -> [?48]
[?22,?33] -> [?53,?60]
[?22,?34] -> [?54]
[?22,?38] -> [?29]
[?22,?39] -> [?30]
[?22,?48] -> [?32]
[?22,?54] -> [?34]
[?22,?60] -> [?33]
[?22,?62] -> [?28]
[?22,?63] -> [?27]
[?23] -> [?33,?35,?48,?54]
[?24] -> [?32,?34,?35]
[?25] -> [?49]
[?27] -> [?36]
[?28] -> [?37]
[?29] -> [?38]
[?30] -> [?39]
[?32] -> [?18,?24]
[?33] -> [?42]
[?34] -> [?18,?24]
[?35] -> [?18,?23,?24]
[?36] -> [?27]
[?37] -> [?28]
[?38] -> [?29]
[?39] -> [?30]
[?42] -> [?33]
[?45] -> [?20]
[?46] -> [?21]
[?47] -> [?22]
[?48] -> [?23]
[?49] -> [?25]
[?50] -> [?42]
[?51] -> [?20,?33,?50]
[?52] -> [?21,?33,?50]
[?53] -> [?22,?33,?50]
[?54] -> [?23,?33]
[?55] -> [?22]
[?56] -> [?21]
[?57] -> [?20]
[?64] -> [?42]
[?70] -> [?7]
[?71] -> [?6]

### Solution ###

[?2,?3,?4,?5,?6,?7,?8,?9,?10,?11,?12,?13,?14,?17,?19,?31,?40,?44,?65,?66,?67,?68,?69,?70,?71,?72,?73,?74,?75,?76,?77,?78,?79,?80,?81,?82,!R]

### Annotated ###

postulate N :E: Type

postulate Z :R: N

postulate S :R: (_ :R: N) -> N

plus :R: (m :R: N) -> (n :R: N) -> N = \(m :R: N) (n :R: N).
  case -R- m of
    Z
      => n
    S (m' :R: N)
      => S -R- (plus -R- m' -R- n)

postulate Vect :E: (_ :E: N) -> Type

postulate Nil :R: Vect -E- Z

postulate Cons :R: (n :E: N) -> (x :E: N) -> (xs :E: Vect -E- n) -> Vect -E- (S -E- n)

zipWith :E: (n :E: N) -> (f :E: (_ :E: N) -> (_ :E: N) -> N) -> (xs :R: Vect -E- n) -> (ys :E: Vect -E- n) -> Vect -E- n = \(n :E: N) (f :E: (_ :E: N) -> (_ :E: N) -> N) (xs :R: Vect -E- n) (ys :E: Vect -E- n).
  case -R- xs of
    Cons (n1 :E: N) (x1 :E: N) (xs1 :E: Vect -E- n1)
      | n = S -E- n1
      => case -E- ys of
        Cons (n2 :E: N) (x2 :E: N) (xs2 :E: Vect -E- n1)
          | n2 = n1
          => Cons -E- n1 -E- (f -E- x1 -E- x2) -E- (zipWith -E- n1 -E- f -E- xs1 -E- xs2)
    Nil
      | n = Z
      => case -E- ys of
        Nil
          => Nil

main :R: N = 
  let pred :R: (x :R: N) -> N = \(x :R: N).
    case -R- x of
      Z
        => Z
      S (x' :R: N)
        => x'
  in plus -R- (pred -R- 4) -R- (pred -R- 5)

### Specialised ###

postulate N :!E: Type

postulate Z :!R: N

postulate S :!R: (_ :!R: N) -> N

plus :!R: (m :!R: N) -> (n :!R: N) -> N = \(m :!R: N) (n :!R: N).
  case -!R- m of
    Z
      => n
    S (m' :!R: N)
      => S -!R- (plus -!R- m' -!R- n)

postulate Vect :!E: (_ :!E: N) -> Type

postulate Nil :!R: Vect -!E- Z

postulate Cons :!R: (n :!E: N) -> (x :!E: N) -> (xs :!E: Vect -!E- n) -> Vect -!E- (S -!E- n)

zipWith :!E: (n :!E: N) -> (f :!E: (_ :!E: N) -> (_ :!E: N) -> N) -> (xs :!R: Vect -!E- n) -> (ys :!E: Vect -!E- n) -> Vect -!E- n = \(n :!E: N) (f :!E: (_ :!E: N) -> (_ :!E: N) -> N) (xs :!R: Vect -!E- n) (ys :!E: Vect -!E- n).
  case -!R- xs of
    Cons (n1 :!E: N) (x1 :!E: N) (xs1 :!E: Vect -!E- n1)
      | n = S -!E- n1
      => case -!E- ys of
        Cons (n2 :!E: N) (x2 :!E: N) (xs2 :!E: Vect -!E- n1)
          | n2 = n1
          => Cons -!E- n1 -!E- (f -!E- x1 -!E- x2) -!E- (zipWith -!E- n1 -!E- f -!E- xs1 -!E- xs2)
    Nil
      | n = Z
      => case -!E- ys of
        Nil
          => Nil

main :!R: N = 
  let pred :!R: (x :!R: N) -> N = \(x :!R: N).
    case -!R- x of
      Z
        => Z
      S (x' :!R: N)
        => x'
  in plus -!R- (pred -!R- 4) -!R- (pred -!R- 5)

### Final annotation ###

postulate N :E: Type

postulate Z :R: N

postulate S :R: (_ :R: N) -> N

plus :R: (m :R: N) -> (n :R: N) -> N = \(m :R: N) (n :R: N).
  case -R- m of
    Z
      => n
    S (m' :R: N)
      => S -R- (plus -R- m' -R- n)

postulate Vect :E: (_ :E: N) -> Type

postulate Nil :R: Vect -E- Z

postulate Cons :R: (n :E: N) -> (x :E: N) -> (xs :E: Vect -E- n) -> Vect -E- (S -E- n)

zipWith :E: (n :E: N) -> (f :E: (_ :E: N) -> (_ :E: N) -> N) -> (xs :R: Vect -E- n) -> (ys :E: Vect -E- n) -> Vect -E- n = \(n :E: N) (f :E: (_ :E: N) -> (_ :E: N) -> N) (xs :R: Vect -E- n) (ys :E: Vect -E- n).
  case -R- xs of
    Cons (n1 :E: N) (x1 :E: N) (xs1 :E: Vect -E- n1)
      | n = S -E- n1
      => case -E- ys of
        Cons (n2 :E: N) (x2 :E: N) (xs2 :E: Vect -E- n1)
          | n2 = n1
          => Cons -E- n1 -E- (f -E- x1 -E- x2) -E- (zipWith -E- n1 -E- f -E- xs1 -E- xs2)
    Nil
      | n = Z
      => case -E- ys of
        Nil
          => Nil

main :R: N = 
  let pred :R: (x :R: N) -> N = \(x :R: N).
    case -R- x of
      Z
        => Z
      S (x' :R: N)
        => x'
  in plus -R- (pred -R- 4) -R- (pred -R- 5)

### Verification ###

Verification successful.

### Pruned ###

postulate Z

postulate S

plus = \m n.
  case m of
    Z
      => n
    S m'
      => S (plus m' n)

postulate Nil

postulate Cons

main = 
  let pred = \x.
    case x of
      Z
        => Z
      S x'
        => x'
  in plus (pred 4) (pred 5)

### Normal forms ###

unerased:
  7
erased:
  7
