-- vim: ft=agda

### Desugared ###

postulate N : Type

postulate Z : N

postulate S : (_ : N) -> N

plus : (m : N) -> (n : N) -> N = \(m : N) (n : N).
  case m of
    Z
      => n
    S (m' : N)
      => S (plus m' n)

postulate Vect : (_ : N) -> Type

postulate Nil : Vect Z

postulate Cons : (n : N) -> (x : N) -> (xs : Vect n) -> Vect (S n)

zipWith : (n : N) -> (f : (_ : N) -> (_ : N) -> N) -> (xs : Vect n) -> (ys : Vect n) -> Vect n = \(n : N) (f : (_ : N) -> (_ : N) -> N) (xs : Vect n) (ys : Vect n).
  case xs of
    Cons (n1 : N) (x1 : N) (xs1 : Vect n1)
      | n = S n1
      => case ys of
        Cons (n2 : N) (x2 : N) (xs2 : Vect n1)
          | n2 = n1
          => Cons n1 (f x1 x2) (zipWith n1 f xs1 xs2)
    Nil
      | n = Z
      => case ys of
        Nil
          => Nil

main :R: N = 
  let pred : (x : N) -> N = \(x : N).
    case x of
      Z
        => Z
      S (x' : N)
        => x'
  in plus (pred 4) (pred 5)

### Metaified ###

postulate N :1: Type

postulate Z :2: N

postulate S :3: (_ :4: N) -> N

plus :5: (m :6: N) -> (n :7: N) -> N = \(m :8: N) (n :9: N).
  case -10- m of
    Z
      => n
    S (m' :11: N)
      => S -12- (plus -14- m' -13- n)

postulate Vect :15: (_ :16: N) -> Type

postulate Nil :17: Vect -18- Z

postulate Cons :19: (n :20: N) -> (x :21: N) -> (xs :22: Vect -23- n) -> Vect -24- (S -25- n)

zipWith :26: (n :27: N) -> (f :28: (_ :29: N) -> (_ :30: N) -> N) -> (xs :31: Vect -32- n) -> (ys :33: Vect -34- n) -> Vect -35- n = \(n :36: N) (f :37: (_ :38: N) -> (_ :39: N) -> N) (xs :40: Vect -41- n) (ys :42: Vect -43- n).
  case -44- xs of
    Cons (n1 :45: N) (x1 :46: N) (xs1 :47: Vect -48- n1)
      | n = S -49- n1
      => case -50- ys of
        Cons (n2 :51: N) (x2 :52: N) (xs2 :53: Vect -54- n1)
          | n2 = n1
          => Cons -57- n1 -56- (f -59- x1 -58- x2) -55- (zipWith -63- n1 -62- f -61- xs1 -60- xs2)
    Nil
      | n = Z
      => case -64- ys of
        Nil
          => Nil

main :R: N = 
  let pred :65: (x :66: N) -> N = \(x :67: N).
    case -68- x of
      Z
        => Z
      S (x' :69: N)
        => x'
  in plus -71- (pred -72- 4) -70- (pred -77- 5)

### Inferred definitions ###

postulate Cons :19: (n :20: N) -> (x :21: N) -> (xs :22: Vect -23- n) -> Vect -24- (S -25- n) {- constraints apply -}
  [] -> [19,R]

postulate N :1: Type {- constraints apply -}
  [] -> [1,R]

postulate Nil :17: Vect -18- Z {- constraints apply -}
  [] -> [17,R]

postulate S :3: (_ :4: N) -> N {- constraints apply -}
  [] -> [3,R]

postulate Type :R: Type

postulate Vect :15: (_ :16: N) -> Type {- constraints apply -}
  [] -> [15,R]

postulate Z :2: N {- constraints apply -}
  [] -> [2,R]

main :R: N = 
  let pred :65: (x :66: N) -> N = \(x :67: N).
    case -68- x of
      Z
        => Z
      S (x' :69: N)
        => x'
  in plus -71- (pred -72- 4) -70- (pred -77- 5) {- constraints apply -}
  [] -> [2,3,4,5,6,7,8,9,10,11,12,13,14,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,R]

plus :5: (m :6: N) -> (n :7: N) -> N = \(m :8: N) (n :9: N).
  case -10- m of
    Z
      => n
    S (m' :11: N)
      => S -12- (plus -14- m' -13- n) {- constraints apply -}
  [] -> [3,4,5,6,7,8,9,10,11,12,13,14,R]

zipWith :26: (n :27: N) -> (f :28: (_ :29: N) -> (_ :30: N) -> N) -> (xs :31: Vect -32- n) -> (ys :33: Vect -34- n) -> Vect -35- n = \(n :36: N) (f :37: (_ :38: N) -> (_ :39: N) -> N) (xs :40: Vect -41- n) (ys :42: Vect -43- n).
  case -44- xs of
    Cons (n1 :45: N) (x1 :46: N) (xs1 :47: Vect -48- n1)
      | n = S -49- n1
      => case -50- ys of
        Cons (n2 :51: N) (x2 :52: N) (xs2 :53: Vect -54- n1)
          | n2 = n1
          => Cons -57- n1 -56- (f -59- x1 -58- x2) -55- (zipWith -63- n1 -62- f -61- xs1 -60- xs2)
    Nil
      | n = Z
      => case -64- ys of
        Nil
          => Nil {- constraints apply -}
  [] -> [17,19,20,21,22,26,28,31,33,37,40,42,44,45,46,47,50,51,52,53,55,56,57,60,61,62,R]
  [18] -> [32,34,35]
  [23] -> [35,48,54]
  [24] -> [32,34,35]
  [25] -> [49]
  [27] -> [36,63]
  [29] -> [38]
  [30] -> [39]
  [32] -> [18,24,48]
  [34] -> [18,24,54]
  [35] -> [18,23,24]
  [36] -> [27]
  [38] -> [29,59]
  [39] -> [30,58]
  [48] -> [23,32]
  [49] -> [25]
  [54] -> [23,34]
  [58] -> [39]
  [59] -> [38]
  [63] -> [27]


### Constraints ###

[] -> [2,3,4,5,6,7,8,9,10,11,12,13,14,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,R]

### Solution ###

[2,3,4,5,6,7,8,9,10,11,12,13,14,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,R]

### Annotated ###

postulate N :E: Type

postulate Z :R: N

postulate S :R: (_ :R: N) -> N

plus :R: (m :R: N) -> (n :R: N) -> N = \(m :R: N) (n :R: N).
  case -R- m of
    Z
      => n
    S (m' :R: N)
      => S -R- (plus -R- m' -R- n)

postulate Vect :E: (_ :E: N) -> Type

postulate Nil :E: Vect -E- Z

postulate Cons :E: (n :E: N) -> (x :E: N) -> (xs :E: Vect -E- n) -> Vect -E- (S -E- n)

zipWith :E: (n :E: N) -> (f :E: (_ :E: N) -> (_ :E: N) -> N) -> (xs :E: Vect -E- n) -> (ys :E: Vect -E- n) -> Vect -E- n = \(n :E: N) (f :E: (_ :E: N) -> (_ :E: N) -> N) (xs :E: Vect -E- n) (ys :E: Vect -E- n).
  case -E- xs of
    Cons (n1 :E: N) (x1 :E: N) (xs1 :E: Vect -E- n1)
      | n = S -E- n1
      => case -E- ys of
        Cons (n2 :E: N) (x2 :E: N) (xs2 :E: Vect -E- n1)
          | n2 = n1
          => Cons -E- n1 -E- (f -E- x1 -E- x2) -E- (zipWith -E- n1 -E- f -E- xs1 -E- xs2)
    Nil
      | n = Z
      => case -E- ys of
        Nil
          => Nil

main :R: N = 
  let pred :R: (x :R: N) -> N = \(x :R: N).
    case -R- x of
      Z
        => Z
      S (x' :R: N)
        => x'
  in plus -R- (pred -R- 4) -R- (pred -R- 5)

### Specialised ###

postulate N :E: Type

postulate Z :R: N

postulate S :R: (_ :R: N) -> N

plus :R: (m :R: N) -> (n :R: N) -> N = \(m :R: N) (n :R: N).
  case -R- m of
    Z
      => n
    S (m' :R: N)
      => S -R- (plus -R- m' -R- n)

postulate Vect :E: (_ :E: N) -> Type

postulate Nil :E: Vect -E- Z

postulate Cons :E: (n :E: N) -> (x :E: N) -> (xs :E: Vect -E- n) -> Vect -E- (S -E- n)

zipWith :E: (n :E: N) -> (f :E: (_ :E: N) -> (_ :E: N) -> N) -> (xs :E: Vect -E- n) -> (ys :E: Vect -E- n) -> Vect -E- n = \(n :E: N) (f :E: (_ :E: N) -> (_ :E: N) -> N) (xs :E: Vect -E- n) (ys :E: Vect -E- n).
  case -E- xs of
    Cons (n1 :E: N) (x1 :E: N) (xs1 :E: Vect -E- n1)
      | n = S -E- n1
      => case -E- ys of
        Cons (n2 :E: N) (x2 :E: N) (xs2 :E: Vect -E- n1)
          | n2 = n1
          => Cons -E- n1 -E- (f -E- x1 -E- x2) -E- (zipWith -E- n1 -E- f -E- xs1 -E- xs2)
    Nil
      | n = Z
      => case -E- ys of
        Nil
          => Nil

main :R: N = 
  let pred :R: (x :R: N) -> N = \(x :R: N).
    case -R- x of
      Z
        => Z
      S (x' :R: N)
        => x'
  in plus -R- (pred -R- 4) -R- (pred -R- 5)

### Final annotation ###

postulate N :E: Type

postulate Z :R: N

postulate S :R: (_ :R: N) -> N

plus :R: (m :R: N) -> (n :R: N) -> N = \(m :R: N) (n :R: N).
  case -R- m of
    Z
      => n
    S (m' :R: N)
      => S -R- (plus -R- m' -R- n)

postulate Vect :E: (_ :E: N) -> Type

postulate Nil :E: Vect -E- Z

postulate Cons :E: (n :E: N) -> (x :E: N) -> (xs :E: Vect -E- n) -> Vect -E- (S -E- n)

zipWith :E: (n :E: N) -> (f :E: (_ :E: N) -> (_ :E: N) -> N) -> (xs :E: Vect -E- n) -> (ys :E: Vect -E- n) -> Vect -E- n = \(n :E: N) (f :E: (_ :E: N) -> (_ :E: N) -> N) (xs :E: Vect -E- n) (ys :E: Vect -E- n).
  case -E- xs of
    Cons (n1 :E: N) (x1 :E: N) (xs1 :E: Vect -E- n1)
      | n = S -E- n1
      => case -E- ys of
        Cons (n2 :E: N) (x2 :E: N) (xs2 :E: Vect -E- n1)
          | n2 = n1
          => Cons -E- n1 -E- (f -E- x1 -E- x2) -E- (zipWith -E- n1 -E- f -E- xs1 -E- xs2)
    Nil
      | n = Z
      => case -E- ys of
        Nil
          => Nil

main :R: N = 
  let pred :R: (x :R: N) -> N = \(x :R: N).
    case -R- x of
      Z
        => Z
      S (x' :R: N)
        => x'
  in plus -R- (pred -R- 4) -R- (pred -R- 5)

### Verification ###

