-- vim: ft=idris

postulate Int : Type.
foreign intS : (x :R: Int) -> Int = "(lambda (x) (+ x 1))".
foreign intZ : Int = "0".

postulate Unspec : Type.

-- `nativePrint` has side effects so we wrap it in an IO action.
printSchemeRepr \ (a : Type) (x : a) : IO Unspec =
    let
        -- The only places where we assert usage are foreign functions.
        foreign nativePrint : (a :E: Type) -> (x :R: a) -> Unspec = "print"
    in
        ioWrapImpure Unspec (\delayToken:Unit. nativePrint a x).

natToInt : Nat -> Int.
  natToInt Z = intZ,
  (n : Nat)
    natToInt (S n) = intS (natToInt n).

foreign intToNat : (x :R: Int) -> Nat = "(lambda (x) (number->peano 'Z 'S x))".

printNat \(x : Nat) : IO Unspec
    = printSchemeRepr Int (natToInt x).

-- this applies any given continuation to a RealWorld
foreign prim__applyToWorld
    : (a :E: Type)
    -> (f :R: (w :R: RealWorld) -> a)
    -> a
    = "(lambda (f) (f 'RealWorld))".

-- This must be a foreign function because otherwise,
-- TTstar's reduction would see through this and substitute
-- RealWorld in programs, "optimising" side effects away.
unsafePerformIO : (a :E: Type) -> (io :R: IO a) -> a.
  (a : Type) (run : RealWorld -> Pair RealWorld a)
    unsafePerformIO a ([MkSt] [RealWorld] [a] run)
      = snd RealWorld a (prim__applyToWorld (Pair RealWorld a) run).
