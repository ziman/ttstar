-- vim: ft=idris

postulate Int : Type.
foreign intS : (x :R: Int) -> Int = "(lambda (x) (+ x 1))".
foreign intZ : Int = "0".

postulate Unspec : Type.
printSchemeRepr \ (a : Type) (x : a) : IO Unspec
    = let
        foreign nativePrint : (a :E: Type) -> (x :R: a) -> (w :R: RealWorld) -> IOResult Unspec
            = "(lambda (x) (lambda (w) (list 'MkIOR (print x) w)))"
      in 
        MkIO Unspec (nativePrint a x).

natToInt : Nat -> Int.
  natToInt Z = intZ,
  (n : Nat)
    natToInt (S n) = intS (natToInt n).

foreign intToNat : (x :R: Int) -> Nat = "(lambda (x) (number->peano 'Z 'S x))".

printNat \(x : Nat) : IO Unspec
    = printSchemeRepr Int (natToInt x).

-- runIO obviously breaks purity. IO as a concept in TTstar is used just to
-- guarantee the correct order of effects within a single IO action.

foreign runIO_prim : (a :E: Type) -> (f :R: (w :R: RealWorld) -> IOResult a) -> IOResult a
    = "(lambda (f) (f 'RealWorld))".

runIO : (a : Type) -> (IO a) -> a.
  (a : Type) (f : RealWorld -> IOResult a)
    runIO a ([MkIO] [a] f) =
      let
        runIO2 : (a : Type) -> (IOResult a) -> a.
          (a : Type) (x : a) (w : RealWorld)
            runIO2 a ([MkIOR] [a] x w) = x.
      in
        runIO2 a (runIO_prim a f).
