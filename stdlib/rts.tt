-- vim: ft=idris

postulate Int : Type.
foreign intS : (x :R: Int) -> Int = "(lambda (x) (+ x 1))".
foreign intZ : Int = "0".

postulate Unspec : Type.

-- `nativePrint` is an impure foreign function.
-- Here, we export/wrap it as an IO action, which simulates passing RealWorld around.
printSchemeRepr \ (a : Type) (x : a) : IO Unspec
    = let
        foreign nativePrint : (a :E: Type) -> (x :R: a) -> Unspec = "print"
      in 
        -- `w` is taken relevantly here because we just pass it on without
        -- actually having it go through the RTS (which we could do as well).
        -- TTstar sees that it's passed unchanged so it allows erasure on it.
        -- However, we want to simulate going through the RTS so we just explicitly
        -- label it as used.
        MkIO Unspec (\w:R:RealWorld. MkIOR Unspec (nativePrint a x) w).

natToInt : Nat -> Int.
  natToInt Z = intZ,
  (n : Nat)
    natToInt (S n) = intS (natToInt n).

foreign intToNat : (x :R: Int) -> Nat = "(lambda (x) (number->peano 'Z 'S x))".

printNat \(x : Nat) : IO Unspec
    = printSchemeRepr Int (natToInt x).
