-- vim: ft=idris

postulate RealWorld : Type.

IO \: Type -> Type = State RealWorld.

ioReturn \(a : Type) (x : a) : IO a
    = stReturn RealWorld a x.

ioBind \(a : Type) (b : Type) (x : IO a) (y : a -> IO b) : IO b
    = stBind RealWorld a b x y.

-- `w` is taken relevantly here because we just pass it on without
-- actually having it go through the RTS (which we could do as well).
-- TTstar sees that it's passed unchanged so it allows erasure on it.
-- However, we want to simulate going through the RTS so we just explicitly
-- label it as used.
ioWrapImpure \(a : Type) (impureF : RealWorld -> a) : IO a
    = MkSt RealWorld a (\w:R:RealWorld. MkPair RealWorld a w (impureF w)).

-- runIO obviously breaks purity. IO as a concept in TTstar is used just to
-- guarantee the correct order of effects within a single IO action.
runIO \(a : Type) (x : IO a) : a
    = let
        postulate w : RealWorld
      in
        execState RealWorld a x w.
