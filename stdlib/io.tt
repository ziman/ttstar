-- vim: ft=idris

postulate RealWorld : Type.

-- IOResult is just a pair (return value, updated world).
data IOResult : Type -> Type where
  MkIOR : (a : Type) -> (x : a) -> (w : RealWorld) -> IOResult a.

-- IO is just a state monad, where the state is RealWorld.
data IO : Type -> Type where
  MkIO : (a : Type) -> (f : (w : RealWorld) -> IOResult a) -> IO a.

ioReturn : (a : Type) -> (x : a) -> IO a.
  (a : Type) (x : a)
    ioReturn a x = MkIO a (\w : RealWorld. MkIOR a x w).

ioBind : (a : Type) -> (b : Type) -> (x : IO a) -> (y : (z :R: a) -> IO b) -> IO b.
  (a : Type) (b : Type) (f : RealWorld -> IOResult a) (g : a -> IO b)
    ioBind a b ([MkIO] [a] f) g
        = let
          ioBind3 : (b : Type) -> RealWorld -> (IO b) -> IOResult b.
            (b : Type) (w : RealWorld) (f : RealWorld -> IOResult b)
              ioBind3 b w ([MkIO] [b] f) = f w.,

          ioBind2 : (a : Type) -> (b : Type) -> (g : (x : a) -> IO b) -> (r : IOResult a) -> IOResult b.
            (a : Type) (b : Type) (g : a -> IO b) (x : a) (w : RealWorld)
              ioBind2 a b g ([MkIOR] [a] x w) = ioBind3 b w (g x).
        in
            MkIO b (\w : RealWorld. ioBind2 a b g (f w)).

ioIgnore \(a : Type) (b : Type) (r : b) (x : IO a) : IO b
    = ioBind a b x (\v:a. ioReturn b r).

-- runIO obviously breaks purity. IO as a concept in TTstar is used just to
-- guarantee the correct order of effects within a single IO action.
runIO : (a : Type) -> (IO a) -> a.
  (a : Type) (f : RealWorld -> IOResult a)
    runIO a ([MkIO] [a] f) =
      let
        runIO2 : (a : Type) -> (IOResult a) -> a.
          (a : Type) (x : a) (w : RealWorld)
            runIO2 a ([MkIOR] [a] x w) = x.,

        postulate TheWorld : RealWorld
      in
        runIO2 a (f TheWorld).
